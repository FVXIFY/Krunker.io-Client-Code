/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/theatre.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./maps/burg.json":
/*!************************!*\
  !*** ./maps/burg.json ***!
  \************************/
/*! exports provided: name, ambient, light, sky, fog, fogD, camPos, spawns, ambO, ambS, modes, shadScale, objects, default */
/***/ (function(module) {

    module.exports = {"name":"Burg","ambient":8220268,"light":16771304,"sky":14141126,"fog":13812161,"fogD":918.7540927106669,"camPos":[11,33,-217],"spawns":[[-80,18,35,0,0,0],[177,0,-188,0,0,0],[215,10,-504,0,1,0],[-169,2,-514,0,2,0],[-328,0,-255,0,0,0],[-154,0,-134,0,1,0],[-125,-28,-341,0,0,0],[32,-28,-509,0,1,0],[331,0,-227,0,2,0],[102,0,-365,0,0,0]],"ambO":0.7,"ambS":5,"modes":[0,1],"shadScale":170,"objects":[{"p":[-96,16,41],"s":[288,2,62],"t":1},{"p":[73,0,33],"s":[50,18,46],"i":9,"t":1,"d":2},{"p":[28,0,8],"s":[152,24,4]},{"p":[0,-2,-71],"s":[516,2,252],"t":1},{"p":[-76,0,-48],"s":[56,74,122],"bo":1},{"p":[37,0,-68],"s":[110,54,80],"bo":1},{"p":[-112,0,74],"s":[126,76,38],"bo":1},{"p":[90,0,77],"s":[158,76,44],"bo":1},{"p":[-136,16,-16],"s":[64,2,52],"t":1},{"p":[-136,0,-44],"s":[64,24,4]},{"p":[-170,0,-18],"s":[4,24,56]},{"p":[-234,0,-27],"s":[32,60,97],"bo":1},{"p":[-258,18,41],"s":[47,32,44],"c":13619151,"bo":1},{"p":[-218,13,74],"s":[88,38,54],"bo":1},{"p":[185,0,-9],"s":[16,67,84],"bo":1},{"p":[180,0,45],"s":[60,92,44],"c":11842740,"bo":1},{"p":[213,0,-61],"s":[94,92,60],"c":11645361,"bo":1},{"p":[96,0,-175],"s":[110,44,44],"bo":1},{"p":[-85,0,-140],"s":[56,84,112],"bo":1},{"p":[126,-4,-300],"s":[228,4,206],"t":1},{"p":[-82,-28,-252],"s":[60,94,138],"bo":1},{"p":[9,-28,-274],"s":[6,34,168]},{"p":[49,-28,-385],"s":[96,104,68],"bo":1},{"p":[-23,-28,-252],"s":[58,28,110],"i":9,"t":1,"d":1},{"p":[59,-32,-452],"s":[218,4,138],"t":1},{"p":[-108,-28,-377],"s":[130,88,42],"bo":1},{"p":[-21,6,-377],"s":[44,38,20],"bo":1},{"p":[-243,0,-105],"s":[21,50,96],"c":12302777,"bo":1},{"p":[190,0,-346],"s":[117,58,118],"bo":1},{"p":[-195,0,-17],"s":[46,18,54],"i":9,"t":1,"d":1},{"p":[-134,0,-191],"s":[90,77,76],"bo":1},{"p":[-278,0,-191],"s":[130,77,76],"bo":1},{"p":[-227,-2,-254],"s":[232,2,50],"t":1},{"p":[-210,-28,-323],"s":[132,90,66],"bo":1},{"p":[-128,-28,-300],"s":[32,28,42],"i":9,"t":1,"d":1},{"p":[-233,-2,-419],"s":[172,2,280],"t":1},{"p":[-326,-22,-321],"s":[34,84,88],"bo":1},{"p":[-370,-2,-253],"s":[55,155,58],"bo":1},{"p":[-158,-28,-274],"s":[28,90,32],"bo":1},{"p":[-263,-20,-322],"s":[30,94,94],"bo":1},{"p":[-330,-23,-394],"s":[22,81,210],"bo":1},{"p":[-88,-28,-429],"s":[78,28,62],"i":9,"t":1,"d":2},{"p":[-103,-22,-497],"s":[49,84,86],"bo":1},{"p":[-137,-2,-463],"s":[20,2,130],"t":1},{"p":[-164,0,-547],"s":[98,86,40],"bo":1},{"p":[-283,0,-506],"s":[72,10,86],"t":1},{"p":[-261,0,-452],"s":[28,10,22],"t":1},{"p":[-298,0,-450],"s":[42,10,26],"i":9,"t":1,"d":3},{"p":[-347,0,-535],"s":[72,72,76],"bo":1},{"p":[-262,0,-567],"s":[98,52,40],"bo":1},{"p":[-319,0,-587],"s":[48,139,54],"c":11645361},{"p":[-1,-28,-377],"s":[4,34,20],"bo":1},{"p":[-41,-28,-377],"s":[4,34,20],"bo":1},{"p":[-63,-28,-506],"s":[52,118,92],"bo":1},{"p":[85,-28,-498],"s":[32,112,88],"bo":1},{"p":[173,8,-503],"s":[148,2,84],"t":1},{"p":[39,-29,-544],"s":[218,94,46],"bo":1},{"p":[182,10,-540],"s":[72,87,60],"bo":1},{"p":[292,-4,-329],"s":[104,4,264],"t":1},{"p":[280,0,-485],"s":[58,10,48],"i":9,"t":1,"d":3},{"p":[278,8,-527],"s":[62,2,36],"t":1},{"p":[264,9,-558],"s":[94,36,26],"bo":1},{"p":[331,-23,-552],"s":[54,135,110],"c":"#aaaaaa","bo":1},{"p":[332,0,-499],"s":[48,55,110],"bo":1},{"p":[342,1,-411],"s":[20,31,110],"bo":1},{"p":[336,0,-303],"s":[54,61,110],"bo":1},{"p":[127,-28,-425],"s":[64,35,4]},{"p":[196,-28,-461],"s":[110,44,4]},{"p":[249,0,-486],"s":[4,16,46]},{"p":[204,-28,-440],"s":[72,28,38],"i":9,"t":1},{"p":[156,0,-188],"s":[32,70,82],"bo":1},{"p":[228,0,-188],"s":[32,86,82],"bo":1},{"p":[367,0,-146],"s":[58,50,118],"c":"#a2a2a2","bo":1},{"p":[335,81,-62],"s":[60,58,60]},{"p":[348,0,-227],"s":[8,44,52],"bo":1},{"p":[393,0,-420],"s":[88,64,197]},{"p":[396,0,-196],"s":[58,81,186]},{"p":[-356,0,-369],"s":[42,98,50]},{"p":[-264,0,-84],"s":[42,124,50],"c":11316396},{"p":[1,0,0],"s":[12,12,12],"i":1},{"p":[-42,0,-79],"s":[12,12,12],"i":1},{"p":[-42,12,-79],"s":[12,12,12],"i":1},{"p":[-42,0,-67],"s":[12,12,12],"i":1},{"p":[0,-28,-325],"s":[12,12,12],"i":1},{"p":[0,-28,-337],"s":[12,12,12],"i":1},{"p":[0,-16,-333],"s":[12,12,12],"i":1},{"p":[-76,-28,-327],"s":[12,12,12],"i":1},{"p":[-76,-16,-327],"s":[12,12,12],"i":1},{"p":[237,10,-473],"s":[12,12,12],"i":1},{"p":[224,10,-520],"s":[12,12,12],"i":1},{"p":[155,10,-504],"s":[12,12,12],"i":1},{"p":[167,10,-504],"s":[12,12,12],"i":1},{"p":[163,22,-504],"s":[12,12,12],"i":1},{"p":[214,10,-466],"s":[6,8,6],"i":2},{"p":[312,0,-399],"s":[2,2,92]},{"p":[318,0,-242],"s":[12,12,12],"i":1},{"p":[227,0,-281],"s":[12,12,12],"i":1},{"p":[215,0,-281],"s":[12,12,12],"i":1},{"p":[224,12,-281],"s":[12,12,12],"i":1},{"p":[-59,18,19],"s":[12,12,12],"i":1},{"p":[-110,18,-36],"s":[12,12,12],"i":1},{"p":[-110,0,-52],"s":[12,12,12],"i":1},{"p":[-122,0,-52],"s":[12,12,12],"i":1},{"p":[-165,18,-39],"s":[6,8,6],"i":2},{"p":[-215,18,13],"s":[6,8,6],"i":2},{"p":[-154,0,-252],"s":[12,12,12],"i":1},{"p":[-313,0,-235],"s":[12,12,12],"i":1},{"p":[-133,0,-469],"s":[12,12,12],"i":8},{"p":[-190,0,-485],"s":[12,12,12],"i":1},{"p":[206,0,-207],"s":[12,12,12],"i":1},{"p":[206,0,-195],"s":[12,12,12],"i":1},{"p":[98,0,-61],"s":[12,12,12],"i":1},{"p":[98,0,-73],"s":[12,12,12],"i":1},{"p":[95,0,-52],"s":[6,8,6],"i":2},{"p":[133,0,-150],"s":[6,8,6],"i":2},{"p":[192,34,-188],"s":[40,24,82],"bo":1},{"p":[128,-4,-415],"s":[68,12,20],"t":1},{"p":[93,-28,-422],"s":[4,42,10]},{"p":[337,-4,-150],"s":[22,4,94],"t":1},{"p":[-11,-28,-384],"s":[20,34,2],"pe":1,"t":2,"bo":1},{"p":[-32,-28,-370],"s":[18,34,2],"pe":1,"t":2,"bo":1},{"p":[173,0,-233],"s":[2,34,24],"pe":1,"t":2},{"p":[202,0,-226],"s":[20,34,2],"pe":1,"t":2,"bo":1},{"p":[182,0,-150],"s":[20,34,2],"pe":1,"t":2,"bo":1},{"p":[211,0,-162],"s":[2,34,24],"t":2,"bo":1},{"p":[20,-28,-438],"s":[28,76,40],"bo":1},{"p":[114,0,-388],"s":[36,8,34],"i":9,"t":1,"d":3},{"p":[-337,139,-563],"s":[12,4,6],"l":1,"c":11184810},{"p":[-299,139,-566],"s":[8,4,12],"l":1,"c":11644847},{"p":[-297,139,-586],"s":[4,4,12],"l":1,"c":11842740},{"p":[-300,139,-608],"s":[10,4,12],"l":1,"c":10855845},{"p":[-316,139,-563],"s":[12,2,6],"l":1,"c":11184810},{"p":[-206,86,-535],"s":[14,4,16],"l":1},{"p":[-126,86,-535],"s":[22,4,16],"l":1},{"p":[-165,86,-530],"s":[22,4,6],"l":1},{"p":[-209,86,-560],"s":[8,4,14],"l":1},{"p":[-230,52,-550],"s":[24,2,6],"l":1},{"p":[-264,52,-550],"s":[18,2,6],"l":1},{"p":[-295,52,-550],"s":[14,4,6],"l":1},{"p":[-316,70,-502],"s":[6,12,6],"l":1,"t":2},{"p":[-378,73,-502],"s":[6,8,6],"l":1,"t":2},{"p":[-318,72,-504],"s":[14,4,14],"l":1},{"p":[-378,72,-504],"s":[10,2,14],"l":1},{"p":[-358,72,-499],"s":[14,2,4],"l":1},{"p":[-314,72,-536],"s":[6,4,16],"l":1},{"p":[-321,58,-480],"s":[4,2,24],"l":1},{"p":[-321,58,-384],"s":[4,4,16],"l":1},{"p":[-321,58,-413],"s":[4,3,21],"l":1},{"p":[-321,58,-446],"s":[4,3,19],"l":1},{"p":[-53,60,-392],"s":[20,6,12],"l":1},{"p":[-166,60,-364],"s":[14,4,16],"l":1},{"p":[233,45,-548],"s":[12,2,6],"l":1},{"p":[262,45,-548],"s":[11,2,6],"l":1,"c":13290186},{"p":[288,45,-548],"s":[16,2,6],"l":1},{"p":[-82,90,-466],"s":[14,4,12],"l":1},{"p":[-43,90,-467],"s":[12,4,14],"l":1},{"p":[-44,90,-519],"s":[14,6,30],"l":1},{"p":[-60,90,-463],"s":[14,2,6],"l":1},{"p":[-39,90,-490],"s":[4,2,16],"l":1},{"p":[-84,90,-524],"s":[10,3,26],"l":1},{"p":[-87,90,-492],"s":[4,2,10],"l":1},{"p":[-63,71,-450],"s":[4,4,20],"t":2,"bo":1},{"p":[-122,55,-459],"s":[6,16,6],"t":2},{"p":[-124,62,-507],"s":[6,3,16],"l":1,"c":14474460},{"p":[-124,62,-476],"s":[6,2,14],"l":1,"c":14935011},{"p":[-88,62,-457],"s":[18,3,6],"l":1},{"p":[-116,60,-396],"s":[26,4,4],"l":1},{"p":[-164,60,-392],"s":[18,6,12],"l":1},{"p":[-82,60,-396],"s":[14,3,4],"l":1},{"p":[85,66,-447],"s":[4,4,16],"t":2,"bo":1},{"p":[-31,44,-377],"s":[9,4,20],"bo":1},{"p":[-14,44,-377],"s":[10,2,20],"bo":1},{"p":[-341,98,-387],"s":[12,4,14],"l":1},{"p":[-341,98,-350],"s":[12,6,12],"l":1},{"p":[-338,98,-369],"s":[6,2,12],"l":1},{"p":[-371,98,-389],"s":[12,4,10],"l":1},{"p":[-356,98,-392],"s":[8,2,4],"l":1},{"p":[53,65,-523],"s":[18,4,4],"l":1},{"p":[135,65,-523],"s":[12,4,4],"l":1},{"p":[114,65,-523],"s":[12,4,4],"l":1},{"p":[211,97,-517],"s":[14,6,14],"l":1},{"p":[153,97,-518],"s":[14,4,16],"l":1},{"p":[184,97,-514],"s":[12,2,8],"l":1},{"p":[215,97,-539],"s":[6,2,18],"l":1},{"p":[211,97,-564],"s":[14,6,12],"l":1},{"p":[153,97,-562],"s":[14,6,16],"l":1},{"p":[149,97,-539],"s":[6,2,12],"l":1},{"p":[148,16,-461],"s":[14,1,4]},{"p":[242,16,-461],"s":[18,2,4]},{"p":[249,16,-497],"s":[4,2,10]},{"p":[96,84,-459],"s":[6,12,6],"l":1,"t":2},{"p":[74,84,-459],"s":[6,10,6],"l":1,"t":2},{"p":[97,84,-537],"s":[6,20,6],"l":1,"t":2},{"p":[94,84,-463],"s":[14,4,18],"l":1},{"p":[74,84,-463],"s":[10,4,18],"l":1},{"p":[76,84,-533],"s":[14,4,18],"l":1},{"p":[96,84,-533],"s":[10,4,18],"l":1},{"p":[98,84,-498],"s":[6,4,20],"l":1},{"p":[72,84,-498],"s":[6,4,26],"l":1},{"p":[91,76,-414],"s":[6,16,6],"l":1,"t":2},{"p":[85,76,-410],"s":[24,6,18],"l":1},{"p":[13,76,-410],"s":[24,6,18],"l":1},{"p":[48,76,-416],"s":[20,4,6],"l":1},{"p":[12,76,-358],"s":[22,6,14],"l":1},{"p":[5,76,-382],"s":[8,4,14],"l":1},{"p":[53,76,-354],"s":[22,4,6],"l":1},{"p":[85,76,-360],"s":[24,6,18],"l":1},{"p":[93,76,-387],"s":[8,4,14],"l":1},{"p":[6,76,-414],"s":[6,20,6],"l":1,"t":2},{"p":[6,76,-356],"s":[6,14,6],"l":1,"t":2},{"p":[334,32,-432],"s":[4,2,18],"l":1},{"p":[334,32,-376],"s":[4,3,18],"l":1},{"p":[334,32,-406],"s":[4,2,22],"l":1},{"p":[147,58,-402],"s":[31,9,6],"l":1},{"p":[136,58,-378],"s":[9,12,42],"l":1},{"p":[198,58,-418],"s":[10,4,6],"l":1},{"p":[245,58,-375],"s":[7,4,20],"l":1},{"p":[234,58,-413],"s":[29,5,16],"l":1},{"p":[236,58,-299],"s":[25,4,24],"l":1},{"p":[245,58,-341],"s":[7,4,20],"l":1},{"p":[243,58,-416],"s":[6,19,6],"t":2},{"p":[314,61,-349],"s":[10,4,18],"l":1},{"p":[333,61,-356],"s":[11,3,4],"l":1},{"p":[354,61,-349],"s":[18,4,18],"l":1},{"p":[312,61,-306],"s":[6,4,28],"l":1},{"p":[316,61,-259],"s":[14,4,22],"l":1},{"p":[334,61,-250],"s":[11,3,4],"l":1},{"p":[356,61,-257],"s":[14,3,18],"l":1},{"p":[285,58,-88],"s":[2,40,2],"l":1,"t":2},{"p":[285,58,-40],"s":[2,40,2],"l":1,"t":2},{"p":[294,93,-64],"s":[22,2,53],"t":2},{"p":[193,58,-290],"s":[24,4,6],"l":1},{"p":[136,58,-332],"s":[9,6,24],"l":1},{"p":[348,44,-236],"s":[8,4,16],"l":1,"c":15132390},{"p":[348,44,-216],"s":[8,2,8],"l":1},{"p":[352,64,-379],"s":[6,4,20],"l":1},{"p":[352,64,-415],"s":[6,3,14],"l":1},{"p":[310,55,-490],"s":[4,4,14],"l":1},{"p":[315,55,-451],"s":[14,4,14],"l":1},{"p":[310,55,-473],"s":[4,2,10],"l":1},{"p":[342,55,-446],"s":[14,4,4],"l":1},{"p":[307,112,-576],"s":[6,4,22],"l":1,"c":"#b1b1b1"},{"p":[335,139,-89],"s":[12,4,6],"l":1},{"p":[313,139,-84],"s":[16,6,16],"l":1},{"p":[357,139,-84],"s":[16,6,16],"l":1},{"p":[313,139,-40],"s":[16,6,16],"l":1},{"p":[308,139,-62],"s":[6,4,12],"l":1},{"p":[228,48,-102],"s":[10,2,14],"l":1},{"p":[-293,40,-321],"s":[32,22,88],"bo":1},{"p":[-192,62,-323],"s":[20,4,66],"l":1},{"p":[-328,62,-361],"s":[20,4,8],"l":1},{"p":[-296,62,-361],"s":[20,4,8],"l":1},{"p":[-253,73,-364],"s":[6,10,6],"l":1,"t":2},{"p":[-274,73,-364],"s":[6,14,6],"l":1,"t":2},{"p":[-274,74,-322],"s":[8,4,94],"l":1},{"p":[-252,74,-283],"s":[8,4,16],"l":1},{"p":[9,6,-313],"s":[6,2,18]},{"p":[9,6,-199],"s":[6,2,18]},{"p":[9,6,-252],"s":[6,2,10]},{"p":[164,0,-61],"s":[4,62,4],"t":2,"bo":1},{"p":[154,54,-61],"s":[16,4,4],"t":2,"bo":1},{"p":[158,51,-61],"s":[16,2,2],"l":1,"r":[0,0,-0.7],"t":2},{"p":[-263,0,-273],"s":[4,54,4],"t":2,"bo":1},{"p":[-263,47,-263],"s":[4,4,16],"t":2,"bo":1},{"p":[-263,43,-268],"s":[2,2,16],"l":1,"r":[-0.7,0,0],"t":2},{"p":[238,86,-224],"s":[12,4,10],"l":1},{"p":[240,86,-152],"s":[8,4,10],"l":1},{"p":[217,86,-222],"s":[10,4,14],"l":1},{"p":[242,86,-189],"s":[4,4,28],"l":1},{"p":[251,92,-82],"s":[18,6,18],"l":1,"c":11184810},{"p":[176,92,-84],"s":[20,4,14],"l":1,"c":11645361},{"p":[173,92,-38],"s":[14,4,14],"l":1,"c":12303291},{"p":[207,92,-88],"s":[20,4,6],"l":1,"c":12171705},{"p":[168,92,-61],"s":[4,2,12],"l":1,"c":10987431},{"p":[254,92,-41],"s":[12,4,20],"l":1,"c":11974326},{"p":[214,92,-34],"s":[24,4,6],"l":1,"c":11513775},{"p":[145,70,-158],"s":[10,4,22],"l":1},{"p":[168,70,-154],"s":[8,4,14],"l":1},{"p":[145,70,-218],"s":[10,4,22],"l":1},{"p":[168,70,-222],"s":[8,4,14],"l":1},{"p":[214,86,-184],"s":[4,2,24],"l":1},{"p":[216,86,-152],"s":[8,4,10],"l":1},{"p":[179,67,0],"s":[4,2,10],"l":1},{"p":[179,67,17],"s":[4,6,15],"l":1},{"p":[136,44,-157],"s":[4,38,4],"t":2},{"p":[45,44,-157],"s":[4,38,4],"t":2},{"p":[45,44,-193],"s":[4,38,4],"t":2},{"p":[136,44,-193],"s":[4,42,4],"t":2},{"p":[91,58,-175],"s":[100,2,44],"t":2,"bo":1},{"p":[127,44,-155],"s":[26,4,4],"l":1},{"p":[48,44,-159],"s":[14,4,12],"l":1},{"p":[46,44,-191],"s":[10,4,12],"l":1},{"p":[90,44,-155],"s":[18,2,4],"l":1},{"p":[195,58,-226],"s":[18,4,6],"l":1},{"p":[186,58,-150],"s":[18,4,6],"l":1},{"p":[-3,54,-100],"s":[30,6,16],"l":1},{"p":[77,54,-98],"s":[30,6,20],"l":1},{"p":[79,54,-35],"s":[26,6,14],"l":1},{"p":[-5,54,-35],"s":[26,6,14],"l":1},{"p":[89,54,-66],"s":[6,4,20],"l":1},{"p":[37,54,-105],"s":[30,4,6],"l":1},{"p":[-15,54,-66],"s":[6,4,20],"l":1},{"p":[38,54,-31],"s":[18,4,6],"l":1},{"p":[-53,60,-364],"s":[20,4,16],"l":1},{"p":[-237,50,35],"s":[5,2,10],"l":1,"c":13158600},{"p":[164,92,31],"s":[28,6,16],"l":1,"c":11842740},{"p":[205,92,31],"s":[10,4,16],"l":1,"c":13816530},{"p":[156,92,60],"s":[12,6,14],"l":1,"c":13158600},{"p":[-260,47,19],"s":[4,54,158]},{"p":[-197,47,97],"s":[158,54,4]},{"p":[-178,13,51],"s":[4,74,4],"t":2},{"p":[-254,13,51],"s":[4,74,4],"t":2},{"p":[-216,80,72],"s":[84,2,50],"t":2},{"p":[-55,74,2],"s":[14,6,22],"l":1},{"p":[-97,74,1],"s":[14,6,24],"l":1},{"p":[-102,74,-42],"s":[4,4,24],"l":1},{"p":[-102,74,-75],"s":[4,4,14],"l":1},{"p":[-77,74,11],"s":[14,4,4],"l":1},{"p":[-50,74,-45],"s":[4,4,24],"l":1},{"p":[-54,74,-97],"s":[12,4,24],"l":1},{"p":[-236,50,-131],"s":[7,4,24],"l":1,"c":13158086},{"p":[-236,50,-96],"s":[7,4,22],"l":1,"c":11974326},{"p":[-221,60,14],"s":[6,2,15],"l":1},{"p":[-244,60,13],"s":[12,2,17],"l":1},{"p":[-224,60,-61],"s":[12,2,29],"l":1},{"p":[-220,60,-17],"s":[4,2,8],"l":1},{"p":[-251,124,-64],"s":[16,4,10],"l":1,"c":12171191},{"p":[-279,124,-66],"s":[12,4,14],"l":1,"c":12829635},{"p":[-278,124,-105],"s":[14,3,8],"l":1},{"p":[-109,60,-359],"s":[34,4,6],"l":1},{"p":[-130,77,-156],"s":[14,3,6],"l":1},{"p":[357,139,-40],"s":[16,6,16],"l":1},{"p":[-296,62,-281],"s":[20,4,8],"l":1},{"p":[-323,62,-281],"s":[14,4,8],"l":1},{"p":[9,0,-180],"s":[4,54,4],"t":2,"bo":1},{"p":[9,44,-175],"s":[2,2,12],"l":1,"r":[-0.7,0,0],"t":2},{"p":[-106,84,-96],"s":[14,6,24],"l":1},{"p":[-110,84,-137],"s":[6,4,24],"l":1},{"p":[-64,84,-96],"s":[14,6,24],"l":1},{"p":[-64,84,-184],"s":[14,6,24],"l":1},{"p":[-60,84,-137],"s":[6,4,16],"l":1},{"p":[-182,51,55],"s":[16,4,16],"l":1},{"p":[-250,51,50],"s":[16,4,6],"l":1},{"p":[-212,51,50],"s":[16,2,6],"l":1},{"p":[-252,51,60],"s":[12,12,12],"i":1},{"p":[343,32,-364],"s":[12,12,12],"i":1},{"p":[243,56,-292],"s":[6,28,6],"t":2},{"p":[10,24,8],"s":[18,2,4]},{"p":[82,24,8],"s":[20,2,4]},{"p":[-35,24,8],"s":[9,1,4]},{"p":[-129,24,-44],"s":[16,2,4]},{"p":[-164,24,-44],"s":[16,2,4]},{"p":[-170,24,-31],"s":[4,2,22]},{"p":[-170,24,4],"s":[4,2,12]},{"p":[-227,62,-323],"s":[20,4,66],"l":1},{"p":[-108,83,-89],"s":[6,26,6],"t":2},{"p":[-250,44,-124],"s":[4,41,4],"t":2},{"p":[-280,44,-124],"s":[4,40,4],"t":2},{"p":[-265,74,-117],"s":[38,2,22],"t":2},{"p":[-57,66,-201],"s":[10,6,36],"l":1},{"p":[-57,66,-260],"s":[10,4,26],"l":1},{"p":[-61,66,-308],"s":[18,4,26],"l":1},{"p":[-103,66,-308],"s":[18,4,26],"l":1},{"p":[-107,66,-251],"s":[10,4,22],"l":1},{"p":[-168,62,-268],"s":[8,2,20],"l":1},{"p":[-150,62,-268],"s":[12,4,20],"l":1},{"p":[-148,62,-304],"s":[8,4,20],"l":1},{"p":[-148,62,-342],"s":[8,4,28],"l":1},{"p":[335,100,-92],"s":[6,20,2],"l":1,"c":0},{"p":[196,51,-91],"s":[6,20,2],"l":1,"c":0},{"p":[-243,94,-84],"s":[2,16,6],"l":1,"c":0},{"p":[-295,112,-587],"s":[2,14,6],"l":1,"c":0},{"p":[-319,112,-560],"s":[5,14,2],"l":1,"c":0},{"p":[305,100,-62],"s":[2,20,6],"l":1,"c":0},{"p":[304,78,-518],"s":[2,14,6],"l":1,"c":0},{"p":[203,70,-510],"s":[5,14,2],"l":1,"c":0},{"p":[183,70,-510],"s":[5,14,2],"l":1,"c":0},{"p":[162,70,-510],"s":[5,14,2],"l":1,"c":0},{"p":[38,18,52],"s":[6,8,6],"i":2},{"p":[300,49,-301],"s":[18,4,4],"t":2,"bo":1},{"p":[-210,0,-155],"s":[4,1,6],"l":1},{"p":[-177,0,-258],"s":[4,2,6],"l":1},{"p":[-271,0,-270],"s":[6,2,4],"l":1},{"p":[-242,0,-431],"s":[8,2,4],"l":1},{"p":[-174,0,-403],"s":[4,1,4],"l":1},{"p":[-154,-1,-404],"s":[8,2,8],"l":1},{"p":[-5,-28,-393],"s":[6,2,4],"l":1},{"p":[307,0,-439],"s":[4,1,6],"l":1},{"p":[338,0,-212],"s":[4,2,8],"l":1},{"p":[305,0,-254],"s":[4,2,6],"l":1},{"p":[223,0,-232],"s":[8,2,4],"l":1},{"p":[203,0,-284],"s":[8,2,4],"c":11316396},{"p":[101,0,-355],"s":[4,2,8],"l":1},{"p":[15,0,-345],"s":[4,2,8],"l":1},{"p":[15,0,-211],"s":[4,2,8]},{"p":[-50,0,-175],"s":[6,2,8],"l":1},{"p":[97,0,-87],"s":[6,2,8],"l":1},{"p":[94,0,0],"s":[10,2,4],"l":1},{"p":[-43,0,-1],"s":[6,2,8],"l":1},{"p":[-11,18,15],"s":[10,2,4],"l":1},{"p":[-154,18,-38],"s":[6,1,3],"l":1},{"p":[-108,18,-7],"s":[4,2,10],"l":1},{"p":[-136,0,-52],"s":[8,2,6],"l":1},{"p":[162,0,-52],"s":[3,2,5],"l":1},{"p":[46,0,-149],"s":[6,1,5],"l":1},{"p":[-306,0,-349],"s":[4,1,7],"l":1},{"p":[-332,0,-270],"s":[4,2,8],"l":1},{"p":[-59,-28,-325],"s":[4,2,4]},{"p":[-141,-28,-351],"s":[4,2,8]},{"p":[-182,0,-218],"s":[4,2,8],"l":1},{"p":[-218,18,43],"s":[8,1,4],"l":1},{"p":[-40,18,52],"s":[6,2,8],"l":1},{"p":[119,0,-149],"s":[6,2,6],"l":1},{"p":[-196,0,-524],"s":[5,1,4],"l":1},{"p":[160,0,-70],"s":[4,2,4],"l":1},{"p":[-52,0,-163],"s":[4,2,4],"l":1},{"p":[251,0,-407],"s":[4,2,6],"l":1},{"p":[-5,-28,-408],"s":[12,12,12],"i":1},{"p":[251,0,-288],"s":[3,1,5],"l":1,"c":12829635},{"p":[313,0,-344],"s":[3,1,4]},{"p":[321,0,-364],"s":[4,2,4],"l":1},{"p":[202,0,-94],"s":[4,1,4]},{"p":[16,0,-264],"s":[4,1,6]},{"p":[37,0,-307],"s":[4,6,38]},{"p":[94,0,-325],"s":[22,6,4]},{"p":[107,0,-314],"s":[4,6,26]},{"p":[37,6,-316],"s":[4,2,10]},{"p":[107,6,-321],"s":[4,2,12]},{"p":[99,6,-325],"s":[12,4,4]},{"p":[76,0,-325],"s":[14,2,4]},{"p":[9,47,-171],"s":[4,4,14],"t":2,"bo":1},{"p":[85,-1,-226],"s":[6,2,4],"l":1},{"p":[65,-1,-200],"s":[6,2,4],"l":1},{"p":[-124,61,-114],"s":[22,4,4],"t":2,"bo":1},{"p":[22,45,-351],"s":[6,14,2],"l":1,"c":0},{"p":[51,45,-351],"s":[6,14,2],"l":1,"c":0},{"p":[79,45,-351],"s":[6,14,2],"l":1,"c":0},{"p":[-63,68,-456],"s":[2,2,14],"l":1,"r":[-0.7,0,0],"t":2},{"p":[-115,57,-114],"s":[14,2,2],"l":1,"r":[0,0,-0.7],"t":2},{"p":[91,77,-175],"s":[100,2,44],"t":2,"bo":1},{"p":[107,10,-469],"s":[12,12,12],"i":1},{"p":[203,-28,-413],"s":[91,86,16],"bo":1},{"p":[165,58,-413],"s":[11,6,16],"l":1},{"p":[179,16,-461],"s":[20,2,4]},{"p":[344,50,-196],"s":[12,3,18],"l":1,"c":"#b1b1b1"},{"p":[340,50,-160],"s":[4,2,18],"l":1,"c":"#b9b9b9"},{"p":[340,50,-123],"s":[4,4,22],"l":1,"c":"#b9b9b9"},{"p":[322,-1,-401],"s":[20,2,96],"c":10987431,"t":1},{"p":[144,58,-294],"s":[25,4,14],"l":1},{"p":[305,45,-301],"s":[14,2,2],"l":1,"r":[0,0,-0.7],"t":2},{"p":[85,62,-453],"s":[2,2,14],"l":1,"r":[-0.7,0,0],"t":2},{"p":[-22,65,-523],"s":[18,4,4],"l":1},{"p":[16,65,-523],"s":[20,2,4],"l":1},{"p":[-146,0,-475],"s":[8,26,2],"i":3,"t":2,"d":1},{"p":[-210,0,-276],"s":[76,5,2],"c":13158600},{"p":[-210,0,-284],"s":[76,4,14],"l":1,"c":1916250,"o":0.8,"t":5},{"p":[-253,0,-269],"s":[4,2,6],"l":1},{"p":[-175,0,-270],"s":[6,8,6],"i":2},{"p":[-302,0,-232],"s":[6,8,6],"i":2},{"p":[-128,0,-115],"s":[6,2,66],"t":2},{"p":[-121,0,-114],"s":[6,2,66],"c":13290186,"t":2},{"p":[-132,2,-113],"s":[6,2,66],"t":2},{"p":[-125,2,-114],"s":[6,2,66],"t":2},{"p":[-128,4,-112],"s":[6,2,66],"c":12632256,"t":2},{"p":[-135,0,-112],"s":[6,2,66],"c":12303291,"t":2},{"p":[-132,38,-114],"s":[1,25,1],"l":1,"c":11645361,"t":2},{"p":[-196,46,-191],"s":[34,31,76],"bo":1},{"p":[-183,40,-157],"s":[2,6,2],"l":1,"c":3421236,"t":5},{"p":[-192,42,-157],"s":[2,6,2],"l":1,"c":3421236,"t":5},{"p":[-201,41,-157],"s":[2,6,2],"l":1,"c":3421236,"t":5},{"p":[-209,40,-157],"s":[2,6,2],"l":1,"c":3421236,"t":5},{"p":[-192,41,-227],"s":[2,6,2],"l":1,"c":3421236,"t":5},{"p":[-183,40,-227],"s":[2,6,2],"l":1,"c":3421236,"t":5},{"p":[-201,42,-227],"s":[2,4,2],"l":1,"c":3421236,"t":5},{"p":[-209,40,-227],"s":[2,6,2],"l":1,"c":3421236,"t":5},{"p":[-442,0,157],"s":[62,206,72],"l":1},{"p":[-418,206,129],"s":[14,6,16],"l":1},{"p":[-414,206,157],"s":[6,6,22],"l":1},{"p":[-414,206,186],"s":[6,4,14],"l":1},{"p":[-444,206,123],"s":[20,6,4],"l":1},{"p":[-468,206,123],"s":[10,6,4],"l":1},{"p":[-442,163,121],"s":[8,20,2],"l":1,"c":0},{"p":[-178,13,93],"s":[4,74,4],"t":2},{"p":[-254,13,93],"s":[4,74,4],"t":2},{"p":[-19,64,74],"s":[60,12,38],"bo":1},{"p":[123,76,57],"s":[28,4,4],"l":1},{"p":[70,76,57],"s":[34,2,4],"l":1},{"p":[21,76,57],"s":[26,4,4],"l":1},{"p":[-41,76,57],"s":[12,2,4],"l":1},{"p":[-75,76,57],"s":[16,2,4],"l":1},{"p":[-127,76,57],"s":[26,4,4],"l":1},{"p":[-19,0,73],"s":[60,64,2],"t":2,"bo":1},{"p":[-46,18,61],"s":[6,8,6],"i":2},{"p":[-13,32,71],"s":[4,4,2],"l":1,"c":3092271,"t":5,"bo":1},{"p":[-26,32,71],"s":[4,4,2],"l":1,"c":3092271,"t":5,"bo":1},{"p":[19,63,48],"s":[4,4,16],"t":2,"bo":1},{"p":[-56,63,48],"s":[4,4,16],"t":2,"bo":1},{"p":[-56,59,53],"s":[2,2,12],"l":1,"r":[0.87,0,0],"t":2},{"p":[19,59,53],"s":[2,2,12],"l":1,"r":[0.87,0,0],"t":2},{"p":[-139,301,405],"s":[110,66,86],"t":5},{"p":[-73,281,361],"s":[70,42,56],"t":5},{"p":[-527,412,373],"s":[146,90,116],"t":5},{"p":[-571,369,297],"s":[118,72,94],"t":5},{"p":[673,319,120],"s":[110,66,86],"t":5},{"p":[485,337,226],"s":[146,88,198],"t":5},{"p":[334,337,95],"s":[58,30,97],"l":1,"t":5},{"p":[-866,323,-277],"s":[146,90,196],"l":1,"t":5},{"p":[-926,303,-516],"s":[122,76,160],"l":1,"t":5},{"p":[-1998,360,-35],"s":[260,76,368],"l":1,"t":5},{"p":[1593,397,-140],"s":[218,132,256],"t":5},{"p":[1593,377,-267],"s":[118,72,92],"t":5},{"p":[-130,234,-914],"s":[146,90,116],"t":5},{"p":[-46,204,-952],"s":[118,74,94],"t":5},{"p":[98,204,-952],"s":[96,38,48],"l":1,"t":5},{"p":[735,363,-1249],"s":[224,104,178],"t":5},{"p":[186,263,500],"s":[104,58,112],"l":1,"t":5},{"p":[81,263,500],"s":[48,28,52],"l":1,"t":5},{"p":[-561,204,-851],"s":[118,74,94],"t":5},{"p":[-22,-28,-518],"s":[6,8,6],"i":2},{"p":[-34,-16,-518],"s":[6,8,6],"i":2},{"p":[-31,-28,-515],"s":[12,12,12],"i":1},{"p":[60,-28,-425],"s":[12,12,12],"i":1},{"p":[63,-28,-515],"s":[12,12,12],"i":1},{"p":[63,-28,-503],"s":[12,12,12],"i":1},{"p":[54,-28,-518],"s":[6,8,6],"i":2},{"p":[218,70,-541],"s":[2,14,6],"l":1,"c":0},{"p":[-13,76,57],"s":[10,4,4],"l":1},{"p":[-19,70,102],"s":[220,40,58],"c":12303291,"bo":1},{"p":[89,110,108],"s":[4,4,18],"l":1,"c":13814731},{"p":[-119,110,80],"s":[20,4,14],"l":1,"c":12303291},{"p":[36,110,75],"s":[16,4,4],"l":1,"c":12500156},{"p":[-2,110,75],"s":[24,2,4],"l":1,"c":12631228},{"p":[-78,110,75],"s":[14,2,4],"l":1,"c":10329501},{"p":[-44,110,75],"s":[14,4,4],"l":1,"c":12961221},{"p":[81,110,80],"s":[20,4,14],"l":1,"c":12303291},{"p":[-127,110,108],"s":[4,4,18],"l":1,"c":11645361},{"p":[-121,99,70],"s":[4,4,8],"t":2},{"p":[82,99,70],"s":[4,4,8],"t":2},{"p":[92,99,82],"s":[12,4,4],"t":2},{"p":[-131,99,82],"s":[10,4,4],"t":2},{"p":[292,45,-113],"s":[60,2,20],"t":2,"bo":1},{"p":[264,0,-121],"s":[2,49,2],"t":2},{"p":[12,-28,-461],"s":[6,8,6],"i":2},{"p":[138,-28,-456],"s":[6,8,6],"i":2},{"p":[20,48,-433],"s":[28,4,14],"l":1},{"p":[20,48,-453],"s":[28,2,10],"l":1},{"p":[161,-28,-424],"s":[4,42,6]},{"p":[-109,40,-404],"s":[4,4,14],"t":2,"bo":1},{"p":[-109,37,-400],"s":[2,2,14],"l":1,"r":[0.7,0,0],"t":2},{"p":[20,34,-461],"s":[4,4,20],"t":2,"bo":1},{"p":[20,32,-461],"s":[2,2,12],"l":1,"r":[0.87,0,0],"t":2},{"p":[21,-28,-464],"s":[12,12,12],"i":1},{"p":[21,-16,-464],"s":[12,12,12],"i":1},{"p":[-253,57,-559],"s":[74,32,2],"c":6904648,"t":5},{"p":[-286,52,-562],"s":[4,40,4],"t":2},{"p":[-221,52,-562],"s":[4,40,4],"t":2},{"p":[260,51,-568],"s":[74,32,2],"c":7363405,"t":5},{"p":[260,67,-566],"s":[69,0,29],"i":11,"l":1,"r":[1.57,0,0],"sad":1},{"p":[-258,69,-18],"s":[2,26,62],"c":6903619,"t":5},{"p":[-256,82,-18],"s":[57,0,23],"i":11,"l":1,"r":[1.57,0,1.57],"sad":1},{"p":[72,0,-277],"s":[64,41,90],"i":14,"l":1},{"p":[-283,10,-505],"s":[69,41,78],"i":14,"l":1},{"p":[174,10,-504],"s":[142,41,78],"i":14,"l":1},{"p":[-136,18,-16],"s":[59,41,49],"i":14,"l":1},{"p":[336,79,-303],"s":[54,2,110],"t":2,"bo":1},{"p":[312,60,-251],"s":[4,25,4],"t":2},{"p":[312,62,-355],"s":[4,25,4],"t":2},{"p":[360,61,-355],"s":[4,24,4],"t":2},{"p":[360,61,-251],"s":[4,26,4],"t":2},{"p":[257,47,-352],"s":[18,4,4],"t":2,"bo":1},{"p":[252,44,-352],"s":[14,2,2],"l":1,"r":[0,0,0.7],"t":2},{"p":[213,0,-97],"s":[12,12,12],"i":1},{"p":[210,56,-292],"s":[6,30,6],"t":2},{"p":[243,56,-326],"s":[6,29,6],"t":2},{"p":[210,56,-326],"s":[6,26,6],"t":2},{"p":[227,77,-309],"s":[42,2,43],"t":2,"bo":1},{"p":[137,56,-292],"s":[6,22,6],"t":2},{"p":[-11,-28,-514],"s":[6,2,4],"l":1},{"p":[277,10,-540],"s":[8,1,4],"l":1},{"p":[2,-28,-448],"s":[6,2,4],"l":1},{"p":[-147,62,-261],"s":[4,12,4],"t":2},{"p":[-169,62,-261],"s":[4,15,4],"t":2},{"p":[-169,62,-286],"s":[4,11,4],"t":2},{"p":[-147,62,-287],"s":[4,13,4],"t":2},{"p":[-158,70,-274],"s":[28,1,32],"t":2,"bo":1},{"p":[-118,61,-197],"s":[48,87,47],"c":10987431},{"p":[-119,96,-197],"s":[85,2,46],"t":2},{"p":[-159,72,-218],"s":[3,30,3],"t":2},{"p":[-143,72,-218],"s":[3,28,3],"t":2},{"p":[-143,72,-176],"s":[3,29,3],"t":2},{"p":[-159,72,-176],"s":[3,28,3],"t":2},{"p":[263,35,-352],"s":[1,13,1],"l":1,"c":11645361,"t":2},{"p":[-109,28,-409],"s":[1,13,1],"l":1,"c":11645361,"t":2},{"p":[-174,0,-472],"s":[6,1,4],"l":1},{"p":[-147,18,52],"s":[6,1,5],"l":1},{"p":[200,220,-911],"s":[174,74,155],"t":5},{"p":[92,76,-356],"s":[6,17,6],"l":1,"t":2},{"p":[-48,59,-361],"s":[6,14,6],"l":1,"t":2},{"p":[228,48,-137],"s":[10,3,11],"l":1},{"p":[37,0,-160],"s":[8,13,4]},{"p":[29,0,-160],"s":[8,6,4]},{"p":[7,0,-173],"s":[4,1,4],"l":1},{"p":[-79,66,-218],"s":[3,33,3],"t":2},{"p":[-79,84,-177],"s":[3,17,3],"t":2},{"p":[-93,84,-177],"s":[3,17,3],"t":2},{"p":[-93,66,-218],"s":[3,35,3],"t":2},{"p":[-96,148,-197],"s":[4,3,11],"l":1,"c":10987431},{"p":[-140,148,-202],"s":[4,3,15],"l":1,"c":9013641},{"p":[-137,148,-178],"s":[10,3,9],"l":1,"c":11513775},{"p":[-99,148,-178],"s":[10,3,9],"l":1,"c":11973298},{"p":[-99,148,-216],"s":[10,4,9],"l":1,"c":10987431},{"p":[-117,148,-218],"s":[12,2,5],"l":1,"c":11974326},{"p":[-138,148,-217],"s":[8,3,7],"l":1,"c":10197915},{"p":[-120,148,-176],"s":[9,2,5],"l":1,"c":11513775},{"p":[-118,117,-197],"s":[50,16,5],"l":1,"c":0},{"p":[-118,117,-197],"s":[5,16,49],"l":1,"c":0},{"p":[-43,43,-298],"s":[18,4,4],"t":2,"bo":1},{"p":[-48,39,-298],"s":[14,2,2],"l":1,"r":[0,0,0.7],"c":15132390,"t":2},{"p":[-37,31,-298],"s":[1,13,1],"l":1,"c":11645361,"t":2},{"p":[-212,50,-63],"s":[14,4,4],"t":2},{"p":[-166,0,-150],"s":[6,8,6],"i":2},{"p":[22,42,-350],"s":[9,3,3],"c":14935011,"bo":1},{"p":[51,42,-350],"s":[9,3,3],"bo":1},{"p":[79,42,-350],"s":[9,3,3],"bo":1},{"p":[183,67,-509],"s":[9,3,3],"bo":1},{"p":[203,67,-509],"s":[9,3,3],"bo":1},{"p":[162,67,-509],"s":[9,3,3],"bo":1},{"p":[-54,0,-115],"s":[4,7,4],"i":16},{"p":[-54,0,-121],"s":[4,7,4],"i":16},{"p":[8,18,69],"s":[4,7,4],"i":16},{"p":[306,0,-321],"s":[4,7,4],"i":16},{"p":[251,0,-352],"s":[4,7,4],"i":16},{"p":[-160,0,-150],"s":[4,7,4],"i":16},{"p":[-154,0,-150],"s":[4,7,4],"i":16},{"p":[71,0,-345],"s":[12,12,12],"i":1},{"p":[-119,18,-39],"s":[4,7,4],"i":16},{"p":[-73,17,16],"s":[5,2,4],"l":1},{"p":[-116,0,-233],"s":[4,2,6],"l":1},{"p":[-169,62,-393],"s":[6,12,6],"l":1,"t":2},{"p":[174,0,-28],"s":[4,7,4],"i":16},{"p":[174,0,-23],"s":[4,7,4],"i":16},{"p":[176,0,-16],"s":[2,19,4],"t":2},{"p":[112,0,-209],"s":[57,26,25],"i":17},{"p":[55,-1,-255],"s":[6,3,4],"l":1},{"p":[56,0,-249],"s":[4,7,4],"i":16},{"p":[62,0,-348],"s":[4,7,4],"i":16},{"p":[86,0,-297],"s":[4,7,4],"i":16},{"p":[86,0,-292],"s":[4,7,4],"i":16},{"p":[-220,0,-104],"s":[57,26,25],"i":17,"l":1,"r":[0,1.57,0]},{"p":[-227,0,-139],"s":[12,12,12],"i":8},{"p":[78,0,-203],"s":[12,12,12],"i":8},{"p":[-173,0,-70],"s":[4,1,4],"l":1},{"p":[169,0,17],"s":[6,2,8],"l":1},{"p":[147,0,28],"s":[6,8,6],"i":2},{"p":[289,10,-542],"s":[4,7,4],"i":16},{"p":[295,10,-542],"s":[4,7,4],"i":16},{"p":[-181,0,-473],"s":[4,7,4],"i":16},{"p":[-52,21,-269],"s":[1,15,6],"l":1,"c":0},{"p":[-52,29,-218],"s":[1,15,6],"l":1,"c":0},{"p":[-53,18,-269],"s":[6,3,9],"l":1,"c":14935011},{"p":[-53,26,-218],"s":[6,3,9],"l":1,"c":14935011},{"p":[217,67,-541],"s":[6,3,9],"c":14935011,"bo":1},{"p":[304,76,-518],"s":[6,3,9],"c":11645361,"bo":1},{"p":[90,44,-195],"s":[16,2,4],"l":1},{"p":[127,44,-195],"s":[26,4,4],"l":1},{"p":[66,44,-195],"s":[12,3,4],"l":1},{"p":[-317,0,-415],"s":[4,7,4],"i":16},{"p":[-53,0,-159],"s":[7,6,8],"i":18,"l":1,"c":"#d5e371"},{"p":[-54,0,-169],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.04,-3.14],"c":"#d5e371"},{"p":[36,0,-165],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#d5e371"},{"p":[37,0,-175],"s":[7,6,8],"i":18,"l":1,"r":[0,0.18,0],"c":"#d5e371"},{"p":[5,0,-188],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.09,-3.14],"c":"#d5e371"},{"p":[-42,0,-57],"s":[7,6,8],"i":18,"l":1,"r":[0,0.18,0],"c":"#c9d47c"},{"p":[-9,0,2],"s":[7,6,8],"i":18,"l":1,"r":[0,0.18,0],"c":"#c9d47c"},{"p":[-19,0,-26],"s":[7,6,8],"i":18,"l":1,"r":[0,0.18,0],"c":"#c9d47c"},{"p":[21,0,-346],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[59,0,-344],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.17,0]},{"p":[80,0,-212],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.17,0]},{"p":[29,0,-346],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0]},{"p":[129,0,-286],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.17,0]},{"p":[101,0,-318],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.17,0]},{"p":[59,0,-243],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.04,0]},{"p":[139,0,-231],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.17,0]},{"p":[-42,-28,-355],"s":[7,6,8],"i":18,"l":1,"r":[0,0.18,0]},{"p":[-5,-28,-347],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0]},{"p":[-86,-28,-325],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.34,0]},{"p":[-260,0,-269],"s":[7,6,8],"i":18,"l":1},{"p":[-298,0,-236],"s":[7,6,8],"i":18,"l":1},{"p":[-307,0,-275],"s":[7,6,8],"i":18,"l":1},{"p":[-182,0,-271],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0]},{"p":[-176,0,-264],"s":[7,6,8],"i":18,"l":1},{"p":[-217,0,-136],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0]},{"p":[-214,0,-72],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0]},{"p":[-147,0,-149],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0]},{"p":[-109,0,-62],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0]},{"p":[-109,18,-25],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0]},{"p":[-215,18,19],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0]},{"p":[-230,18,43],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0]},{"p":[-46,18,54],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.22,-3.14]},{"p":[10,18,54],"s":[7,6,8],"i":18,"l":1,"r":[0,1.57,0]},{"p":[-48,18,16],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0]},{"p":[160,0,-62],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0]},{"p":[169,0,-27],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0],"c":"#c9d47c"},{"p":[162,0,20],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0],"c":"#c9d47c"},{"p":[173,0,11],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.38,0],"c":"#c9d47c"},{"p":[166,0,-92],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.34,0]},{"p":[126,0,-150],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.34,0]},{"p":[127,0,-65],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0],"c":"#c9d47c"},{"p":[134,0,-70],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#c9d47c"},{"p":[128,0,-77],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.23,3.14],"c":"#c9d47c"},{"p":[96,0,-46],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0],"c":"#c9d47c"},{"p":[130,0,-71],"s":[6,8,6],"i":2},{"p":[174,0,20],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0],"c":"#c9d47c"},{"p":[11,0,3],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0],"c":"#c9d47c"},{"p":[206,0,-218],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.34,0]},{"p":[208,0,-186],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.51,0]},{"p":[174,0,-156],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.51,0]},{"p":[101,0,2],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0]},{"p":[205,0,-279],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.17,0]},{"p":[237,0,-283],"s":[7,6,8],"i":18,"l":1,"r":[0,0.88,0],"c":"#c9d47c"},{"p":[307,-1,-247],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.41,3.14],"c":"#c9d47c"},{"p":[253,0,-108],"s":[6,1,6],"l":1},{"p":[306,0,-316],"s":[7,6,8],"i":18,"l":1,"r":[0,0.71,0],"c":"#c9d47c"},{"p":[274,0,-350],"s":[7,6,8],"i":18,"l":1,"r":[-3.13,-1.41,-3.13]},{"p":[320,1,-440],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14]},{"p":[320,1,-420],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0]},{"p":[319,1,-430],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.56,0]},{"p":[322,1,-372],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.04,0]},{"p":[318,1,-385],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.39,0]},{"p":[326,1,-389],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0]},{"p":[329,1,-361],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0]},{"p":[251,0,-357],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14]},{"p":[327,1,-422],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.39,0]},{"p":[318,1,-395],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.18,3.14]},{"p":[326,1,-434],"s":[7,6,8],"i":18,"l":1,"r":[-0.1,-1.56,-0.1]},{"p":[301,10,-541],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14]},{"p":[222,10,-511],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14]},{"p":[221,10,-467],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14]},{"p":[-40,-28,-362],"s":[4,1,6]},{"p":[-214,0,-68],"s":[2,1,2],"l":1},{"p":[-280,0,-296],"s":[3,1,4],"l":1},{"p":[195,0,-284],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0]},{"p":[305,0,-307],"s":[7,6,8],"i":18,"l":1,"r":[0,0.88,0],"c":"#c9d47c"},{"p":[164,-28,-429],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.36,-3.14]},{"p":[105,-28,-456],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.88,-3.14]},{"p":[129,-28,-455],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.88,-3.14]},{"p":[222,10,-529],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14]},{"p":[220,10,-543],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.51,-3.14]},{"p":[61,-29,-435],"s":[6,2,4],"l":1},{"p":[276,0,-346],"s":[2,1,3],"l":1},{"p":[134,0,-77],"s":[2,1,3],"l":1},{"p":[-157,0,-147],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.57,0]},{"p":[-247,0,-271],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0]},{"p":[50,-28,-423],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.88,-3.14]},{"p":[53,-28,-511],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14]},{"p":[49,-28,-517],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.51,0]},{"p":[-15,-28,-517],"s":[7,6,8],"i":18,"l":1,"r":[0,1.06,0]},{"p":[-21,-28,-512],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.16,0]},{"p":[-32,-28,-505],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.56,-3.14]},{"p":[6,-28,-462],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.21,-3.14]},{"p":[11,0,-186],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.04,-3.14],"c":"#d5e371"},{"p":[3,-28,-315],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0]},{"p":[-6,-28,-318],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.39,0]},{"p":[2,-28,-347],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.22,0]},{"p":[-67,-28,-325],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.34,0]},{"p":[3,-28,-422],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.21,-3.14]},{"p":[-187,0,-477],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0]},{"p":[-316,0,-368],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0]},{"p":[-316,0,-376],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.57,0]},{"p":[-315,0,-410],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.7,-3.14]},{"p":[-175,0,-398],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.7,3.14]},{"p":[-186,0,-499],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.7,3.14]},{"p":[-245,0,-360],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.7,3.14]},{"p":[-2,-28,-417],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.16,-3.14]},{"p":[-249,0,-434],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.7,-3.14]},{"p":[-194,0,-476],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.52,3.14]},{"p":[133,0,-224],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[293,39,-301],"s":[1,10,1],"l":1,"c":11645361,"t":2},{"p":[-165,18,-33],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0]},{"p":[71,0,-274],"s":[57,26,25],"i":19,"l":1,"r":[0,1.57,0]},{"p":[71,0,-274],"s":[25,2,57],"v":1,"t":5},{"p":[71,24,-274],"s":[25,2,57],"v":1,"t":5},{"p":[59,2,-274],"s":[1,22,57],"pe":1,"v":1,"t":5},{"p":[83,2,-274],"s":[1,22,57],"pe":1,"v":1,"t":5},{"p":[71,-1,-274],"s":[22,2,54],"c":7677719,"t":5},{"p":[-52,-28,-322],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0]},{"p":[-48,-28,-315],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.7,3.14]},{"p":[87,0,-287],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[251,0,-414],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14]},{"p":[68,0,-114],"s":[12,12,12],"i":8},{"p":[228,48,-124],"s":[10,2,6],"l":1},{"p":[223,0,-143],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.34,0]},{"p":[261,0,-321],"s":[57,26,25],"i":19,"l":1,"r":[0,1.57,0]},{"p":[261,0,-321],"s":[25,2,57],"v":1,"t":5},{"p":[261,24,-321],"s":[25,2,57],"pe":1,"v":1,"t":5},{"p":[273,2,-321],"s":[1,22,57],"pe":1,"v":1,"t":5},{"p":[249,2,-321],"s":[1,22,55],"pe":1,"t":5},{"p":[261,0,-321],"s":[23,1,54],"c":9518129,"t":5},{"p":[275,0,-291],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.19,-3.14],"c":"#c9d47c"},{"p":[-202,0,-485],"s":[12,12,12],"i":1},{"p":[-190,12,-485],"s":[12,12,12],"i":1},{"p":[-187,0,-494],"s":[6,8,6],"i":2},{"p":[-156,0,-514],"s":[57,26,25],"i":19,"l":1},{"p":[-156,0,-527],"s":[57,52,2],"c":1776411,"t":5},{"p":[-153,0,-514],"s":[63,1,23],"c":1776411,"t":5},{"p":[-217,0,-544],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.52,3.14]},{"p":[-187,0,-524],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.52,3.14]},{"p":[-155,1,-502],"s":[54,24,2],"v":1,"c":1776411,"t":5},{"p":[-155,24,-514],"s":[57,2,25],"pe":1,"v":1,"c":1776411,"t":5},{"p":[-245,0,-453],"s":[4,11,23]},{"p":[324,-18,-158],"s":[4,25,80]},{"p":[260,-18,-158],"s":[4,25,80]},{"p":[292,-14,-175],"s":[61,14,44],"i":9,"c":"#ffffff","t":1,"d":3},{"p":[-305,10,-521],"s":[12,12,12],"i":1},{"p":[-270,10,-445],"s":[6,8,6],"i":2},{"p":[-265,0,-375],"s":[12,12,12],"i":1},{"p":[-165,0,-404],"s":[12,12,12],"i":1},{"p":[-275,0,-453],"s":[4,16,24]},{"p":[324,7,-150],"s":[4,2,22]},{"p":[324,7,-182],"s":[4,2,16]},{"p":[-245,16,-522],"s":[4,2,12]},{"p":[-245,16,-479],"s":[4,2,12]},{"p":[-245,0,-507],"s":[4,16,80]},{"p":[-245,0,-467],"s":[5,17,5]},{"p":[-275,16,-451],"s":[4,2,12]},{"p":[228,0,-98],"s":[10,48,18],"bo":1},{"p":[292,-1,-112],"s":[68,1,22],"t":1},{"p":[292,-18,-121],"s":[60,19,6],"c":"#525252","t":5},{"p":[228,20,-109],"s":[10,28,4],"bo":1},{"p":[292,36,-64],"s":[50,2,80],"c":"#3e3e3e","t":5,"bo":1},{"p":[292,-3,-73],"s":[50,4,90],"c":"#525252","t":5},{"p":[259,0,-63],"s":[18,37,80],"bo":1},{"p":[380,0,-63],"s":[128,37,80],"bo":1},{"p":[305,10,-69],"s":[66,22,2],"l":1,"r":[0,-1.57,0],"c":"#2c3f55","t":5},{"p":[292,10,-69],"s":[66,2,24],"l":1,"r":[0,-1.57,0],"c":2899797,"t":5},{"p":[292,32,-69],"s":[66,2,28],"l":1,"r":[0,-1.57,0],"c":"#2c3f55","t":5},{"p":[292,3,-78],"s":[4,4,27],"r":[0,-1.57,0],"c":8551805,"t":5},{"p":[303,1,-78],"s":[8,8,4],"r":[0,-1.57,0],"c":1447446,"t":5},{"p":[298,1,-78],"s":[8,8,4],"r":[0,-1.57,0],"c":1447446,"t":5},{"p":[281,1,-78],"s":[8,8,4],"r":[0,-1.57,0],"c":1447446,"t":5},{"p":[286,1,-78],"s":[8,8,4],"r":[0,-1.57,0],"c":1447446,"t":5},{"p":[292,6,-67],"s":[66,4,5],"l":1,"r":[0,-1.57,0],"c":8551805,"t":5},{"p":[292,6,-101],"s":[3,4,24],"l":1,"r":[0,-1.57,0],"c":8551805,"t":5},{"p":[285,12,-102],"s":[2,20,12],"l":1,"r":[0,-1.57,0],"c":"#6b6b6b","t":5},{"p":[306,12,-97],"s":[12,20,2],"l":1,"r":[0,-1.57,0],"c":"#6b6b6b","t":5},{"p":[292,5,-101],"s":[4,1,27],"l":1,"r":[0,-1.57,0],"c":8551805,"t":5},{"p":[282,7,-102],"s":[2,2,2],"l":1,"r":[0,-1.57,0],"c":16730880,"e":16711680,"o":0.8,"t":5},{"p":[302,7,-102],"s":[2,2,2],"l":1,"r":[0,-1.57,0],"c":"#ff4b00","e":16711680,"o":0.8,"t":5},{"p":[316,0,-64],"s":[2,36,80],"c":"#3e3e3e","t":5,"bo":1},{"p":[292,0,-38],"s":[46,36,1],"c":0,"t":5},{"p":[292,0,-57],"s":[46,36,1],"c":0,"o":0.4,"t":5},{"p":[292,0,-73],"s":[46,36,1],"c":0,"o":0.4,"t":5},{"p":[292,0,-73],"s":[46,36,1],"c":0,"o":0.4,"t":5},{"p":[292,-18,-139],"s":[60,4,30],"c":"#b6b6b6","t":1},{"p":[292,0,-103],"s":[46,36,1],"c":0,"o":0.4,"t":5,"bo":1},{"p":[292,0,-91],"s":[46,36,1],"c":0,"o":0.4,"t":5},{"p":[228,0,-142],"s":[10,48,14],"bo":1},{"p":[228,19,-133],"s":[10,29,4],"bo":1},{"p":[228,26,-121],"s":[10,22,20],"bo":1},{"p":[222,0,-131],"s":[7,1,4],"l":1},{"p":[-156,0,-488],"s":[57,26,25],"i":17},{"p":[-265,10,-443],"s":[4,7,4],"i":16},{"p":[320,0,-121],"s":[2,50,2],"t":2},{"p":[317,-14,-130],"s":[4,1,4],"l":1,"c":"#c5c5c5"},{"p":[313,1,-100],"s":[4,7,4],"i":16},{"p":[315,1,-119],"s":[6,8,6],"i":2},{"p":[-54,0,-118],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#d5e371"},{"p":[236,0,-94],"s":[6,8,6],"i":2},{"p":[236,0,-144],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0]},{"p":[-253,73,-557],"s":[69,0,28],"i":11,"l":1,"r":[1.57,0,0],"sad":1},{"p":[-250,10,-544],"s":[4,7,4],"i":16},{"p":[-129,2,-514],"s":[1,24,23],"l":1,"c":0,"o":0.7000000000000001,"t":5},{"p":[-122,58,-524],"s":[6,14,6],"t":2},{"p":[-83,62,-459],"s":[6,16,6],"t":2},{"p":[-156,26,-514],"s":[57,26,25],"i":17},{"p":[-136,-28,-350],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0]},{"p":[176,0,-10],"s":[2,18,4],"c":14145495,"t":2},{"p":[-56,0,-128],"s":[2,18,4],"c":14145495,"t":2},{"p":[138,0,-286],"s":[5,19,2],"t":2},{"p":[145,0,-286],"s":[5,18,2],"t":2},{"p":[26,0,-350],"s":[5,18,2],"t":2},{"p":[309,0,-306],"s":[2,19,4],"t":2},{"p":[308,0,-316],"s":[2,19,4],"t":2},{"p":[-260,0,-439],"s":[26,16,4]},{"p":[-269,10,-452],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.7,-3.14]},{"p":[-212,0,-385],"s":[51,15,20],"i":7,"l":1,"r":[-3.14,0,-3.14]},{"p":[-212,0,-384],"s":[49,8,16],"v":1},{"p":[-217,8,-384],"s":[24,7,16],"v":1},{"p":[-155,0,-412],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.87,3.14]},{"p":[-241,0,-388],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.7,3.14]},{"p":[-192,0,-371],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.7,3.14]},{"p":[279,10,-69],"s":[66,22,2],"l":1,"r":[0,-1.57,0],"c":"#2c3f55","t":5},{"p":[343,32,-376],"s":[12,12,12],"i":1},{"p":[343,44,-369],"s":[12,12,12],"i":1},{"p":[183,88,-4],"s":[4,2,54],"t":2},{"p":[199,88,-4],"s":[4,2,54],"t":2},{"p":[190,90,-27],"s":[26,1,4],"c":14277081,"t":2},{"p":[190,90,-20],"s":[25,1,4],"t":2},{"p":[191,90,-12],"s":[26,1,4],"c":13158600,"t":2},{"p":[191,90,19],"s":[26,1,4],"t":2},{"p":[190,90,-5],"s":[24,1,4],"t":2},{"p":[190,90,12],"s":[23,1,4],"t":2},{"p":[190,90,4],"s":[23,1,4],"c":12303291,"t":2},{"p":[170,87,-87],"s":[6,19,6],"t":2},{"p":[177,43,-5],"s":[2,13,4],"l":1,"c":0},{"p":[318,1,-403],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0]},{"p":[324,1,-410],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0]},{"p":[146,0,51],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0]},{"p":[18,28,-520],"s":[11,3,3],"bo":1},{"p":[-17,31,-520],"s":[11,3,3],"bo":1},{"p":[51,31,-520],"s":[11,3,3],"bo":1},{"p":[18,31,-521],"s":[7,16,2],"l":1,"c":0},{"p":[51,34,-521],"s":[7,16,2],"l":1,"c":0},{"p":[-17,34,-521],"s":[7,16,2],"l":1,"c":0},{"p":[150,7,-425],"s":[18,7,4]},{"p":[100,7,-425],"s":[10,7,4]},{"p":[101,10,-461],"s":[8,6,4]},{"p":[112,-28,-461],"s":[58,36,4]},{"p":[123,4,-443],"s":[36,1,32]},{"p":[143,4,-443],"s":[4,10,32]},{"p":[103,4,-443],"s":[4,10,32]},{"p":[143,14,-435],"s":[4,2,9]},{"p":[103,14,-449],"s":[4,2,9]},{"p":[103,14,-433],"s":[4,2,9]},{"p":[123,8,-443],"s":[36,2,36],"i":9,"t":1,"d":3},{"p":[152,14,-425],"s":[8,2,4]},{"p":[139,1,-444],"s":[4,3,34],"t":2},{"p":[107,1,-444],"s":[4,3,34],"t":2},{"p":[139,-1,-455],"s":[2,2,14],"l":1,"r":[-0.7,0,0],"c":13948116,"t":2},{"p":[107,-1,-455],"s":[2,2,14],"l":1,"r":[-0.7,0,0],"c":14277081,"t":2},{"p":[107,-1,-429],"s":[2,2,14],"l":1,"r":[0.7,0,0],"c":15132390,"t":2},{"p":[139,-1,-430],"s":[2,2,14],"l":1,"r":[0.7,0,0],"c":14803425,"t":2},{"p":[154,8,-408],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[101,8,-419],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[-241,0,-453],"s":[4,8,25],"l":1},{"p":[-237,0,-453],"s":[4,5,25],"l":1},{"p":[-233,0,-453],"s":[4,2,25]},{"p":[-236,0,-453],"s":[14,11,23],"i":9,"v":1,"t":1,"d":2},{"p":[-193,0,-494],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.53,3.14]},{"p":[369,81,-121],"s":[4,3,17],"l":1},{"p":[-148,101,97],"s":[20,2,4],"l":1},{"p":[-238,-1,-586],"s":[175,90,11]},{"p":[-280,89,-586],"s":[22,4,11],"l":1},{"p":[-252,50,27],"s":[12,12,12],"i":1},{"p":[248,15,-574],"s":[129,75,11]},{"p":[223,90,-574],"s":[21,3,11],"l":1},{"p":[253,90,-574],"s":[21,2,11],"l":1},{"p":[287,90,-574],"s":[17,4,11],"l":1},{"p":[-249,124,-103],"s":[12,4,12],"l":1,"c":12499642},{"p":[-246,124,-84],"s":[6,2,12],"l":1,"c":14145495},{"p":[-178,101,97],"s":[13,2,4],"l":1},{"p":[-207,101,97],"s":[13,3,4],"l":1},{"p":[-237,101,97],"s":[16,2,4],"l":1},{"p":[-260,101,73],"s":[4,2,17],"l":1},{"p":[-260,101,41],"s":[4,2,13],"l":1},{"p":[-260,101,12],"s":[4,3,11],"l":1},{"p":[-260,101,-21],"s":[4,2,23],"l":1},{"p":[-243,91,-84],"s":[6,3,10],"c":12171705},{"p":[-159,77,-156],"s":[14,4,6],"l":1},{"p":[-185,77,-156],"s":[11,3,6],"l":1},{"p":[-220,77,-158],"s":[14,3,10],"l":1},{"p":[-278,77,-226],"s":[23,4,6],"l":1},{"p":[-310,77,-156],"s":[27,2,6],"l":1},{"p":[357,98,-450],"s":[16,3,16],"l":1},{"p":[352,98,-487],"s":[6,4,12],"l":1},{"p":[369,81,-235],"s":[4,3,17],"l":1},{"p":[369,81,-202],"s":[4,2,11],"l":1},{"p":[369,81,-165],"s":[4,2,21],"l":1},{"p":[328,37,-63],"s":[156,44,80],"bo":1},{"p":[347,81,-101],"s":[13,2,4],"l":1},{"p":[257,81,-100],"s":[14,3,6],"l":1},{"p":[318,81,-101],"s":[16,3,4],"l":1},{"p":[285,81,-101],"s":[14,3,4],"l":1},{"p":[361,50,-188],"s":[12,12,12],"i":1},{"p":[361,50,-176],"s":[12,12,12],"i":1},{"p":[-242,89,-586],"s":[22,3,11],"l":1},{"p":[-200,89,-586],"s":[18,4,11],"l":1},{"p":[-256,77,-156],"s":[17,4,6],"l":1},{"p":[-234,77,-226],"s":[16,4,6],"l":1},{"p":[-319,77,-226],"s":[20,3,6],"l":1},{"p":[-193,77,-226],"s":[19,2,6],"l":1},{"p":[-151,77,-226],"s":[19,3,6],"l":1},{"p":[-171,18,51],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0]},{"p":[-118,116,-197],"s":[9,3,52],"c":11513775},{"p":[-118,116,-197],"s":[52,3,9],"c":9868950},{"p":[-143,0,-49],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.05,-3.14]},{"p":[-348,153,-230],"s":[11,4,12],"l":1},{"p":[-349,153,-276],"s":[13,4,12],"l":1},{"p":[-392,153,-230],"s":[11,4,12],"l":1},{"p":[-390,153,-276],"s":[15,4,12],"l":1},{"p":[-370,110,-253],"s":[72,2,76],"t":2},{"p":[-370,106,-253],"s":[67,4,4],"t":2},{"p":[-370,106,-235],"s":[67,4,4],"t":2},{"p":[-370,106,-272],"s":[67,4,4],"t":2},{"p":[-370,106,-253],"s":[4,4,72],"t":2},{"p":[-354,106,-253],"s":[4,4,72],"t":2},{"p":[-387,106,-253],"s":[4,4,72],"t":2},{"p":[-343,123,-254],"s":[2,16,6],"l":1,"c":0},{"p":[-345,153,-252],"s":[5,3,12],"l":1},{"p":[-368,153,-226],"s":[14,2,4],"l":1},{"p":[-368,153,-280],"s":[11,3,4],"l":1},{"p":[-319,103,-587],"s":[62,2,67],"c":12500670,"t":2},{"p":[-319,100,-587],"s":[4,3,63],"c":14802654,"t":2},{"p":[-334,100,-587],"s":[4,3,63],"c":14276053,"t":2},{"p":[-303,100,-587],"s":[4,3,63],"c":14474460,"t":2},{"p":[-319,100,-587],"s":[58,3,3],"c":12829635,"t":2},{"p":[-319,100,-569],"s":[58,3,3],"c":13158600,"t":2},{"p":[-319,100,-603],"s":[58,3,3],"c":13619151,"t":2},{"p":[183,85,-28],"s":[2,2,11],"l":1,"r":[-0.7,0,0],"t":2},{"p":[199,85,-28],"s":[2,2,11],"l":1,"r":[-0.7,0,0],"t":2},{"p":[199,85,20],"s":[2,2,11],"l":1,"r":[0.7,0,0],"t":2},{"p":[183,85,20],"s":[2,2,11],"l":1,"r":[0.7,0,0],"t":2},{"p":[270,-14,-130],"s":[12,12,12],"i":8},{"p":[-231,0,-398],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.05,0]},{"p":[-202,0,-397],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.05,0]},{"p":[-260,16,-439],"s":[12,2,4]},{"p":[-245,0,-439],"s":[5,17,5]},{"p":[-275,0,-439],"s":[5,17,5]},{"p":[-236,0,-467],"s":[14,13,3]},{"p":[-236,0,-439],"s":[14,13,3]},{"p":[-239,0,-472],"s":[6,8,6],"i":2,"r":[-3.14,0,-3.14]},{"p":[-229,0,-439],"s":[4,14,4]},{"p":[-229,0,-467],"s":[4,14,4]},{"p":[-178,0,-361],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.7,3.14]},{"p":[-203,0,-372],"s":[7,6,8],"i":18,"l":1,"r":[0.01,-1.39,0.01]},{"p":[-221,0,-371],"s":[7,6,8],"i":18,"l":1,"r":[0.01,-1.39,0.01]},{"p":[-232,1,-372],"s":[7,6,8],"i":18,"l":1,"r":[0,1.23,0.01]},{"p":[-184,0,-388],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0]},{"p":[-185,0,-378],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.88,-3.14]},{"p":[-227,0,-357],"s":[4,19,2],"l":1,"t":2},{"p":[-217,0,-356],"s":[4,19,2],"l":1,"t":2},{"p":[-222,0,-357],"s":[4,14,2],"l":1,"t":2},{"p":[144,-28,-455],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.21,0]},{"p":[-239,0,-479],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.88,0]},{"p":[260,7,-182],"s":[4,2,16]},{"p":[260,7,-150],"s":[4,2,22]},{"p":[335,139,-35],"s":[12,4,6],"l":1},{"p":[362,139,-62],"s":[6,4,12],"l":1},{"p":[212,16,-461],"s":[20,2,4]},{"p":[143,14,-450],"s":[4,2,9]},{"p":[268,0,-64],"s":[2,36,80],"c":"#3e3e3e","t":5,"bo":1},{"p":[-69,-32,-345],"s":[150,4,76],"t":1},{"p":[-196,-2,-213],"s":[34,2,32],"t":1},{"p":[-210,42,-361],"s":[76,1,12],"t":2,"bo":1},{"p":[-247,38,-360],"s":[2,2,12],"l":1,"r":[0.7,0,0],"t":2},{"p":[-210,38,-360],"s":[2,2,12],"l":1,"r":[0.7,0,0],"t":2},{"p":[-174,38,-360],"s":[2,2,12],"l":1,"r":[0.7,0,0],"t":2},{"p":[-178,43,-362],"s":[6,8,6],"i":2},{"p":[-184,43,-360],"s":[6,8,6],"i":2},{"p":[-180,51,-360],"s":[6,8,6],"i":2},{"p":[-228,28,-368],"s":[1,13,1],"l":1,"c":11645361,"t":2},{"p":[-215,0,-395],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.05,0]},{"p":[-415,0,-444],"s":[58,127,90],"c":10986917},{"p":[-394,127,-406],"s":[16,3,14],"l":1,"c":11645361},{"p":[-394,127,-481],"s":[16,4,16],"l":1,"c":11645361},{"p":[-394,127,-444],"s":[16,3,16],"l":1,"c":11184810},{"p":[-434,127,-407],"s":[20,3,16],"l":1,"c":10855331},{"p":[-436,127,-481],"s":[16,3,16],"l":1,"c":11645361},{"p":[-210,41,-368],"s":[76,2,2],"t":2,"bo":1},{"p":[-345,72,-526],"s":[40,3,3],"c":"#ffffff","t":2},{"p":[-345,72,-540],"s":[40,3,3],"c":"#ffffff","t":2},{"p":[-345,72,-533],"s":[3,3,40],"c":"#ffffff","t":2},{"p":[-352,90,-526],"s":[40,3,3],"l":1,"r":[0,0,1.05],"c":"#ffffff","t":2},{"p":[-345,72,-526],"s":[3,42,3],"c":"#ffffff","t":2},{"p":[-337,90,-526],"s":[40,3,3],"l":1,"r":[0,0,-1.05],"c":"#ffffff","t":2},{"p":[-337,90,-540],"s":[40,3,3],"l":1,"r":[0,0,-1.05],"c":"#ffffff","t":2},{"p":[-352,90,-540],"s":[40,3,3],"l":1,"r":[0,0,1.05],"c":"#ffffff","t":2},{"p":[-345,72,-540],"s":[3,38,3],"c":"#ffffff","t":2},{"p":[-345,86,-533],"s":[3,3,33],"c":"#ffffff","t":2},{"p":[-345,86,-540],"s":[21,3,3],"c":"#ffffff","t":2},{"p":[-345,86,-526],"s":[21,3,3],"c":"#ffffff","t":2},{"p":[-345,72,-514],"s":[3,17,3],"l":1,"r":[-0.26,0,0],"c":"#ffffff","t":2},{"p":[-345,72,-552],"s":[3,17,3],"l":1,"r":[0.26,0,0],"c":"#ffffff","t":2},{"p":[-356,98,-362],"s":[40,3,3],"c":"#ffffff","t":2},{"p":[-356,98,-376],"s":[40,3,3],"c":"#ffffff","t":2},{"p":[-356,98,-369],"s":[3,3,40],"c":"#ffffff","t":2},{"p":[-363,116,-362],"s":[40,3,3],"l":1,"r":[0,0,1.05],"c":"#ffffff","t":2},{"p":[-356,98,-362],"s":[3,42,3],"c":"#ffffff","t":2},{"p":[-348,116,-362],"s":[40,3,3],"l":1,"r":[0,0,-1.05],"c":"#ffffff","t":2},{"p":[-348,116,-376],"s":[40,3,3],"l":1,"r":[0,0,-1.05],"c":"#ffffff","t":2},{"p":[-363,116,-376],"s":[40,3,3],"l":1,"r":[0,0,1.05],"c":"#ffffff","t":2},{"p":[-356,98,-376],"s":[3,42,3],"c":"#ffffff","t":2},{"p":[-356,112,-369],"s":[3,3,33],"c":"#ffffff","t":2},{"p":[-356,112,-376],"s":[21,3,3],"c":"#ffffff","t":2},{"p":[-356,112,-362],"s":[21,3,3],"c":"#ffffff","t":2},{"p":[-356,140,-369],"s":[3,3,20],"c":"#ffffff","t":2},{"p":[-359,125,-369],"s":[9,11,6],"c":"#757575"},{"p":[-346,151,-369],"s":[41,3,3],"l":1,"r":[0,0,-2.45],"c":"#ffffff","t":2},{"p":[-327,164,-369],"s":[5,2,2],"l":1,"r":[0,0,0.7],"c":"#ffffff","t":2},{"p":[-326,132,-369],"s":[1,34,1],"c":"#ffffff","t":2},{"p":[-326,129,-369],"s":[2,3,2],"c":"#343434","t":5},{"p":[-356,98,-350],"s":[3,17,3],"l":1,"r":[-0.26,0,0],"c":"#ffffff","t":2},{"p":[-356,98,-388],"s":[3,17,3],"l":1,"r":[0.26,0,0],"c":"#ffffff","t":2},{"p":[-360,136,-369],"s":[5,3,6],"c":"#757575"},{"p":[-386,90,-445],"s":[2,19,6],"l":1,"c":0},{"p":[-386,88,-445],"s":[6,4,12],"c":11183011},{"p":[-216,48,-63],"s":[8,2,2],"l":1,"r":[0,0,0.7],"t":2},{"p":[-207,34,-63],"s":[1,18,1],"l":1,"c":11645361,"t":2},{"p":[378,98,-463],"s":[40,3,3],"c":"#ffffff","t":2},{"p":[378,98,-477],"s":[40,3,3],"c":"#ffffff","t":2},{"p":[378,98,-470],"s":[3,3,40],"c":"#ffffff","t":2},{"p":[371,116,-463],"s":[40,3,3],"r":[0,0,1.05],"c":"#ffffff","t":2},{"p":[378,98,-463],"s":[3,42,3],"c":"#ffffff","t":2},{"p":[386,116,-463],"s":[40,3,3],"r":[0,0,-1.05],"c":"#ffffff","t":2},{"p":[386,116,-477],"s":[40,3,3],"r":[0,0,-1.05],"c":"#ffffff","t":2},{"p":[371,116,-477],"s":[40,3,3],"r":[0,0,1.05],"c":"#ffffff","t":2},{"p":[378,98,-477],"s":[3,42,3],"c":"#ffffff","t":2},{"p":[378,112,-470],"s":[3,3,33],"c":"#ffffff","t":2},{"p":[378,112,-477],"s":[21,3,3],"c":"#ffffff","t":2},{"p":[378,112,-463],"s":[21,3,3],"c":"#ffffff","t":2},{"p":[378,140,-470],"s":[3,3,20],"c":"#ffffff","t":2},{"p":[383,125,-470],"s":[9,11,6],"c":"#757575"},{"p":[367,150,-470],"s":[41,3,3],"l":1,"r":[0,0,-0.7],"c":"#ffffff","t":2},{"p":[353,165,-470],"s":[5,2,2],"l":1,"r":[0,0,2.45],"c":"#522505","t":5},{"p":[351,131,-470],"s":[1,34,1],"c":"#522505","t":5},{"p":[351,128,-470],"s":[2,3,2],"c":"#343434","t":5},{"p":[378,98,-451],"s":[3,17,3],"r":[-0.26,0,0],"c":"#ffffff","t":2},{"p":[378,98,-489],"s":[3,17,3],"r":[0.26,0,0],"c":"#ffffff","t":2},{"p":[383,136,-470],"s":[5,3,6],"c":"#757575"},{"p":[311,112,-508],"s":[14,4,22],"l":1,"c":"#b1b1b1"},{"p":[347,112,-500],"s":[22,3,6],"l":1,"c":"#b1b1b1"},{"p":[307,112,-539],"s":[6,3,18],"l":1,"c":"#b1b1b1"},{"p":[253,0,-457],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.04,0]},{"p":[219,0,-106],"s":[4,2,3],"l":1},{"p":[234,0,-112],"s":[3,1,4],"l":1},{"p":[219,0,-142],"s":[3,1,4],"l":1},{"p":[313,58,-449],"s":[6,10,6],"l":1,"t":2},{"p":[393,64,-477],"s":[88,34,70]},{"p":[385,98,-444],"s":[18,3,4],"l":1},{"p":[411,98,-444],"s":[16,3,4],"l":1},{"p":[432,98,-447],"s":[10,3,10],"l":1},{"p":[388,89,-435],"s":[4,4,16],"t":2},{"p":[388,85,-441],"s":[2,2,14],"l":1,"r":[-0.7,0,0],"t":2},{"p":[282,-14,-128],"s":[7,1,4],"l":1,"c":"#c5c5c5"},{"p":[179,67,-24],"s":[4,5,15],"l":1},{"p":[-224,0,-104],"s":[31,24,54],"c":4276545,"t":5},{"p":[-18,18,36],"s":[24,36,24],"i":23,"l":1,"tm":0},{"p":[-276,10,-518],"s":[24,36,24],"i":23,"l":1,"tm":"1"},{"p":[96,8,-421],"s":[2,6,4],"pe":1,"v":1},{"p":[221,0,-97],"s":[4,12,12],"pe":1,"v":1},{"p":[320,0,-120],"s":[4,7,4],"pe":1,"v":1},{"p":[138,0,-150],"s":[4,8,6],"pe":1,"v":1},{"p":[-156,26,-514],"s":[57,1,26],"v":1,"bo":1},{"p":[-306,10,-511],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.7,-3.14]},{"p":[-253,10,-542],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.17,-3.14]},{"p":[-304,10,-542],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.17,-3.14]},{"p":[-252,10,-475],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.17,-3.14]},{"p":[93,24,-69],"s":[2,26,62],"c":6903619,"t":5,"bo":1},{"p":[95,37,-69],"s":[57,0,23],"i":11,"l":1,"r":[1.57,0,1.57],"sad":1}]};

    /***/ }),
    
    /***/ "./maps/freight.json":
    /*!***************************!*\
      !*** ./maps/freight.json ***!
      \***************************/
    /*! exports provided: name, shadowR, ambient, light, sky, fog, fogD, dthY, camPos, spawns, objects, default */
    /***/ (function(module) {
    
    module.exports = {"name":"Freight","shadowR":1288,"ambient":7508378,"light":9149341,"sky":7710385,"fog":7710385,"fogD":374.8837427323032,"dthY":-10,"camPos":[316,33,-156],"spawns":[[-15,0,-356,0,1,0],[232,0,-392,2,2,0],[394,0,-201,0,2,0],[292,0,164,1,2,0],[86,4,116,0,0,0],[-67,0,-40,0,3,0],[33,0,-69,0,0,0],[68,0,-189,0,1,0],[-87,26,-73,0,0,0]],"objects":[{"p":[-47,24,-71],"s":[108,2,40],"c":10197658},{"p":[-18,0,-88],"s":[42,24,4],"c":9854020},{"p":[-47,56,-71],"s":[107,3,44],"c":10197658,"bo":1},{"p":[4,27,-54],"s":[3,29,9],"c":9854020},{"p":[4,27,-87],"s":[3,31,7],"c":9854020},{"p":[26,0,-20],"s":[129,24,60],"c":9854020},{"p":[-47,26,-85],"s":[108,2,13],"l":1,"c":"#818d93","t":5},{"p":[-47,59,-71],"s":[108,2,45],"l":1,"c":"#818d93","t":5},{"p":[4,0,-70],"s":[3,27,40],"c":9854020},{"p":[-98,26,-71],"s":[3,31,34],"c":9854020},{"p":[49,49,-196],"s":[22,6,3],"c":9854020},{"p":[100,0,-121],"s":[54,46,30],"c":11172712,"e":1447446,"bo":1},{"p":[-101,0,-18],"s":[4,32,577],"c":"#b5b5b5","bo":1},{"p":[37,20,-113],"s":[74,3,48],"c":10197658,"bo":1},{"p":[146,20,-121],"s":[144,3,32],"c":"#9b9a9a","bo":1},{"p":[37,0,-113],"s":[72,63,46],"c":11172712,"e":1447446,"bo":1},{"p":[17,0,-122],"s":[78,23,63],"c":11172712,"e":1447446},{"p":[37,62,-113],"s":[74,3,48],"c":10197658,"bo":1},{"p":[145,46,-121],"s":[147,3,33],"c":10197658,"bo":1},{"p":[36,4,-113],"s":[3,60,47],"c":10197915},{"p":[-74,26,-57],"s":[10,52,10],"c":9854020},{"p":[-69,26,-52],"s":[61,33,4],"c":9854020},{"p":[-18,0,-52],"s":[41,56,4],"c":9854020},{"p":[0,26,-89],"s":[5,26,3],"c":9854020},{"p":[-11,26,-20],"s":[203,25,61],"c":9854020,"bo":1},{"p":[-11,24,-20],"s":[204,2,62],"c":"#9b9a9a","bo":1},{"p":[-41,-1,6],"s":[6,26,9],"c":10197658},{"p":[81,35,-5],"s":[8,43,43],"l":1,"r":[-0.8,0,0],"c":9854020},{"p":[-107,34,-5],"s":[8,43,43],"l":1,"r":[-0.8,0,0],"c":9854020},{"p":[-44,52,-89],"s":[93,4,3],"c":9854020},{"p":[-95,26,-89],"s":[9,30,3],"c":9854020},{"p":[-21,0,-120],"s":[3,25,63],"c":10197658},{"p":[-74,77,-57],"s":[13,2,12],"c":16119285},{"p":[-2,0,-251],"s":[185,36,113],"c":"#965c44","bo":1},{"p":[-99,-1,-40],"s":[1,25,95],"c":"#9b9a9a"},{"p":[-13,0,-196],"s":[5,55,6],"c":10197658},{"p":[-96,0,-197],"s":[6,55,8],"c":10197658},{"p":[-5,-2,-249],"s":[189,3,107],"c":5853501,"t":2},{"p":[-97,1,-251],"s":[4,57,100],"c":9854020},{"p":[99,42,-299],"s":[4,1,2],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[154,-1,-189],"s":[3,77,3],"pe":1,"t":2},{"p":[-14,42,-196],"s":[151,1,1],"l":1,"c":"#4f4f4f"},{"p":[-90,36,-196],"s":[12,20,3],"c":9854020},{"p":[-13,36,-196],"s":[26,19,3],"c":9854020},{"p":[76,36,-306],"s":[32,19,3],"c":9854020},{"p":[11,36,-196],"s":[1,13,1],"l":1,"c":"#4f4f4f"},{"p":[49,36,-196],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[-37,36,-196],"s":[1,13,1],"l":1,"c":"#4f4f4f"},{"p":[-74,36,-196],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[146,0,-161],"s":[20,46,50],"c":11172712,"e":1447446,"bo":1},{"p":[-98,0,-218],"s":[3,30,34],"c":9854020},{"p":[-55,36,-196],"s":[14,19,3],"c":9854020},{"p":[30,36,-196],"s":[16,20,3],"c":9854020},{"p":[-3,55,-251],"s":[196,3,117],"c":10197658,"bo":1},{"p":[-3,58,-251],"s":[197,2,118],"l":1,"c":"#818d93","t":5},{"p":[-50,57,-243],"s":[30,21,15],"c":9854020},{"p":[-50,74,-243],"s":[32,2,18],"c":16119285},{"p":[146,46,-162],"s":[22,3,49],"c":10197658,"bo":1},{"p":[146,20,-162],"s":[21,3,50],"c":10197658,"bo":1},{"p":[-1,27,-251],"s":[189,3,115],"c":10197658,"bo":1},{"p":[-30,57,-280],"s":[16,16,15],"c":9854020},{"p":[-54,0,-196],"s":[5,55,6],"c":10197658},{"p":[30,0,-196],"s":[5,55,6],"c":10197658},{"p":[220,-1,-108],"s":[3,75,3],"t":2},{"p":[151,-1,-351],"s":[3,78,3],"pe":1,"t":2},{"p":[154,69,-190],"s":[32,2,3],"t":2},{"p":[153,61,-190],"s":[23,2,3],"t":2},{"p":[197,63,-150],"s":[1,1,107],"l":1,"r":[0,0.7,0],"c":9539985,"t":5},{"p":[220,61,-108],"s":[24,2,3],"t":2},{"p":[219,68,-108],"s":[32,2,3],"t":2},{"p":[96,-1,-299],"s":[1,46,1],"pe":1,"c":"#727272","t":5,"bo":1},{"p":[17,0,-153],"s":[79,25,3],"c":"#9b9a9a"},{"p":[422,32,-230],"s":[402,26,11],"c":7485215,"e":1447446},{"p":[421,-11,-383],"s":[449,39,5],"c":7485215,"e":1447446,"bo":1},{"p":[227,79,-303],"s":[5,78,34],"l":1,"r":[2,0,0],"c":7485215,"e":1447446},{"p":[421,28,-296],"s":[451,2,182],"c":"#827e7d","bo":1},{"p":[-44,0,-328],"s":[4,30,50],"c":"#b5b5b5","bo":1},{"p":[18,23,-121],"s":[76,2,64],"l":1,"c":"#818d93","t":5},{"p":[19,25,-153],"s":[76,2,4],"l":1,"c":"#818d93","t":5},{"p":[145,0,-192],"s":[12,12,12],"i":1},{"p":[153,-1,-453],"s":[3,78,3],"r":[0,-0.35,0],"t":2},{"p":[152,69,-350],"s":[32,2,3],"t":2},{"p":[152,61,-352],"s":[23,2,3],"t":2},{"p":[177,63,-149],"s":[1,1,108],"l":1,"r":[0,0.7,0],"c":9539985,"t":5},{"p":[227,77,-289],"s":[5,78,37],"l":1,"r":[-2,0,0],"c":7485215,"e":1447446},{"p":[229,61,-296],"s":[11,36,11],"c":"#472213","e":1447446},{"p":[271,77,-296],"s":[7,48,6],"c":7485215,"e":1447446},{"p":[421,30,-296],"s":[452,2,183],"l":1,"c":"#818d93","t":5},{"p":[422,61,-296],"s":[404,2,145],"l":1,"c":"#818d93","t":5},{"p":[-21,25,-123],"s":[4,2,64],"l":1,"c":"#818d93","t":5},{"p":[162,63,-321],"s":[1,1,262],"l":1,"c":9539985,"t":5},{"p":[145,49,-121],"s":[148,2,34],"l":1,"c":"#818d93","t":5},{"p":[137,23,-121],"s":[162,2,32],"l":1,"c":"#818d93","t":5},{"p":[37,65,-113],"s":[75,2,49],"l":1,"c":"#818d93","t":5},{"p":[146,49,-162],"s":[23,2,50],"l":1,"c":"#818d93","t":5},{"p":[146,23,-162],"s":[21,2,50],"l":1,"c":"#818d93","t":5},{"p":[429,84,-296],"s":[320,21,52],"c":7485215,"e":1447446},{"p":[271,111,-299],"s":[3,28,15],"l":1,"r":[2,0,0],"c":7485215,"e":1447446},{"p":[271,99,-319],"s":[3,28,15],"l":1,"r":[1.13,0,0],"c":7485215,"e":1447446},{"p":[92,0,-196],"s":[5,55,6],"c":10197658,"bo":1},{"p":[119,59,-195],"s":[50,1,1],"l":1,"r":[0.03,-0.17,0.18],"c":9539985,"t":5},{"p":[318,103,-280],"s":[7,19,7],"c":9854020},{"p":[411,103,-280],"s":[7,19,7],"c":9854020},{"p":[514,103,-280],"s":[7,20,7],"c":9854020},{"p":[318,104,-314],"s":[7,20,7],"c":9854020},{"p":[410,103,-314],"s":[7,19,7],"c":9854020},{"p":[512,103,-314],"s":[7,21,7],"c":9854020},{"p":[335,-24,18],"s":[1734,4,2577],"l":1,"c":"#26414f","e":"#1a4054","o":0.9,"t":1,"ts":0.8},{"p":[361,-29,-160],"s":[74,29,96],"c":"#818d93","t":5},{"p":[446,-132,-32],"s":[240,117,58],"c":8552061,"e":1447446},{"p":[447,-141,-296],"s":[398,130,180],"c":8552061,"e":1447446},{"p":[-11,49,-20],"s":[204,3,62],"c":10197658,"bo":1},{"p":[-11,52,-20],"s":[205,2,63],"l":1,"c":"#818d93","t":5},{"p":[-11,26,-20],"s":[205,2,63],"l":1,"c":"#818d93","t":5},{"p":[274,-30,-395],"s":[6,54,62],"c":"#b5b5b5","bo":1},{"p":[231,63,310],"s":[1,1,839],"l":1,"c":9539985,"t":5},{"p":[422,58,-296],"s":[403,3,144],"c":"#827e7d"},{"p":[276,-30,102],"s":[9,36,97],"c":"#b5b5b5"},{"p":[305,-29,57],"s":[49,35,7],"c":"#b5b5b5"},{"p":[126,0,-427],"s":[291,30,4],"c":"#b5b5b5","bo":1},{"p":[274,-31,-427],"s":[7,66,7],"c":"#ababab","bo":1},{"p":[134,0,-427],"s":[7,35,7],"c":"#ababab","bo":1},{"p":[218,0,-427],"s":[7,35,7],"c":"#ababab","bo":1},{"p":[222,-2,112],"s":[3,75,3],"pe":1,"t":2},{"p":[196,29,-23],"s":[115,2,109],"c":"#9b9a9a","bo":1},{"p":[196,31,-23],"s":[115,2,109],"l":1,"c":"#818d93","t":5},{"p":[97,-1,-200],"s":[3,58,3],"t":2,"bo":1},{"p":[442,49,-31],"s":[247,2,61],"c":"#9b9a9a","bo":1},{"p":[442,51,-31],"s":[247,2,61],"l":1,"c":"#818d93","t":5},{"p":[221,61,112],"s":[23,2,3],"t":2},{"p":[221,68,112],"s":[32,2,3],"t":2},{"p":[212,63,310],"s":[1,1,839],"l":1,"c":9539985,"t":5},{"p":[-416,-1,-546],"s":[118,134,335],"l":1,"c":"#aa7b68"},{"p":[-416,132,-546],"s":[121,4,337],"l":1,"c":12632256,"e":1447446},{"p":[-416,67,-546],"s":[121,4,337],"l":1,"c":12632256,"e":1447446},{"p":[-39,-1,-40],"s":[1,25,95],"c":"#9b9a9a"},{"p":[145,94,-580],"s":[219,4,137],"l":1,"e":1447446},{"p":[145,63,-580],"s":[219,4,137],"l":1,"e":1447446},{"p":[-100,0,-112],"s":[7,34,7],"c":"#ababab","bo":1},{"p":[-100,0,-156],"s":[7,34,7],"c":"#ababab","bo":1},{"p":[-100,0,100],"s":[7,34,7]},{"p":[-100,0,146],"s":[7,34,7]},{"p":[-100,0,204],"s":[7,34,7]},{"p":[-2,30,-251],"s":[191,2,115],"l":1,"c":"#818d93","t":5},{"p":[141,2,29],"s":[4,57,4],"c":10197658},{"p":[251,4,29],"s":[4,55,4],"c":10197658},{"p":[192,6,-23],"s":[4,53,108],"c":10197658},{"p":[141,3,-75],"s":[4,57,4],"c":10197658},{"p":[251,-1,-75],"s":[4,61,4],"c":"#9b9a9a"},{"p":[141,-1,29],"s":[5,7,5],"c":10197658},{"p":[251,0,29],"s":[5,6,5],"c":10197658},{"p":[192,0,-23],"s":[5,6,109],"c":10197658},{"p":[251,-1,-75],"s":[5,7,5],"c":10197658},{"p":[141,-1,-75],"s":[5,7,5],"c":10197658},{"p":[563,-15,-32],"s":[4,64,57],"c":10197658},{"p":[26,33,129],"s":[253,3,117],"c":"#9b9a9a","bo":1},{"p":[92,0,85],"s":[119,33,28],"c":11172712,"e":1447446,"bo":1},{"p":[-51,0,133],"s":[96,33,122],"c":11172712,"e":1447446,"bo":1},{"p":[-3,0,70],"s":[5,33,7],"c":10197658},{"p":[31,0,69],"s":[5,33,5],"c":10197658},{"p":[14,33,67],"s":[39,3,7],"c":10197658,"bo":1},{"p":[-47,4,67],"s":[31,1,2],"c":"#453d2f","t":5},{"p":[26,0,136],"s":[253,4,132],"c":"#9b9a9a"},{"p":[-97,-1,6],"s":[6,26,9],"c":10197658},{"p":[-96,-1,-86],"s":[6,26,9],"c":10197658},{"p":[-40,-1,-86],"s":[7,26,9],"c":10197658},{"p":[152,61,-452],"s":[23,2,3],"r":[0,-0.09,0],"t":2},{"p":[152,69,-453],"s":[32,2,3],"r":[0,-0.09,0],"t":2},{"p":[-244,-3,-227],"s":[34,154,39],"l":1,"c":11172712,"e":1447446},{"p":[26,36,129],"s":[253,2,117],"l":1,"c":"#818d93","t":5},{"p":[14,36,67],"s":[40,2,8],"l":1,"c":"#818d93","t":5},{"p":[475,-11,-282],"s":[341,40,151],"c":7485215,"e":1447446,"bo":1},{"p":[237,-11,-240],"s":[81,39,66],"c":7485215,"e":1447446,"bo":1},{"p":[422,32,-362],"s":[402,27,11],"c":7485215,"e":1447446},{"p":[224,32,-296],"s":[2,27,122],"c":7485215,"e":1447446},{"p":[274,24,-404],"s":[6,2,39],"l":1,"c":"#818d93","t":5},{"p":[325,6,-84],"s":[9,2,57],"l":1,"c":"#818d93","t":5},{"p":[92,0,-306],"s":[5,55,6],"c":"#9b9a9a","bo":1},{"p":[402,6,-160],"s":[9,2,95],"l":1,"c":"#818d93","t":5},{"p":[326,6,28],"s":[7,2,65],"l":1,"c":"#818d93","t":5},{"p":[297,6,57],"s":[51,2,7],"l":1,"c":"#818d93","t":5},{"p":[276,6,105],"s":[9,2,91],"l":1,"c":"#818d93","t":5},{"p":[-101,32,131],"s":[4,2,241],"l":1,"c":"#818d93","t":5},{"p":[-101,32,-179],"s":[5,2,255],"l":1,"c":"#818d93","t":5},{"p":[-44,30,-324],"s":[4,2,41],"l":1,"c":"#818d93","t":5},{"p":[185,30,-427],"s":[181,2,5],"l":1,"c":"#818d93","t":5},{"p":[26,37,129],"s":[251,80,115],"c":11172712,"e":1447446},{"p":[-380,93,106],"s":[255,4,125],"l":1,"c":"#bababa"},{"p":[-380,97,106],"s":[254,2,125],"l":1,"c":"#818d93","t":5},{"p":[149,0,-121],"s":[44,46,30],"c":11172712,"e":1447446,"bo":1},{"p":[-67,0,-410],"s":[62,31,131],"c":"#965c44","e":"#0e0e0e","bo":1},{"p":[2,12,-135],"s":[3,50,3],"c":10197915},{"p":[126,6,-121],"s":[3,42,31],"c":10197915},{"p":[172,5,-121],"s":[3,43,31],"c":10197915},{"p":[216,5,-107],"s":[3,41,3],"c":10197915},{"p":[72,5,-91],"s":[3,57,3],"c":10197915},{"p":[72,0,-134],"s":[3,62,5],"c":10197915},{"p":[216,-2,-107],"s":[4,8,4],"c":10197658},{"p":[216,3,-135],"s":[3,45,3],"c":10197915},{"p":[216,0,-135],"s":[4,6,4],"c":10197658},{"p":[172,0,-135],"s":[4,6,4],"c":10197658},{"p":[126,0,-135],"s":[4,6,4],"c":10197658},{"p":[72,0,-135],"s":[4,6,4],"c":10197658},{"p":[172,-2,-107],"s":[4,8,4],"c":10197658},{"p":[126,-2,-107],"s":[4,8,4],"c":10197658},{"p":[72,-1,-91],"s":[4,7,4],"c":10197658},{"p":[36,-1,-91],"s":[4,7,4],"c":10197658},{"p":[326,-30,24],"s":[7,36,59],"c":"#b5b5b5"},{"p":[325,-29,-84],"s":[9,35,57],"c":8552061,"e":1447446},{"p":[-70,-2,-40],"s":[63,1,100],"c":7039851,"t":1},{"p":[322,-1,-59],"s":[6,50,3],"c":10197658,"bo":1},{"p":[73,-26,-94],"s":[404,26,876],"c":"#818d93","t":5},{"p":[411,24,-7],"s":[46,16,4],"c":7485215,"e":1447446},{"p":[491,24,-57],"s":[46,16,4],"c":7485215,"e":1447446},{"p":[339,24,-57],"s":[29,16,4],"c":7485215,"e":1447446},{"p":[556,24,-57],"s":[16,16,4],"c":7485215,"e":1447446},{"p":[445,32,-58],"s":[212,1,1],"l":1,"c":"#4f4f4f"},{"p":[458,25,-58],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[444,25,-58],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[377,25,-58],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[364,25,-58],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[524,25,-58],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[539,25,-58],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[531,23,-32],"s":[36,2,56],"c":"#9b9a9a","bo":1},{"p":[300,-29,-138],"s":[50,29,383],"c":"#818d93","t":5},{"p":[368,6,-108],"s":[77,2,9],"l":1,"c":"#818d93","t":5},{"p":[620,20,-296],"s":[6,38,121],"c":7485215,"e":1447446},{"p":[368,-29,-108],"s":[77,35,9],"c":8552061,"e":1447446},{"p":[402,-29,-160],"s":[9,35,95],"c":8552061,"e":1447446},{"p":[443,40,-57],"s":[237,9,4],"c":7485215,"e":1447446},{"p":[-4,26,-89],"s":[3,10,3],"c":9854020},{"p":[4,54,-71],"s":[3,2,25],"c":9854020},{"p":[11,49,-196],"s":[22,6,3],"c":9854020},{"p":[-37,49,-196],"s":[22,6,3],"c":9854020},{"p":[-73,49,-196],"s":[22,6,3],"c":9854020},{"p":[76,36,-196],"s":[32,19,3],"c":9854020},{"p":[30,0,-306],"s":[5,55,6],"c":10197658},{"p":[30,36,-306],"s":[16,20,3],"c":9854020},{"p":[-13,0,-305],"s":[5,55,6],"c":10197658},{"p":[-13,36,-306],"s":[26,19,3],"c":9854020},{"p":[-54,0,-305],"s":[5,55,6],"c":10197658},{"p":[-55,36,-306],"s":[14,19,3],"c":9854020},{"p":[-90,36,-306],"s":[12,20,3],"c":9854020},{"p":[-96,0,-305],"s":[6,55,8],"c":10197658},{"p":[-37,49,-306],"s":[22,6,3],"c":9854020},{"p":[-73,49,-306],"s":[22,6,3],"c":9854020},{"p":[49,49,-306],"s":[22,6,3],"c":9854020},{"p":[11,49,-306],"s":[22,6,3],"c":9854020},{"p":[-14,42,-306],"s":[151,1,1],"l":1,"c":"#4f4f4f"},{"p":[49,36,-306],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[11,36,-306],"s":[1,13,1],"l":1,"c":"#4f4f4f"},{"p":[-37,36,-306],"s":[1,13,1],"l":1,"c":"#4f4f4f"},{"p":[-74,36,-306],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[89,36,-297],"s":[3,19,13],"c":"#965c44"},{"p":[89,36,-206],"s":[3,19,15],"c":9854020},{"p":[89,36,-238],"s":[3,19,11],"c":9854020},{"p":[89,36,-267],"s":[3,19,9],"c":9854020},{"p":[89,49,-223],"s":[3,6,19],"c":9854020},{"p":[89,49,-253],"s":[3,6,19],"c":9854020},{"p":[89,49,-281],"s":[3,6,19],"c":9854020},{"p":[89,42,-252],"s":[1,1,81],"l":1,"c":"#4f4f4f"},{"p":[89,36,-253],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[89,36,-223],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[89,36,-282],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[238,0,-595],"s":[22,237,21],"l":1,"c":11172712,"e":1447446},{"p":[197,0,-594],"s":[22,237,21],"l":1,"c":11172712,"e":1447446},{"p":[26,72,129],"s":[253,3,117],"c":"#9b9a9a"},{"p":[26,75,129],"s":[253,2,117],"l":1,"c":"#818d93","t":5},{"p":[26,115,129],"s":[253,3,117],"c":"#9b9a9a"},{"p":[26,118,129],"s":[253,2,117],"l":1,"c":"#818d93","t":5},{"p":[145,12,-192],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[205,0,-142],"s":[12,12,12],"i":1},{"p":[205,12,-142],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[318,0,-201],"s":[12,12,12],"i":1},{"p":[318,0,-189],"s":[12,12,12],"i":1},{"p":[280,12,-104],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[318,12,-195],"s":[12,2,24],"l":1,"c":"#818d93","t":5},{"p":[293,0,-124],"s":[6,8,6],"i":2},{"p":[343,0,-119],"s":[12,12,12],"i":1},{"p":[343,12,-119],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[293,7,-124],"s":[6,2,6],"l":1,"c":"#818d93","t":5},{"p":[216,0,160],"s":[57,26,25],"i":17},{"p":[286,-1,-31],"s":[70,90,56],"c":"#965c44","bo":1},{"p":[322,-1,-3],"s":[6,50,3],"c":10197658,"bo":1},{"p":[149,0,-264],"s":[20,21,36],"c":11172712,"e":1447446},{"p":[149,21,-264],"s":[1,4,40],"c":"#9b9a9a"},{"p":[155,20,-264],"s":[12,1,37],"l":1,"r":[0,0,-0.2],"c":"#9b9a9a"},{"p":[143,20,-264],"s":[12,1,37],"l":1,"r":[0,0,0.2],"c":"#9b9a9a"},{"p":[133,0,-255],"s":[12,12,12],"i":1},{"p":[133,12,-255],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[195,0,-121],"s":[44,46,30],"c":11172712,"e":1447446,"bo":1},{"p":[56,0,-144],"s":[2,23,4],"i":3,"t":2},{"p":[155,21,-264],"s":[13,2,38],"l":1,"r":[0,0,-0.2],"c":"#818d93","t":5},{"p":[143,21,-264],"s":[13,2,38],"l":1,"r":[0,0,0.2],"c":"#818d93","t":5},{"p":[83,0,-189],"s":[12,12,12],"i":1},{"p":[83,12,-189],"s":[12,12,12],"i":1},{"p":[280,0,-128],"s":[20,21,36],"c":11172712,"e":1447446},{"p":[280,21,-128],"s":[1,4,40],"c":"#9b9a9a"},{"p":[286,20,-128],"s":[12,1,37],"l":1,"r":[0,0,-0.2],"c":"#9b9a9a"},{"p":[274,20,-128],"s":[12,1,37],"l":1,"r":[0,0,0.2],"c":"#9b9a9a"},{"p":[286,21,-128],"s":[13,2,38],"l":1,"r":[0,0,-0.2],"c":"#818d93","t":5},{"p":[274,21,-128],"s":[13,2,38],"l":1,"r":[0,0,0.2],"c":"#818d93","t":5},{"p":[83,24,-189],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[216,25,160],"s":[58,2,26],"l":1,"c":"#818d93","t":5},{"p":[65,23,-105],"s":[18,2,32],"l":1,"c":"#818d93","t":5},{"p":[82,0,-56],"s":[12,12,12],"i":1},{"p":[82,12,-56],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[-28,0,-143],"s":[12,12,12],"i":1},{"p":[-28,12,-143],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[3,26,-65],"s":[8,2,28],"l":1,"c":"#818d93","t":5},{"p":[-5,26,-74],"s":[8,2,10],"l":1,"c":"#818d93","t":5},{"p":[7,0,-70],"s":[2,26,4],"i":3,"t":2},{"p":[5,0,-70],"s":[4,24,9],"v":1,"c":"#ffffff","t":5,"ab":1},{"p":[-86,34,-89],"s":[9,2,3],"l":1,"c":"#818d93","t":5},{"p":[-86,26,-89],"s":[9,8,3],"c":9854020},{"p":[-4,36,-89],"s":[3,2,3],"l":1,"c":"#818d93","t":5},{"p":[280,0,-104],"s":[12,12,12],"i":1},{"p":[286,29,-31],"s":[70,2,58],"c":"#9b9a9a","bo":1},{"p":[286,31,-31],"s":[70,2,58],"l":1,"c":"#818d93","t":5},{"p":[286,59,-31],"s":[71,2,58],"c":"#9b9a9a","bo":1},{"p":[286,61,-31],"s":[71,2,58],"l":1,"c":"#818d93","t":5},{"p":[286,89,-31],"s":[71,2,58],"c":"#9b9a9a"},{"p":[286,91,-31],"s":[72,2,60],"l":1,"c":"#818d93","t":5},{"p":[204,0,36],"s":[12,12,12],"i":1},{"p":[204,12,36],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[-2,36,-251],"s":[180,13,109],"c":"#475e72","o":0.7000000000000001,"t":5},{"p":[443,-16,-7],"s":[238,40,4],"c":7485215,"e":1447446,"bo":1},{"p":[491,24,-7],"s":[46,16,4],"c":7485215,"e":1447446},{"p":[411,24,-57],"s":[46,16,4],"c":7485215,"e":1447446},{"p":[339,24,-7],"s":[29,16,4],"c":7485215,"e":1447446,"bo":1},{"p":[556,24,-7],"s":[16,16,4],"c":7485215,"e":1447446},{"p":[443,40,-7],"s":[237,9,4],"c":7485215,"e":1447446},{"p":[443,-16,-57],"s":[238,40,4],"c":7485215,"e":1447446,"bo":1},{"p":[445,32,-7],"s":[212,1,1],"l":1,"c":"#4f4f4f"},{"p":[377,25,-7],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[364,25,-7],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[444,25,-7],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[458,25,-7],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[524,25,-7],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[539,25,-7],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[451,23,-32],"s":[36,2,56],"c":"#9b9a9a","bo":1},{"p":[371,23,-32],"s":[36,2,56],"c":"#9b9a9a","bo":1},{"p":[450,25,-32],"s":[197,15,46],"c":"#475e72","o":0.7000000000000001,"t":5},{"p":[99,43,-299],"s":[5,1,3],"l":1,"c":"#727272","t":5},{"p":[157,43,76],"s":[4,1,2],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[154,-1,76],"s":[1,47,1],"c":"#727272","t":5,"bo":1},{"p":[157,44,76],"s":[5,1,3],"l":1,"c":"#727272","t":5},{"p":[296,41,-143],"s":[4,1,2],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[293,1,-143],"s":[1,43,1],"c":"#727272","t":5,"bo":1},{"p":[296,42,-143],"s":[5,1,3],"l":1,"c":"#727272","t":5},{"p":[200,-1,-390],"s":[1,47,1],"pe":1,"c":"#727272","t":5,"bo":1},{"p":[-94,43,-136],"s":[4,1,2],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[-97,-1,-136],"s":[1,47,1],"pe":1,"c":"#727272","t":5,"bo":1},{"p":[-94,44,-136],"s":[5,1,3],"l":1,"c":"#727272","t":5},{"p":[28,43,16],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[28,-1,13],"s":[1,47,1],"pe":1,"c":"#727272","t":5,"bo":1},{"p":[28,44,16],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[96,42,-21],"s":[4,1,2],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[93,-1,-21],"s":[1,46,1],"pe":1,"c":"#727272","t":5,"bo":1},{"p":[96,43,-21],"s":[5,1,3],"l":1,"c":"#727272","t":5},{"p":[200,43,-393],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[200,42,-393],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[-13,43,-189],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[-13,44,-192],"s":[1,1,3],"c":"#727272","t":5},{"p":[-13,42,-189],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[172,43,-101],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[172,44,-104],"s":[1,1,3],"c":"#727272","t":5,"bo":1},{"p":[172,42,-101],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[-97,-1,42],"s":[1,47,1],"pe":1,"c":"#727272","t":5,"bo":1},{"p":[-94,44,42],"s":[5,1,3],"l":1,"c":"#727272","t":5},{"p":[-94,43,42],"s":[4,1,2],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[18,0,16],"s":[12,12,12],"i":1},{"p":[18,12,16],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[191,0,-363],"s":[12,12,12],"i":1},{"p":[191,12,-363],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[248,37,-23],"s":[9,15,107],"c":9854020},{"p":[196,52,-23],"s":[113,7,107],"c":9854020},{"p":[192,37,-23],"s":[22,15,107],"c":9854020},{"p":[144,37,-70],"s":[9,15,13],"c":9854020},{"p":[144,37,-22],"s":[9,15,11],"c":9854020},{"p":[144,37,24],"s":[9,15,13],"c":9854020},{"p":[196,44,-75],"s":[98,1,1],"l":1,"c":"#4f4f4f"},{"p":[196,44,29],"s":[98,1,1],"l":1,"c":"#4f4f4f"},{"p":[159,37,-75],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[171,37,-75],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[216,37,-75],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[230,37,-75],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[230,37,29],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[216,37,29],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[171,37,29],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[159,37,29],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[141,37,-6],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[141,37,-52],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[141,44,-22],"s":[1,1,82],"l":1,"c":"#4f4f4f"},{"p":[194,37,-23],"s":[105,15,103],"c":"#475e72","o":0.7000000000000001,"t":5},{"p":[141,37,-40],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[141,37,6],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[92,0,-347],"s":[6,48,7],"c":"#9b9a9a","bo":1},{"p":[-78,0,-347],"s":[6,48,7],"c":"#9b9a9a"},{"p":[7,48,-410],"s":[176,4,133],"c":"#9b9a9a","bo":1},{"p":[7,52,-410],"s":[177,2,134],"l":1,"c":"#818d93","t":5},{"p":[-45,0,-33],"s":[12,12,12],"i":1},{"p":[-95,0,-2],"s":[6,8,6],"i":2},{"p":[-93,0,-45],"s":[12,12,12],"i":1},{"p":[-68,0,-189],"s":[12,12,12],"i":1},{"p":[-68,12,-189],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[-86,49,-89],"s":[9,3,3],"c":9854020},{"p":[-4,50,-89],"s":[3,2,3],"c":9854020},{"p":[26,0,-311],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.61,0],"c":"#d8f2ff"},{"p":[154,-1,-194],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.61,0],"c":"#d8f2ff"},{"p":[134,-1,-265],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.78,0],"c":"#d8f2ff"},{"p":[154,-1,-285],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.78,0],"c":"#d8f2ff"},{"p":[192,-1,-372],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.78,0],"c":"#d8f2ff"},{"p":[150,-1,-343],"s":[7,6,8],"i":18,"l":1,"r":[0,1.31,0],"c":"#d8f2ff"},{"p":[95,-1,-301],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.57,0],"c":"#d8f2ff"},{"p":[160,-1,-139],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.7,-3.14],"c":"#d8f2ff"},{"p":[195,-1,-139],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.7,-3.14],"c":"#d8f2ff"},{"p":[203,-1,-203],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.7,-3.14],"c":"#d8f2ff"},{"p":[215,-1,-141],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.87,-3.14],"c":"#d8f2ff"},{"p":[267,-1,-138],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.87,-3.14],"c":"#d8f2ff"},{"p":[309,-1,-203],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.87,-3.14],"c":"#d8f2ff"},{"p":[195,-1,-204],"s":[7,6,8],"i":18,"l":1,"r":[-3.13,-1.49,-3.13],"c":"#d8f2ff"},{"p":[293,-1,-141],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.87,-3.14],"c":"#d8f2ff"},{"p":[294,-1,-119],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.88,-3.14],"c":"#d8f2ff"},{"p":[317,-1,-64],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.87,-3.14],"c":"#d8f2ff"},{"p":[256,-1,-64],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.87,-3.14],"c":"#d8f2ff"},{"p":[271,-1,-107],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.87,-3.14],"c":"#d8f2ff"},{"p":[216,-1,-103],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#d8f2ff"},{"p":[187,-1,-79],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.78,0],"c":"#d8f2ff"},{"p":[148,-1,-103],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.78,0],"c":"#d8f2ff"},{"p":[77,-1,-102],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.78,0],"c":"#d8f2ff"},{"p":[77,-1,-94],"s":[7,6,8],"i":18,"l":1,"r":[0,1.14,0],"c":"#d8f2ff"},{"p":[92,-1,-53],"s":[7,6,8],"i":18,"l":1,"r":[0,0.79,0],"c":"#d8f2ff"},{"p":[73,-1,-53],"s":[7,6,8],"i":18,"l":1,"r":[0,0.79,0],"c":"#d8f2ff"},{"p":[9,-1,-53],"s":[7,6,8],"i":18,"l":1,"r":[0,0.79,0],"c":"#d8f2ff"},{"p":[9,-1,-88],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.79,3.14],"c":"#d8f2ff"},{"p":[94,-1,-18],"s":[7,6,8],"i":18,"l":1,"r":[0,0.79,0],"c":"#d8f2ff"},{"p":[35,-1,67],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.43,-3.14],"c":"#d8f2ff"},{"p":[76,-1,66],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.53,-3.14],"c":"#d8f2ff"},{"p":[27,-1,14],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.53,-3.14],"c":"#d8f2ff"},{"p":[75,0,11],"s":[7,6,8],"i":18,"l":1,"r":[2.93,1.56,-2.93],"c":"#d8f2ff"},{"p":[156,-1,76],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.43,-3.14],"c":"#d8f2ff"},{"p":[219,-1,110],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.43,-3.14],"c":"#d8f2ff"},{"p":[203,-1,108],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.09,-3.14],"c":"#d8f2ff"},{"p":[196,-1,25],"s":[7,6,8],"i":18,"l":1,"r":[0,0.26,0],"c":"#d8f2ff"},{"p":[138,-1,17],"s":[7,6,8],"i":18,"l":1,"r":[0,0.96,0],"c":"#d8f2ff"},{"p":[137,-1,-68],"s":[7,6,8],"i":18,"l":1,"r":[0,0.96,0],"c":"#d8f2ff"},{"p":[134,0,-22],"s":[12,12,12],"i":1},{"p":[134,12,-22],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[136,-1,-29],"s":[7,6,8],"i":18,"l":1,"r":[0,0.96,0],"c":"#d8f2ff"},{"p":[129,-1,-15],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.09,0],"c":"#d8f2ff"},{"p":[129,-1,68],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#d8f2ff"},{"p":[-8,-1,68],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#d8f2ff"},{"p":[-96,-1,66],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.61,-3.14],"c":"#d8f2ff"},{"p":[-39,-1,14],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#d8f2ff"},{"p":[9,-1,13],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#d8f2ff"},{"p":[-95,-1,41],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.44,-3.14],"c":"#d8f2ff"},{"p":[-42,-1,-24],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#d8f2ff"},{"p":[-95,-1,-35],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#d8f2ff"},{"p":[-95,-1,-9],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.48,-3.14],"c":"#d8f2ff"},{"p":[-44,-1,-78],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.23,-3.14],"c":"#d8f2ff"},{"p":[-96,-1,-55],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14],"c":"#d8f2ff"},{"p":[-26,-1,-153],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14],"c":"#d8f2ff"},{"p":[-59,-1,-192],"s":[7,6,8],"i":18,"l":1,"r":[0,0.97,0],"c":"#d8f2ff"},{"p":[-95,-1,-137],"s":[7,6,8],"i":18,"l":1,"r":[0,0.97,0],"c":"#d8f2ff"},{"p":[74,-1,-190],"s":[7,6,8],"i":18,"l":1,"r":[0,0.71,0],"c":"#d8f2ff"},{"p":[60,-1,-139],"s":[7,6,8],"i":18,"l":1,"r":[0,0.71,0],"c":"#d8f2ff"},{"p":[136,-1,-189],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.88,-3.14],"c":"#d8f2ff"},{"p":[139,-1,-245],"s":[7,6,8],"i":18,"l":1,"r":[0,0.44,0],"c":"#d8f2ff"},{"p":[94,-1,-204],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.09,3.14],"c":"#d8f2ff"},{"p":[96,-1,-194],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.96,-3.14],"c":"#d8f2ff"},{"p":[102,-1,-138],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.96,0],"c":"#d8f2ff"},{"p":[194,-1,-268],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0],"c":"#d8f2ff"},{"p":[195,-1,-353],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0],"c":"#d8f2ff"},{"p":[96,-1,-352],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.52,3.14],"c":"#d8f2ff"},{"p":[198,-1,-390],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.52,3.14],"c":"#d8f2ff"},{"p":[100,0,-370],"s":[12,12,12],"i":1},{"p":[100,12,-370],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[97,-1,-380],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.52,3.14],"c":"#d8f2ff"},{"p":[142,-1,-422],"s":[7,6,8],"i":18,"l":1,"r":[0,1.04,0],"c":"#d8f2ff"},{"p":[212,-1,-422],"s":[7,6,8],"i":18,"l":1,"r":[0,1.04,0],"c":"#d8f2ff"},{"p":[218,35,-427],"s":[7,3,7],"l":1,"c":"#818d93","t":5},{"p":[134,35,-427],"s":[7,3,7],"l":1,"c":"#818d93","t":5},{"p":[274,35,-427],"s":[7,3,7],"l":1,"c":"#818d93","t":5},{"p":[152,-1,-354],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.05,0],"c":"#d8f2ff"},{"p":[194,0,-308],"s":[6,8,6],"i":2},{"p":[193,-1,-331],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0],"c":"#d8f2ff"},{"p":[194,7,-308],"s":[6,2,6],"l":1,"c":"#818d93","t":5},{"p":[220,-1,-114],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.87,-3.14],"c":"#d8f2ff"},{"p":[4,51,-82],"s":[3,3,3],"c":9854020},{"p":[4,52,-60],"s":[3,2,3],"c":9854020},{"p":[4,27,-60],"s":[3,3,3],"l":1,"c":9854020},{"p":[216,0,91],"s":[20,21,36],"c":11172712,"e":1447446},{"p":[216,21,91],"s":[1,4,40],"c":"#9b9a9a"},{"p":[222,20,91],"s":[12,1,37],"l":1,"r":[0,0,-0.2],"c":"#9b9a9a"},{"p":[210,20,91],"s":[12,1,37],"l":1,"r":[0,0,0.2],"c":"#9b9a9a"},{"p":[200,0,100],"s":[12,12,12],"i":1},{"p":[200,12,100],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[222,21,91],"s":[13,2,38],"l":1,"r":[0,0,-0.2],"c":"#818d93","t":5},{"p":[210,21,91],"s":[13,2,38],"l":1,"r":[0,0,0.2],"c":"#818d93","t":5},{"p":[201,-1,90],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.78,0],"c":"#d8f2ff"},{"p":[221,-1,70],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.78,0],"c":"#d8f2ff"},{"p":[229,-1,91],"s":[7,6,8],"i":18,"l":1,"r":[0,0.61,0],"c":"#d8f2ff"},{"p":[181,0,167],"s":[12,12,12],"i":1},{"p":[181,12,167],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[245,-1,147],"s":[7,6,8],"i":18,"l":1,"r":[0,1.4,0],"c":"#d8f2ff"},{"p":[248,-1,170],"s":[7,6,8],"i":18,"l":1,"r":[0,0.88,0],"c":"#d8f2ff"},{"p":[268,-1,96],"s":[7,6,8],"i":18,"l":1,"r":[0,0.71,0],"c":"#d8f2ff"},{"p":[214,-1,34],"s":[7,6,8],"i":18,"l":1,"r":[0,0.71,0],"c":"#d8f2ff"},{"p":[254,-1,32],"s":[7,6,8],"i":18,"l":1,"r":[0,0.8,0],"c":"#d8f2ff"},{"p":[316,-1,48],"s":[7,6,8],"i":18,"l":1,"r":[0,0.45,0],"c":"#d8f2ff"},{"p":[318,-1,0],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.03,-3.14],"c":"#d8f2ff"},{"p":[4,27,-82],"s":[3,4,3],"l":1,"c":9854020},{"p":[156,0,116],"s":[17,2,34],"c":10197658},{"p":[153,0,133],"s":[5,33,5],"c":10197658},{"p":[153,0,99],"s":[5,33,5],"c":10197658},{"p":[155,33,116],"s":[5,3,39],"c":10197658,"bo":1},{"p":[152,36,116],"s":[13,2,40],"l":1,"c":"#818d93","t":5},{"p":[74,0,158],"s":[155,33,50],"c":11172712,"e":1447446,"bo":1},{"p":[157,-1,135],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.43,-3.14],"c":"#d8f2ff"},{"p":[158,-1,96],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.43,-3.14],"c":"#d8f2ff"},{"p":[133,4,127],"s":[12,12,12],"i":1},{"p":[184,-1,158],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.88,-3.14],"c":"#d8f2ff"},{"p":[-28,-1,-94],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14],"c":"#d8f2ff"},{"p":[-95,-1,-190],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.71,-3.14],"c":"#d8f2ff"},{"p":[-8,-1,-191],"s":[7,6,8],"i":18,"l":1,"r":[0,0.8,0],"c":"#d8f2ff"},{"p":[28,-1,-156],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.68,0],"c":"#d8f2ff"},{"p":[135,-1,-164],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.33,0],"c":"#d8f2ff"},{"p":[92,-1,-249],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.2,3.14],"c":"#d8f2ff"},{"p":[320,-1,-115],"s":[7,6,8],"i":18,"l":1,"r":[-3.13,-1.48,-3.13],"c":"#d8f2ff"},{"p":[253,-2,-170],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.96,-3.14],"c":"#d8f2ff"},{"p":[272,-2,-149],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.61,-3.14],"c":"#d8f2ff"},{"p":[245,-1,-176],"s":[7,6,8],"i":18,"l":1,"r":[-3.13,-1.4,-3.13],"c":"#d8f2ff"},{"p":[74,-1,-343],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.78,-3.14],"c":"#d8f2ff"},{"p":[2,-1,-343],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.26,0],"c":"#d8f2ff"},{"p":[248,0,-172],"s":[6,8,6],"i":2},{"p":[248,7,-172],"s":[6,2,6],"l":1,"c":"#818d93","t":5},{"p":[48,4,105],"s":[12,12,12],"i":1},{"p":[327,-1,-204],"s":[7,6,8],"i":18,"l":1,"r":[0,0.96,0],"c":"#d8f2ff"},{"p":[394,-1,-204],"s":[7,6,8],"i":18,"l":1,"r":[0,0.96,0],"c":"#d8f2ff"},{"p":[393,-1,-116],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.05,3.14],"c":"#d8f2ff"},{"p":[120,0,-103],"s":[6,8,6],"i":2},{"p":[120,7,-103],"s":[6,2,6],"l":1,"c":"#818d93","t":5},{"p":[363,-1,-204],"s":[7,6,8],"i":18,"l":1,"r":[0,0.96,0],"c":"#d8f2ff"},{"p":[356,0,-203],"s":[6,8,6],"i":2},{"p":[356,7,-203],"s":[6,2,6],"l":1,"c":"#818d93","t":5},{"p":[351,-1,-116],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.7,-3.14],"c":"#d8f2ff"},{"p":[145,-1,26],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.12,-3.14],"c":"#d8f2ff"},{"p":[158,-1,-167],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.7,-3.14],"c":"#d8f2ff"},{"p":[394,-1,-164],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.78,-3.14],"c":"#d8f2ff"},{"p":[354,0,-159],"s":[8,8,8],"pe":1,"c":"#818d93","t":5},{"p":[354,8,-159],"s":[6,7,6],"pe":1,"c":"#818d93","t":5},{"p":[354,15,-159],"s":[4,4,4],"pe":1,"c":"#818d93","t":5},{"p":[351,10,-159],"s":[1,1,1],"l":1,"c":"#474747","t":5},{"p":[351,13,-159],"s":[1,1,1],"l":1,"c":"#474747","t":5},{"p":[351,16,-159],"s":[2,1,1],"l":1,"c":"#ce7e3c","t":5},{"p":[352,17,-160],"s":[1,1,1],"l":1,"c":"#474747","t":5},{"p":[352,17,-158],"s":[1,1,1],"l":1,"c":"#474747","t":5},{"p":[354,13,-153],"s":[1,1,6],"l":1,"r":[-0.35,0,0],"c":"#563f2c","t":5},{"p":[354,13,-165],"s":[1,1,6],"l":1,"r":[0.44,0,0],"c":"#563f2c","t":5},{"p":[354,19,-159],"s":[6,1,6],"l":1,"c":"#292929","t":5},{"p":[354,20,-159],"s":[4,3,4],"l":1,"c":"#292929","t":5},{"p":[349,-1,-163],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.48,0],"c":"#d8f2ff"},{"p":[350,-1,-154],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.61,0],"c":"#d8f2ff"},{"p":[360,-1,-160],"s":[7,6,8],"i":18,"l":1,"r":[0,1.22,0],"c":"#d8f2ff"},{"p":[6,0,-347],"s":[5,48,7],"c":"#9b9a9a","bo":1},{"p":[211,2,-68],"s":[6,8,6],"i":2},{"p":[211,9,-68],"s":[6,2,6],"l":1,"c":"#818d93","t":5},{"p":[6,42,-343],"s":[1,1,3],"c":"#727272","t":5},{"p":[6,41,-340],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[6,40,-340],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[-502,-26,-94],"s":[746,26,1221],"l":1,"c":"#818d93","t":5},{"p":[14,0,67],"s":[34,2,18],"c":10197658},{"p":[-47,4,64],"s":[31,1,2],"c":"#453d2f","t":5},{"p":[-47,6,68],"s":[31,2,1],"c":"#453d2f","t":5},{"p":[-47,9,68],"s":[31,2,1],"c":"#453d2f","t":5},{"p":[-34,3,66],"s":[1,1,7],"c":"#474747","t":5},{"p":[-60,3,66],"s":[1,1,7],"c":"#474747","t":5},{"p":[-60,4,69],"s":[1,8,1],"c":"#474747","t":5},{"p":[-34,4,69],"s":[1,8,1],"c":"#474747","t":5},{"p":[-34,0,68],"s":[1,3,1],"c":"#474747","t":5},{"p":[-34,0,64],"s":[1,3,1],"c":"#474747","t":5},{"p":[-60,0,64],"s":[1,3,1],"c":"#474747","t":5},{"p":[-60,0,68],"s":[1,3,1],"c":"#474747","t":5},{"p":[89,4,67],"s":[31,1,2],"c":"#453d2f","t":5},{"p":[89,4,64],"s":[31,1,2],"c":"#453d2f","t":5},{"p":[89,6,68],"s":[31,2,1],"c":"#453d2f","t":5},{"p":[89,9,68],"s":[31,2,1],"c":"#453d2f","t":5},{"p":[102,3,66],"s":[1,1,7],"c":"#474747","t":5},{"p":[76,3,66],"s":[1,1,7],"c":"#474747","t":5},{"p":[76,4,69],"s":[1,8,1],"c":"#474747","t":5},{"p":[102,4,69],"s":[1,8,1],"c":"#474747","t":5},{"p":[102,0,68],"s":[1,3,1],"c":"#474747","t":5},{"p":[102,0,64],"s":[1,3,1],"c":"#474747","t":5},{"p":[76,0,64],"s":[1,3,1],"c":"#474747","t":5},{"p":[76,0,68],"s":[1,3,1],"c":"#474747","t":5},{"p":[288,4,-62],"s":[31,1,2],"c":"#453d2f","t":5},{"p":[288,4,-65],"s":[31,1,2],"c":"#453d2f","t":5},{"p":[288,6,-61],"s":[31,2,1],"c":"#453d2f","t":5},{"p":[288,9,-61],"s":[31,2,1],"c":"#453d2f","t":5},{"p":[301,3,-63],"s":[1,1,7],"c":"#474747","t":5},{"p":[275,3,-63],"s":[1,1,7],"c":"#474747","t":5},{"p":[275,4,-60],"s":[1,8,1],"c":"#474747","t":5},{"p":[301,4,-60],"s":[1,8,1],"c":"#474747","t":5},{"p":[301,0,-61],"s":[1,3,1],"c":"#474747","t":5},{"p":[301,0,-65],"s":[1,3,1],"c":"#474747","t":5},{"p":[275,0,-65],"s":[1,3,1],"c":"#474747","t":5},{"p":[275,0,-61],"s":[1,3,1],"c":"#474747","t":5},{"p":[213,0,-201],"s":[12,12,12],"i":1},{"p":[213,12,-201],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[223,-2,-203],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.96,-3.14],"c":"#d8f2ff"},{"p":[98,0,-139],"s":[6,8,6],"i":2},{"p":[98,7,-139],"s":[6,2,6],"l":1,"c":"#818d93","t":5},{"p":[146,0,-423],"s":[6,8,6],"i":2},{"p":[146,7,-423],"s":[6,2,6],"l":1,"c":"#818d93","t":5},{"p":[135,-1,-355],"s":[7,6,8],"i":18,"l":1,"r":[0,0.79,0],"c":"#d8f2ff"},{"p":[143,12,-350],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[149,23,-242],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[149,22,-242],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[72,50,-52],"s":[1,1,3],"c":"#727272","t":5,"bo":1},{"p":[72,49,-55],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[72,48,-55],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[222,46,115],"s":[1,1,3],"c":"#727272","t":5,"bo":1},{"p":[222,45,118],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[222,44,118],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[322,46,-1],"s":[1,1,3],"c":"#727272","t":5,"bo":1},{"p":[322,45,2],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[322,44,2],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[115,34,70],"s":[1,1,3],"c":"#727272","t":5},{"p":[115,33,67],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[115,32,67],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[251,30,-78],"s":[1,1,3],"l":1,"c":"#727272","t":5},{"p":[251,29,-81],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[251,28,-81],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[151,40,-353],"s":[1,1,3],"c":"#727272","t":5},{"p":[151,39,-356],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[151,38,-356],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[267,-1,-423],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.52,3.14],"c":"#d8f2ff"},{"p":[268,-1,-388],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#d8f2ff"},{"p":[304,-1,-64],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.88,-3.14],"c":"#d8f2ff"},{"p":[-95,-1,-162],"s":[7,6,8],"i":18,"l":1,"r":[0,0.97,0],"c":"#d8f2ff"},{"p":[145,-48,-580],"s":[215,142,132],"l":1,"c":"#aa7b68","e":"#161616"},{"p":[143,63,-321],"s":[1,1,262],"l":1,"c":9539985,"t":5},{"p":[163,63,-483],"s":[1,1,72],"l":1,"r":[0,-0.61,0],"c":9539985,"t":5},{"p":[183,63,-482],"s":[1,1,76],"l":1,"r":[0,-0.61,0],"c":9539985,"t":5},{"p":[143,0,-350],"s":[12,12,12],"i":1},{"p":[68,0,-313],"s":[12,12,12],"i":1},{"p":[68,12,-313],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[425,76,-334],"s":[404,3,73],"l":1,"r":[-0.44,0,0],"c":"#818d93","t":5},{"p":[425,77,-259],"s":[404,3,73],"l":1,"r":[0.43,0,0],"c":"#818d93","t":5},{"p":[429,110,-282],"s":[322,3,29],"l":1,"r":[0.43,0,0],"c":"#818d93","t":5},{"p":[429,110,-311],"s":[322,3,29],"l":1,"r":[-0.44,0,0],"c":"#818d93","t":5},{"p":[7,23,-410],"s":[175,3,132],"c":"#9b9a9a","bo":1},{"p":[7,26,-410],"s":[175,2,132],"l":1,"c":"#818d93","t":5},{"p":[78,31,-352],"s":[32,17,15],"c":9854020,"e":"#0e0e0e"},{"p":[-52,31,-410],"s":[56,17,131],"c":9854020,"e":"#0e0e0e"},{"p":[78,31,-469],"s":[32,17,13],"c":9854020,"e":"#0e0e0e"},{"p":[93,31,-383],"s":[2,17,9],"c":"#965c44","e":"#0e0e0e"},{"p":[93,42,-369],"s":[2,6,19],"c":"#965c44","e":"#0e0e0e"},{"p":[93,42,-397],"s":[2,6,19],"c":"#965c44","e":"#0e0e0e"},{"p":[93,31,-425],"s":[2,17,37],"c":"#965c44","e":"#0e0e0e"},{"p":[93,42,-453],"s":[2,6,19],"c":"#965c44","e":"#0e0e0e"},{"p":[6,31,-346],"s":[20,17,3],"c":"#965c44","e":"#0e0e0e"},{"p":[39,31,-346],"s":[6,17,3],"c":"#965c44","e":"#0e0e0e"},{"p":[52,43,-346],"s":[20,5,3],"c":"#965c44","e":"#0e0e0e"},{"p":[26,43,-346],"s":[20,5,3],"c":"#965c44","e":"#0e0e0e"},{"p":[-14,43,-346],"s":[20,5,3],"c":"#965c44","e":"#0e0e0e"},{"p":[6,31,-474],"s":[20,17,3],"c":"#965c44","e":"#0e0e0e"},{"p":[39,31,-474],"s":[6,17,3],"c":"#965c44","e":"#0e0e0e"},{"p":[93,36,-412],"s":[1,1,107],"l":1,"c":"#4f4f4f"},{"p":[17,36,-346],"s":[90,1,1],"l":1,"c":"#4f4f4f"},{"p":[93,30,-369],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[93,30,-397],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[93,30,-453],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[52,30,-346],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[26,30,-346],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[-14,30,-346],"s":[1,14,1],"l":1,"c":"#4f4f4f"},{"p":[8,31,-401],"s":[169,13,109],"c":"#475e72","o":0.7000000000000001,"t":5},{"p":[92,0,-427],"s":[6,48,7],"c":"#9b9a9a","bo":1},{"p":[98,-1,-420],"s":[7,6,8],"i":18,"l":1,"r":[0,1.22,0],"c":"#d8f2ff"},{"p":[160,40,-162],"s":[5,1,3],"l":1,"c":"#727272","t":5},{"p":[160,39,-162],"s":[4,1,2],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[157,41,-162],"s":[5,1,1],"l":1,"c":"#727272","t":5},{"p":[36,59,-138],"s":[1,1,3],"c":"#727272","t":5,"bo":1},{"p":[36,58,-140],"s":[3,1,5],"l":1,"c":"#727272","t":5},{"p":[36,57,-140],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[-13,66,-34],"s":[199,3,37],"l":1,"r":[-0.79,0,0],"c":"#818d93","t":5},{"p":[-13,67,-8],"s":[199,3,41],"l":1,"r":[0.78,0,0],"c":"#818d93","t":5},{"p":[-100,34,-156],"s":[7,2,7],"l":1,"c":"#818d93","t":5},{"p":[-100,34,-112],"s":[7,2,7],"l":1,"c":"#818d93","t":5},{"p":[-169,58,-245],"s":[115,2,101],"c":"#9b9a9a"},{"p":[-169,28,-245],"s":[115,2,101],"c":"#9b9a9a"},{"p":[-169,30,-245],"s":[115,2,101],"l":1,"c":"#818d93","t":5},{"p":[-169,60,-245],"s":[116,2,102],"l":1,"c":"#818d93","t":5},{"p":[-224,-2,-197],"s":[4,61,4],"c":10197658},{"p":[-114,0,-197],"s":[4,58,4],"c":10197658},{"p":[-173,5,-245],"s":[4,54,100],"c":10197658},{"p":[-224,2,-293],"s":[4,57,4],"c":10197658},{"p":[-114,-2,-293],"s":[4,61,4],"c":"#9b9a9a"},{"p":[-224,-2,-197],"s":[5,7,5],"c":10197658},{"p":[-114,-1,-197],"s":[5,6,5],"c":10197658},{"p":[-173,-1,-245],"s":[5,6,101],"c":10197658},{"p":[-114,-2,-293],"s":[5,7,5],"c":10197658},{"p":[-224,-2,-293],"s":[5,7,5],"c":10197658},{"p":[-169,-1,-245],"s":[113,37,99],"c":9854020},{"p":[-117,36,-245],"s":[9,15,99],"c":9854020},{"p":[-169,51,-245],"s":[113,7,99],"c":9854020},{"p":[-173,36,-245],"s":[22,15,99],"c":9854020},{"p":[-221,36,-288],"s":[9,15,13],"c":9854020},{"p":[-221,36,-245],"s":[9,15,11],"c":9854020},{"p":[-221,36,-202],"s":[9,15,13],"c":9854020},{"p":[-169,43,-293],"s":[98,1,1],"l":1,"c":"#4f4f4f"},{"p":[-169,43,-197],"s":[98,1,1],"l":1,"c":"#4f4f4f"},{"p":[-206,36,-293],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[-194,36,-293],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[-149,36,-293],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[-135,36,-293],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[-135,36,-197],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[-149,36,-197],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[-194,36,-197],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[-206,36,-197],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[-224,36,-229],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[-224,36,-272],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[-224,43,-246],"s":[1,1,78],"l":1,"c":"#4f4f4f"},{"p":[-171,36,-245],"s":[105,15,95],"c":"#475e72","o":0.7000000000000001,"t":5},{"p":[-224,36,-261],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[-224,36,-218],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[208,58,223],"s":[115,2,101],"c":"#9b9a9a","bo":1},{"p":[208,28,223],"s":[115,2,101],"c":"#9b9a9a","bo":1},{"p":[208,30,223],"s":[115,2,101],"l":1,"c":"#818d93","t":5},{"p":[208,60,223],"s":[116,2,102],"l":1,"c":"#818d93","t":5},{"p":[153,-2,271],"s":[4,61,4],"c":10197658},{"p":[263,0,271],"s":[4,58,4],"c":10197658},{"p":[204,5,177],"s":[4,54,8],"c":10197658},{"p":[153,2,175],"s":[4,57,4],"c":10197658},{"p":[263,-2,175],"s":[4,61,4],"c":"#9b9a9a"},{"p":[153,-2,271],"s":[5,7,5],"c":10197658},{"p":[263,-1,271],"s":[5,6,5],"c":10197658},{"p":[204,-1,223],"s":[5,6,101],"c":10197658},{"p":[263,-2,175],"s":[5,7,5],"c":10197658},{"p":[153,-2,175],"s":[5,7,5],"c":10197658},{"p":[208,-1,223],"s":[113,34,99],"c":9854020,"bo":1},{"p":[260,33,223],"s":[9,18,99],"c":"#965c44"},{"p":[208,51,223],"s":[113,7,99],"c":9854020},{"p":[204,36,176],"s":[22,15,5],"c":9854020},{"p":[156,36,180],"s":[9,15,13],"c":9854020},{"p":[156,36,223],"s":[9,15,11],"c":9854020},{"p":[156,36,266],"s":[9,15,13],"c":9854020},{"p":[208,43,175],"s":[98,1,1],"l":1,"c":"#4f4f4f"},{"p":[208,43,271],"s":[98,1,1],"l":1,"c":"#4f4f4f"},{"p":[171,36,175],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[183,36,175],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[228,36,175],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[242,36,175],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[242,36,271],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[228,36,271],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[183,36,271],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[171,36,271],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[153,36,239],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[153,36,196],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[153,43,222],"s":[1,1,78],"l":1,"c":"#4f4f4f"},{"p":[206,36,223],"s":[105,15,95],"c":"#475e72","o":0.7000000000000001,"t":5},{"p":[153,36,207],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[153,36,250],"s":[1,15,1],"l":1,"c":"#4f4f4f"},{"p":[200,-4,-410],"s":[40,54,37],"i":32,"l":1,"r":[0.35,0,0],"c":"#e8eda1","o":0.2},{"p":[151,11,-363],"s":[30,33,36],"i":32,"l":1,"r":[0.26,0,0],"c":"#e8eda1","o":0.2},{"p":[6,12,-330],"s":[29,34,39],"i":32,"l":1,"r":[-0.35,0,0],"c":"#e8eda1","o":0.2},{"p":[111,15,-299],"s":[28,35,36],"i":32,"l":1,"r":[0,0,0.43],"c":"#e8eda1","o":0.2},{"p":[169,19,-162],"s":[28,25,36],"i":32,"l":1,"r":[0,0,0.43],"c":"#e8eda1","o":0.2},{"p":[149,5,-236],"s":[36,20,34],"i":32,"l":1,"r":[-0.35,0,0],"c":"#e8eda1","o":0.2},{"p":[309,13,-143],"s":[28,35,36],"i":32,"l":1,"r":[0,0,0.43],"c":"#e8eda1","o":0.2},{"p":[288,5,-65],"s":[31,1,2],"l":1,"c":"#818d93","t":5},{"p":[288,5,-62],"s":[31,1,2],"l":1,"c":"#818d93","t":5},{"p":[288,11,-61],"s":[31,1,1],"l":1,"c":"#818d93","t":5},{"p":[251,7,-86],"s":[30,25,36],"i":32,"l":1,"r":[0.26,0,0],"c":"#e8eda1","o":0.2},{"p":[172,4,-87],"s":[43,46,38],"i":32,"l":1,"r":[-0.35,0,0],"c":"#e8eda1","o":0.2},{"p":[72,9,-69],"s":[43,46,38],"i":32,"l":1,"r":[0.35,0,0],"c":"#e8eda1","o":0.2},{"p":[222,6,132],"s":[43,46,38],"i":32,"l":1,"r":[-0.35,0,0],"c":"#e8eda1","o":0.2},{"p":[322,13,13],"s":[43,38,38],"i":32,"l":1,"r":[-0.35,0,0],"c":"#e8eda1","o":0.2},{"p":[-13,3,-175],"s":[43,46,38],"i":32,"l":1,"r":[-0.35,0,0],"c":"#e8eda1","o":0.2},{"p":[28,4,30],"s":[43,46,38],"i":32,"l":1,"r":[-0.35,0,0],"c":"#e8eda1","o":0.2},{"p":[115,5,57],"s":[43,32,38],"i":32,"l":1,"r":[0.35,0,0],"c":"#e8eda1","o":0.2},{"p":[36,31,-152],"s":[43,32,38],"i":32,"l":1,"r":[0.44,0,0],"c":"#e8eda1","o":0.2},{"p":[-82,17,-136],"s":[33,32,36],"i":32,"l":1,"r":[0,0,0.43],"c":"#e8eda1","o":0.2},{"p":[105,22,-21],"s":[28,25,36],"i":32,"l":1,"r":[0,0,0.43],"c":"#e8eda1","o":0.2},{"p":[-81,16,42],"s":[31,35,36],"i":32,"l":1,"r":[0,0,0.43],"c":"#e8eda1","o":0.2},{"p":[170,15,76],"s":[31,35,36],"i":32,"l":1,"r":[0,0,0.43],"c":"#e8eda1","o":0.2},{"p":[89,5,64],"s":[31,1,2],"l":1,"c":"#818d93","t":5},{"p":[89,5,67],"s":[31,1,2],"l":1,"c":"#818d93","t":5},{"p":[89,11,68],"s":[31,1,1],"l":1,"c":"#818d93","t":5},{"p":[-47,5,64],"s":[31,1,2],"l":1,"c":"#818d93","t":5},{"p":[-47,5,67],"s":[31,1,2],"l":1,"c":"#818d93","t":5},{"p":[-47,11,68],"s":[31,1,1],"l":1,"c":"#818d93","t":5},{"p":[-380,-3,105],"s":[251,96,122],"l":1,"c":11172712,"e":1447446},{"p":[-227,-3,-96],"s":[203,63,61],"l":1,"c":"#965c44"},{"p":[-135,46,-81],"s":[8,43,43],"l":1,"r":[-0.8,0,0],"c":9854020},{"p":[-323,45,-81],"s":[8,43,43],"l":1,"r":[-0.8,0,0],"c":9854020},{"p":[-227,60,-96],"s":[204,3,62],"l":1,"c":10197658},{"p":[-227,63,-96],"s":[205,2,63],"l":1,"c":"#818d93","t":5},{"p":[-229,77,-110],"s":[199,3,37],"l":1,"r":[-0.79,0,0],"c":"#818d93","t":5},{"p":[-229,78,-84],"s":[199,3,41],"l":1,"r":[0.78,0,0],"c":"#818d93","t":5},{"p":[-209,-3,88],"s":[203,62,61],"l":1,"c":9854020},{"p":[-117,45,103],"s":[8,43,43],"l":1,"r":[-0.8,0,0],"c":9854020},{"p":[-305,44,103],"s":[8,43,43],"l":1,"r":[-0.8,0,0],"c":9854020},{"p":[-209,59,88],"s":[204,3,62],"l":1,"c":10197658},{"p":[-209,62,88],"s":[205,2,63],"l":1,"c":"#818d93","t":5},{"p":[-211,76,74],"s":[199,3,37],"l":1,"r":[-0.79,0,0],"c":"#818d93","t":5},{"p":[-211,77,100],"s":[199,3,41],"l":1,"r":[0.78,0,0],"c":"#818d93","t":5},{"p":[-204,-9,-353],"s":[203,65,61],"l":1,"c":9854020},{"p":[-112,42,-338],"s":[8,43,43],"l":1,"r":[-0.8,0,0],"c":9854020},{"p":[-300,41,-338],"s":[8,43,43],"l":1,"r":[-0.8,0,0],"c":9854020},{"p":[-204,56,-353],"s":[204,3,62],"l":1,"c":10197658},{"p":[-204,59,-353],"s":[205,2,63],"l":1,"c":"#818d93","t":5},{"p":[-206,73,-367],"s":[199,3,37],"l":1,"r":[-0.79,0,0],"c":"#818d93","t":5},{"p":[-206,74,-341],"s":[199,3,41],"l":1,"r":[0.78,0,0],"c":"#818d93","t":5},{"p":[-387,-3,-231],"s":[251,96,122],"l":1,"c":11172712,"e":1447446},{"p":[-387,93,-231],"s":[255,4,125],"l":1,"c":"#bababa"},{"p":[229,97,-296],"s":[12,3,12],"c":"#818d93","t":5},{"p":[204,36,270],"s":[22,15,5],"c":9854020},{"p":[208,33,176],"s":[95,3,5],"c":9854020},{"p":[208,33,270],"s":[108,3,5],"c":9854020},{"p":[156,33,223],"s":[9,3,99],"c":9854020},{"p":[204,5,270],"s":[4,54,6],"c":10197658},{"p":[335,-28,18],"s":[1734,3,2577],"l":1,"c":"#4a433a","t":5,"ts":0.8},{"p":[281,0,-126],"s":[49,0,70],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[145,0,-263],"s":[54,0,64],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[235,0,-203],"s":[98,0,29],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[122,0,-105],"s":[41,0,23],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[81,0,-53],"s":[41,0,32],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[84,0,68],"s":[48,0,35],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[213,0,92],"s":[44,0,55],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[26,0,13],"s":[47,0,26],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[-40,0,7],"s":[35,0,32],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[-30,0,-87],"s":[41,0,59],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[150,0,-64],"s":[41,0,40],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[147,0,-352],"s":[35,0,41],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[77,0,-301],"s":[49,0,46],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[200,0,-373],"s":[49,0,63],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[149,0,-182],"s":[40,0,46],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[-96,0,-181],"s":[25,0,63],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[246,0,-66],"s":[30,0,37],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[82,0,-198],"s":[50,0,38],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[194,-1,-224],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.78,0],"c":"#d8f2ff"},{"p":[141,0,-430],"s":[31,0,39],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[204,0,-125],"s":[49,0,56],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[327,-30,222],"s":[5,36,143],"c":"#b5b5b5"},{"p":[305,-29,147],"s":[49,35,7],"c":"#b5b5b5"},{"p":[305,6,147],"s":[49,2,7],"l":1,"c":"#818d93","t":5},{"p":[327,6,290],"s":[5,2,279],"l":1,"c":"#818d93","t":5},{"p":[300,-29,247],"s":[50,29,194],"c":"#818d93","t":5},{"p":[217,-48,353],"s":[215,142,132],"l":1,"c":"#965c44"},{"p":[327,-30,365],"s":[5,36,143],"l":1,"c":"#b5b5b5"},{"p":[268,0,170],"s":[7,6,8],"i":18,"l":1,"r":[0,1.4,0],"c":"#d8f2ff"},{"p":[320,0,172],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.35,3.14],"c":"#d8f2ff"},{"p":[271,0,152],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.22,0],"c":"#d8f2ff"},{"p":[317,0,159],"s":[12,12,12],"i":1},{"p":[317,12,159],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[217,94,353],"s":[217,3,136],"l":1,"c":"#5b5b5b"},{"p":[217,97,353],"s":[219,2,139],"l":1,"c":"#818d93","t":5},{"p":[217,44,353],"s":[217,3,136],"l":1,"c":"#5b5b5b"},{"p":[217,47,353],"s":[219,2,139],"l":1,"c":"#818d93","t":5},{"p":[294,-1,235],"s":[61,29,109],"c":9854020,"bo":1},{"p":[294,28,235],"s":[63,2,111],"c":"#9b9a9a"},{"p":[-333,-3,-47],"s":[56,157,37],"l":1,"c":"#965c44"},{"p":[-22,0,-144],"s":[36,0,39],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[-97,0,-87],"s":[25,0,37],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[93,0,-253],"s":[6,8,6],"i":2},{"p":[93,7,-253],"s":[6,2,6],"l":1,"c":"#818d93","t":5},{"p":[270,48,-60],"s":[95,1,28],"i":30,"r":[1.57,0,-3.14],"st":"A-13","sc":"#6b493b","bv":1,"sf":120},{"p":[222,48,-311],"s":[95,1,28],"i":30,"r":[1.57,0,1.57],"st":"C-12","sc":"#936e5f","bv":1,"sf":120},{"p":[274,49,-224],"s":[95,1,28],"i":30,"r":[1.57,0,0],"st":"C-12","sc":"#936e5f","bv":1,"sf":120},{"p":[101,56,71],"s":[95,1,28],"i":30,"r":[1.57,0,-3.14],"st":"A-13","sc":"#896e62","bv":1,"sf":120},{"p":[152,57,70],"s":[97,1,30],"i":30,"r":[1.57,0,-1.57],"st":"A-13","sc":"#b18876","bv":1,"sf":120},{"p":[-48,-1,-192],"s":[7,6,8],"i":18,"l":1,"r":[0,0.97,0],"c":"#d8f2ff"},{"p":[-40,0,-338],"s":[6,8,6],"i":2},{"p":[-39,-1,-332],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.78,-3.14],"c":"#d8f2ff"},{"p":[-40,7,-338],"s":[6,2,6],"l":1,"c":"#818d93","t":5},{"p":[268,0,-417],"s":[6,8,6],"i":2},{"p":[268,7,-417],"s":[6,2,6],"l":1,"c":"#818d93","t":5},{"p":[50,0,-144],"s":[37,0,30],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[-100,0,36],"s":[7,34,7],"c":"#ababab","bo":1},{"p":[-100,34,36],"s":[7,2,7],"l":1,"c":"#818d93","t":5},{"p":[14,31,86],"s":[6,2,7],"l":1,"c":"#777777","t":5},{"p":[14,30,86],"s":[3,2,3],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[14,14,86],"s":[43,18,38],"i":32,"l":1,"c":"#e8eda1","o":0.2},{"p":[56,31,115],"s":[6,2,7],"l":1,"c":"#777777","t":5},{"p":[56,30,115],"s":[3,2,3],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[56,14,115],"s":[43,18,38],"i":32,"l":1,"c":"#e8eda1","o":0.2},{"p":[122,31,115],"s":[6,2,7],"l":1,"c":"#777777","t":5},{"p":[122,30,115],"s":[3,2,3],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[122,14,115],"s":[43,18,38],"i":32,"l":1,"c":"#e8eda1","o":0.2},{"p":[192,25,146],"s":[10,2,2],"l":1,"c":"#818d93","t":5},{"p":[188,19,146],"s":[2,6,2],"l":1,"c":"#818d93","t":5},{"p":[192,23,146],"s":[4,2,2],"l":1,"c":"#818d93","t":5},{"p":[241,61,-239],"s":[15,81,12],"c":"#472213","e":1447446},{"p":[241,142,-239],"s":[18,4,15],"c":"#4f4f4f","t":5},{"p":[-67,26,-65],"s":[3,1,2],"l":1,"r":[0,-0.61,0],"c":9854020},{"p":[-83,27,-83],"s":[5,2,3],"l":1,"r":[0,0.26,0],"c":9854020},{"p":[-3,25,-95],"s":[5,2,3],"l":1,"r":[0,0.7,0],"c":9854020},{"p":[-16,25,-95],"s":[2,1,3],"l":1,"r":[0,0.7,0],"c":9854020},{"p":[-5,26,-61],"s":[2,1,3],"l":1,"r":[0,0.7,0],"c":9854020},{"p":[-21,28,-87],"s":[3,1,4],"l":1,"c":9854020},{"p":[356,0,-160],"s":[64,50,90],"i":14},{"p":[213,0,92],"s":[78,50,76],"i":14},{"p":[145,0,-376],"s":[76,50,68],"i":14},{"p":[-66,0,-138],"s":[59,50,89],"i":14},{"p":[151,0,-396],"s":[24,36,24],"i":23,"tm":0},{"p":[249,0,95],"s":[24,36,24],"i":23,"tm":"1"},{"p":[50,0,-410],"s":[88,31,131],"c":"#965c44","e":"#0e0e0e","bo":1},{"p":[-15,26,-410],"s":[42,5,131],"c":"#965c44","e":"#0e0e0e","bo":1},{"p":[-15,0,-395],"s":[42,23,46],"c":"#965c44","e":"#0e0e0e","bo":1},{"p":[-32,-1,-369],"s":[7,6,8],"i":18,"l":1,"r":[0,0.97,0],"c":"#d8f2ff"},{"p":[4,-1,-369],"s":[7,6,8],"i":18,"l":1,"r":[0,0.97,0],"c":"#d8f2ff"},{"p":[352,0,-159],"s":[26,0,27],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[196,59,-23],"s":[115,2,109],"c":"#9b9a9a","bo":1},{"p":[196,61,-23],"s":[116,2,110],"l":1,"c":"#818d93","t":5},{"p":[174,0,-23],"s":[69,37,107],"c":9854020,"bo":1},{"p":[226,0,29],"s":[47,37,3],"c":9854020,"bo":1},{"p":[248,0,-40],"s":[9,37,73],"c":9854020,"bo":1},{"p":[250,33,12],"s":[5,4,31],"c":9854020,"bo":1},{"p":[226,33,-75],"s":[35,4,3],"c":9854020,"bo":1},{"p":[226,0,28],"s":[68,0,33],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[211,0,-68],"s":[22,0,33],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[292,0,47],"s":[12,12,12],"i":1},{"p":[292,12,47],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[301,0,44],"s":[45,0,24],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[294,30,235],"s":[65,2,112],"l":1,"c":"#818d93","t":5},{"p":[324,-30,230],"s":[20,58,99],"v":1,"c":"#000000","e":1447446,"bo":1},{"p":[-39,0,-340],"s":[27,0,32],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[251,-11,-341],"s":[109,39,79],"c":7485215,"e":1447446,"bo":1},{"p":[21,0,-339],"s":[12,12,12],"i":1},{"p":[21,12,-339],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[191,0,-216],"s":[12,12,12],"i":1},{"p":[191,12,-216],"s":[12,2,12],"l":1,"c":"#818d93","t":5},{"p":[190,-1,-304],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.39,0],"c":"#d8f2ff"},{"p":[273,-2,-203],"s":[7,6,8],"i":18,"l":1,"r":[0,0.61,0],"c":"#d8f2ff"},{"p":[291,28,-201],"s":[3,1,5],"l":1,"c":"#777777","t":5},{"p":[291,27,-201],"s":[2,1,4],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[291,11,-201],"s":[43,18,38],"i":32,"l":1,"c":"#e8eda1","o":0.2},{"p":[192,28,-288],"s":[5,1,3],"l":1,"c":"#777777","t":5},{"p":[192,27,-288],"s":[4,1,2],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[192,11,-288],"s":[43,18,38],"i":32,"l":1,"c":"#e8eda1","o":0.2},{"p":[252,-2,-204],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#d8f2ff"},{"p":[315,0,-205],"s":[39,0,54],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[291,0,-204],"s":[31,2,6],"c":10197658},{"p":[291,0,-255],"s":[27,2,96],"c":10197658},{"p":[237,0,-287],"s":[81,2,29],"c":10197658},{"p":[194,0,-287],"s":[5,2,32],"c":10197658},{"p":[291,27,-286],"s":[6,2,7],"l":1,"c":"#777777","t":5},{"p":[291,26,-286],"s":[3,2,3],"l":1,"c":"#000000","e":"#e9edb8","t":5},{"p":[291,10,-286],"s":[43,18,38],"i":32,"l":1,"c":"#e8eda1","o":0.2},{"p":[201,0,-283],"s":[39,0,71],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[291,29,-204],"s":[1,1,3],"l":1,"c":"#777777","t":5},{"p":[194,29,-288],"s":[3,1,1],"l":1,"c":"#777777","t":5},{"p":[240,0,166],"s":[61,0,51],"i":4,"l":1,"en":5,"c":"#818d93","t":5},{"p":[226,-1,-24],"s":[35,3,105],"c":10197658},{"p":[250,-1,12],"s":[13,3,34],"c":10197658},{"p":[260,-1,-1],"s":[7,6,8],"i":18,"l":1,"r":[0,0.97,0],"c":"#d8f2ff"},{"p":[226,-1,-78],"s":[39,3,3],"c":10197658},{"p":[207,-1,-80],"s":[7,6,8],"i":18,"l":1,"r":[0,0.97,0],"c":"#d8f2ff"},{"p":[-54,55,70],"s":[62,0,25],"i":11,"l":1,"r":[1.57,0,-3.14],"sad":1},{"p":[-54,41,71],"s":[67,28,1],"l":1,"c":"#433d31","t":5},{"p":[-54,40,71],"s":[69,2,3],"l":1,"c":"#433d31","t":5},{"p":[221,47,-266],"s":[47,0,19],"i":11,"l":1,"r":[1.57,0,-1.57],"sad":1},{"p":[222,36,-266],"s":[1,21,49],"l":1,"c":"#433d31","t":5},{"p":[-125,47,-102],"s":[42,0,20],"i":11,"l":1,"r":[1.57,0,1.57],"sad":1}]};
    
    /***/ }),
    
    /***/ "./maps/kanji.json":
    /*!*************************!*\
      !*** ./maps/kanji.json ***!
      \*************************/
    /*! exports provided: name, ambInd, skyDome, skyDomeCol0, skyDomeCol1, skyDomeCol2, shadowR, ambient, light, sky, fog, fogD, dthY, camPos, spawns, objects, default */
    /***/ (function(module) {
    
    module.exports = {"name":"Kanji","ambInd":2,"skyDome":true,"skyDomeCol0":"#071250","skyDomeCol1":"#452e7d","skyDomeCol2":"#2f3b7d","shadowR":2227.25487273401,"ambient":6184555,"light":3358064,"sky":693197,"fog":3551876,"fogD":888.9947618183014,"dthY":-118.35524224550045,"camPos":[-296,67,-379],"spawns":[[-150,-21,-611,0,0,0],[-306,-20,-524,0,0,0],[-63,-21,-548,0,0,0],[-21,-20,-243,0,0,0],[-470,-18,-219,0,3,0],[-379,-1,-373,0,0,0],[-83,-21,-312,0,0,0],[-323,-3,-8,0,0,0],[-17,0,80,0,3,0],[-149.99999999999997,-21,-611,0,0,0],[-306,-20,-524,0,0,0],[-63,-20.999999999999996,-547.9999999999999,0,0,0],[-21,-19.999999999999996,-243,0,0,0],[-469.99999999999994,-17.99999999999999,-219,0,3,0],[-378.9999999999999,-0.9999999999999998,-373,0,0,0],[-83,-20.99999999999999,-311.99999999999994,0,0,0],[-323,-2.9999999999999996,-8,0,0,0]],"objects":[{"p":[0,-1200,0],"s":[125,1200,203],"c":"#969696","t":5},{"p":[-62,2,101],"s":[2,30,2],"c":"#323232","t":5},{"p":[-30,-1182,-33],"s":[132,1161,203],"c":"#cfcfcf","t":5},{"p":[62,2,101],"s":[2,30,2],"c":"#323232","t":5},{"p":[-62,2,61],"s":[2,30,2],"c":"#323232","t":5},{"p":[-90,-19,-34],"s":[9,15,26],"t":5},{"p":[0,0,-101],"s":[120,2,4],"c":"#787878","t":5},{"p":[0,0,101],"s":[120,2,4],"c":"#787878","t":5},{"p":[62,0,0],"s":[4,2,206],"c":"#787878","t":5},{"p":[-62,0,0],"s":[4,2,206],"c":"#787878","t":5},{"p":[-98,-21,54],"s":[5,2,24],"c":"#787878","t":5},{"p":[-62,-21,-134],"s":[74,2,4],"c":"#787878","t":5},{"p":[35,2,75],"s":[2,16,2],"c":"#666666","t":5},{"p":[11,2,75],"s":[2,16,2],"c":"#666666","t":5},{"p":[11,2,51],"s":[2,16,2],"c":"#666666","t":5},{"p":[35,2,51],"s":[2,16,2],"c":"#666666","t":5},{"p":[23,18,63],"s":[28,1,28],"c":"#666666","t":5},{"p":[23,19,63],"s":[25,21,25],"c":"#acacac","t":5},{"p":[11,0,51],"s":[3,2,3],"c":"#666666","t":5},{"p":[35,0,51],"s":[3,2,3],"c":"#666666","t":5},{"p":[35,0,75],"s":[3,2,3],"c":"#666666","t":5},{"p":[11,0,75],"s":[3,2,3],"c":"#666666","t":5},{"p":[23,3,51],"s":[22,1,1],"c":"#666666","t":5},{"p":[11,3,63],"s":[1,1,22],"c":"#666666","t":5},{"p":[23,3,75],"s":[22,1,1],"c":"#666666","t":5},{"p":[35,3,63],"s":[1,1,22],"c":"#666666","t":5},{"p":[10,21,56],"s":[1,4,4],"c":"#666666","t":5},{"p":[10,21,61],"s":[1,4,4],"c":"#666666","t":5},{"p":[-47,-21,-103],"s":[2,25,4],"i":3,"c":"#e84d4d","t":5,"d":3},{"p":[-90,-21,-34],"s":[7,6,25],"c":"#505050","t":5},{"p":[23,40,63],"s":[28,1,28],"c":"#666666","t":5},{"p":[-19,6,-62],"s":[30,20,33],"t":5},{"p":[30,6,-61],"s":[20,14,39],"c":"#acacac","t":5},{"p":[-19,26,-62],"s":[33,1,36],"c":"#666666","t":5},{"p":[30,20,-61],"s":[22,1,41],"c":"#666666","t":5},{"p":[-7,27,-48],"s":[3,1,3],"c":"#666666","t":5},{"p":[-7,28,-48],"s":[4,2,4],"c":"#666666","t":5},{"p":[30,0,-61],"s":[19,6,38],"c":"#666666","t":5},{"p":[0,2,101],"s":[123,29,1],"pe":1,"t":12},{"p":[-62,2,81],"s":[1,29,38],"pe":1,"t":12},{"p":[0,2,101],"s":[2,30,2],"c":"#323232","t":5},{"p":[-64,-21,22],"s":[2,25,4],"i":3,"c":"#e84d4d","t":5,"d":2},{"p":[62,2,71],"s":[2,30,2],"c":"#323232","t":5},{"p":[62,2,-15],"s":[1,29,172],"pe":1,"t":12},{"p":[192,-708,517],"s":[139,784,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-112,-712,319],"s":[186,710,214],"r":[-3.14,0,3.14],"c":"#757575","t":5},{"p":[-294,-905,765],"s":[145,1089,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-112,-2,212],"s":[189,2,4],"c":"#4d4d4d","t":5,"bo":1},{"p":[-112,-2,426],"s":[189,2,4],"c":"#4d4d4d","t":5},{"p":[-20,-2,319],"s":[5,2,218],"c":"#4d4d4d","t":5,"bo":1},{"p":[-204,-2,319],"s":[5,2,218],"c":"#4d4d4d","t":5,"bo":1},{"p":[192,76,517],"s":[142,3,145],"l":1,"c":"#696969","t":5},{"p":[308,-708,191],"s":[139,745,142],"c":"#b6b6b6","t":5},{"p":[308,11,191],"s":[100,75,106],"c":"#b6b6b6","t":5},{"p":[308,86,191],"s":[106,3,111],"c":"#707070","t":5},{"p":[308,37,191],"s":[145,2,147],"c":"#707070","t":5,"bo":1},{"p":[300,-708,467],"s":[158,608,142],"l":1,"c":"#7d7d7d","t":5},{"p":[0,165,368],"s":[143,3,146],"c":"#828282","t":5},{"p":[559,-708,21],"s":[158,796,139],"l":1,"c":"#7d7d7d","t":5},{"p":[308,-708,-55],"s":[139,694,142],"c":"#b6b6b6","t":5},{"p":[-377,-708,284],"s":[162,796,139],"c":"#6b6b6b","t":5,"bo":1},{"p":[-82,-708,830],"s":[139,926,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-33,0,55],"s":[22,6,48],"c":"#666666","t":5},{"p":[-33,6,55],"s":[23,14,49],"c":"#acacac","t":5},{"p":[-33,20,55],"s":[25,1,51],"c":"#666666","t":5},{"p":[-478,-708,187],"s":[139,732,161],"c":"#b6b6b6","t":5,"bo":1},{"p":[-383,-708,-199],"s":[148,860,130],"c":"#919191","t":5,"bo":1},{"p":[-322,-708,-222],"s":[88,687,142],"c":"#d9d9d9","t":5},{"p":[-291,-21,-293],"s":[30,2,4],"c":"#939393","t":5},{"p":[-278,-21,-238],"s":[4,2,112],"c":"#939393","t":5},{"p":[-865,-708,375],"s":[139,926,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-633,-905,-887],"s":[145,1088,142],"l":1,"c":"#e3e3e3","t":5},{"p":[2,-708,-231],"s":[55,688,136],"c":"#b6b6b6","t":5},{"p":[-211,-708,-147],"s":[34,844,34],"c":"#b6b6b6","t":5,"bo":1},{"p":[618,-708,215],"s":[139,945,142],"l":1,"c":"#b6b6b6","t":5},{"p":[438,-708,627],"s":[158,858,139],"l":1,"c":"#7d7d7d","t":5},{"p":[129,-905,772],"s":[225,962,142],"l":1,"c":"#b6b6b6","t":5},{"p":[62,2,19],"s":[2,30,2],"c":"#323232","t":5},{"p":[62,2,-101],"s":[2,30,2],"c":"#323232","t":5},{"p":[-830,-905,119],"s":[185,965,116],"l":1,"c":"#f0f0f0","t":5},{"p":[-659,-712,-122],"s":[186,744,214],"r":[-3.14,0,3.14],"c":"#757575","t":5,"bo":1},{"p":[-1107,-708,30],"s":[139,926,142],"l":1,"c":"#141414","t":5},{"p":[-496,-905,789],"s":[145,1202,142],"l":1,"c":"#b6b6b6","t":5},{"p":[415,-905,789],"s":[145,1257,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-208,-905,1060],"s":[225,1031,142],"l":1,"c":"#fcfcfc","t":5},{"p":[580,-905,464],"s":[208,962,214],"l":1,"c":"#b6b6b6","t":5},{"p":[-707,-905,586],"s":[225,1010,256],"l":1,"c":"#c8c8c8","t":5},{"p":[-90,-3,-43],"s":[4,2,4],"c":"#666666","t":5},{"p":[-90,-4,-43],"s":[3,1,3],"c":"#666666","t":5},{"p":[355,-905,-147],"s":[145,1066,142],"l":1,"c":"#b6b6b6","t":5},{"p":[2,24,-231],"s":[55,84,136],"c":"#8c8c8c","t":5,"bo":1},{"p":[-145,-796,-231],"s":[239,905,136],"c":"#8c8c8c","t":5,"bo":1},{"p":[-79,-21,68],"s":[43,2,4],"c":"#787878","t":5},{"p":[24,-20,-168],"s":[11,44,10],"c":"#b6b6b6","t":5,"bo":1},{"p":[0,-708,368],"s":[139,873,142],"c":"#b6b6b6","t":5},{"p":[230,-708,-401],"s":[139,873,142],"c":"#616161","t":5},{"p":[484,-905,-475],"s":[208,962,214],"l":1,"c":"#f2f2f2","t":5},{"p":[889,-708,-261],"s":[171,889,259],"l":1,"c":"#7d7d7d","t":5},{"p":[547,-905,-486],"s":[145,1257,142],"l":1,"c":"#484848","t":5},{"p":[-853,-905,-279],"s":[145,1202,142],"l":1,"c":"#969696","t":5},{"p":[154,-905,-948],"s":[145,1202,142],"l":1,"c":"#555454","t":5},{"p":[-461,-905,37],"s":[106,761,94],"l":1,"c":"#646464","t":5},{"p":[504,-708,72],"s":[158,608,142],"l":1,"c":"#7d7d7d","t":5},{"p":[-943,-905,716],"s":[145,1292,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-31,27,-78],"s":[1,2,1],"c":"#666666","t":5},{"p":[-31,29,-78],"s":[2,1,2],"c":"#666666","t":5},{"p":[-706,-905,-504],"s":[145,1034,142],"c":"#828282","t":5},{"p":[-1007,-708,-410],"s":[158,796,139],"l":1,"c":"#7d7d7d","t":5},{"p":[-791,-905,-1167],"s":[145,1202,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-165,-905,-1488],"s":[145,1212,142],"l":1,"c":"#616161","t":5},{"p":[-1655,-820,-464],"s":[145,1238,142],"l":1,"c":"#b6b6b6","t":5},{"p":[276,-905,-739],"s":[145,1034,142],"l":1,"c":"#b9b9b9","t":5},{"p":[-657,-785,-556],"s":[158,757,139],"c":"#7d7d7d","t":5,"bo":1},{"p":[190,-710,-360],"s":[123,763,135],"r":[-3.14,0,3.14],"c":"#a0a0a0","t":5,"bo":1},{"p":[87,-708,-895],"s":[158,731,139],"l":1,"c":"#acacac","t":5},{"p":[-700,-905,-818],"s":[145,981,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-282,-710,-534],"s":[96,690,104],"r":[-3.14,0,3.14],"c":"#c0c0c0","t":5},{"p":[-235,-21,-533],"s":[4,2,105],"c":"#787878","t":5},{"p":[-331,-21,-533],"s":[4,2,105],"c":"#787878","t":5},{"p":[-312,-21,-483],"s":[39,2,5],"c":"#787878","t":5},{"p":[-283,-21,-583],"s":[100,2,5],"c":"#787878","t":5},{"p":[-331,-19,-583],"s":[2,30,2],"c":"#323232","t":5},{"p":[-331,-19,-483],"s":[2,30,2],"c":"#323232","t":5},{"p":[-331,-19,-533],"s":[2,30,2],"c":"#323232","t":5},{"p":[-284,-19,-583],"s":[2,30,2],"c":"#323232","t":5},{"p":[-235,-19,-583],"s":[2,30,2],"c":"#323232","t":5},{"p":[-308,-19,-583],"s":[47,29,1],"pe":1,"t":12},{"p":[-331,-19,-533],"s":[1,29,99],"pe":1,"t":12},{"p":[-307,-17,-502],"s":[25,13,14],"c":"#cfcfcf","t":5},{"p":[-307,-22,-502],"s":[24,5,13],"c":"#7a7a7a","t":5},{"p":[-307,-4,-502],"s":[27,1,16],"c":"#737373","t":5},{"p":[-707,-905,-54],"s":[145,1034,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-111,-708,-1048],"s":[158,796,151],"l":1,"c":"#7d7d7d","t":5},{"p":[-854,-708,-684],"s":[139,926,142],"l":1,"c":"#4b4b4b","t":5},{"p":[-1056,-708,-814],"s":[158,885,139],"l":1,"c":"#7d7d7d","t":5},{"p":[-405,-708,-987],"s":[158,680,139],"l":1,"c":"#acacac","t":5},{"p":[-224,-708,-1269],"s":[139,876,142],"l":1,"c":"#343434","t":5},{"p":[-564,-708,-1215],"s":[158,796,139],"l":1,"c":"#b4b4b4","t":5},{"p":[500,-905,-912],"s":[145,1285,142],"l":1,"c":"#b6b6b6","t":5},{"p":[83,-905,-1262],"s":[145,1112,142],"l":1,"c":"#7f7f7f","t":5},{"p":[-414,-905,-1447],"s":[145,1068,142],"l":1,"c":"#ffffff","t":5},{"p":[-592,-708,-1418],"s":[158,1072,139],"l":1,"c":"#7d7d7d","t":5},{"p":[133,-708,-1094],"s":[158,796,139],"l":1,"c":"#6e6e6e","t":5},{"p":[484,-708,-653],"s":[158,915,139],"l":1,"c":"#6e6e6e","t":5},{"p":[379,-708,-1008],"s":[158,821,139],"l":1,"c":"#6e6e6e","t":5},{"p":[-1217,-708,-567],"s":[158,979,139],"l":1,"c":"#7d7d7d","t":5},{"p":[-1275,-905,-1165],"s":[145,1238,142],"l":1,"c":"#b6b6b6","t":5},{"p":[991,-708,134],"s":[171,933,138],"l":1,"c":"#7d7d7d","t":5},{"p":[1380,-708,-70],"s":[171,1084,138],"l":1,"c":"#7d7d7d","t":5},{"p":[680,-708,544],"s":[171,1084,138],"l":1,"c":"#7d7d7d","t":5},{"p":[295,-905,1272],"s":[145,1257,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-1455,-905,-155],"s":[145,1305,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-1206,-905,376],"s":[145,1305,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-254,-22,-502],"s":[24,5,13],"c":"#7a7a7a","t":5},{"p":[-254,-17,-502],"s":[25,13,14],"c":"#cfcfcf","t":5},{"p":[-254,-4,-502],"s":[27,1,16],"c":"#737373","t":5},{"p":[-383,151,-199],"s":[152,3,135],"c":"#737373","t":5,"bo":1},{"p":[-305,-2,-557],"s":[25,21,25],"c":"#acacac","t":5},{"p":[-305,19,-557],"s":[28,1,28],"c":"#666666","t":5},{"p":[-305,-3,-557],"s":[28,1,28],"c":"#666666","t":5},{"p":[-294,-18,-546],"s":[2,15,2],"c":"#666666","t":5},{"p":[-294,-20,-546],"s":[3,2,3],"c":"#666666","t":5},{"p":[-294,-18,-568],"s":[2,15,2],"c":"#666666","t":5},{"p":[-294,-20,-568],"s":[3,2,3],"c":"#666666","t":5},{"p":[-316,-18,-546],"s":[2,15,2],"c":"#666666","t":5},{"p":[-316,-20,-546],"s":[3,2,3],"c":"#666666","t":5},{"p":[-316,-18,-568],"s":[2,15,2],"c":"#666666","t":5},{"p":[-316,-20,-568],"s":[3,2,3],"c":"#666666","t":5},{"p":[-294,-17,-557],"s":[1,1,22],"c":"#666666","t":5},{"p":[-316,-17,-557],"s":[1,1,22],"c":"#666666","t":5},{"p":[-305,-17,-546],"s":[20,1,1],"c":"#666666","t":5},{"p":[-305,-17,-568],"s":[20,1,1],"c":"#666666","t":5},{"p":[-121,-708,-427],"s":[157,687,70],"c":"#cfcfcf","t":5},{"p":[-63,-708,-533],"s":[41,687,142],"c":"#cfcfcf","t":5},{"p":[-199,-21,-427],"s":[4,2,73],"c":"#787878","t":5},{"p":[-121,-21,-393],"s":[160,2,4],"c":"#787878","t":5},{"p":[-43,-21,-517],"s":[4,2,245],"c":"#787878","t":5},{"p":[-131,-23,-436],"s":[102,96,52],"c":"#b6b6b6","t":5,"bo":1},{"p":[-67,-708,-322],"s":[193,688,46],"c":"#b6b6b6","t":5},{"p":[24,-20,-294],"s":[11,44,10],"c":"#b6b6b6","t":5,"bo":1},{"p":[24,-20,-232],"s":[11,44,10],"c":"#b6b6b6","t":5,"bo":1},{"p":[-20,-20,-340],"s":[11,44,10],"c":"#b6b6b6","t":5},{"p":[-20,-20,-168],"s":[11,44,10],"c":"#b6b6b6","t":5,"bo":1},{"p":[-20,-20,-232],"s":[11,44,10],"c":"#b6b6b6","t":5},{"p":[24,-20,-340],"s":[11,44,10],"c":"#b6b6b6","t":5},{"p":[-20,-20,-294],"s":[11,44,10],"c":"#b6b6b6","t":5},{"p":[2,24,-322],"s":[55,9,46],"c":"#b6b6b6","t":5},{"p":[6,-1182,-144],"s":[69,1161,19],"c":"#cfcfcf","t":5},{"p":[-27,-21,-143],"s":[4,2,14],"c":"#787878","t":5},{"p":[6,-21,-152],"s":[70,2,4],"c":"#787878","t":5},{"p":[50,2,-101],"s":[2,30,2],"c":"#323232","t":5},{"p":[56,2,-101],"s":[12,29,1],"pe":1,"t":12},{"p":[-129,-20,-322],"s":[69,33,46],"c":"#b6b6b6","t":5},{"p":[-93,-21,-323],"s":[2,38,4],"i":3,"r":[-3.14,0,-3.14],"c":"#e84d4d","t":5},{"p":[-95,13,-323],"s":[4,2,48],"c":"#787878","t":5},{"p":[-129,13,-345],"s":[64,2,4],"c":"#787878","t":5},{"p":[-67,-19,-367],"s":[4,1,56],"c":"#897966","t":5},{"p":[-63,-19,-367],"s":[4,1,59],"c":"#988671","t":5},{"p":[-94,-20,-323],"s":[2,35,9],"v":1,"c":"#cfcfcf","t":5},{"p":[-132,96,-533],"s":[184,4,147],"c":"#707070","t":5,"bo":1},{"p":[-131,73,-440],"s":[105,4,65],"c":"#707070","t":5,"bo":1},{"p":[-141,13,-339],"s":[5,1,5],"c":"#666666","t":5},{"p":[-383,-21,-199],"s":[151,2,133],"l":1,"c":"#919191","t":5},{"p":[-141,14,-339],"s":[2,23,2],"c":"#666666","t":5},{"p":[-101,13,-339],"s":[5,1,5],"c":"#666666","t":5},{"p":[-101,14,-339],"s":[2,23,2],"c":"#666666","t":5},{"p":[-101,37,-349],"s":[2,2,27],"c":"#666666","t":5},{"p":[-101,-14,-360],"s":[1,52,1],"c":"#505050","t":5},{"p":[-141,37,-349],"s":[2,2,27],"c":"#666666","t":5},{"p":[-141,-14,-360],"s":[1,52,1],"c":"#505050","t":5},{"p":[-121,-15,-361],"s":[41,1,19],"c":"#646464","t":5},{"p":[-100,-15,-361],"s":[1,2,19],"c":"#e84d4d","t":5},{"p":[-142,-15,-361],"s":[1,2,19],"c":"#e84d4d","t":5},{"p":[-121,-15,-371],"s":[43,2,1],"c":"#e84d4d","t":5},{"p":[-121,-15,-351],"s":[43,2,1],"c":"#e84d4d","t":5},{"p":[-142,-13,-360],"s":[1,2,4],"c":"#e84d4d","t":5},{"p":[-100,-13,-360],"s":[1,2,4],"c":"#e84d4d","t":5},{"p":[-106,13,-340],"s":[4,7,4],"i":16},{"p":[-158,13,-302],"s":[4,7,4],"i":16},{"p":[16,-20,-342],"s":[4,7,4],"i":16},{"p":[-21,-20,-286],"s":[4,7,4],"i":16},{"p":[16,-20,-166],"s":[4,7,4],"i":16},{"p":[-235,-19,-560],"s":[1,29,45],"pe":1,"t":12},{"p":[-235,-19,-537],"s":[2,30,2],"c":"#323232","t":5},{"p":[230,165,-401],"s":[143,3,146],"c":"#575757","t":5},{"p":[355,161,-147],"s":[151,5,147],"l":1,"c":"#737373","t":5},{"p":[-117,107,-231],"s":[299,4,142],"c":"#6b6b6b","t":5,"bo":1},{"p":[-211,136,-143],"s":[38,3,46],"c":"#787878","t":5,"bo":1},{"p":[-19,0,-62],"s":[29,6,32],"c":"#757575","t":5},{"p":[-101,111,-164],"s":[2,23,2],"l":1,"c":"#666666","t":5},{"p":[-141,111,-164],"s":[2,23,2],"l":1,"c":"#666666","t":5},{"p":[-101,134,-155],"s":[3,3,27],"l":1,"c":"#666666","t":5},{"p":[-141,134,-155],"s":[3,3,27],"l":1,"c":"#666666","t":5},{"p":[-101,34,-143],"s":[1,99,1],"l":1,"c":"#505050","t":5},{"p":[-141,34,-143],"s":[1,102,1],"l":1,"c":"#505050","t":5},{"p":[-121,33,-143],"s":[41,1,19],"c":"#646464","t":5,"bo":1},{"p":[-121,33,-133],"s":[43,2,1],"c":"#e84d4d","t":5,"bo":1},{"p":[-121,33,-153],"s":[43,2,1],"c":"#e84d4d","t":5},{"p":[-100,33,-143],"s":[1,2,19],"c":"#e84d4d","t":5,"bo":1},{"p":[-142,33,-143],"s":[1,2,19],"c":"#e84d4d","t":5,"bo":1},{"p":[-100,35,-143],"s":[1,2,4],"c":"#e84d4d","t":5},{"p":[-142,35,-143],"s":[1,2,4],"c":"#e84d4d","t":5},{"p":[-100,35,-133],"s":[1,11,1],"c":"#e84d4d","t":5},{"p":[-100,35,-153],"s":[1,11,1],"c":"#e84d4d","t":5},{"p":[-142,35,-153],"s":[1,11,1],"c":"#e84d4d","t":5},{"p":[-142,35,-133],"s":[1,11,1],"c":"#e84d4d","t":5},{"p":[-121,44,-133],"s":[45,1,2],"c":"#e84d4d","t":5},{"p":[-121,44,-153],"s":[45,1,2],"c":"#e84d4d","t":5},{"p":[-121,35,-133],"s":[1,9,1],"c":"#e84d4d","t":5},{"p":[-121,35,-153],"s":[1,9,1],"c":"#e84d4d","t":5},{"p":[-100,37,-143],"s":[1,7,1],"c":"#e84d4d","t":5},{"p":[-142,37,-143],"s":[1,7,1],"c":"#e84d4d","t":5},{"p":[-142,44,-143],"s":[2,1,18],"c":"#e84d4d","t":5},{"p":[-100,44,-143],"s":[2,1,18],"c":"#e84d4d","t":5},{"p":[-297,-2,-498],"s":[3,1,3],"c":"#666666","t":5},{"p":[-297,-3,-498],"s":[2,1,2],"c":"#666666","t":5},{"p":[-264,-3,-498],"s":[2,1,2],"c":"#666666","t":5},{"p":[-264,-2,-498],"s":[3,1,3],"c":"#666666","t":5},{"p":[263,89,144],"s":[1,64,1],"l":1,"c":"#ffffff","t":5},{"p":[-63,168,304],"s":[1,40,1],"l":1,"c":"#ffffff","t":5},{"p":[48,166,315],"s":[27,14,22],"l":1,"c":"#acacac","t":5},{"p":[48,180,315],"s":[29,1,24],"l":1,"c":"#5c5c5c","t":5},{"p":[-377,88,284],"s":[167,3,142],"l":1,"c":"#555555","t":5},{"p":[-478,24,187],"s":[145,3,165],"l":1,"c":"#696969","t":5},{"p":[-112,-2,221],"s":[3,8,3],"l":1,"c":"#696969","t":5},{"p":[308,-14,-55],"s":[144,4,147],"c":"#696565","t":5,"bo":1},{"p":[-163,-708,-623],"s":[241,687,38],"c":"#cfcfcf","t":5},{"p":[-196,-2,221],"s":[3,8,3],"l":1,"c":"#696969","t":5},{"p":[-154,6,221],"s":[116,54,3],"l":1,"c":"#343434","t":5},{"p":[-448,-905,-776],"s":[145,943,142],"c":"#828282","t":5},{"p":[-448,38,-776],"s":[149,4,147],"c":"#616161","t":5,"bo":1},{"p":[928,-708,-443],"s":[171,1084,138],"l":1,"c":"#ffffff","t":5},{"p":[-283,-21,-623],"s":[4,2,33],"c":"#787878","t":5},{"p":[-163,-21,-642],"s":[244,2,5],"c":"#787878","t":5},{"p":[-293,56,249],"s":[22,4,2],"l":1,"c":"#3e3e3e","t":5},{"p":[-293,8,249],"s":[22,4,2],"l":1,"c":"#3e3e3e","t":5},{"p":[-281,8,249],"s":[2,69,2],"l":1,"c":"#3e3e3e","t":5},{"p":[-268,-3,249],"s":[25,83,5],"l":1,"c":"#000000","t":5},{"p":[-268,75,246],"s":[18,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-276,73,246],"s":[2,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-260,73,246],"s":[2,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-264,71,246],"s":[6,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-274,68,246],"s":[6,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-264,68,246],"s":[10,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-267,61,246],"s":[2,7,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-274,63,246],"s":[2,10,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,60,246],"s":[5,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-262,61,246],"s":[2,7,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-261,60,246],"s":[2,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,54,246],"s":[18,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-276,41,246],"s":[2,10,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-275,40,246],"s":[2,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-260,40,246],"s":[2,11,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,47,246],"s":[9,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,40,246],"s":[2,17,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-272,49,246],"s":[2,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-270,33,246],"s":[2,4,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,34,246],"s":[17,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,30,246],"s":[14,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,26,246],"s":[6,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,20,246],"s":[2,14,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-264,26,246],"s":[2,4,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,23,246],"s":[14,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-261,5,246],"s":[2,12,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-262,12,246],"s":[6,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-264,2,246],"s":[2,13,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-263,4,246],"s":[7,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-272,15,246],"s":[10,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-272,13,246],"s":[4,1,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-272,10,246],"s":[4,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-269,9,246],"s":[2,8,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-276,10,246],"s":[2,1,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,9,246],"s":[2,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,5,246],"s":[2,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-272,5,246],"s":[2,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-276,5,246],"s":[2,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-270,1,246],"s":[2,7,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-269,0,246],"s":[2,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-274,0,246],"s":[2,8,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,79,246],"s":[25,1,1],"l":1,"c":"#00ff69","e":"#00ff69","t":5},{"p":[-268,-3,246],"s":[25,1,1],"l":1,"c":"#00ff69","e":"#00ff69","t":5},{"p":[-256,-3,246],"s":[1,83,1],"l":1,"c":"#00ff69","e":"#00ff69","t":5},{"p":[-280,-3,246],"s":[1,83,1],"l":1,"c":"#00ff69","e":"#00ff69","t":5},{"p":[-264,49,246],"s":[2,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,43,246],"s":[10,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-268,51,246],"s":[18,2,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-266,33,246],"s":[2,4,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-272,26,246],"s":[2,4,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-262,0,246],"s":[2,3,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-275,9,246],"s":[2,8,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-308,90,223],"s":[2,76,2],"l":1,"c":"#aaaaaa","t":5},{"p":[-40,35,-521],"s":[9,1,1],"c":"#372d2d","t":5},{"p":[-40,52,-521],"s":[9,1,1],"c":"#372d2d","t":5},{"p":[-35,33,-521],"s":[1,22,2],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-28,34,-521],"s":[13,20,1],"c":"#021606","e":"#010903","t":5},{"p":[-21,33,-521],"s":[1,22,2],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-28,33,-521],"s":[14,1,2],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-28,54,-521],"s":[14,1,2],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-25,51,-521],"s":[5,1,2],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-26,49,-521],"s":[5,1,2],"l":1,"r":[0,0,0.7],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-25,44,-521],"s":[5,1,2],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-23,35,-521],"s":[1,6,2],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-26,37,-521],"s":[1,3,2],"l":1,"r":[0,0,1.22],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-26,39,-521],"s":[1,2,2],"l":1,"r":[0,0,0.87],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-27,40,-521],"s":[1,2,2],"l":1,"r":[0,0,0.7],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-29,36,-521],"s":[1,4,2],"l":1,"r":[0,0,-0.17],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-32,36,-521],"s":[1,4,2],"l":1,"r":[0,0,-0.17],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-30,36,-521],"s":[2,1,2],"l":1,"r":[0,0,-0.17],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-31,39,-521],"s":[2,1,2],"l":1,"r":[0,0,-0.17],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-31,37,-521],"s":[1,2,2],"l":1,"r":[0,0,-0.17],"c":"#004aff","e":"#7800ff","t":5},{"p":[-31,40,-521],"s":[4,1,2],"l":1,"r":[0,0,-0.17],"c":"#fffe00","e":"#fff000","t":5},{"p":[-31,41,-521],"s":[1,4,2],"l":1,"r":[0,0,0.18],"c":"#002dff","e":"#0000ff","t":5},{"p":[-32,41,-521],"s":[1,3,2],"l":1,"r":[0,0,-0.52],"c":"#002dff","e":"#0000ff","t":5},{"p":[-19,35,-521],"s":[4,1,1],"l":1,"c":"#372d2d","t":5},{"p":[-40,43,-521],"s":[9,1,1],"c":"#372d2d","t":5},{"p":[-19,41,-521],"s":[4,1,1],"l":1,"c":"#372d2d","t":5},{"p":[-19,53,-521],"s":[4,1,1],"l":1,"c":"#372d2d","t":5},{"p":[-17,32,-521],"s":[1,23,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-9,32,-521],"s":[1,23,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-13,32,-521],"s":[7,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-13,54,-521],"s":[7,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-13,33,-521],"s":[7,21,1],"c":"#120216","e":"#010903","t":5},{"p":[-13,51,-521],"s":[5,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-14,50,-521],"s":[1,3,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-12,50,-521],"s":[1,3,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-13,43,-521],"s":[1,6,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-12,48,-521],"s":[3,1,2],"l":1,"r":[0,0,0.7],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-14,48,-521],"s":[3,1,2],"l":1,"r":[0,0,-0.7],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-13,45,-521],"s":[5,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-15,44,-521],"s":[3,1,2],"l":1,"r":[0,0,-0.7],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-11,44,-521],"s":[3,1,2],"l":1,"r":[0,0,0.52],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-11,37,-521],"s":[1,4,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-13,37,-521],"s":[1,5,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-13,40,-521],"s":[5,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-14,38,-521],"s":[3,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-14,36,-521],"s":[3,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-15,35,-521],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-12,35,-521],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-13,34,-521],"s":[3,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-10,35,-521],"s":[1,3,2],"l":1,"r":[0,0,-0.35],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-15,34,-521],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-12,36,-521],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-31,47,-521],"s":[3,1,2],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-31,50,-521],"s":[3,1,2],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-30,47,-521],"s":[1,3,2],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-33,47,-521],"s":[1,4,2],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-32,51,-521],"s":[3,1,2],"l":1,"c":"#ff8700","e":"#553200","t":5},{"p":[-30,51,-521],"s":[1,1,2],"l":1,"c":"#ff8700","e":"#553200","t":5},{"p":[-26,29,-521],"s":[1,4,1],"l":1,"c":"#372d2d","t":5},{"p":[-30,29,-521],"s":[1,4,1],"l":1,"c":"#372d2d","t":5},{"p":[-28,30,-521],"s":[8,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-28,22,-521],"s":[4,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-32,18,-521],"s":[1,13,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-24,18,-521],"s":[1,13,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-28,19,-521],"s":[7,11,1],"c":"#000337","t":5},{"p":[-25,22,-521],"s":[1,7,2],"l":1,"r":[0,0,-0.17],"c":"#000de8","e":"#004aff","t":5},{"p":[-28,28,-521],"s":[3,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-28,26,-521],"s":[3,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-30,26,-521],"s":[1,3,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-28,24,-521],"s":[5,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-29,23,-521],"s":[2,1,2],"l":1,"r":[0,0,-0.87],"c":"#000de8","e":"#004aff","t":5},{"p":[-28,23,-521],"s":[2,1,2],"l":1,"r":[0,0,0.87],"c":"#000de8","e":"#004aff","t":5},{"p":[-28,18,-521],"s":[8,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-28,20,-521],"s":[1,3,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-28,20,-521],"s":[6,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-32,36,-521],"s":[1,1,2],"l":1,"r":[0,0,-0.17],"c":"#ff0000","e":"#ff0000","t":5},{"p":[92,25,318],"s":[36,136,3],"l":1,"c":"#200028","t":5},{"p":[100,132,315],"s":[3,20,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[84,132,315],"s":[3,20,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[92,141,315],"s":[17,3,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[92,125,315],"s":[17,3,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[100,108,315],"s":[3,20,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[83,108,315],"s":[3,20,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[92,108,315],"s":[17,3,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[92,101,315],"s":[21,3,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[92,83,315],"s":[3,18,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[91,77,315],"s":[19,3,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[100,60,315],"s":[3,20,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[91,60,315],"s":[19,3,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[91,69,315],"s":[19,3,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[100,36,315],"s":[3,20,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[91,36,315],"s":[21,3,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[77,56,322],"s":[22,5,4],"l":1,"c":"#3e3e3e","t":5},{"p":[77,118,322],"s":[22,5,4],"l":1,"c":"#3e3e3e","t":5},{"p":[-448,48,-706],"s":[128,42,5],"l":1,"c":"#1b1b1b","t":5},{"p":[-404,63,-704],"s":[20,2,4],"l":1,"r":[0,0,-0.87],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-394,64,-703],"s":[20,2,3],"l":1,"r":[0,0,-2.27],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-400,72,-703],"s":[23,2,3],"l":1,"r":[0,0,3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-400,80,-703],"s":[2,11,3],"l":1,"r":[0,0,3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-428,58,-704],"s":[7,2,5],"l":1,"r":[0,0,3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-423,60,-704],"s":[8,2,5],"l":1,"r":[0,0,-1.57],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-428,64,-704],"s":[10,2,6],"l":1,"r":[0,0,3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-426,80,-703],"s":[2,18,3],"l":1,"r":[0,0,-2.79],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-427,78,-703],"s":[20,2,3],"l":1,"r":[0,0,-2.79],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-429,72,-703],"s":[20,2,3],"l":1,"r":[0,0,-2.79],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-456,81,-703],"s":[2,20,3],"l":1,"r":[0,0,2.8],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-454,78,-703],"s":[15,2,2],"l":1,"r":[0,0,-3.05],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-462,73,-704],"s":[2,15,5],"l":1,"r":[0,0,-3.13],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-459,59,-702],"s":[7,2,1],"l":1,"r":[0,0,-3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-456,62,-703],"s":[2,5,3],"l":1,"r":[0,0,-3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-462,62,-703],"s":[12,2,3],"l":1,"r":[0,0,2.97],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-468,79,-703],"s":[9,2,3],"l":1,"r":[0,0,2.79],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-484,78,-703],"s":[2,20,3],"l":1,"r":[0,0,2.97],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-481,65,-703],"s":[2,6,3],"l":1,"r":[0,0,-2.44],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-480,76,-703],"s":[2,6,3],"l":1,"r":[0,0,2.97],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-486,74,-703],"s":[2,6,3],"l":1,"r":[0,0,2.45],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-493,79,-703],"s":[2,11,4],"l":1,"r":[0,0,-3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-497,79,-703],"s":[2,11,4],"l":1,"r":[0,0,-3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-501,74,-703],"s":[2,6,4],"l":1,"r":[0,0,-3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-495,75,-703],"s":[12,2,4],"l":1,"r":[0,0,-3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-495,70,-703],"s":[12,2,4],"l":1,"r":[0,0,-3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-489,74,-703],"s":[2,6,4],"l":1,"r":[0,0,-3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-495,80,-703],"s":[14,2,4],"l":1,"r":[0,0,-3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-495,59,-703],"s":[2,8,3],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-495,60,-703],"s":[14,2,3],"l":1,"r":[0,0,-3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-495,64,-703],"s":[9,2,3],"l":1,"r":[0,0,-3.14],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-480,46,-709],"s":[9,8,17],"l":1,"r":[-1.05,0,0],"c":"#929292","t":5},{"p":[-425,45,-709],"s":[9,8,16],"l":1,"r":[-1.05,0,0],"c":"#929292","t":5},{"p":[-448,46,-706],"s":[131,2,9],"l":1,"c":"#000000","e":"#ff0000","t":5},{"p":[-448,90,-706],"s":[131,2,9],"l":1,"c":"#000000","e":"#ff0000","t":5},{"p":[-513,46,-706],"s":[2,46,9],"l":1,"c":"#000000","e":"#ff0000","t":5},{"p":[-384,46,-706],"s":[3,46,9],"l":1,"c":"#000000","e":"#ff0000","t":5},{"p":[55,44,-833],"s":[17,3,4],"l":1,"r":[0,0,-0.52],"c":"#f000ff","e":"#f000ff","t":5},{"p":[46,41,-833],"s":[3,9,4],"l":1,"r":[0,0,-0.52],"c":"#f000ff","e":"#f000ff","t":5},{"p":[55,50,-833],"s":[3,1,4],"l":1,"r":[0,0,-0.52],"c":"#f000ff","e":"#f000ff","t":5},{"p":[56,52,-833],"s":[3,1,4],"l":1,"r":[0,0,-0.52],"c":"#f000ff","e":"#f000ff","t":5},{"p":[78,44,-833],"s":[17,3,4],"l":1,"c":"#f000ff","e":"#f000ff","t":5},{"p":[98,48,-833],"s":[17,3,4],"l":1,"c":"#f000ff","e":"#f000ff","t":5},{"p":[98,40,-833],"s":[17,3,4],"l":1,"c":"#f000ff","e":"#f000ff","t":5},{"p":[105,39,-833],"s":[3,12,4],"l":1,"c":"#f000ff","e":"#f000ff","t":5},{"p":[121,44,-833],"s":[17,3,4],"l":1,"r":[0,0,0.52],"c":"#f000ff","e":"#f000ff","t":5},{"p":[118,49,-833],"s":[3,1,4],"l":1,"r":[0,0,-0.52],"c":"#f000ff","e":"#f000ff","t":5},{"p":[86,31,-836],"s":[107,30,4],"l":1,"c":"#0012ff","t":5},{"p":[48,24,-842],"s":[5,40,5],"l":1,"c":"#575757","t":5},{"p":[125,24,-842],"s":[5,40,5],"l":1,"c":"#575757","t":5},{"p":[-310,59,-252],"s":[9,1,1],"c":"#372d2d","t":5,"bo":1},{"p":[-310,76,-252],"s":[9,1,1],"c":"#372d2d","t":5,"bo":1},{"p":[-305,57,-252],"s":[1,22,2],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-298,58,-252],"s":[13,20,1],"c":"#021606","e":"#010903","t":5},{"p":[-291,57,-252],"s":[1,22,2],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-298,57,-252],"s":[14,1,2],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-298,78,-252],"s":[14,1,2],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-295,75,-252],"s":[5,1,2],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-296,73,-252],"s":[5,1,2],"l":1,"r":[0,0,0.7],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-295,68,-252],"s":[5,1,2],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-293,59,-252],"s":[1,6,2],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-296,61,-252],"s":[1,3,2],"l":1,"r":[0,0,1.22],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-296,63,-252],"s":[1,2,2],"l":1,"r":[0,0,0.87],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-297,64,-252],"s":[1,2,2],"l":1,"r":[0,0,0.7],"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-299,60,-252],"s":[1,4,2],"l":1,"r":[0,0,-0.17],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-302,60,-252],"s":[1,4,2],"l":1,"r":[0,0,-0.17],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-300,60,-252],"s":[2,1,2],"l":1,"r":[0,0,-0.17],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-301,63,-252],"s":[2,1,2],"l":1,"r":[0,0,-0.17],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-301,61,-252],"s":[1,2,2],"l":1,"r":[0,0,-0.17],"c":"#004aff","e":"#7800ff","t":5},{"p":[-301,64,-252],"s":[4,1,2],"l":1,"r":[0,0,-0.17],"c":"#fffe00","e":"#fff000","t":5},{"p":[-301,65,-252],"s":[1,4,2],"l":1,"r":[0,0,0.18],"c":"#002dff","e":"#0000ff","t":5},{"p":[-302,65,-252],"s":[1,3,2],"l":1,"r":[0,0,-0.52],"c":"#002dff","e":"#0000ff","t":5},{"p":[-301,71,-252],"s":[3,1,2],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-301,74,-252],"s":[3,1,2],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-300,71,-252],"s":[1,3,2],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-303,71,-252],"s":[1,4,2],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-302,75,-252],"s":[3,1,2],"l":1,"c":"#ff8700","e":"#553200","t":5},{"p":[-300,75,-252],"s":[1,1,2],"l":1,"c":"#ff8700","e":"#553200","t":5},{"p":[-301,72,-252],"s":[1,2,2],"l":1,"c":"#053e0f","e":"#0c1e05","t":5},{"p":[-302,72,-252],"s":[1,2,2],"l":1,"c":"#053e0f","e":"#0c1e05","t":5},{"p":[-296,54,-252],"s":[1,3,1],"l":1,"c":"#372d2d","t":5},{"p":[-300,54,-252],"s":[1,3,1],"l":1,"c":"#372d2d","t":5},{"p":[-298,54,-252],"s":[8,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-298,46,-252],"s":[4,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-302,42,-252],"s":[1,13,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-294,42,-252],"s":[1,13,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-298,43,-252],"s":[7,11,1],"c":"#000337","t":5},{"p":[-295,46,-252],"s":[1,7,2],"l":1,"r":[0,0,-0.17],"c":"#000de8","e":"#004aff","t":5},{"p":[-298,52,-252],"s":[3,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-298,50,-252],"s":[3,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-300,50,-252],"s":[1,3,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-298,48,-252],"s":[5,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-299,47,-252],"s":[2,1,2],"l":1,"r":[0,0,-0.87],"c":"#000de8","e":"#004aff","t":5},{"p":[-298,47,-252],"s":[2,1,2],"l":1,"r":[0,0,0.87],"c":"#000de8","e":"#004aff","t":5},{"p":[-298,42,-252],"s":[8,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-298,44,-252],"s":[1,3,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-298,44,-252],"s":[6,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-302,60,-252],"s":[1,1,2],"l":1,"r":[0,0,-0.17],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-573,39,-78],"s":[4,50,112],"l":1,"c":"#000337","t":5},{"p":[-576,33,-32],"s":[4,58,4],"l":1,"c":"#434343","t":5},{"p":[-576,33,-122],"s":[4,58,4],"l":1,"c":"#434343","t":5},{"p":[-571,88,-78],"s":[2,2,112],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-571,38,-78],"s":[2,2,112],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-571,38,-135],"s":[2,52,2],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-571,38,-21],"s":[2,52,2],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-1206,106,376],"s":[105,498,103],"l":1,"c":"#b6b6b6","t":5},{"p":[-1206,600,376],"s":[5,92,6],"l":1,"c":"#b6b6b6","t":5},{"p":[-308,166,223],"s":[3,4,3],"l":1,"c":"#000000","e":"#ff0000","t":5},{"p":[-63,206,304],"s":[3,4,3],"l":1,"c":"#000000","e":"#ff0000","t":5},{"p":[263,152,144],"s":[3,4,3],"l":1,"c":"#000000","e":"#ff0000","t":5},{"p":[-176,64,-407],"s":[1,2,10],"c":"#1f1f1f","t":5,"bo":1},{"p":[-176,49,-389],"s":[3,1,21],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-176,63,-385],"s":[3,1,3],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-176,49,-378],"s":[3,15,1],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-176,49,-400],"s":[3,15,1],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-176,51,-380],"s":[3,11,1],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-176,58,-382],"s":[3,15,1],"l":1,"r":[-0.17,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-176,58,-386],"s":[3,15,1],"l":1,"r":[-0.35,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-176,63,-380],"s":[3,1,4],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-176,63,-395],"s":[3,1,11],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-176,51,-384],"s":[3,1,5],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,55,-384],"s":[3,1,5],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,52,-382],"s":[3,3,1],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,52,-386],"s":[3,3,1],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,53,-384],"s":[3,1,1],"l":1,"c":"#02d625","e":"#02d625","t":5},{"p":[-176,52,-392],"s":[3,3,1],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,51,-390],"s":[3,1,5],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,51,-396],"s":[3,1,5],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,52,-398],"s":[3,3,1],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,55,-396],"s":[3,1,5],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,52,-394],"s":[3,3,1],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,52,-388],"s":[3,3,1],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,55,-390],"s":[3,1,5],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-176,53,-390],"s":[3,1,1],"l":1,"c":"#d60202","e":"#d60202","t":5},{"p":[-176,53,-396],"s":[3,1,1],"l":1,"c":"#ff8708","e":"#ff2d00","t":5},{"p":[-176,66,-397],"s":[3,1,5],"l":1,"c":"#ff8b78","e":"#ff5134","t":5},{"p":[-176,67,-399],"s":[3,3,1],"l":1,"c":"#ff8b78","e":"#ff5134","t":5},{"p":[-176,70,-398],"s":[3,1,3],"l":1,"c":"#ff8b78","e":"#ff5134","t":5},{"p":[-176,68,-396],"s":[3,3,1],"l":1,"c":"#ff8b78","e":"#ff5134","t":5},{"p":[-176,68,-397],"s":[3,1,1],"l":1,"c":"#ff8b78","e":"#ff5134","t":5},{"p":[-176,44,-376],"s":[3,30,1],"c":"#181717","t":5,"bo":1},{"p":[-176,44,-402],"s":[3,30,1],"c":"#181717","t":5,"bo":1},{"p":[-176,74,-389],"s":[3,1,27],"c":"#181717","t":5,"bo":1},{"p":[-176,43,-389],"s":[3,1,27],"c":"#181717","t":5,"bo":1},{"p":[-176,48,-407],"s":[1,2,10],"c":"#1f1f1f","t":5,"bo":1},{"p":[-176,44,-389],"s":[1,30,25],"l":1,"c":"#2a867f","t":5,"bo":1},{"p":[-176,57,-388],"s":[3,5,1],"l":1,"r":[-0.35,0,0],"c":"#ff9200","e":"#ff2d00","t":5},{"p":[-176,57,-391],"s":[3,5,1],"l":1,"r":[-0.35,0,0],"c":"#ff9200","e":"#ff2d00","t":5},{"p":[-176,57,-394],"s":[3,5,1],"l":1,"r":[-0.35,0,0],"c":"#ff9200","e":"#ff2d00","t":5},{"p":[-176,57,-397],"s":[3,5,1],"l":1,"r":[-0.35,0,0],"c":"#ff9200","e":"#ff2d00","t":5},{"p":[75,25,315],"s":[2,137,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[110,25,315],"s":[2,137,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[92,160,315],"s":[35,2,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[92,25,315],"s":[35,2,3],"l":1,"c":"#d200ff","e":"#d200ff","t":5},{"p":[135,61,-356],"s":[4,50,112],"l":1,"c":"#000337","t":5},{"p":[133,110,-356],"s":[2,2,112],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[133,60,-356],"s":[2,2,112],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[133,60,-412],"s":[2,52,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[133,60,-300],"s":[2,52,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[138,55,-310],"s":[4,58,4],"l":1,"c":"#434343","t":5},{"p":[138,55,-400],"s":[4,58,4],"l":1,"c":"#434343","t":5},{"p":[-830,60,119],"s":[191,2,121],"l":1,"c":"#707070","t":5},{"p":[87,23,-895],"s":[161,2,144],"l":1,"c":"#5a5a5a","t":5},{"p":[-223,47,-589],"s":[4,2,1],"c":"#372d2d","t":5,"bo":1},{"p":[-223,60,-589],"s":[4,2,1],"c":"#372d2d","t":5},{"p":[-225,43,-589],"s":[1,23,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-233,43,-589],"s":[1,23,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-229,43,-589],"s":[7,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-229,65,-589],"s":[7,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-229,44,-589],"s":[7,22,1],"c":"#120216","e":"#010903","t":5},{"p":[-229,62,-589],"s":[5,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-228,61,-589],"s":[1,3,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-230,61,-589],"s":[1,3,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-229,54,-589],"s":[1,6,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-230,59,-589],"s":[3,1,2],"l":1,"r":[0,0,0.7],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-228,59,-589],"s":[3,1,2],"l":1,"r":[0,0,-0.7],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-229,56,-589],"s":[5,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-227,55,-589],"s":[3,1,2],"l":1,"r":[0,0,-0.7],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-231,55,-589],"s":[3,1,2],"l":1,"r":[0,0,0.52],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-231,48,-589],"s":[1,4,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-229,48,-589],"s":[1,5,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-229,51,-589],"s":[5,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-228,49,-589],"s":[3,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-228,47,-589],"s":[3,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-227,46,-589],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-230,46,-589],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-229,45,-589],"s":[3,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-232,46,-589],"s":[1,3,2],"l":1,"r":[0,0,-0.35],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-227,45,-589],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-230,47,-589],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-360,18,-711],"s":[4,16,4],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-360,24,-711],"s":[16,4,4],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-360,17,-711],"s":[7,18,1],"l":1,"c":"#252a26","t":5},{"p":[-360,23,-711],"s":[18,6,1],"l":1,"c":"#252a26","t":5},{"p":[-373,25,-711],"s":[8,2,1],"l":1,"c":"#555555","t":5},{"p":[-592,362,-1418],"s":[112,103,88],"l":1,"c":"#7d7d7d","t":5},{"p":[-592,467,-1418],"s":[6,103,5],"l":1,"c":"#7d7d7d","t":5},{"p":[-592,570,-1418],"s":[6,6,5],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-252,-21,-604],"s":[66,2,5],"c":"#787878","t":5},{"p":[-283,-19,-642],"s":[2,30,2],"c":"#323232","t":5},{"p":[-220,-19,-642],"s":[2,30,2],"c":"#323232","t":5},{"p":[-159,-19,-642],"s":[2,30,2],"c":"#323232","t":5},{"p":[-163,-19,-642],"s":[239,29,1],"pe":1,"t":12},{"p":[-283,-19,-623],"s":[1,29,37],"pe":1,"t":12},{"p":[-283,-19,-604],"s":[2,30,2],"c":"#323232","t":5},{"p":[-411,-7,96],"s":[2,27,11],"l":1,"c":"#001100","t":5},{"p":[-411,-4,96],"s":[3,1,7],"l":1,"c":"#0eff00","e":"#0eff00","t":5},{"p":[-411,-4,99],"s":[3,8,1],"l":1,"c":"#0eff00","e":"#0eff00","t":5},{"p":[-411,3,97],"s":[3,1,7],"l":1,"r":[0.17,0,0],"c":"#0eff00","e":"#0eff00","t":5},{"p":[-411,15,97],"s":[3,1,7],"l":1,"r":[0.35,0,0],"c":"#0eff00","e":"#0eff00","t":5},{"p":[-411,12,98],"s":[3,1,6],"l":1,"r":[1.58,0,0],"c":"#0eff00","e":"#0eff00","t":5},{"p":[-411,-3,106],"s":[1,2,10],"c":"#555555","t":5},{"p":[-411,13,106],"s":[1,2,10],"c":"#555555","t":5},{"p":[-411,12,93],"s":[3,1,6],"l":1,"r":[1.58,0,0],"c":"#0eff00","e":"#0eff00","t":5},{"p":[-411,-8,90],"s":[3,29,1],"l":1,"c":"#0eff00","e":"#0eff00","t":5},{"p":[-411,-8,102],"s":[3,29,1],"l":1,"c":"#0eff00","e":"#0eff00","t":5},{"p":[-411,20,96],"s":[3,1,11],"l":1,"c":"#0eff00","e":"#0eff00","t":5},{"p":[-411,-8,96],"s":[3,1,11],"l":1,"c":"#0eff00","e":"#0eff00","t":5},{"p":[-414,29,160],"s":[3,42,99],"l":1,"c":"#5f5f5f","t":5},{"p":[-416,26,120],"s":[3,47,3],"l":1,"c":"#696969","t":5},{"p":[-496,210,789],"s":[5,204,3],"l":1,"c":"#b6b6b6","t":5},{"p":[-416,26,197],"s":[3,47,3],"l":1,"c":"#696969","t":5},{"p":[248,-7,-43],"s":[3,48,113],"l":1,"c":"#434343","t":5},{"p":[250,-10,-3],"s":[3,50,5],"l":1,"c":"#696969","t":5},{"p":[250,-10,-80],"s":[3,50,5],"l":1,"c":"#696969","t":5},{"p":[189,53,-359],"s":[126,2,137],"l":1,"r":[-3.14,0,3.14],"c":"#4d4d4d","t":5},{"p":[-706,129,-504],"s":[152,4,150],"l":1,"c":"#919191","t":5},{"p":[-586,-24,-560],"s":[3,47,111],"l":1,"c":"#484848","t":5},{"p":[-588,-28,-518],"s":[3,53,4],"l":1,"c":"#696969","t":5},{"p":[-588,-28,-601],"s":[3,53,4],"l":1,"c":"#696969","t":5},{"p":[-384,57,-265],"s":[125,54,2],"c":"#464646","t":5,"bo":1},{"p":[-384,55,-266],"s":[128,2,4],"l":1,"c":"#525252","t":5},{"p":[276,129,-739],"s":[151,3,148],"l":1,"c":"#898989","t":5},{"p":[202,58,-739],"s":[3,56,128],"l":1,"c":"#434343","t":5},{"p":[201,55,-739],"s":[5,3,132],"l":1,"c":"#575656","t":5},{"p":[-43,-19,-642],"s":[2,30,2],"c":"#323232","t":5},{"p":[-99,-19,-642],"s":[2,30,2],"c":"#323232","t":5},{"p":[176,-5,-498],"s":[3,164,35],"l":1,"c":"#181717","t":5},{"p":[176,35,-476],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[176,125,-476],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[176,-5,-515],"s":[4,164,3],"l":1,"c":"#0eff00","e":"#0eff00","t":5},{"p":[176,-5,-481],"s":[4,164,3],"l":1,"c":"#0eff00","e":"#0eff00","t":5},{"p":[176,-6,-498],"s":[4,3,37],"l":1,"c":"#0eff00","e":"#0eff00","t":5},{"p":[176,159,-498],"s":[4,3,37],"l":1,"c":"#0eff00","e":"#0eff00","t":5},{"p":[-223,34,-523],"s":[3,53,109],"c":"#4d4d4d","t":5,"bo":1},{"p":[-224,34,-523],"s":[5,3,114],"l":1,"c":"#575757","t":5},{"p":[135,38,-279],"s":[4,16,4],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[135,37,-279],"s":[1,18,6],"l":1,"c":"#252a26","t":5},{"p":[135,43,-279],"s":[1,6,17],"l":1,"c":"#252a26","t":5},{"p":[135,45,-290],"s":[1,2,5],"l":1,"c":"#252a26","t":5},{"p":[127,-9,-358],"s":[3,56,125],"c":"#5a5a5a","t":5,"bo":1},{"p":[125,-12,-359],"s":[5,3,128],"l":1,"c":"#575656","t":5},{"p":[-192,45,-300],"s":[114,52,2],"c":"#6e6e6e","t":5,"bo":1},{"p":[-192,43,-301],"s":[118,2,4],"l":1,"c":"#525252","t":5},{"p":[-341,90,230],"s":[40,19,22],"l":1,"c":"#989898","t":5},{"p":[-95,48,-162],"s":[108,46,2],"c":"#393939","t":5,"bo":1},{"p":[-95,47,-161],"s":[112,2,4],"l":1,"c":"#525252","t":5},{"p":[-1385,-905,265],"s":[145,1295,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-211,-708,-126],"s":[34,670,8],"c":"#b6b6b6","t":5},{"p":[-225,-38,-126],"s":[6,177,8],"c":"#b6b6b6","t":5,"bo":1},{"p":[-211,129,-126],"s":[22,7,8],"c":"#b6b6b6","t":5},{"p":[-211,30,-126],"s":[22,7,8],"c":"#b6b6b6","t":5},{"p":[-211,65,-126],"s":[22,7,8],"c":"#b6b6b6","t":5,"bo":1},{"p":[-211,99,-126],"s":[22,7,8],"c":"#b6b6b6","t":5,"bo":1},{"p":[-211,-38,-127],"s":[22,169,7],"c":"#282828","t":5},{"p":[-211,-5,-126],"s":[22,7,8],"c":"#b6b6b6","t":5},{"p":[-197,-38,-126],"s":[6,175,8],"c":"#b6b6b6","t":5,"bo":1},{"p":[-308,45,-190],"s":[3,43,88],"c":"#464646","t":5,"bo":1},{"p":[-307,44,-190],"s":[6,2,91],"l":1,"c":"#525252","t":5},{"p":[-43,-19,-624],"s":[1,29,36],"pe":1,"t":12},{"p":[-43,-19,-606],"s":[2,30,2],"c":"#323232","t":5},{"p":[78,-708,-626],"s":[139,703,142],"c":"#7f7f7f","t":5},{"p":[-700,76,-818],"s":[149,3,146],"l":1,"c":"#787272","t":5},{"p":[-633,183,-887],"s":[153,3,151],"l":1,"c":"#8c8c8c","t":5},{"p":[-1275,282,-1165],"s":[4,169,4],"l":1,"c":"#b6b6b6","t":5},{"p":[-255,-19,-594],"s":[4,1,32],"c":"#917d66","t":5},{"p":[-251,-19,-594],"s":[4,1,33],"c":"#847462","t":5},{"p":[-247,-19,-594],"s":[4,1,32],"c":"#968169","t":5},{"p":[-141,35,-605],"s":[108,47,2],"c":"#4d4d4d","t":5,"bo":1},{"p":[-141,33,-606],"s":[112,2,4],"l":1,"c":"#525252","t":5},{"p":[-131,25,-409],"s":[79,38,2],"c":"#4d4d4d","t":5,"bo":1},{"p":[-131,25,-408],"s":[82,2,4],"l":1,"c":"#434343","t":5},{"p":[-151,-708,-533],"s":[142,805,142],"c":"#b6b6b6","t":5,"bo":1},{"p":[-62,20,-533],"s":[39,78,142],"c":"#b6b6b6","t":5,"bo":1},{"p":[-47,-21,-466],"s":[9,41,8],"c":"#b6b6b6","t":5,"bo":1},{"p":[-47,-21,-600],"s":[9,41,8],"c":"#b6b6b6","t":5,"bo":1},{"p":[-47,-21,-535],"s":[9,41,8],"c":"#b6b6b6","t":5,"bo":1},{"p":[-59,-19,-367],"s":[4,1,58],"c":"#a79177","t":5},{"p":[-447,-24,-704],"s":[123,53,2],"l":1,"c":"#505050","t":5},{"p":[-447,-26,-703],"s":[127,2,4],"l":1,"c":"#525252","t":5},{"p":[-405,-28,-987],"s":[162,4,143],"l":1,"c":"#7d7d7d","t":5},{"p":[-373,-9,-711],"s":[8,3,2],"l":1,"c":"#555555","t":5},{"p":[-359,-53,-711],"s":[19,61,2],"l":1,"c":"#555555","t":5},{"p":[-373,-35,-711],"s":[8,3,2],"l":1,"c":"#555555","t":5},{"p":[-349,-53,-711],"s":[2,61,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-369,-53,-711],"s":[2,61,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-359,7,-711],"s":[22,2,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-359,-55,-711],"s":[22,2,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[282,98,-148],"s":[3,55,120],"l":1,"c":"#3e3e3e","t":5},{"p":[282,98,-148],"s":[7,2,124],"l":1,"c":"#525252","t":5},{"p":[-633,56,-505],"s":[3,60,128],"c":"#3c3c3c","t":5},{"p":[-633,53,-505],"s":[7,3,131],"l":1,"c":"#393939","t":5},{"p":[-707,129,-54],"s":[150,4,149],"l":1,"c":"#616161","t":5},{"p":[-646,-1,41],"s":[3,122,33],"l":1,"c":"#181717","t":5},{"p":[-646,97,20],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[-646,25,20],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[-646,-1,57],"s":[4,122,3],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-646,-1,25],"s":[4,122,3],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-646,-2,41],"s":[4,3,35],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-646,121,41],"s":[4,3,35],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-1,87,295],"s":[121,57,3],"l":1,"c":"#393939","t":5},{"p":[-1,86,294],"s":[126,2,6],"l":1,"c":"#555555","t":5},{"p":[248,-80,96],"s":[3,112,31],"l":1,"c":"#000337","t":5},{"p":[230,101,-329],"s":[113,55,3],"l":1,"c":"#3c3c3c","t":5},{"p":[230,100,-329],"s":[119,2,8],"l":1,"c":"#5c5c5c","t":5},{"p":[248,-81,96],"s":[4,3,31],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[248,30,96],"s":[4,3,31],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[248,-81,80],"s":[4,114,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[248,-81,111],"s":[4,114,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[248,6,116],"s":[3,5,10],"l":1,"c":"#181717","t":5},{"p":[248,-61,116],"s":[3,5,10],"l":1,"c":"#181717","t":5},{"p":[135,44,-279],"s":[4,4,15],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[261,-53,-139],"s":[2,27,11],"c":"#001100","t":5},{"p":[261,-50,-139],"s":[3,1,7],"c":"#0eff00","e":"#0eff00","t":5},{"p":[261,-50,-136],"s":[3,8,1],"c":"#0eff00","e":"#0eff00","t":5},{"p":[261,-43,-138],"s":[3,1,7],"r":[0.17,0,0],"c":"#0eff00","e":"#0eff00","t":5},{"p":[261,-31,-138],"s":[3,1,7],"r":[0.35,0,0],"c":"#0eff00","e":"#0eff00","t":5},{"p":[261,-34,-137],"s":[3,1,6],"r":[1.58,0,0],"c":"#0eff00","e":"#0eff00","t":5},{"p":[261,-49,-129],"s":[1,2,10],"l":1,"c":"#555555","t":5},{"p":[261,-33,-129],"s":[1,2,10],"l":1,"c":"#555555","t":5},{"p":[261,-34,-142],"s":[3,1,6],"r":[1.58,0,0],"c":"#0eff00","e":"#0eff00","t":5},{"p":[261,-54,-145],"s":[3,29,1],"c":"#0eff00","e":"#0eff00","t":5},{"p":[261,-54,-133],"s":[3,29,1],"c":"#0eff00","e":"#0eff00","t":5},{"p":[261,-26,-139],"s":[3,1,11],"c":"#0eff00","e":"#0eff00","t":5},{"p":[261,-54,-139],"s":[3,1,11],"c":"#0eff00","e":"#0eff00","t":5},{"p":[211,132,-672],"s":[2,64,2],"l":1,"c":"#ffffff","t":5},{"p":[211,195,-672],"s":[3,4,3],"l":1,"c":"#000000","e":"#ff0000","t":5},{"p":[-74,-2,229],"s":[22,6,21],"l":1,"c":"#666666","t":5},{"p":[-74,4,229],"s":[23,14,22],"l":1,"c":"#acacac","t":5},{"p":[-74,18,229],"s":[25,1,24],"l":1,"c":"#666666","t":5},{"p":[237,-53,-643],"s":[3,164,35],"l":1,"c":"#181717","t":5},{"p":[237,78,-665],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[237,-18,-665],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[237,-53,-625],"s":[4,164,3],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[237,-53,-661],"s":[4,164,3],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[237,111,-643],"s":[4,3,39],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[237,-56,-643],"s":[4,3,39],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[-633,111,-815],"s":[131,59,2],"l":1,"c":"#413f3f","t":5},{"p":[-633,109,-815],"s":[134,2,6],"l":1,"c":"#555555","t":5},{"p":[-354,32,213],"s":[104,50,3],"l":1,"c":"#252525","t":5},{"p":[-354,32,213],"s":[106,3,8],"l":1,"c":"#4b4b4b","t":5},{"p":[212,55,-298],"s":[2,23,2],"l":1,"c":"#373737","t":5},{"p":[192,-20,-278],"s":[41,1,19],"l":1,"c":"#646464","t":5},{"p":[212,77,-288],"s":[3,3,27],"l":1,"c":"#373737","t":5},{"p":[212,-19,-278],"s":[1,96,1],"l":1,"c":"#505050","t":5},{"p":[172,-19,-278],"s":[1,97,1],"l":1,"c":"#505050","t":5},{"p":[172,77,-288],"s":[3,3,27],"l":1,"c":"#373737","t":5},{"p":[172,55,-298],"s":[2,23,2],"l":1,"c":"#373737","t":5},{"p":[192,-20,-268],"s":[43,2,1],"l":1,"c":"#e84d4d","t":5},{"p":[192,-20,-288],"s":[43,2,1],"l":1,"c":"#e84d4d","t":5},{"p":[171,-20,-278],"s":[1,2,19],"l":1,"c":"#e84d4d","t":5},{"p":[213,-20,-278],"s":[1,2,19],"l":1,"c":"#e84d4d","t":5},{"p":[-19,77,-161],"s":[1,2,10],"c":"#1f1f1f","t":5},{"p":[-19,67,-139],"s":[3,2,6],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-19,74,-139],"s":[2,16,1],"l":1,"r":[-0.96,0,0],"c":"#ffffff","e":"#ffffff","t":5},{"p":[-19,73,-143],"s":[2,11,1],"l":1,"r":[-1.31,0,0],"c":"#ffffff","e":"#ffffff","t":5},{"p":[-19,62,-143],"s":[4,5,15],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-19,56,-130],"s":[3,30,1],"l":1,"c":"#181717","t":5},{"p":[-19,56,-156],"s":[3,30,1],"l":1,"c":"#181717","t":5},{"p":[-19,86,-143],"s":[3,1,27],"l":1,"c":"#181717","t":5},{"p":[-19,55,-143],"s":[3,1,27],"l":1,"c":"#181717","t":5},{"p":[-19,60,-161],"s":[1,2,10],"c":"#1f1f1f","t":5,"bo":1},{"p":[-19,56,-143],"s":[1,30,25],"c":"#2a8586","t":5},{"p":[-19,67,-145],"s":[4,1,9],"l":1,"c":"#ff7800","e":"#ff7800","t":5},{"p":[-19,60,-143],"s":[3,2,9],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-19,67,-146],"s":[2,2,3],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-19,67,-143],"s":[2,2,2],"l":1,"c":"#68ff00","e":"#68ff00","t":5},{"p":[-19,69,-142],"s":[3,6,3],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-19,68,-142],"s":[4,9,1],"l":1,"c":"#ff9600","e":"#ff9600","t":5},{"p":[-19,78,-137],"s":[3,6,2],"l":1,"r":[0.7,0,0],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-19,79,-141],"s":[3,4,2],"l":1,"r":[0.09,0,0],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-19,75,-135],"s":[3,3,2],"l":1,"r":[1.14,0,0],"c":"#ff0000","e":"#ff0000","t":5},{"p":[171,-18,-268],"s":[1,11,1],"l":1,"c":"#e84d4d","t":5},{"p":[213,-18,-268],"s":[1,11,1],"l":1,"c":"#e84d4d","t":5},{"p":[213,-18,-288],"s":[1,11,1],"l":1,"c":"#e84d4d","t":5},{"p":[171,-18,-288],"s":[1,11,1],"l":1,"c":"#e84d4d","t":5},{"p":[192,-18,-268],"s":[1,11,1],"l":1,"c":"#e84d4d","t":5},{"p":[192,-18,-288],"s":[1,11,1],"l":1,"c":"#e84d4d","t":5},{"p":[192,-7,-268],"s":[44,1,2],"l":1,"c":"#e84d4d","t":5},{"p":[192,-7,-288],"s":[44,1,2],"l":1,"c":"#e84d4d","t":5},{"p":[171,-18,-278],"s":[1,11,1],"l":1,"c":"#e84d4d","t":5},{"p":[213,-18,-278],"s":[1,11,1],"l":1,"c":"#e84d4d","t":5},{"p":[213,-7,-278],"s":[2,1,18],"l":1,"c":"#e84d4d","t":5},{"p":[171,-7,-278],"s":[2,1,18],"l":1,"c":"#e84d4d","t":5},{"p":[-579,-77,-252],"s":[3,100,35],"l":1,"c":"#181717","t":5},{"p":[-579,-11,-230],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[-579,-47,-230],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[-579,-78,-270],"s":[4,102,3],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-579,-78,-235],"s":[4,103,3],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-579,22,-253],"s":[4,3,37],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-579,-78,-253],"s":[4,3,37],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[282,89,158],"s":[27,14,22],"l":1,"c":"#acacac","t":5},{"p":[-1,116,293],"s":[118,0,53],"i":11,"l":1,"r":[1.57,0,-3.14],"bb":4,"sad":1},{"p":[-154,33,219],"s":[110,0,49],"i":11,"l":1,"r":[1.57,0,-3.14],"bb":1},{"p":[-354,58,211],"s":[103,0,47],"i":11,"l":1,"r":[1.57,0,-3.14],"bb":3,"sad":1},{"p":[-412,50,160],"s":[96,0,40],"i":11,"l":1,"r":[1.57,0,1.57],"bb":2},{"p":[-95,72,-160],"s":[104,0,42],"i":11,"l":1,"r":[1.57,0,0],"bb":1,"sad":1},{"p":[-306,67,-190],"s":[86,0,41],"i":11,"l":1,"r":[1.57,0,1.57],"bb":4},{"p":[246,17,-43],"s":[110,0,46],"i":11,"l":1,"r":[1.57,0,-1.57],"bb":2,"sad":1},{"p":[280,126,-147],"s":[117,0,50],"i":11,"l":1,"r":[1.57,0,-1.57],"bb":3},{"p":[230,129,-327],"s":[108,0,50],"i":11,"l":1,"r":[1.57,0,0],"bb":1},{"p":[125,19,-358],"s":[120,0,53],"i":11,"l":1,"r":[1.57,0,-1.57],"bb":4,"sad":1},{"p":[200,85,-739],"s":[126,0,56],"i":11,"l":1,"r":[1.57,0,-1.57],"bb":2},{"p":[-193,71,-302],"s":[110,0,49],"i":11,"l":1,"r":[1.57,0,-3.14],"bb":2,"sad":1},{"p":[-131,45,-407],"s":[76,0,34],"i":11,"l":1,"r":[1.57,0,0],"bb":3},{"p":[-384,84,-267],"s":[120,0,50],"i":11,"l":1,"r":[1.57,0,-3.14],"bb":4},{"p":[-584,0,-560],"s":[109,0,45],"i":11,"l":1,"r":[1.57,0,1.57],"bb":3},{"p":[-631,86,-505],"s":[128,0,61],"i":11,"l":1,"r":[1.57,0,1.57],"bb":4,"sad":1},{"p":[-447,2,-702],"s":[120,0,50],"i":11,"l":1,"r":[1.57,0,0],"bb":2},{"p":[-633,140,-813],"s":[127,0,55],"i":11,"l":1,"r":[1.57,0,0],"bb":1},{"p":[-225,62,-523],"s":[108,0,49],"i":11,"l":1,"r":[1.57,0,-1.57],"bb":4,"sad":1},{"p":[-141,59,-607],"s":[107,0,47],"i":11,"l":1,"r":[1.57,0,-3.14],"bb":4,"sad":1},{"p":[-183,48,-416],"s":[5,1,1],"c":"#372d2d","t":5,"bo":1},{"p":[-188,58,-416],"s":[8,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-188,50,-416],"s":[4,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-192,46,-416],"s":[1,13,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-184,46,-416],"s":[1,13,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-188,47,-416],"s":[7,11,1],"c":"#000337","t":5},{"p":[-185,50,-416],"s":[1,7,2],"l":1,"r":[0,0,-0.17],"c":"#000de8","e":"#004aff","t":5},{"p":[-188,56,-416],"s":[3,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-188,54,-416],"s":[3,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-190,54,-416],"s":[1,3,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-188,52,-416],"s":[5,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-189,51,-416],"s":[2,1,2],"l":1,"r":[0,0,-0.87],"c":"#000de8","e":"#004aff","t":5},{"p":[-188,51,-416],"s":[2,1,2],"l":1,"r":[0,0,0.87],"c":"#000de8","e":"#004aff","t":5},{"p":[-188,46,-416],"s":[8,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-188,48,-416],"s":[1,3,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-188,48,-416],"s":[6,1,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[-183,55,-416],"s":[5,1,1],"c":"#372d2d","t":5,"bo":1},{"p":[-853,297,-279],"s":[148,4,146],"l":1,"c":"#707070","t":5},{"p":[-674,-66,-721],"s":[3,142,35],"l":1,"c":"#000000","t":5},{"p":[-674,42,-743],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[-674,-54,-743],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[-674,-68,-703],"s":[4,144,3],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-674,-68,-739],"s":[4,146,3],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-674,75,-721],"s":[4,3,39],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[-674,-68,-721],"s":[4,3,39],"l":1,"c":"#00ff2d","e":"#00ff2d","t":5},{"p":[8,-4,-834],"s":[8,3,2],"l":1,"c":"#555555","t":5},{"p":[-7,-48,-834],"s":[19,61,2],"l":1,"c":"#555555","t":5},{"p":[7,-30,-834],"s":[8,3,2],"l":1,"c":"#555555","t":5},{"p":[3,-48,-834],"s":[2,61,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-17,-48,-834],"s":[2,61,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-7,12,-834],"s":[22,2,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-7,-50,-834],"s":[22,2,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[16,44,-860],"s":[4,3,17],"l":1,"r":[-0.52,0,-1.57],"c":"#f000ff","e":"#f000ff","t":5},{"p":[18,46,-854],"s":[4,9,3],"l":1,"r":[-0.52,0,-3.14],"c":"#f000ff","e":"#f000ff","t":5},{"p":[19,50,-859],"s":[4,1,3],"l":1,"r":[-0.52,-0.05,0.08],"c":"#f000ff","e":"#f000ff","t":5},{"p":[17,44,-879],"s":[4,3,17],"l":1,"c":"#f000ff","e":"#f000ff","t":5},{"p":[17,48,-903],"s":[4,3,17],"l":1,"c":"#f000ff","e":"#f000ff","t":5},{"p":[17,40,-903],"s":[4,3,17],"l":1,"c":"#f000ff","e":"#f000ff","t":5},{"p":[17,39,-910],"s":[4,12,3],"l":1,"c":"#f000ff","e":"#f000ff","t":5},{"p":[17,44,-926],"s":[4,3,17],"l":1,"r":[-0.44,0,-1.57],"c":"#f000ff","e":"#f000ff","t":5},{"p":[19,51,-925],"s":[4,1,3],"l":1,"r":[0,0,-3.14],"c":"#f000ff","e":"#f000ff","t":5},{"p":[20,31,-891],"s":[4,30,107],"l":1,"c":"#0012ff","t":5},{"p":[26,24,-853],"s":[5,40,5],"l":1,"c":"#575757","t":5},{"p":[26,24,-930],"s":[5,40,5],"l":1,"c":"#575757","t":5},{"p":[19,53,-860],"s":[4,1,3],"l":1,"r":[-0.52,-0.05,0.08],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-1275,451,-1165],"s":[6,8,6],"l":1,"c":"#fc0000","e":"#ff0000","t":5},{"p":[-496,413,789],"s":[6,6,5],"l":1,"c":"#056100","e":"#056100","t":5},{"p":[-449,-905,1613],"s":[209,1548,142],"l":1,"c":"#b6b6b6","t":5},{"p":[1746,-905,2165],"s":[209,1714,142],"l":1,"c":"#b6b6b6","t":5},{"p":[-1329,-905,1432],"s":[209,1351,142],"l":1,"c":"#b6b6b6","t":5},{"p":[193,25,-289],"s":[104,0,42],"i":11,"l":1,"r":[1.57,0,0],"bb":2},{"p":[192,2,-291],"s":[106,45,3],"c":"#3c3c3c","t":5,"bo":1},{"p":[484,57,-475],"s":[217,4,220],"l":1,"c":"#a0a0a0","t":5},{"p":[-455,47,111],"s":[17,3,4],"l":1,"r":[-3.14,0,-2.62],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-446,44,111],"s":[3,9,4],"l":1,"r":[-3.14,0,-2.62],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-451,51,111],"s":[3,1,4],"l":1,"r":[-3.14,0,-2.62],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-450,54,111],"s":[3,1,4],"l":1,"r":[-3.14,0,-2.62],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-475,47,111],"s":[17,3,4],"l":1,"r":[3.14,0,3.14],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-498,51,111],"s":[17,3,4],"l":1,"r":[3.14,0,3.14],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-498,43,111],"s":[17,3,4],"l":1,"r":[3.14,0,3.14],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-505,42,111],"s":[3,12,4],"l":1,"r":[3.14,0,3.14],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-521,47,111],"s":[17,3,4],"l":1,"r":[3.14,0,2.62],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-521,55,111],"s":[3,1,4],"l":1,"r":[-3.14,0,-2.19],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-486,34,114],"s":[107,30,4],"l":1,"r":[3.14,0,3.14],"c":"#0012ff","t":5},{"p":[-448,27,120],"s":[5,40,5],"l":1,"r":[3.14,0,3.14],"c":"#575757","t":5},{"p":[-525,27,120],"s":[5,40,5],"l":1,"r":[3.14,0,3.14],"c":"#575757","t":5},{"p":[237,-25,190],"s":[3,54,121],"l":1,"c":"#434343","t":5},{"p":[235,2,191],"s":[115,0,50],"i":11,"l":1,"r":[1.57,0,-1.57],"bb":1,"sad":1},{"p":[-591,52,-216],"s":[17,3,6],"l":1,"r":[-3.14,0,-2.62],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-583,47,-216],"s":[3,12,6],"l":1,"r":[-3.14,0,-2.62],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-588,57,-216],"s":[3,1,6],"l":1,"r":[-3.14,0,-2.62],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-587,60,-216],"s":[3,1,6],"l":1,"r":[-3.14,0,-2.62],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-613,52,-216],"s":[17,3,6],"l":1,"r":[-3.14,0,-3.14],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-637,56,-216],"s":[17,3,6],"l":1,"r":[-3.14,0,-3.14],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-636,48,-216],"s":[17,3,6],"l":1,"r":[-3.14,0,-3.14],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-643,47,-216],"s":[3,12,6],"l":1,"r":[-3.14,0,-3.14],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-660,51,-216],"s":[17,3,6],"l":1,"r":[3.14,0,2.62],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-659,58,-216],"s":[3,1,6],"l":1,"r":[-3.14,0,-2.62],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-622,39,-216],"s":[107,30,4],"l":1,"r":[-3.14,0,-3.14],"c":"#0012ff","t":5},{"p":[-584,32,-216],"s":[5,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#575757","t":5},{"p":[-660,32,-216],"s":[5,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#575757","t":5},{"p":[-264,63,-293],"s":[4,1,1],"c":"#372d2d","t":5,"bo":1},{"p":[-264,78,-293],"s":[4,1,1],"c":"#372d2d","t":5,"bo":1},{"p":[-274,60,-293],"s":[1,23,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-266,60,-293],"s":[1,23,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-270,60,-293],"s":[7,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-270,82,-293],"s":[7,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-270,61,-293],"s":[7,21,1],"c":"#120216","e":"#010903","t":5},{"p":[-270,79,-293],"s":[5,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-271,78,-293],"s":[1,3,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-269,78,-293],"s":[1,3,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-270,71,-293],"s":[1,6,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-269,76,-293],"s":[3,1,2],"l":1,"r":[0,0,0.7],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-271,76,-293],"s":[3,1,2],"l":1,"r":[0,0,-0.7],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-270,73,-293],"s":[5,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-272,72,-293],"s":[3,1,2],"l":1,"r":[0,0,-0.7],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-268,72,-293],"s":[3,1,2],"l":1,"r":[0,0,0.52],"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-268,65,-293],"s":[1,4,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-270,65,-293],"s":[1,5,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-270,68,-293],"s":[5,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-271,66,-293],"s":[3,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-271,64,-293],"s":[3,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-272,63,-293],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-269,63,-293],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-270,62,-293],"s":[3,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-272,62,-293],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[-269,64,-293],"s":[1,1,2],"l":1,"c":"#ff00e0","e":"#d200ff","t":5},{"p":[37,21,-44],"s":[3,1,3],"c":"#666666","t":5},{"p":[37,22,-44],"s":[4,2,4],"c":"#666666","t":5},{"p":[-496,289,789],"s":[122,48,100],"l":1,"c":"#b6b6b6","t":5},{"p":[242,55,160],"s":[17,3,4],"l":1,"r":[-0.43,-1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[242,54,153],"s":[3,9,4],"l":1,"r":[-0.43,-1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[242,60,159],"s":[3,1,4],"l":1,"r":[-0.43,-1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[242,57,182],"s":[13,3,4],"l":1,"r":[0,-1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[242,61,205],"s":[17,3,4],"l":1,"r":[0,-1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[242,53,205],"s":[17,3,4],"l":1,"r":[0,-1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[242,52,212],"s":[3,12,4],"l":1,"r":[0,-1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[242,55,231],"s":[17,3,4],"l":1,"r":[-0.61,-1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[242,62,227],"s":[3,2,4],"l":1,"r":[1.57,-1.48,1.57],"c":"#f000ff","e":"#f000ff","t":5},{"p":[245,44,193],"s":[107,30,4],"l":1,"r":[0,-1.57,0],"c":"#0012ff","t":5},{"p":[251,37,155],"s":[5,40,5],"l":1,"r":[0,-1.57,0],"c":"#575757","t":5},{"p":[251,37,232],"s":[5,40,5],"l":1,"r":[0,-1.57,0],"c":"#575757","t":5},{"p":[242,62,157],"s":[3,1,4],"l":1,"r":[-0.43,-1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[78,-5,-626],"s":[143,3,146],"c":"#4d4d4d","t":5,"bo":1},{"p":[-32,-708,-1854],"s":[158,1320,139],"l":1,"c":"#7d7d7d","t":5},{"p":[154,78,-877],"s":[129,55,2],"l":1,"c":"#323232","t":5},{"p":[154,105,-875],"s":[130,0,53],"i":11,"l":1,"r":[1.57,0,0],"bb":4},{"p":[-125,-23,-163],"s":[110,48,4],"c":"#000337","t":5},{"p":[-125,24,-163],"s":[112,2,5],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-125,-25,-163],"s":[112,2,5],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-181,-25,-163],"s":[2,51,5],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-70,-25,-163],"s":[2,51,5],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[290,171,-207],"s":[4,39,9],"l":1,"c":"#ff003b","e":"#ff003b","t":5},{"p":[290,171,-191],"s":[4,39,9],"l":1,"c":"#ff003b","e":"#ff003b","t":5},{"p":[290,180,-177],"s":[4,21,10],"l":1,"c":"#ff003b","e":"#ff003b","t":5},{"p":[290,201,-143],"s":[4,9,24],"l":1,"c":"#ff003b","e":"#ff003b","t":5},{"p":[290,171,-88],"s":[4,9,24],"l":1,"c":"#ff003b","e":"#ff003b","t":5},{"p":[290,186,-116],"s":[4,9,24],"l":1,"c":"#ff003b","t":5,"ab":1},{"p":[290,187,-199],"s":[4,8,7],"l":1,"c":"#ff003b","e":"#ff003b","t":5},{"p":[290,171,-170],"s":[4,9,24],"l":1,"c":"#ff003b","e":"#ff003b","t":5},{"p":[290,201,-170],"s":[4,9,24],"l":1,"c":"#ff003b","e":"#ff003b","t":5},{"p":[290,180,-163],"s":[4,21,10],"l":1,"c":"#ff003b","e":"#ff003b","t":5},{"p":[290,171,-143],"s":[4,30,9],"l":1,"c":"#ff003b","e":"#ff003b","t":5},{"p":[290,171,-96],"s":[4,39,8],"l":1,"c":"#ff003b","e":"#ff003b","t":5},{"p":[290,171,-116],"s":[4,9,24],"l":1,"c":"#ff003b","t":5,"ab":1},{"p":[290,201,-116],"s":[4,9,24],"l":1,"c":"#ff003b","t":5,"ab":1},{"p":[290,179,-124],"s":[4,22,8],"l":1,"c":"#ff003b","t":5,"ab":1},{"p":[282,53,-148],"s":[3,33,123],"l":1,"c":"#282828","t":5},{"p":[282,6,-148],"s":[3,33,123],"l":1,"c":"#282828","t":5},{"p":[-1,41,296],"s":[114,36,2],"l":1,"c":"#282828","t":5},{"p":[282,-40,-148],"s":[3,33,123],"l":1,"c":"#282828","t":5},{"p":[282,-87,-148],"s":[3,33,123],"l":1,"c":"#282828","t":5},{"p":[282,-133,-148],"s":[3,33,123],"l":1,"c":"#282828","t":5},{"p":[282,-177,-148],"s":[3,33,123],"l":1,"c":"#282828","t":5},{"p":[282,-223,-148],"s":[3,33,123],"l":1,"c":"#282828","t":5},{"p":[282,-269,-148],"s":[3,33,123],"l":1,"c":"#282828","t":5},{"p":[-353,-14,214],"s":[89,36,2],"l":1,"c":"#282828","t":5},{"p":[-1,-4,296],"s":[114,36,2],"l":1,"c":"#282828","t":5},{"p":[-1,-50,296],"s":[114,36,2],"l":1,"c":"#282828","t":5},{"p":[-1,-97,296],"s":[114,36,2],"l":1,"c":"#282828","t":5},{"p":[-1,-145,296],"s":[114,36,2],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-1,-193,296],"s":[114,36,2],"l":1,"c":"#282828","t":5},{"p":[-353,-60,214],"s":[89,36,2],"l":1,"c":"#282828","t":5},{"p":[-353,-108,214],"s":[89,36,2],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-353,-157,214],"s":[89,36,2],"l":1,"c":"#282828","t":5},{"p":[-353,-206,214],"s":[89,36,2],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-353,-258,214],"s":[89,36,2],"l":1,"c":"#282828","t":5},{"p":[-446,-254,106],"s":[56,268,1],"l":1,"c":"#b6b6b6","t":3},{"p":[-408,-83,160],"s":[3,45,91],"l":1,"c":"#5f5f5f","t":5},{"p":[-406,-61,160],"s":[90,0,45],"i":11,"l":1,"r":[1.57,0,1.57],"bb":4},{"p":[-1,-241,296],"s":[114,36,2],"l":1,"c":"#282828","t":5},{"p":[-1,-289,296],"s":[114,36,2],"l":1,"c":"#282828","t":5},{"p":[-567,-24,-120],"s":[3,43,183],"l":1,"c":"#282828","t":5},{"p":[-567,-80,-120],"s":[3,43,183],"l":1,"c":"#282828","t":5},{"p":[-567,-137,-120],"s":[3,43,183],"l":1,"c":"#282828","t":5},{"p":[238,-68,192],"s":[3,33,119],"l":1,"c":"#282828","t":5},{"p":[238,-111,192],"s":[3,33,119],"l":1,"c":"#282828","t":5},{"p":[238,-154,192],"s":[3,33,119],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[238,-197,192],"s":[3,33,119],"l":1,"c":"#282828","t":5},{"p":[238,-240,192],"s":[3,33,119],"l":1,"c":"#282828","t":5},{"p":[238,-282,192],"s":[3,33,119],"l":1,"c":"#282828","t":5},{"p":[238,-324,192],"s":[3,33,119],"l":1,"c":"#282828","t":5},{"p":[238,-276,-54],"s":[3,59,119],"l":1,"c":"#b6b6b6","t":3},{"p":[282,-312,-148],"s":[3,33,123],"l":1,"c":"#282828","t":5},{"p":[-649,108,-565],"s":[2,76,2],"l":1,"c":"#aaaaaa","t":5},{"p":[-649,184,-565],"s":[3,4,3],"l":1,"c":"#000000","e":"#ff0000","t":5},{"p":[-780,-719,-280],"s":[3,989,116],"l":1,"c":"#b6b6b6","t":3},{"p":[-263,5,-227],"s":[3,43,88],"c":"#464646","t":5},{"p":[-264,5,-227],"s":[6,2,91],"l":1,"c":"#464646","t":5},{"p":[-265,28,-227],"s":[86,0,40],"i":11,"l":1,"r":[1.57,0,-1.57],"bb":2,"sad":1},{"p":[-633,8,-504],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-578,-120,-557],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-578,-166,-557],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-578,-212,-557],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-578,-258,-557],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-578,-305,-557],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[190,-45,-292],"s":[104,36,2],"l":1,"c":"#282828","t":5},{"p":[190,-90,-292],"s":[104,36,2],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[190,-135,-292],"s":[104,36,2],"l":1,"c":"#282828","t":5},{"p":[190,-181,-292],"s":[104,36,2],"l":1,"c":"#282828","t":5},{"p":[190,-228,-292],"s":[104,36,2],"l":1,"c":"#282828","t":5},{"p":[190,-275,-292],"s":[104,36,2],"l":1,"c":"#282828","t":5},{"p":[190,-321,-292],"s":[104,36,2],"l":1,"c":"#282828","t":5},{"p":[190,-367,-292],"s":[104,36,2],"l":1,"c":"#282828","t":5},{"p":[-448,-71,-705],"s":[122,36,2],"l":1,"c":"#282828","t":5},{"p":[-448,-116,-705],"s":[122,36,2],"l":1,"c":"#282828","t":5},{"p":[-448,-162,-705],"s":[122,36,2],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-448,-209,-705],"s":[122,36,2],"l":1,"c":"#282828","t":5},{"p":[-448,-256,-705],"s":[122,36,2],"l":1,"c":"#282828","t":5},{"p":[-448,-304,-705],"s":[122,36,2],"l":1,"c":"#282828","t":5},{"p":[-448,-351,-705],"s":[122,36,2],"l":1,"c":"#282828","t":5},{"p":[-110,31,-972],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[-110,-26,-972],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[-110,-84,-972],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[-110,-141,-972],"s":[137,46,2],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-110,-198,-972],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[-110,-256,-972],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[-110,-314,-972],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[-110,-373,-972],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[-110,-430,-972],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[-110,-486,-972],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[203,0,-738],"s":[3,46,121],"l":1,"c":"#282828","t":5},{"p":[203,-56,-738],"s":[3,46,121],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[203,-114,-738],"s":[3,46,121],"l":1,"c":"#282828","t":5},{"p":[203,-174,-738],"s":[3,46,121],"l":1,"c":"#282828","t":5},{"p":[203,-234,-738],"s":[3,46,121],"l":1,"c":"#282828","t":5},{"p":[156,142,-877],"s":[122,42,3],"l":1,"c":"#282828","t":5},{"p":[156,192,-877],"s":[122,42,3],"l":1,"c":"#282828","t":5},{"p":[156,243,-877],"s":[122,42,3],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[613,221,217],"s":[7,118,4],"l":1,"c":"#aaaaaa","t":5},{"p":[-215,-88,-985],"s":[3,164,35],"l":1,"r":[0,1.57,0],"c":"#181717","t":5},{"p":[-193,-48,-985],"s":[3,6,9],"l":1,"r":[0,1.57,0],"c":"#343434","t":5},{"p":[-193,42,-985],"s":[3,6,9],"l":1,"r":[0,1.57,0],"c":"#343434","t":5},{"p":[-232,-88,-985],"s":[4,164,3],"l":1,"r":[0,1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-198,-88,-985],"s":[4,164,3],"l":1,"r":[0,1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-215,-89,-985],"s":[4,3,37],"l":1,"r":[0,1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-215,76,-985],"s":[4,3,37],"l":1,"r":[0,1.57,0],"c":"#f000ff","e":"#f000ff","t":5},{"p":[-170,88,-986],"s":[4,39,9],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-154,88,-986],"s":[4,39,9],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-106,118,-986],"s":[4,9,24],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-51,88,-986],"s":[4,9,24],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-79,103,-986],"s":[4,9,24],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-162,104,-986],"s":[4,8,7],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-133,88,-986],"s":[4,9,24],"l":1,"r":[0,1.57,0],"c":"#fffb00","t":5,"ab":1},{"p":[-133,118,-986],"s":[4,9,24],"l":1,"r":[0,1.57,0],"c":"#fffb00","t":5,"ab":1},{"p":[-126,97,-986],"s":[4,21,10],"l":1,"r":[0,1.57,0],"c":"#fffb00","t":5,"ab":1},{"p":[-106,88,-986],"s":[4,30,9],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-59,88,-986],"s":[4,39,8],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-79,88,-986],"s":[4,9,24],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-79,118,-986],"s":[4,9,24],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-87,96,-986],"s":[4,22,8],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-140,97,-986],"s":[4,21,10],"l":1,"r":[0,1.57,0],"c":"#fffb00","t":5,"ab":1},{"p":[86,-31,-825],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[86,-86,-825],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[86,-142,-825],"s":[137,46,2],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[86,-199,-825],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[86,-257,-825],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[127,-69,-359],"s":[3,47,117],"l":1,"c":"#282828","t":5},{"p":[127,-126,-359],"s":[3,47,117],"l":1,"c":"#282828","t":5},{"p":[127,-184,-359],"s":[3,47,117],"l":1,"c":"#282828","t":5},{"p":[127,-245,-359],"s":[3,47,117],"l":1,"c":"#282828","t":5},{"p":[127,-305,-359],"s":[3,47,117],"l":1,"c":"#282828","t":5},{"p":[62,74,-1031],"s":[2,64,2],"l":1,"c":"#ffffff","t":5},{"p":[-578,-74,-557],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-633,-41,-504],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-633,-88,-504],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-633,-136,-504],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-633,-186,-504],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-633,-234,-504],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-633,-283,-504],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[-633,-332,-504],"s":[3,37,121],"l":1,"c":"#282828","t":5},{"p":[432,-644,-454],"s":[59,688,173],"l":1,"c":"#f2f2f2","t":3},{"p":[479,37,22],"s":[3,41,121],"l":1,"c":"#282828","t":5},{"p":[479,-12,22],"s":[3,41,121],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[479,-62,22],"s":[3,41,121],"l":1,"c":"#282828","t":5},{"p":[479,-113,22],"s":[3,41,121],"l":1,"c":"#282828","t":5},{"p":[426,-278,74],"s":[3,59,121],"l":1,"c":"#b6b6b6","t":3},{"p":[-376,-8,-778],"s":[4,37,121],"l":1,"c":"#282828","t":5},{"p":[-376,-56,-778],"s":[4,37,121],"l":1,"c":"#282828","t":5},{"p":[-376,-103,-778],"s":[4,37,121],"l":1,"c":"#282828","t":5},{"p":[-376,-151,-778],"s":[4,37,121],"l":1,"c":"#282828","t":5},{"p":[-376,-199,-778],"s":[4,37,121],"l":1,"c":"#282828","t":5},{"p":[-376,-247,-778],"s":[4,37,121],"l":1,"c":"#282828","t":5},{"p":[-376,-294,-778],"s":[4,37,121],"l":1,"c":"#282828","t":5},{"p":[-571,64,-44],"s":[2,3,23],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-571,58,-38],"s":[2,3,17],"l":1,"r":[-0.87,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[-571,73,-45],"s":[2,2,7],"l":1,"r":[0.87,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[-571,63,-110],"s":[2,3,23],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-571,72,-109],"s":[2,2,8],"l":1,"r":[-0.35,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[-571,59,-76],"s":[2,3,20],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-571,68,-76],"s":[2,3,20],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-571,63,-86],"s":[2,3,21],"l":1,"r":[1.57,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[-571,55,-110],"s":[2,2,8],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-645,109,50],"s":[2,19,3],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,93,44],"s":[2,19,3],"l":1,"r":[-0.7,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,115,46],"s":[2,12,2],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,75,43],"s":[2,3,17],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,53,50],"s":[2,19,3],"l":1,"r":[-1.4,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,49,48],"s":[2,3,17],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,42,48],"s":[2,17,3],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,20,49],"s":[2,17,3],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,27,45],"s":[2,10,3],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,20,49],"s":[2,17,3],"l":1,"r":[-2.27,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-795,25,373],"s":[3,67,124],"l":1,"c":"#282828","t":5},{"p":[246,10,96],"s":[2,3,18],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[246,-2,96],"s":[2,3,18],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[246,-18,97],"s":[2,3,18],"l":1,"r":[-0.17,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[246,-8,100],"s":[2,3,20],"l":1,"r":[1.57,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[246,18,96],"s":[2,2,8],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[246,-39,96],"s":[2,3,18],"l":1,"r":[-0.52,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[246,-30,95],"s":[2,2,8],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[246,-40,101],"s":[2,3,14],"l":1,"r":[1.57,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[246,-58,96],"s":[2,3,18],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[246,-69,101],"s":[2,7,3],"l":1,"r":[0.17,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[-646,12,-599],"s":[3,112,31],"l":1,"c":"#000337","t":5},{"p":[-646,11,-599],"s":[4,3,31],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-646,122,-599],"s":[4,3,31],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-646,11,-615],"s":[4,114,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-646,11,-584],"s":[4,114,3],"l":1,"c":"#00b3ff","e":"#00b3ff","t":5},{"p":[-646,98,-579],"s":[3,5,10],"l":1,"c":"#181717","t":5},{"p":[-646,31,-579],"s":[3,5,10],"l":1,"c":"#181717","t":5},{"p":[-644,102,-599],"s":[2,3,18],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-644,90,-599],"s":[2,3,18],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-644,74,-598],"s":[2,3,18],"l":1,"r":[-0.17,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[-644,84,-595],"s":[2,3,20],"l":1,"r":[1.57,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[-644,110,-599],"s":[2,2,8],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-644,53,-599],"s":[2,3,18],"l":1,"r":[-0.52,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[-644,62,-600],"s":[2,2,8],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-644,52,-594],"s":[2,3,14],"l":1,"r":[1.57,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[-644,34,-599],"s":[2,3,18],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-644,23,-594],"s":[2,7,3],"l":1,"r":[0.17,0,0],"c":"#ff0086","e":"#ff0086","t":5},{"p":[-646,-7,-410],"s":[3,122,33],"l":1,"c":"#181717","t":5},{"p":[-646,91,-431],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[-646,19,-431],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[-646,-7,-394],"s":[4,122,3],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-646,-7,-426],"s":[4,122,3],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-646,-8,-410],"s":[4,3,35],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-646,115,-410],"s":[4,3,35],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-645,103,-401],"s":[2,19,3],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,87,-407],"s":[2,19,3],"l":1,"r":[-0.7,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,109,-405],"s":[2,12,2],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,69,-408],"s":[2,3,17],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,47,-401],"s":[2,19,3],"l":1,"r":[-1.4,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,43,-403],"s":[2,3,17],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,36,-403],"s":[2,17,3],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,14,-402],"s":[2,17,3],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,21,-406],"s":[2,10,3],"l":1,"r":[-1.57,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-645,14,-402],"s":[2,17,3],"l":1,"r":[-2.27,0,0],"c":"#00ff69","e":"#00ff69","t":5},{"p":[-617,-817,-349],"s":[5000,1,5000],"l":1,"c":"#3e4984","t":5},{"p":[-674,41,-728],"s":[4,18,2],"l":1,"c":"#feff00","e":"#feff00","t":5},{"p":[-674,41,-714],"s":[4,18,2],"l":1,"c":"#feff00","e":"#feff00","t":5},{"p":[-674,41,-721],"s":[4,2,16],"l":1,"c":"#feff00","e":"#feff00","t":5},{"p":[-674,46,-723],"s":[4,11,1],"l":1,"c":"#feff00","e":"#feff00","t":5},{"p":[-674,46,-719],"s":[4,11,1],"l":1,"c":"#feff00","e":"#feff00","t":5},{"p":[-674,56,-715],"s":[5,3,5],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-674,59,-721],"s":[5,3,17],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-674,62,-721],"s":[5,3,13],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-674,46,-733],"s":[4,10,2],"l":1,"c":"#feff00","e":"#feff00","t":5},{"p":[-674,46,-730],"s":[4,2,4],"l":1,"c":"#feff00","e":"#feff00","t":5},{"p":[-674,54,-730],"s":[4,2,4],"l":1,"c":"#feff00","e":"#feff00","t":5},{"p":[-674,19,-714],"s":[4,3,21],"l":1,"r":[1.57,0,0],"c":"#feff00","e":"#feff00","t":5},{"p":[-674,11,-722],"s":[4,3,16],"l":1,"r":[3.14,0,0],"c":"#feff00","e":"#feff00","t":5},{"p":[-674,21,-718],"s":[4,3,9],"l":1,"r":[-2.97,0,0],"c":"#feff00","e":"#feff00","t":5},{"p":[-674,25,-727],"s":[4,2,4],"l":1,"r":[2.09,0,0],"c":"#feff00","e":"#feff00","t":5},{"p":[-674,27,-730],"s":[4,2,4],"l":1,"r":[2.09,0,0],"c":"#feff00","e":"#feff00","t":5},{"p":[-674,-8,-721],"s":[4,4,21],"l":1,"r":[3.14,0,0],"c":"#feff00","e":"#feff00","t":5},{"p":[-674,-38,-716],"s":[4,3,21],"l":1,"r":[1.4,0,0],"c":"#feff00","e":"#feff00","t":5},{"p":[-674,-38,-725],"s":[4,3,22],"l":1,"r":[1.57,0,0],"c":"#feff00","e":"#feff00","t":5},{"p":[-674,-44,-728],"s":[4,3,11],"l":1,"r":[-2.79,0,0],"c":"#feff00","e":"#feff00","t":5},{"p":[-359,-1,-711],"s":[6,1,3],"l":1,"c":"#fff000","e":"#fff000","t":5},{"p":[-360,-6,-711],"s":[10,2,3],"l":1,"r":[0,0,0.35],"c":"#fff000","e":"#fff000","t":5},{"p":[-354,-6,-711],"s":[7,2,3],"l":1,"r":[0,0,1.92],"c":"#fff000","e":"#fff000","t":5},{"p":[-358,-20,-711],"s":[12,2,3],"l":1,"r":[0,0,1.57],"c":"#fff000","e":"#fff000","t":5},{"p":[-361,-39,-711],"s":[12,2,3],"l":1,"r":[0,0,1.57],"c":"#fff000","e":"#fff000","t":5},{"p":[-355,-45,-711],"s":[2,8,3],"l":1,"r":[0,0,1.4],"c":"#fff000","e":"#fff000","t":5},{"p":[216,-2,258],"s":[24,4,4],"l":1,"r":[0,0,-0.01],"c":"#ffffff","e":"#ffffff","t":5},{"p":[219,4,258],"s":[4,20,4],"l":1,"r":[0,0,-0.35],"c":"#ffe100","e":"#ffe100","t":5},{"p":[215,4,258],"s":[4,16,4],"l":1,"r":[0,0,-0.19],"c":"#ffe100","e":"#ffe100","t":5},{"p":[215,-5,258],"s":[37,31,2],"l":1,"c":"#e31a1a","e":"#e31a1a","t":5},{"p":[235,-5,258],"s":[3,31,4],"l":1,"c":"#4d4d4d","t":5},{"p":[197,-5,258],"s":[3,31,4],"l":1,"c":"#4d4d4d","t":5},{"p":[216,-8,258],"s":[41,3,4],"l":1,"c":"#4d4d4d","t":5},{"p":[216,26,258],"s":[41,3,4],"l":1,"c":"#4d4d4d","t":5},{"p":[238,18,258],"s":[3,4,4],"l":1,"c":"#4d4d4d","t":5},{"p":[238,1,258],"s":[3,4,4],"l":1,"c":"#4d4d4d","t":5},{"p":[-399,-613,-917],"s":[123,570,2],"l":1,"c":"#b6b6b6","t":3},{"p":[-204,59,-984],"s":[4,21,5],"l":1,"r":[-1.57,0,1.57],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-208,47,-984],"s":[4,3,9],"l":1,"r":[-1.57,0.7,1.57],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-214,12,-984],"s":[4,21,5],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-214,-6,-984],"s":[4,5,17],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-220,-40,-984],"s":[4,23,4],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-225,-23,-984],"s":[4,21,4],"l":1,"r":[1.57,0,-1.57],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-216,-30,-984],"s":[4,9,4],"l":1,"r":[1.57,0,-1.57],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-214,-49,-984],"s":[4,5,22],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-214,-74,-984],"s":[4,13,5],"l":1,"r":[0,1.57,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-579,9,-253],"s":[4,4,22],"l":1,"c":"#ffe100","e":"#ffe100","t":5},{"p":[-577,2,-257],"s":[4,3,8],"l":1,"r":[0.87,0,0],"c":"#ffe100","e":"#ffe100","t":5},{"p":[-579,-27,-253],"s":[4,17,5],"l":1,"c":"#ffe100","e":"#ffe100","t":5},{"p":[-579,-63,-253],"s":[4,4,20],"l":1,"r":[-0.35,0,0],"c":"#ffe100","e":"#ffe100","t":5},{"p":[-579,-54,-258],"s":[4,3,8],"l":1,"r":[0.52,0,0],"c":"#ffe100","e":"#ffe100","t":5},{"p":[-579,-41,-253],"s":[4,4,22],"l":1,"c":"#ffe100","e":"#ffe100","t":5},{"p":[-7,4,-832],"s":[11,3,2],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-7,-1,-832],"s":[5,2,2],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-4,-21,-832],"s":[2,12,2],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-6,-19,-832],"s":[9,2,2],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-6,-13,-832],"s":[13,3,2],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-7,-31,-832],"s":[13,3,2],"l":1,"c":"#ff0086","e":"#ff0086","t":5},{"p":[-5,-37,-832],"s":[5,2,2],"l":1,"r":[0,0,0.7],"c":"#ff0086","e":"#ff0086","t":5},{"p":[-698,-113,-746],"s":[118,0,55],"i":11,"l":1,"r":[1.57,0,0],"bb":1},{"p":[-699,-753,-747],"s":[118,600,2],"l":1,"c":"#b6b6b6","t":3},{"p":[-829,-708,-1511],"s":[111,970,102],"l":1,"c":"#7d7d7d","t":5},{"p":[-380,-708,-1581],"s":[111,982,102],"l":1,"c":"#7d7d7d","t":5},{"p":[-1491,-708,-1083],"s":[111,1125,102],"l":1,"c":"#7d7d7d","t":5},{"p":[919,-708,-604],"s":[171,933,138],"l":1,"c":"#7d7d7d","t":5},{"p":[-1239,-708,-57],"s":[158,1062,139],"l":1,"c":"#7d7d7d","t":5},{"p":[2,-19,-159],"s":[4,1,23],"c":"#9d8161","t":5},{"p":[-2,-19,-159],"s":[4,1,21],"c":"#8e7252","t":5},{"p":[6,-19,-159],"s":[4,1,20],"c":"#93795b","t":5},{"p":[295,51,-240],"s":[3,100,35],"l":1,"c":"#181717","t":5},{"p":[295,117,-218],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[295,81,-218],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[295,50,-258],"s":[4,102,3],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[295,50,-223],"s":[4,103,3],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[295,150,-241],"s":[4,3,37],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[295,50,-241],"s":[4,3,37],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[295,137,-241],"s":[4,4,22],"l":1,"c":"#ffe100","e":"#ffe100","t":5},{"p":[297,130,-245],"s":[4,3,8],"l":1,"r":[0.87,0,0],"c":"#ffe100","e":"#ffe100","t":5},{"p":[295,106,-241],"s":[4,17,5],"l":1,"c":"#ffe100","e":"#ffe100","t":5},{"p":[295,65,-241],"s":[4,4,20],"l":1,"r":[-0.35,0,0],"c":"#ffe100","e":"#ffe100","t":5},{"p":[295,74,-246],"s":[4,3,8],"l":1,"r":[0.52,0,0],"c":"#ffe100","e":"#ffe100","t":5},{"p":[295,89,-241],"s":[4,4,22],"l":1,"c":"#ffe100","e":"#ffe100","t":5},{"p":[237,70,-638],"s":[4,20,5],"l":1,"r":[-0.79,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[237,89,-643],"s":[4,5,23],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[237,31,-648],"s":[4,25,5],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[237,44,-636],"s":[4,5,9],"l":1,"r":[-0.17,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[237,4,-653],"s":[4,22,5],"l":1,"r":[0.96,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[237,0,-639],"s":[4,5,11],"l":1,"r":[0.96,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[237,-28,-643],"s":[4,5,23],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[175,129,-505],"s":[4,3,24],"l":1,"r":[1.74,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[175,117,-498],"s":[4,3,19],"l":1,"r":[-0.01,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[175,117,-490],"s":[4,9,3],"l":1,"r":[-0.01,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[175,99,-498],"s":[4,3,21],"l":1,"r":[-0.01,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[175,89,-500],"s":[4,3,12],"l":1,"r":[0.51,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[175,55,-497],"s":[4,12,3],"l":1,"r":[-0.01,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[175,71,-498],"s":[4,3,19],"l":1,"r":[-0.01,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[175,21,-489],"s":[4,16,3],"l":1,"r":[-0.01,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[175,21,-505],"s":[4,16,3],"l":1,"r":[-0.01,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[175,21,-497],"s":[4,3,19],"l":1,"r":[-0.01,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[175,34,-497],"s":[4,3,19],"l":1,"r":[-0.01,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[175,30,-497],"s":[4,12,3],"l":1,"r":[-0.01,0,0],"c":"#ff004a","e":"#ff004a","t":5},{"p":[-103,-21,-607],"s":[4,7,4],"i":16},{"p":[-49,-21,-542],"s":[4,7,4],"i":16},{"p":[216,2,258],"s":[29,10,5],"l":1,"r":[0,0,-0.01],"c":"#ffffff","e":"#ffffff","t":5},{"p":[-24,21,33],"s":[3,1,3],"c":"#666666","t":5},{"p":[-24,22,33],"s":[5,3,5],"c":"#666666","t":5},{"p":[-41,4,3],"s":[9,14,19],"c":"#919191","t":5},{"p":[-41,18,3],"s":[10,1,20],"c":"#616161","t":5},{"p":[-41,0,3],"s":[8,4,18],"c":"#696969","t":5},{"p":[62,2,-42],"s":[2,30,2],"c":"#323232","t":5},{"p":[64,-21,86],"s":[2,24,4],"i":3,"c":"#e84d4d","t":5},{"p":[60,-1182,-17],"s":[48,1161,235],"c":"#cfcfcf","t":5},{"p":[74,-21,102],"s":[26,2,4],"c":"#787878","t":5},{"p":[85,-21,-16],"s":[4,2,232],"c":"#787878","t":5},{"p":[39,-21,-143],"s":[4,2,14],"c":"#787878","t":5},{"p":[62,-21,-134],"s":[50,2,4],"c":"#787878","t":5},{"p":[65,-21,-98],"s":[4,7,4],"i":16},{"p":[96,-43,-18],"s":[19,1,50],"c":"#646464","t":5},{"p":[106,-43,-18],"s":[1,2,50],"c":"#e84d4d","t":5},{"p":[86,-43,-18],"s":[1,2,50],"c":"#e84d4d","t":5},{"p":[96,-43,-43],"s":[21,2,1],"c":"#e84d4d","t":5},{"p":[96,-43,7],"s":[21,2,1],"c":"#e84d4d","t":5},{"p":[96,-42,-42],"s":[1,48,1],"c":"#505050","t":5},{"p":[96,-42,6],"s":[1,48,1],"c":"#505050","t":5},{"p":[96,-41,-43],"s":[4,2,1],"c":"#e84d4d","t":5},{"p":[96,-41,7],"s":[4,2,1],"c":"#e84d4d","t":5},{"p":[80,-21,6],"s":[2,26,2],"c":"#666666","t":5},{"p":[87,5,6],"s":[22,2,2],"c":"#666666","t":5},{"p":[80,-21,-42],"s":[2,26,2],"c":"#666666","t":5},{"p":[87,5,-42],"s":[22,2,2],"c":"#666666","t":5},{"p":[80,-21,6],"s":[4,1,4],"c":"#666666","t":5},{"p":[80,-21,-42],"s":[4,1,4],"c":"#666666","t":5},{"p":[-8,-21,-104],"s":[4,7,4],"i":16},{"p":[297,44,-51],"s":[3,129,35],"l":1,"c":"#181717","t":5},{"p":[297,140,-73],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[297,72,-73],"s":[3,6,9],"l":1,"c":"#343434","t":5},{"p":[297,42,-33],"s":[4,134,3],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[297,41,-69],"s":[4,135,3],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[297,173,-51],"s":[4,3,39],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[297,41,-51],"s":[4,3,39],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[297,132,-46],"s":[4,20,5],"l":1,"r":[-0.79,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[297,151,-51],"s":[4,5,23],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[297,93,-56],"s":[4,25,5],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[297,106,-44],"s":[4,5,9],"l":1,"r":[-0.17,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[297,66,-61],"s":[4,22,5],"l":1,"r":[0.96,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[297,62,-47],"s":[4,5,11],"l":1,"r":[0.96,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,39,-101],"s":[1,164,35],"c":"#181717","t":5,"bo":1},{"p":[-422,40,-85],"s":[4,162,1],"l":1,"c":"#ffffff","t":5},{"p":[-422,40,-86],"s":[3,161,1],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[-422,40,-116],"s":[2,161,1],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[-422,40,-117],"s":[4,161,1],"l":1,"c":"#ffffff","t":5},{"p":[-422,40,-101],"s":[4,1,33],"l":1,"c":"#ffffff","t":5},{"p":[-422,41,-101],"s":[2,1,29],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[-422,201,-101],"s":[4,1,33],"l":1,"c":"#ffffff","t":5},{"p":[-422,200,-101],"s":[3,1,29],"l":1,"c":"#bf00ff","e":"#bf00ff","t":5},{"p":[-421,141,-126],"s":[1,3,16],"c":"#101010","t":5,"bo":1},{"p":[-422,192,-102],"s":[4,1,17],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,191,-102],"s":[3,3,19],"l":1,"c":"#ffffff","t":5},{"p":[-422,184,-102],"s":[4,1,14],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,183,-102],"s":[3,3,16],"l":1,"c":"#ffffff","t":5},{"p":[-422,175,-102],"s":[4,1,21],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,174,-102],"s":[3,3,23],"l":1,"c":"#ffffff","t":5},{"p":[-422,180,-110],"s":[4,1,10],"l":1,"r":[-1.22,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,176,-111],"s":[3,9,2],"l":1,"r":[0.35,0,0],"c":"#ffffff","t":5},{"p":[-421,176,-113],"s":[1,10,2],"l":1,"r":[0.35,0,0],"c":"#ffffff","t":5},{"p":[-422,175,-102],"s":[4,17,1],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,175,-102],"s":[3,17,3],"l":1,"c":"#ffffff","t":5},{"p":[-422,164,-102],"s":[3,3,19],"l":1,"r":[0.17,0,0],"c":"#ffffff","t":5},{"p":[-422,165,-102],"s":[4,1,17],"l":1,"r":[0.17,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,156,-103],"s":[4,13,1],"l":1,"r":[-0.52,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,156,-104],"s":[3,12,3],"l":1,"r":[-0.52,0,0],"c":"#ffffff","t":5},{"p":[-422,155,-102],"s":[4,1,21],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,154,-102],"s":[3,3,23],"l":1,"c":"#ffffff","t":5},{"p":[-422,142,-106],"s":[4,13,1],"l":1,"r":[0.17,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,142,-106],"s":[4,7,1],"l":1,"r":[0.87,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,141,-106],"s":[3,15,3],"l":1,"r":[0.17,0,0],"c":"#ffffff","t":5},{"p":[-422,142,-106],"s":[3,8,3],"l":1,"r":[0.87,0,0],"c":"#ffffff","t":5},{"p":[-422,135,-102],"s":[4,1,13],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,134,-102],"s":[3,3,15],"l":1,"c":"#ffffff","t":5},{"p":[-422,130,-102],"s":[4,1,20],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,129,-102],"s":[3,3,22],"l":1,"c":"#ffffff","t":5},{"p":[-422,115,-103],"s":[4,18,1],"l":1,"r":[-0.52,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,114,-102],"s":[3,19,3],"l":1,"r":[-0.52,0,0],"c":"#ffffff","t":5},{"p":[-422,91,-102],"s":[4,16,1],"l":1,"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,90,-102],"s":[3,18,3],"l":1,"c":"#ffffff","t":5},{"p":[-422,68,-93],"s":[4,26,1],"l":1,"r":[-0.7,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,67,-93],"s":[3,28,3],"l":1,"r":[-0.7,0,0],"c":"#ffffff","t":5},{"p":[-422,67,-110],"s":[4,19,1],"l":1,"r":[0.52,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,66,-111],"s":[3,22,3],"l":1,"r":[0.52,0,0],"c":"#ffffff","t":5},{"p":[-422,51,-102],"s":[4,1,23],"l":1,"r":[0.35,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,50,-102],"s":[3,3,25],"l":1,"r":[0.35,0,0],"c":"#ffffff","t":5},{"p":[-422,57,-102],"s":[4,9,1],"l":1,"r":[0.17,0,0],"c":"#fffb00","e":"#fffb00","t":5},{"p":[-422,56,-102],"s":[3,11,3],"l":1,"r":[0.17,0,0],"c":"#ffffff","t":5},{"p":[-421,95,-126],"s":[1,3,16],"c":"#101010","t":5,"bo":1},{"p":[-421,51,-126],"s":[1,3,16],"c":"#101010","t":5},{"p":[-422,-21,-73],"s":[34,18,48],"c":"#969696","t":5},{"p":[-513,-21,-171],"s":[4,2,243],"c":"#787878","t":5},{"p":[-487,-21,-293],"s":[57,2,4],"c":"#787878","t":5},{"p":[-446,-3,-50],"s":[74,2,4],"c":"#787878","t":5},{"p":[-480,-3,-150],"s":[4,2,100],"c":"#787878","t":5},{"p":[-407,-3,-101],"s":[4,2,106],"c":"#787878","t":5},{"p":[-460,-3,-99],"s":[44,2,4],"c":"#787878","t":5},{"p":[-454,-3,-202],"s":[56,2,4],"c":"#787878","t":5},{"p":[-470,-21,-204],"s":[2,20,4],"i":3,"c":"#e84d4d","t":5,"d":3},{"p":[-513,-19,-51],"s":[2,30,2],"c":"#323232","t":5},{"p":[-513,-19,-104],"s":[2,30,2],"c":"#323232","t":5},{"p":[-513,-19,-171],"s":[1,29,240],"pe":1,"t":12},{"p":[-513,-19,-237],"s":[2,30,2],"c":"#323232","t":5},{"p":[-513,-19,-292],"s":[2,30,2],"c":"#323232","t":5},{"p":[-513,-19,-170],"s":[2,30,2],"c":"#323232","t":5},{"p":[192,-59,446],"s":[116,118,2],"l":1,"c":"#b6b6b6","t":3},{"p":[192,-201,446],"s":[116,118,2],"l":1,"c":"#b6b6b6","t":3},{"p":[192,-347,446],"s":[116,118,2],"l":1,"c":"#b6b6b6","t":3},{"p":[426,-182,74],"s":[3,59,121],"l":1,"c":"#b6b6b6","t":3},{"p":[426,-369,74],"s":[3,59,121],"l":1,"c":"#b6b6b6","t":3},{"p":[192,-501,446],"s":[116,118,2],"l":1,"c":"#b6b6b6","t":3},{"p":[-737,-414,119],"s":[3,448,57],"l":1,"c":"#b6b6b6","t":3},{"p":[-795,122,373],"s":[3,67,124],"l":1,"c":"#282828","t":5},{"p":[-795,-75,373],"s":[3,67,124],"l":1,"c":"#282828","t":5},{"p":[-795,-176,373],"s":[3,67,124],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-795,-284,373],"s":[3,67,124],"l":1,"c":"#282828","t":5},{"p":[404,-455,-653],"s":[3,651,59],"l":1,"c":"#b6b6b6","t":3},{"p":[403,84,-639],"s":[3,29,30],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[403,-95,-666],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[402,-36,-638],"s":[1,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-512,-254,106],"s":[56,268,1],"l":1,"c":"#b6b6b6","t":3},{"p":[-527,-44,106],"s":[26,28,2],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-736,-144,104],"s":[2,28,26],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-220,-709,-1198],"s":[121,869,2],"l":1,"c":"#b6b6b6","t":3},{"p":[-234,70,-1197],"s":[28,29,3],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-234,-231,-1197],"s":[28,29,3],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[238,-184,-54],"s":[3,59,119],"l":1,"c":"#b6b6b6","t":3},{"p":[238,-95,-54],"s":[3,59,119],"l":1,"c":"#b6b6b6","t":3},{"p":[-114,-78,213],"s":[163,58,2],"l":1,"c":"#757575","t":3},{"p":[-114,-164,213],"s":[163,58,2],"l":1,"c":"#757575","t":3},{"p":[-114,-253,213],"s":[163,58,2],"l":1,"c":"#757575","t":3},{"p":[-114,-345,213],"s":[163,58,2],"l":1,"c":"#757575","t":3},{"p":[888,-644,-266],"s":[173,787,178],"l":1,"c":"#f2f2f2","t":3},{"p":[176,-29,445],"s":[26,28,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[147,-286,445],"s":[27,28,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[236,0,445],"s":[26,28,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[549,-182,216],"s":[3,387,117],"l":1,"c":"#b6b6b6","t":3},{"p":[466,-646,-444],"s":[173,681,121],"l":1,"c":"#f2f2f2","t":3},{"p":[537,-644,-454],"s":[59,688,173],"l":1,"c":"#f2f2f2","t":3},{"p":[-376,-346,-778],"s":[4,37,121],"l":1,"c":"#282828","t":5},{"p":[133,60,-400],"s":[2,16,1],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[133,67,-401],"s":[2,1,20],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[133,71,-396],"s":[2,1,11],"l":1,"r":[0.7,0,0],"c":"#000de8","e":"#004aff","t":5},{"p":[133,74,-397],"s":[2,2,16],"l":1,"r":[0.35,0,0],"c":"#000de8","e":"#004aff","t":5},{"p":[133,78,-396],"s":[2,4,18],"l":1,"r":[0.35,0,0],"c":"#000de8","e":"#004aff","t":5},{"p":[133,80,-397],"s":[2,4,12],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[133,79,-393],"s":[2,4,7],"l":1,"r":[0.87,0,0],"c":"#000de8","e":"#004aff","t":5},{"p":[133,81,-404],"s":[2,12,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[133,90,-397],"s":[2,7,2],"l":1,"c":"#000de8","e":"#004aff","t":5},{"p":[133,89,-397],"s":[2,9,2],"l":1,"r":[-1.05,0,0],"c":"#000de8","e":"#004aff","t":5},{"p":[133,95,-398],"s":[2,5,6],"l":1,"r":[0.52,0,0],"c":"#000de8","e":"#004aff","t":5},{"p":[133,98,-402],"s":[2,1,10],"l":1,"r":[0.69,0,0],"c":"#000de8","e":"#004aff","t":5},{"p":[133,99,-400],"s":[2,1,11],"l":1,"r":[0.35,0,0],"c":"#000de8","e":"#004aff","t":5},{"p":[132,97,-397],"s":[1,1,2],"l":1,"r":[0.52,0,0],"c":"#e80000","e":"#ff0000","t":5},{"p":[133,75,-387],"s":[2,2,2],"l":1,"r":[0.35,0,0],"c":"#000de8","e":"#004aff","t":5},{"p":[133,73,-381],"s":[2,26,3],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,87,-378],"s":[2,3,9],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,78,-375],"s":[2,3,12],"l":1,"r":[1.05,0,0],"c":"#e80000","e":"#ff0000","t":5},{"p":[133,94,-374],"s":[2,3,9],"l":1,"r":[-0.87,0,0],"c":"#e80000","e":"#ff0000","t":5},{"p":[133,74,-355],"s":[2,24,3],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,92,-357],"s":[2,3,14],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,83,-360],"s":[2,3,14],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,93,-363],"s":[2,5,3],"l":1,"r":[-0.35,0,0],"c":"#e80000","e":"#ff0000","t":5},{"p":[133,81,-363],"s":[2,12,3],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,74,-366],"s":[2,12,3],"l":1,"r":[0.35,0,0],"c":"#e80000","e":"#ff0000","t":5},{"p":[133,74,-336],"s":[2,25,3],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,74,-347],"s":[2,9,3],"l":1,"r":[0.52,0,0],"c":"#e80000","e":"#ff0000","t":5},{"p":[133,85,-345],"s":[2,9,3],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,93,-345],"s":[2,5,3],"l":1,"r":[-0.35,0,0],"c":"#e80000","e":"#ff0000","t":5},{"p":[133,91,-345],"s":[2,12,3],"l":1,"r":[2.27,0,0],"c":"#e80000","e":"#ff0000","t":5},{"p":[133,93,-329],"s":[2,5,3],"l":1,"r":[-0.35,0,0],"c":"#e80000","e":"#ff0000","t":5},{"p":[133,93,-325],"s":[2,3,9],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,81,-324],"s":[2,12,3],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,73,-329],"s":[2,11,3],"l":1,"r":[0.52,0,0],"c":"#e80000","e":"#ff0000","t":5},{"p":[133,77,-312],"s":[2,22,3],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,93,-314],"s":[2,3,9],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[133,74,-314],"s":[2,3,9],"l":1,"c":"#e80000","e":"#ff0000","t":5},{"p":[-137,-14,-163],"s":[9,9,5],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-148,-14,-163],"s":[9,9,5],"l":1,"c":"#ffffff","e":"#ffffff","t":5},{"p":[-167,-4,-163],"s":[9,9,5],"l":1,"r":[0,0,-0.87],"c":"#ffffff","e":"#ffffff","t":5},{"p":[-148,-11,-163],"s":[3,3,6],"l":1,"c":"#ff5a00","e":"#ff5a00","t":5},{"p":[-137,-11,-163],"s":[3,3,6],"l":1,"c":"#00ff0f","e":"#00ff0f","t":5},{"p":[-165,-2,-163],"s":[3,3,6],"l":1,"r":[0,0,-0.87],"c":"#ff5a00","e":"#ff5a00","t":5},{"p":[-165,-14,-163],"s":[2,47,6],"l":1,"r":[0,0,-0.87],"c":"#ffe100","e":"#ffe100","t":5},{"p":[-173,9,-163],"s":[2,47,6],"l":1,"r":[0,0,-1.57],"c":"#ffe100","e":"#ffe100","t":5},{"p":[-116,6,-163],"s":[2,12,6],"l":1,"r":[0,0,-1.05],"c":"#ffffff","e":"#ffffff","t":5},{"p":[-101,3,-164],"s":[3,14,7],"l":1,"r":[0,0,1.57],"c":"#ffffff","e":"#ffffff","t":5},{"p":[-91,3,-163],"s":[3,14,6],"l":1,"r":[0,0,-1.57],"c":"#ffffff","e":"#ffffff","t":5},{"p":[-76,6,-163],"s":[2,12,6],"l":1,"r":[0,0,1.05],"c":"#ffffff","e":"#ffffff","t":5},{"p":[-109,-8,-164],"s":[5,5,7],"l":1,"c":"#ffffff","e":"#ff00ff","t":5},{"p":[-83,-8,-164],"s":[5,5,7],"l":1,"c":"#ffffff","e":"#ff00ff","t":5},{"p":[-150,-21,-163],"s":[54,2,5],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-149,20,-163],"s":[54,2,5],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-177,-21,-163],"s":[2,43,5],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-122,-21,-163],"s":[2,43,5],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-100,-9,-163],"s":[5,3,6],"l":1,"r":[0,0,1.57],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-89,-9,-163],"s":[5,3,6],"l":1,"r":[0,0,1.57],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-97,-12,-163],"s":[3,3,6],"l":1,"r":[0,0,1.57],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-92,-12,-163],"s":[3,3,6],"l":1,"r":[0,0,1.57],"c":"#ff0000","e":"#ff0000","t":5},{"p":[-94,-13,-163],"s":[3,4,6],"l":1,"r":[0,0,1.57],"c":"#ff0000","e":"#ff0000","t":5},{"p":[14,0,6],"s":[69,50,80],"i":14,"l":1},{"p":[-283,-20,-533],"s":[91,50,94],"i":14,"l":1},{"p":[-227,21,-34],"s":[76,50,99],"i":14,"l":1},{"p":[-70,-78,212],"s":[28,28,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-160,-134,212],"s":[28,28,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[127,-371,-359],"s":[3,47,117],"l":1,"c":"#282828","t":5},{"p":[418,-75,-368],"s":[29,29,3],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[549,-194,-368],"s":[29,29,3],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[549,-13,-368],"s":[29,29,3],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[448,-255,-368],"s":[29,29,3],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[380,-107,-399],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[380,-346,-399],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[380,-227,-457],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[380,-77,-488],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-353,-224,-917],"s":[28,29,3],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-412,-134,-917],"s":[28,29,3],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-353,-75,-917],"s":[28,29,3],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-444,-313,-917],"s":[28,29,3],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-385,-613,-987],"s":[120,568,57],"l":1,"c":"#b6b6b6","t":3},{"p":[-326,-194,-974],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-326,-254,-974],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-326,-374,-1000],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-326,-74,-1000],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-683,-214,-746],"s":[28,29,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-654,-272,-746],"s":[28,29,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-713,-394,-746],"s":[28,29,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-778,211,-324],"s":[1,29,28],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-778,150,-266],"s":[1,29,28],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-778,1,-266],"s":[1,29,28],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-778,1,-325],"s":[1,29,28],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-778,-90,-294],"s":[1,29,28],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-778,-300,-295],"s":[1,29,28],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-778,-238,-237],"s":[1,29,28],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-353,-320,214],"s":[89,36,2],"l":1,"c":"#282828","t":5},{"p":[-130,-48,212],"s":[28,28,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[296,-667,394],"s":[116,538,2],"l":1,"c":"#b6b6b6","t":3},{"p":[252,-188,393],"s":[27,28,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[310,-246,393],"s":[27,28,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[279,-366,393],"s":[27,28,1],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[424,-340,30],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[424,-277,90],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[424,-182,90],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[237,-95,-9],"s":[3,28,28],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[237,-65,-68],"s":[3,28,28],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[237,-154,-99],"s":[3,28,28],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[548,87,172],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[548,149,172],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[548,149,233],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[548,-64,172],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[86,-318,-825],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[86,-385,-825],"s":[137,46,2],"l":1,"c":"#282828","t":5},{"p":[203,-301,-738],"s":[3,46,121],"l":1,"c":"#282828","t":5},{"p":[403,145,-666],"s":[3,29,30],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[380,-17,-458],"s":[3,29,29],"l":1,"c":"#f5e14c","e":"#f5e14c","t":5},{"p":[-926,-719,-432],"s":[3,781,116],"l":1,"c":"#b6b6b6","t":3},{"p":[-63,-708,-533],"s":[5000,1,5000],"c":"#363284","t":5},{"p":[-349,-4,-446],"s":[112,2,4],"c":"#787878","t":5},{"p":[-314,-4,-318],"s":[183,2,4],"c":"#787878","t":5},{"p":[-404,-4,-382],"s":[4,2,132],"c":"#787878","t":5},{"p":[-224,-4,-382],"s":[4,2,132],"c":"#787878","t":5},{"p":[-314,-691,-382],"s":[179,687,129],"c":"#b6b6b6","t":5},{"p":[-404,-2,-382],"s":[1,29,129],"pe":1,"t":12},{"p":[-404,-2,-318],"s":[2,30,2],"c":"#323232","t":5},{"p":[-404,-2,-446],"s":[2,30,2],"c":"#323232","t":5},{"p":[-404,-2,-384],"s":[2,30,2],"c":"#323232","t":5},{"p":[-375,-2,-446],"s":[58,29,1],"pe":1,"t":12},{"p":[-345,-2,-446],"s":[2,30,2],"c":"#323232","t":5},{"p":[-375,14,-415],"s":[25,21,25],"c":"#acacac","t":5},{"p":[-375,35,-415],"s":[28,1,28],"c":"#666666","t":5},{"p":[-375,13,-415],"s":[28,1,28],"c":"#666666","t":5},{"p":[-364,-2,-404],"s":[2,15,2],"c":"#666666","t":5},{"p":[-364,-4,-404],"s":[3,2,3],"c":"#666666","t":5},{"p":[-364,-2,-426],"s":[2,15,2],"c":"#666666","t":5},{"p":[-364,-4,-426],"s":[3,2,3],"c":"#666666","t":5},{"p":[-386,-2,-404],"s":[2,15,2],"c":"#666666","t":5},{"p":[-386,-4,-404],"s":[3,2,3],"c":"#666666","t":5},{"p":[-386,-2,-426],"s":[2,15,2],"c":"#666666","t":5},{"p":[-386,-4,-426],"s":[3,2,3],"c":"#666666","t":5},{"p":[-364,-1,-415],"s":[1,1,22],"c":"#666666","t":5},{"p":[-386,-1,-415],"s":[1,1,22],"c":"#666666","t":5},{"p":[-375,-1,-404],"s":[20,1,1],"c":"#666666","t":5},{"p":[-375,-1,-426],"s":[20,1,1],"c":"#666666","t":5},{"p":[-380,-1,-353],"s":[16,13,26],"c":"#cfcfcf","t":5},{"p":[-380,-4,-353],"s":[15,3,25],"c":"#7a7a7a","t":5},{"p":[-380,12,-353],"s":[18,1,28],"c":"#828282","t":5},{"p":[-374,13,-342],"s":[3,1,3],"c":"#666666","t":5},{"p":[-374,14,-342],"s":[4,2,4],"c":"#666666","t":5},{"p":[-392,-2,-318],"s":[22,29,1],"pe":1,"t":12},{"p":[-381,-2,-318],"s":[2,30,2],"c":"#323232","t":5},{"p":[-251,-2,-318],"s":[53,29,1],"pe":1,"t":12},{"p":[-278,-2,-318],"s":[2,30,2],"c":"#323232","t":5},{"p":[-224,-2,-318],"s":[2,30,2],"c":"#323232","t":5},{"p":[-293,-6,-370],"s":[99,19,67],"c":"#969696","t":5},{"p":[-244,13,-370],"s":[4,2,68],"c":"#787878","t":5},{"p":[-342,13,-370],"s":[4,2,68],"c":"#787878","t":5},{"p":[-268,12,-350],"s":[24,5,13],"c":"#7a7a7a","t":5},{"p":[-268,16,-350],"s":[25,13,14],"c":"#cfcfcf","t":5},{"p":[-268,29,-350],"s":[27,1,16],"c":"#737373","t":5},{"p":[-278,30,-345],"s":[3,1,3],"c":"#666666","t":5},{"p":[-278,31,-345],"s":[4,2,4],"c":"#666666","t":5},{"p":[-366,36,-406],"s":[3,1,3],"c":"#666666","t":5},{"p":[-366,37,-406],"s":[5,3,5],"c":"#666666","t":5},{"p":[-252,-6,-415],"s":[4,14,23],"c":"#969696","t":5},{"p":[-252,8,-415],"s":[5,1,24],"c":"#828282","t":5},{"p":[-200,-11,-406],"s":[56,1,4],"l":1,"r":[0,0,-0.35],"c":"#917d66","t":5},{"p":[-335,15,-396],"s":[5,3,5],"c":"#666666","t":5},{"p":[-335,13,-396],"s":[3,2,3],"c":"#666666","t":5},{"p":[-293,13,-370],"s":[92,50,60],"i":14,"l":1},{"p":[-382,-715,-277],"s":[68,711,28],"c":"#d9d9d9","t":5},{"p":[-200,-11,-398],"s":[56,1,4],"l":1,"r":[0,0,-0.35],"c":"#917d66","t":5},{"p":[-200,-11,-402],"s":[56,1,4],"l":1,"r":[0,0,-0.35],"c":"#847666","t":5},{"p":[-198,-21,-402],"s":[48,19,11],"i":9,"d":2},{"p":[-251,-1164,-34],"s":[187,1161,160],"c":"#d9d9d9","t":5},{"p":[-160,-3,43],"s":[5,2,10],"c":"#939393","t":5},{"p":[-344,-3,-34],"s":[4,2,164],"c":"#939393","t":5},{"p":[-218,-3,-114],"s":[116,2,4],"c":"#939393","t":5},{"p":[-344,-1,-114],"s":[2,30,2],"c":"#323232","t":5},{"p":[-344,-1,46],"s":[2,30,2],"c":"#323232","t":5},{"p":[-344,-1,-96],"s":[2,30,2],"c":"#323232","t":5},{"p":[-221,-1,46],"s":[2,30,2],"c":"#323232","t":5},{"p":[-252,-1,46],"s":[184,29,1],"pe":1,"t":12},{"p":[-344,-1,-4],"s":[1,29,98],"pe":1,"t":12},{"p":[-344,-1,-54],"s":[2,30,2],"c":"#323232","t":5},{"p":[-227,-5,-34],"s":[82,26,104],"c":"#969696","t":5},{"p":[-186,21,-34],"s":[4,2,108],"c":"#939393","t":5},{"p":[-268,21,-34],"s":[4,2,108],"c":"#939393","t":5},{"p":[-227,21,-86],"s":[78,2,4],"c":"#939393","t":5},{"p":[-227,21,18],"s":[78,2,4],"c":"#939393","t":5},{"p":[-184,-3,-1],"s":[2,27,4],"i":3,"c":"#e84d4d","t":5},{"p":[-205,24,-61],"s":[16,13,26],"c":"#cfcfcf","t":5},{"p":[-205,21,-61],"s":[15,3,25],"c":"#8c8c8c","t":5},{"p":[-205,37,-61],"s":[18,1,28],"c":"#646464","t":5},{"p":[-199,38,-50],"s":[3,1,3],"c":"#666666","t":5},{"p":[-199,39,-50],"s":[4,2,4],"c":"#666666","t":5},{"p":[-159,-1,46],"s":[2,30,2],"c":"#323232","t":5},{"p":[-285,-1,46],"s":[2,30,2],"c":"#323232","t":5},{"p":[-254,-3,-88],"s":[2,27,4],"i":3,"c":"#e84d4d","t":5,"d":3},{"p":[-246,22,2],"s":[18,14,6],"c":"#919191","t":5},{"p":[-246,21,2],"s":[17,1,5],"c":"#5a5a5a","t":5},{"p":[-246,36,2],"s":[19,1,7],"c":"#575757","t":5},{"p":[-246,21,-11],"s":[12,1,12],"c":"#ffffff","t":5},{"p":[-246,21,-11],"s":[3,11,3],"c":"#ffffff","t":5},{"p":[-246,24,-11],"s":[1,64,1],"c":"#ffffff","t":5},{"p":[-211,38,-71],"s":[1,2,1],"c":"#666666","t":5},{"p":[-211,40,-71],"s":[2,1,2],"c":"#666666","t":5},{"p":[-137,-1164,-34],"s":[41,1161,84],"c":"#d9d9d9","t":5},{"p":[-159,-3,-111],"s":[4,2,10],"c":"#939393","t":5},{"p":[-117,-3,-34],"s":[4,2,86],"c":"#939393","t":5},{"p":[-139,-3,7],"s":[40,2,4],"c":"#939393","t":5},{"p":[-134,-3,-55],"s":[18,6,29],"c":"#666666","t":5},{"p":[-134,23,-55],"s":[22,1,34],"c":"#666666","t":5},{"p":[-134,1,-55],"s":[20,22,31],"c":"#acacac","t":5},{"p":[-128,25,-42],"s":[4,2,4],"c":"#666666","t":5},{"p":[-128,24,-42],"s":[3,1,3],"c":"#666666","t":5},{"p":[-251,-3,46],"s":[186,2,4],"c":"#939393","t":5},{"p":[-270,-3,-24],"s":[2,27,4],"i":3,"c":"#e84d4d","t":5,"d":2},{"p":[-344,-1,-105],"s":[1,29,17],"pe":1,"t":12},{"p":[-320,-7,-47],"s":[18,17,6],"c":"#787878","t":5},{"p":[-322,1,-99],"s":[20,17,8],"c":"#bbbbbb","t":5},{"p":[-322,18,-99],"s":[21,1,9],"c":"#787878","t":5},{"p":[-375,-1,-81],"s":[71,1,4],"c":"#9d8161","t":5},{"p":[-374,-1,-77],"s":[71,1,4],"c":"#a78e71","t":5},{"p":[-375,-1,-73],"s":[71,1,4],"c":"#9d8161","t":5},{"p":[-335,-1,-114],"s":[17,29,1],"pe":1,"t":12},{"p":[-326,-1,-114],"s":[2,30,2],"c":"#323232","t":5},{"p":[-292,-669,-124],"s":[31,648,60],"c":"#d9d9d9","t":5},{"p":[-443,-21,-150],"s":[76,18,106],"c":"#969696","t":5},{"p":[-461,-21,-60],"s":[44,18,22],"c":"#969696","t":5},{"p":[-461,-3,-69],"s":[44,2,4],"c":"#787878","t":5},{"p":[-481,-3,-60],"s":[4,2,16],"c":"#787878","t":5},{"p":[-128,-1147,-91],"s":[64,126,30],"c":"#cfcfcf","t":5},{"p":[-382,-21,-293],"s":[153,19,4],"c":"#939393","t":5},{"p":[-363,-2,-306],"s":[4,1,31],"c":"#847462","t":5},{"p":[-359,-2,-305],"s":[4,1,31],"c":"#847462","t":5},{"p":[-355,-2,-306],"s":[4,1,31],"c":"#847462","t":5},{"p":[-459,-708,-171],"s":[108,687,244],"c":"#d9d9d9","t":5},{"p":[-499,-21,-50],"s":[32,2,4],"c":"#787878","t":5},{"p":[-127,-1147,23],"s":[62,1126,30],"c":"#cfcfcf","t":5},{"p":[-326,-3,-114],"s":[32,2,4],"c":"#939393","t":5},{"p":[-278,-21,-147],"s":[4,20,70],"c":"#939393","t":5},{"p":[-308,-21,-147],"s":[4,20,70],"c":"#939393","t":5},{"p":[-419,-2,-293],"s":[75,29,1],"pe":1,"t":12},{"p":[-381,-2,-293],"s":[2,30,2],"c":"#323232","t":5},{"p":[-457,-2,-293],"s":[2,30,2],"c":"#323232","t":5},{"p":[-328,-21,-278],"s":[40,17,27],"i":9,"c":"#d9d9d9","t":5,"d":2},{"p":[-383,-21,-263],"s":[150,19,4],"c":"#939393","t":5},{"p":[-127,-1147,-91],"s":[62,1126,30],"c":"#cfcfcf","t":5},{"p":[-98,-21,-34],"s":[5,2,76],"c":"#787878","t":5},{"p":[-97,-21,-119],"s":[4,2,26],"c":"#787878","t":5},{"p":[-107,-21,-108],"s":[16,2,4],"c":"#787878","t":5},{"p":[-137,-688,40],"s":[41,685,4],"c":"#cfcfcf","t":5},{"p":[-137,-3,40],"s":[41,2,4],"c":"#939393","t":5},{"p":[-267,-655,-464],"s":[4,651,36],"c":"#cfcfcf","t":5},{"p":[-247,-4,-446],"s":[44,2,4],"c":"#787878","t":5},{"p":[-267,-4,-465],"s":[4,2,34],"c":"#787878","t":5},{"p":[-295,-4,-465],"s":[4,2,34],"c":"#787878","t":5},{"p":[-252,-21,-483],"s":[35,2,5],"c":"#787878","t":5},{"p":[-320,1,-47],"s":[20,17,8],"c":"#bbbbbb","t":5},{"p":[-322,-7,-99],"s":[18,17,6],"c":"#787878","t":5},{"p":[-320,18,-47],"s":[21,1,9],"c":"#787878","t":5},{"p":[-507,-19,-293],"s":[4,7,4],"i":16},{"p":[-471,-19,-293],"s":[4,7,4],"i":16},{"p":[-137,-21,23],"s":[41,18,30],"i":9,"c":"#cfcfcf","t":5,"d":2},{"p":[-137,-21,-91],"s":[41,18,30],"i":9,"c":"#cfcfcf","t":5,"d":2},{"p":[-136,-723,-108],"s":[42,720,4],"c":"#cfcfcf","t":5},{"p":[-136,-3,-108],"s":[42,2,4],"c":"#939393","t":5},{"p":[-293,-21,-148],"s":[26,18,68],"i":9,"c":"#d9d9d9","t":5,"d":1},{"p":[-437,-21,-278],"s":[42,17,27],"i":9,"c":"#cfcfcf","t":5},{"p":[-460,-21,-84],"s":[42,18,26],"i":9,"c":"#cfcfcf","t":5},{"p":[-281,-21,-465],"s":[24,17,37],"i":9,"c":"#c0c0c0","t":5,"d":1},{"p":[0,0,0],"s":[24,36,24],"i":23,"l":1,"tm":0},{"p":[-248,-21,-624],"s":[24,36,24],"i":23,"l":1,"tm":"1"},{"p":[-163,13,-323],"s":[4,2,48],"c":"#787878","t":5},{"p":[-293,13,-338],"s":[94,2,4],"c":"#787878","t":5},{"p":[-106,-21,-74],"s":[21,2,4],"c":"#787878","t":5},{"p":[-106,-21,6],"s":[21,2,4],"c":"#787878","t":5},{"p":[-106,-21,40],"s":[21,2,4],"c":"#787878","t":5},{"p":[-175,132,-314],"s":[2,2,34],"c":"#666666","t":5},{"p":[-175,17,-328],"s":[1,116,1],"c":"#505050","t":5},{"p":[-215,132,-314],"s":[2,2,34],"c":"#666666","t":5},{"p":[-215,17,-328],"s":[1,115,1],"c":"#505050","t":5},{"p":[-195,16,-329],"s":[41,1,19],"c":"#646464","t":5},{"p":[-174,16,-329],"s":[1,2,19],"c":"#e84d4d","t":5},{"p":[-216,16,-329],"s":[1,2,19],"c":"#e84d4d","t":5},{"p":[-195,16,-339],"s":[43,2,1],"c":"#e84d4d","t":5},{"p":[-195,16,-319],"s":[43,2,1],"c":"#e84d4d","t":5},{"p":[-216,18,-328],"s":[1,2,4],"c":"#e84d4d","t":5},{"p":[-174,18,-328],"s":[1,2,4],"c":"#e84d4d","t":5},{"p":[-293,13,-402],"s":[94,2,4],"c":"#787878","t":5},{"p":[-139,-3,-75],"s":[40,2,4],"c":"#939393","t":5},{"p":[-175,109,-298],"s":[2,23,2],"c":"#666666","t":5},{"p":[-215,109,-298],"s":[2,23,2],"c":"#666666","t":5},{"p":[-459,84,-199],"s":[108,0,48],"i":11,"l":1,"r":[1.57,0,-1.57],"bb":3},{"p":[-457,57,-199],"s":[3,54,113],"l":1,"c":"#484848","t":5},{"p":[-457,55,-199],"s":[7,2,116],"l":1,"c":"#484848","t":5},{"p":[-330,1,-9],"s":[7,17,20],"c":"#bbbbbb","t":5},{"p":[-330,-3,-9],"s":[4,17,18],"c":"#787878","t":5},{"p":[-330,18,-9],"s":[8,1,21],"c":"#787878","t":5},{"p":[-295,-655,-464],"s":[4,651,36],"c":"#cfcfcf","t":5},{"p":[-292,-4,-404],"s":[2,20,4],"i":3,"c":"#e84d4d","t":5,"d":3},{"p":[-292,-4,-336],"s":[2,20,4],"i":3,"c":"#e84d4d","t":5,"d":1},{"p":[-421,54,-126],"s":[1,1,16],"i":9,"v":1,"b":2.6,"d":2,"ab":1},{"p":[-36,53,-521],"s":[12,1,1],"i":9,"v":1,"b":2.6,"ab":1},{"p":[-36,44,-521],"s":[12,1,1],"i":9,"v":1,"b":2.6,"ab":1},{"p":[-36,36,-521],"s":[12,1,1],"i":9,"v":1,"b":2.6,"ab":1}]};
    
    /***/ }),
    
    /***/ "./maps/littletown.json":
    /*!******************************!*\
      !*** ./maps/littletown.json ***!
      \******************************/
    /*! exports provided: name, ambient, light, sky, fog, fogD, nAmb, camPos, spawns, ambO, ambS, objects, default */
    /***/ (function(module) {
    
    module.exports = {"name":"Littletown","ambient":8093324,"light":5461350,"sky":6716054,"fog":7832738,"fogD":722.1829102596926,"nAmb":1,"camPos":[36,53,252],"spawns":[[424,0,-102,0,2,0],[-276,0,12,0,3,0],[-274,0,186,0,3,0],[287,38,32,0,2,0],[-156,38,33,0,3,0],[-95,38,-4,0,0,0],[384,0,87,0,2,0],[141,0,337,0,2,0]],"ambO":0.7,"ambS":5,"objects":[{"p":[138,2,6],"s":[4,36,60],"c":12927811,"t":5},{"p":[205,36,30],"s":[62,2,108],"c":7368816,"t":5},{"p":[238,38,45],"s":[4,38,74],"c":16767158,"t":5},{"p":[170,2,123],"s":[30,116,18],"c":7368816,"t":11,"bo":1},{"p":[-65,2,69],"s":[4,30,10],"c":5799880,"t":5,"bo":1},{"p":[304,2,-7],"s":[2,52,12],"i":3,"t":2},{"p":[138,38,3],"s":[4,6,38],"c":12927811,"t":5},{"p":[138,38,81],"s":[4,6,34],"c":12927811,"t":5},{"p":[138,38,43],"s":[4,46,42],"c":12927811,"t":5,"bo":1},{"p":[138,38,104],"s":[4,40,12],"c":12927811,"t":5,"bo":1},{"p":[138,38,-20],"s":[4,51,8],"c":12927811,"t":5,"bo":1},{"p":[138,66,3],"s":[4,21,38],"c":12927811,"t":5,"bo":1},{"p":[138,2,81],"s":[4,36,58],"c":12927811,"t":5},{"p":[138,26,44],"s":[4,12,16],"c":12927811,"t":5,"bo":1},{"p":[220,2,112],"s":[168,74,4],"c":12927811,"t":5,"bo":1},{"p":[205,2,-26],"s":[138,88,4],"c":12927811,"t":5,"bo":1},{"p":[297,2,-26],"s":[14,88,4],"c":12927811,"t":5,"bo":1},{"p":[282,26,-26],"s":[16,64,4],"c":12927811,"t":5,"bo":1},{"p":[302,38,16],"s":[4,46,80],"c":12927811,"t":5,"bo":1},{"p":[302,79,74],"s":[4,3,4],"c":12927811,"t":5},{"p":[302,62,64],"s":[4,20,16],"c":12927811,"t":5,"bo":1},{"p":[302,2,25],"s":[4,36,98],"c":12927811,"t":5},{"p":[302,2,100],"s":[4,36,20],"c":12927811,"t":5,"bo":1},{"p":[302,26,82],"s":[4,12,16],"c":12927811,"t":5,"bo":1},{"p":[238,38,-16],"s":[4,38,16],"c":16767158,"t":5},{"p":[238,64,0],"s":[4,12,16],"c":16767158,"t":5},{"p":[176,34,98],"s":[4,42,24],"c":16767158,"t":5},{"p":[291,38,84],"s":[18,38,4],"c":16767158,"t":5},{"p":[262,38,84],"s":[8,38,4],"c":16767158,"t":5},{"p":[274,62,84],"s":[16,14,4],"c":16767158,"t":5},{"p":[216,2,84],"s":[84,74,4],"c":16767158,"t":5},{"p":[256,2,98],"s":[4,36,24],"c":16767158,"t":5},{"p":[238,2,67],"s":[4,36,30],"c":16767158,"t":5},{"p":[238,2,-5],"s":[4,36,38],"c":16767158,"t":5},{"p":[238,26,33],"s":[4,12,38],"c":16767158,"t":5},{"p":[157,36,43],"s":[34,2,134],"c":7368816,"t":5},{"p":[270,36,30],"s":[60,2,108],"c":7368816,"t":5},{"p":[279,36,97],"s":[42,2,26],"c":7368816,"t":5},{"p":[220,0,43],"s":[172,2,146],"c":7368816,"t":5},{"p":[183,0,-75],"s":[150,2,98],"c":7368816,"t":5},{"p":[158,2,-31],"s":[4,30,6],"c":12927811,"t":5,"bo":1},{"p":[158,2,-74],"s":[4,30,4],"c":12927811,"t":5,"bo":1},{"p":[158,2,-117],"s":[4,30,2],"c":12927811,"t":5,"bo":1},{"p":[158,32,-73],"s":[4,12,90],"c":12927811,"t":5,"bo":1},{"p":[254,2,-60],"s":[4,42,64],"c":12927811,"t":5,"bo":1},{"p":[254,2,-113],"s":[4,42,10],"c":12927811,"t":5,"bo":1},{"p":[254,26,-100],"s":[4,18,16],"c":12927811,"t":5,"bo":1},{"p":[206,2,-120],"s":[100,42,4],"c":12927811,"t":5,"bo":1},{"p":[158,2,-96],"s":[2,30,42],"pe":1,"c":"#ffffff","t":10},{"p":[170,0,125],"s":[34,2,18],"c":7368816,"t":5},{"p":[260,0,-100],"s":[4,2,20],"c":7368816,"t":5},{"p":[308,0,82],"s":[4,2,20],"c":7368816,"t":5},{"p":[-41,0,-24],"s":[4,2,20],"c":7368816,"t":5},{"p":[282,0,-32],"s":[20,2,4],"c":7368816,"t":5},{"p":[29,-1,323],"s":[106,2,845],"c":3750201,"t":5},{"p":[-65,32,115],"s":[4,12,102],"c":5799880,"t":5,"bo":1},{"p":[-65,2,115],"s":[4,30,10],"c":5799880,"t":5,"bo":1},{"p":[-65,2,161],"s":[4,30,10],"c":5799880,"t":5,"bo":1},{"p":[-145,2,161],"s":[4,42,10],"c":5799880,"t":5,"bo":1},{"p":[-145,2,102],"s":[4,42,76],"c":5799880,"t":5,"bo":1},{"p":[-105,2,168],"s":[84,42,4],"c":5799880,"t":5,"bo":1},{"p":[-145,26,148],"s":[4,18,16],"c":5799880,"t":5,"bo":1},{"p":[-65,2,139],"s":[2,30,42],"pe":1,"t":10},{"p":[-91,0,118],"s":[116,2,108],"c":7368816,"t":5},{"p":[-113,0,-16],"s":[140,2,164],"c":7368816,"t":5},{"p":[-142,2,62],"s":[30,74,4],"c":5799880,"t":5,"bo":1},{"p":[-78,2,62],"s":[66,74,4],"c":5799880,"t":5,"bo":1},{"p":[-113,2,-94],"s":[136,74,4],"c":5799880,"t":5,"bo":1},{"p":[-47,66,-16],"s":[4,10,152],"c":5799880,"t":5,"bo":1},{"p":[-47,38,-77],"s":[4,28,30],"c":5799880,"t":5,"bo":1},{"p":[-47,38,-3],"s":[4,28,42],"c":5799880,"t":5,"bo":1},{"p":[-47,38,35],"s":[4,6,34],"c":5799880,"t":5},{"p":[-47,38,-43],"s":[4,6,38],"c":5799880,"t":5},{"p":[-47,38,56],"s":[4,28,8],"c":5799880,"t":5,"bo":1},{"p":[-47,2,-62],"s":[4,36,60],"c":5799880,"t":5},{"p":[-47,26,-24],"s":[4,12,16],"c":5799880,"t":5},{"p":[-177,2,62],"s":[8,74,4],"c":5799880,"t":5,"bo":1},{"p":[-179,2,5],"s":[4,74,110],"c":5799880,"t":5,"bo":1},{"p":[-179,2,-79],"s":[4,74,26],"c":5799880,"t":5,"bo":1},{"p":[-119,26,62],"s":[16,50,4],"c":5799880,"t":5,"bo":1},{"p":[-165,26,62],"s":[16,50,4],"c":5799880,"t":5,"bo":1},{"p":[-140,2,-80],"s":[4,36,24],"c":16767158,"t":5},{"p":[-105,2,-66],"s":[74,74,4],"c":16767158,"t":5},{"p":[-70,34,-80],"s":[4,42,24],"c":16767158,"t":5},{"p":[-179,26,-58],"s":[4,12,16],"c":5799880,"t":5},{"p":[-58,36,-16],"s":[20,2,152],"c":7368816,"t":5},{"p":[-134,2,32],"s":[4,28,56],"c":16767158,"t":5},{"p":[-134,2,-49],"s":[4,28,30],"c":16767158,"t":5},{"p":[-134,30,-2],"s":[4,8,124],"c":16767158,"t":5},{"p":[-100,36,-2],"s":[64,2,124],"c":7368816,"t":5},{"p":[-157,36,-3],"s":[42,2,126],"c":7368816,"t":5},{"p":[-160,36,-79],"s":[36,2,26],"c":7368816,"t":5},{"p":[-179,62,-58],"s":[4,14,16],"c":5799880,"t":5,"bo":1},{"p":[-134,38,-57],"s":[4,38,14],"c":16767158,"t":5},{"p":[-134,38,13],"s":[4,38,94],"c":16767158,"t":5},{"p":[-134,60,-42],"s":[4,16,16],"c":16767158,"t":5},{"p":[337,-2,99],"s":[4,40,4],"pe":1,"c":7692103,"t":5},{"p":[306,-2,99],"s":[4,40,4],"pe":1,"c":7692103,"t":5},{"p":[337,-2,5],"s":[4,40,4],"pe":1,"c":7692103,"t":5},{"p":[306,-2,5],"s":[4,40,4],"pe":1,"c":7692103,"t":5},{"p":[322,34,52],"s":[36,2,100],"pe":1,"c":7692103,"t":5},{"p":[-199,34,-47],"s":[36,2,82],"pe":1,"c":7692103,"t":5},{"p":[-214,-1,-9],"s":[4,38,4],"pe":1,"c":7692103,"t":5},{"p":[-214,-1,-85],"s":[4,38,4],"pe":1,"c":7692103,"t":5},{"p":[-183,-1,-85],"s":[4,38,4],"pe":1,"c":7692103,"t":5},{"p":[-183,-1,-9],"s":[4,38,4],"pe":1,"c":7692103,"t":5},{"p":[132,0,44],"s":[4,2,20],"c":7368816,"t":5},{"p":[-185,0,-58],"s":[4,2,20],"c":7368816,"t":5},{"p":[-151,0,148],"s":[4,2,20],"c":7368816,"t":5},{"p":[-165,0,68],"s":[18,2,4],"c":7368816,"t":5},{"p":[-113,76,-16],"s":[146,4,170],"c":5263440,"t":5,"bo":1},{"p":[-105,44,119],"s":[94,4,112],"c":5263440,"t":5,"bo":1},{"p":[220,75,42],"s":[165,4,137],"c":5263440,"t":5,"bo":1},{"p":[206,44,-77],"s":[108,4,98],"c":5263440,"t":5,"bo":1},{"p":[-79,2,-105],"s":[30,118,18],"c":7368816,"t":11,"bo":1},{"p":[-79,0,-107],"s":[34,2,18],"c":7368816,"t":5},{"p":[32,2,-207],"s":[124,74,150],"c":12958048,"t":5,"bo":1},{"p":[32,74,-207],"s":[136,4,162],"c":5263440,"t":5,"bo":1},{"p":[32,0,-207],"s":[128,2,154],"c":7368816,"t":5},{"p":[94,-1,159],"s":[4,26,4],"c":7692103,"t":5},{"p":[94,-1,217],"s":[2,24,113],"pe":1,"c":7692103,"t":10,"bo":1},{"p":[246,-1,159],"s":[302,24,2],"pe":1,"c":7692103,"t":10,"bo":1},{"p":[-37,-1,235],"s":[2,24,58],"c":7692103,"t":10,"bo":1},{"p":[-37,-1,205],"s":[4,26,4],"c":7692103,"t":5},{"p":[-163,-1,205],"s":[254,24,2],"c":7692103,"t":10,"bo":1},{"p":[398,-1,159],"s":[4,26,4],"c":7692103,"t":5},{"p":[399,-1,59],"s":[2,24,206],"c":7692103,"t":10,"bo":1},{"p":[399,-1,-156],"s":[4,26,4],"c":7692103,"t":5},{"p":[260,-1,-157],"s":[340,24,2],"c":7692103,"t":10,"bo":1},{"p":[-161,-1,-157],"s":[262,24,2],"c":7692103,"t":10,"bo":1},{"p":[-290,-1,204],"s":[4,26,4],"c":7692103,"t":5},{"p":[-291,-1,24],"s":[2,24,358],"c":7692103,"t":10,"bo":1},{"p":[-290,-1,-156],"s":[4,26,4],"c":7692103,"t":5},{"p":[-181,2,3],"s":[2,52,12],"i":3,"t":2,"d":2},{"p":[32,0,-121],"s":[48,2,18],"c":7368816,"t":5},{"p":[32,39,-123],"s":[46,3,19],"l":1,"c":5263440,"t":5},{"p":[-251,-1,173],"s":[2,24,63],"pe":1,"c":7692103,"t":10},{"p":[-267,0,73],"s":[46,30,42],"c":5799880,"t":5},{"p":[-267,30,73],"s":[54,2,50],"c":5395026,"t":5},{"p":[343,0,-138],"s":[52,32,36],"c":12927811,"t":5},{"p":[343,32,-138],"s":[56,2,40],"c":5263440,"t":5},{"p":[399,-1,-46],"s":[4,26,4],"c":7692103,"t":5},{"p":[416,-1,-45],"s":[30,24,2],"c":7692103,"t":10,"bo":1},{"p":[431,-1,-46],"s":[4,26,4],"c":7692103,"t":5},{"p":[432,-1,-101],"s":[2,24,110],"c":7692103,"t":10,"bo":1},{"p":[431,-1,-156],"s":[4,26,4],"c":7692103,"t":5},{"p":[-250,-1,16],"s":[8,24,72],"pe":1,"c":6984507,"t":5},{"p":[-213,-1,-120],"s":[8,10,20],"pe":1,"c":6984507,"t":5},{"p":[-232,26,-143],"s":[58,2,32],"c":7039851,"t":5},{"p":[-232,0,-143],"s":[52,26,26],"c":5799880,"t":5},{"p":[-233,-1,86],"s":[22,10,8],"pe":1,"c":6984507,"t":5},{"p":[313,-1,-134],"s":[8,10,44],"c":6984507,"t":5},{"p":[-144,-1,-154],"s":[124,10,5],"c":6984507,"t":5},{"p":[435,0,-16],"s":[52,32,36],"c":12927811,"t":5},{"p":[435,32,-16],"s":[56,2,40],"c":5263440,"t":5},{"p":[399,-2,-100],"s":[8,20,56],"pe":1,"c":6984507,"t":5},{"p":[342,-1,52],"s":[6,10,104],"pe":1,"c":6984507,"t":5},{"p":[-251,-1,205],"s":[4,26,4],"c":7692103,"t":5},{"p":[-251,-1,106],"s":[2,24,25],"pe":1,"c":7692103,"t":10},{"p":[151,2,-99],"s":[12,12,12],"i":1},{"p":[340,0,-114],"s":[12,12,12],"i":1},{"p":[108,0,152],"s":[12,12,12],"i":1},{"p":[108,12,152],"s":[12,12,12],"i":1},{"p":[191,2,-112],"s":[12,12,12],"i":1},{"p":[246,2,-50],"s":[12,12,12],"i":1},{"p":[-137,2,116],"s":[12,12,12],"i":1},{"p":[-104,2,160],"s":[12,12,12],"i":1},{"p":[-56,0,198],"s":[12,12,12],"i":1},{"p":[-56,12,198],"s":[12,12,12],"i":1},{"p":[-140,2,106],"s":[6,8,6],"i":2},{"p":[249,2,-59],"s":[6,8,6],"i":2},{"p":[-202,0,-148],"s":[6,8,6],"i":2},{"p":[-92,2,160],"s":[12,12,12],"i":8},{"p":[203,2,-112],"s":[12,12,12],"i":8},{"p":[130,34,79],"s":[12,2,42],"pe":1,"c":7692103,"t":5},{"p":[136,2,105],"s":[2,42,8],"i":3,"t":2,"d":2},{"p":[-47,44,35],"s":[1,22,34],"pe":1,"c":9533019,"t":10},{"p":[-219,-1,176],"s":[4,32,4],"pe":1,"c":6574655,"t":5},{"p":[-219,30,176],"s":[26,26,28],"c":6193707,"t":5,"bo":1},{"p":[-219,20,181],"s":[2,2,8],"pe":1,"c":6574655,"t":5},{"p":[-219,19,188],"s":[6,6,8],"pe":1,"c":6193707,"t":5,"bo":1},{"p":[-224,18,176],"s":[6,2,2],"pe":1,"c":6574655,"t":5},{"p":[-229,17,176],"s":[6,4,6],"pe":1,"c":6193707,"t":5,"bo":1},{"p":[375,-1,138],"s":[4,32,4],"pe":1,"c":6574655,"t":5,"bo":1},{"p":[375,29,138],"s":[26,26,28],"c":6193707,"t":5,"bo":1},{"p":[375,19,133],"s":[2,2,8],"c":6574655,"t":5},{"p":[375,18,127],"s":[6,6,8],"c":6193707,"t":5,"bo":1},{"p":[371,15,138],"s":[6,2,2],"c":6574655,"t":5},{"p":[365,14,138],"s":[6,4,6],"c":6193707,"t":5,"bo":1},{"p":[37,1,-78],"s":[12,12,12],"i":1},{"p":[49,1,-78],"s":[12,12,12],"i":1},{"p":[44,1,-66],"s":[12,12,12],"i":8},{"p":[41,13,-78],"s":[12,12,12],"i":1},{"p":[130,2,51],"s":[16,24,2],"pe":1,"c":7692103,"t":5},{"p":[-39,2,-31],"s":[16,24,2],"pe":1,"c":7692103,"t":5},{"p":[29,1,225],"s":[51,15,20],"i":7,"l":1},{"p":[-125,-1,175],"s":[4,22,2],"l":1,"r":[-0.17,0,0],"c":7692103,"t":5},{"p":[-113,0,175],"s":[4,22,2],"l":1,"r":[-0.17,0,0],"c":7692103,"t":5},{"p":[154,2,-46],"s":[51,15,20],"i":7,"l":1,"r":[-3.14,0,-3.14]},{"p":[-60,2,115],"s":[6,8,6],"i":2},{"p":[169,0,-150],"s":[12,12,12],"i":1},{"p":[90,0,175],"s":[6,8,6],"i":2},{"p":[395,0,28],"s":[6,8,6],"i":2},{"p":[-246,0,112],"s":[6,8,6],"i":2},{"p":[29,1,225],"s":[48,8,16],"v":1,"t":5},{"p":[34,8,225],"s":[24,8,16],"v":1,"t":5},{"p":[148,9,-45],"s":[24,8,16],"v":1,"t":5},{"p":[154,3,-45],"s":[48,8,16],"v":1,"t":5},{"p":[138,44,3],"s":[1,22,38],"pe":1,"c":7692103,"t":10},{"p":[117,21,180],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[117,-1,180],"s":[4,28,4],"l":1,"c":6574655,"t":5},{"p":[-64,-1,235],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[-64,21,235],"s":[26,28,28],"l":1,"c":7709238,"t":5},{"p":[-42,23,288],"s":[27,28,24],"pe":1,"c":6193707,"t":5,"bo":1},{"p":[-37,-1,265],"s":[4,26,4],"c":7692103,"t":5},{"p":[94,-1,275],"s":[4,26,4],"c":7692103,"t":5},{"p":[-42,-1,289],"s":[4,31,4],"pe":1,"c":6574655,"t":5,"bo":1},{"p":[-315,-1,13],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[-321,-1,-132],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[459,14,-62],"s":[26,27,35],"l":1,"c":6324784,"t":5},{"p":[207,17,-188],"s":[26,25,28],"l":1,"c":5204775,"t":5},{"p":[-102,16,-181],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[-320,19,175],"s":[26,28,28],"l":1,"c":7709238,"t":5},{"p":[85,0,188],"s":[2,73,2],"c":7368816,"t":5},{"p":[79,71,188],"s":[10,2,2],"c":7368816,"t":5},{"p":[75,70,498],"s":[10,2,4],"l":1,"c":7368816,"t":5},{"p":[75,69,188],"s":[9,1,3],"l":1,"c":0,"e":16767098,"t":5},{"p":[-27,0,332],"s":[2,73,2],"c":7368816,"t":5},{"p":[-21,71,332],"s":[10,2,2],"c":7368816,"t":5},{"p":[-17,70,332],"s":[10,2,4],"c":7368816,"t":5},{"p":[-17,69,332],"s":[9,1,3],"l":1,"c":0,"e":16767098,"t":5},{"p":[-9,0,-104],"s":[2,73,2],"c":7368816,"t":5},{"p":[-9,71,-99],"s":[2,2,8],"c":7368816,"t":5},{"p":[-9,69,-96],"s":[2,1,8],"l":1,"c":0,"e":16767098,"t":5},{"p":[-9,70,-96],"s":[3,2,9],"c":7368816,"t":5},{"p":[279,15,184],"s":[26,28,28],"l":1,"c":6193707,"t":5},{"p":[-321,11,-132],"s":[26,30,28],"l":1,"c":7709238,"t":5},{"p":[230,2,2],"s":[12,12,12],"i":1},{"p":[246,2,62],"s":[12,12,12],"i":1},{"p":[246,38,28],"s":[12,12,12],"i":1},{"p":[190,38,76],"s":[12,12,12],"i":1},{"p":[-126,38,36],"s":[12,12,12],"i":1},{"p":[-171,38,-16],"s":[12,12,12],"i":1},{"p":[-126,2,-58],"s":[12,12,12],"i":1},{"p":[-55,2,-1],"s":[12,12,12],"i":1},{"p":[-84,38,56],"s":[4,22,2],"l":1,"r":[0.17,0,0],"c":7692103,"t":5},{"p":[-76,38,56],"s":[4,22,2],"l":1,"r":[0.17,0,0],"c":7692103,"t":5},{"p":[-96,38,56],"s":[4,22,2],"l":1,"r":[0.17,0,0],"c":7692103,"t":5},{"p":[-114,39,29],"s":[4,0,5],"i":4,"l":1,"r":[0,0.52,0],"c":10987431,"t":5},{"p":[-81,39,47],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":11645361,"t":5},{"p":[-144,39,-57],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":10658466,"t":5},{"p":[-109,3,-53],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":11184810,"t":5},{"p":[60,2,-62],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":9671571,"t":5},{"p":[8,2,178],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":10329501,"t":5},{"p":[-120,38,28],"s":[2,4,2],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-67,39,-59],"s":[4,0,5],"i":4,"l":1,"r":[-3.14,1.05,-3.14],"c":10987431,"t":5},{"p":[-120,40,28],"s":[1,4,1],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-53,38,55],"s":[2,4,2],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-53,40,55],"s":[1,4,1],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-80,38,-62],"s":[2,4,2],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-80,40,-62],"s":[1,4,1],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-138,38,-11],"s":[2,4,2],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-138,40,-11],"s":[1,4,1],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-142,39,-5],"s":[4,0,5],"i":4,"l":1,"r":[3.14,-1.04,3.14],"c":10658466,"t":5},{"p":[-89,38,-58],"s":[12,12,12],"i":8},{"p":[-70,3,108],"s":[4,0,5],"i":4,"l":1,"r":[-3.14,1.05,-3.14],"c":10987431,"t":5},{"p":[-86,2,66],"s":[2,4,2],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-86,4,66],"s":[1,4,1],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-106,3,127],"s":[4,0,5],"i":4,"l":1,"r":[-3.14,1.05,-3.14],"c":10987431,"t":5},{"p":[-103,3,119],"s":[4,0,5],"i":4,"l":1,"r":[0,0.7,0],"c":10987431,"t":5},{"p":[-92,4,58],"s":[1,4,1],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-92,2,58],"s":[2,4,2],"l":1,"pe":1,"c":5211204,"t":5},{"p":[173,2,-20],"s":[1,8,7],"pe":1,"c":7692103,"t":5},{"p":[195,2,-20],"s":[1,8,7],"pe":1,"c":7692103,"t":5},{"p":[184,9,-20],"s":[11,1,4],"pe":1,"c":3421236,"t":5},{"p":[184,8,-20],"s":[21,1,6],"pe":1,"c":7692103,"t":5},{"p":[184,10,-20],"s":[2,1,1],"pe":1,"c":3421236,"t":5},{"p":[184,11,-20],"s":[22,11,1],"pe":1,"c":3421236,"t":5},{"p":[184,12,-19],"s":[20,9,1],"pe":1,"c":3421236,"e":16777215,"t":5},{"p":[164,3,-13],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":9671571,"t":5},{"p":[235,3,48],"s":[4,0,5],"i":4,"l":1,"r":[-3.14,1.4,-3.14],"c":9671571,"t":5},{"p":[143,2,84],"s":[1,17,3],"l":1,"r":[0,0,0.17],"c":7692103,"t":5},{"p":[143,2,80],"s":[1,17,3],"l":1,"r":[0,0,0.17],"c":7692103,"t":5},{"p":[225,3,68],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":9671571,"t":5},{"p":[258,30,-100],"s":[8,1,1],"l":1,"c":9012870,"t":5},{"p":[261,28,-100],"s":[5,2,3],"l":1,"c":9012870,"t":5},{"p":[261,27,-100],"s":[4,1,2],"l":1,"c":0,"e":16767098,"t":5},{"p":[-152,27,148],"s":[5,2,3],"l":1,"c":9012870,"t":5},{"p":[-150,29,148],"s":[6,1,1],"l":1,"c":9012870,"t":5},{"p":[-152,26,148],"s":[4,1,2],"l":1,"c":0,"e":16767098,"t":5},{"p":[-242,26,73],"s":[4,1,1],"l":1,"c":9012870,"t":5},{"p":[-240,24,73],"s":[4,2,3],"l":1,"c":9012870,"t":5},{"p":[-240,23,73],"s":[3,1,2],"l":1,"c":0,"e":16767098,"t":5},{"p":[-234,22,-128],"s":[1,1,4],"l":1,"c":9012870,"t":5},{"p":[-234,20,-126],"s":[3,2,4],"l":1,"c":9012870,"t":5},{"p":[-234,19,-126],"s":[2,1,3],"l":1,"c":0,"e":16767098,"t":5},{"p":[306,65,63],"s":[8,1,1],"l":1,"c":9012870,"t":5},{"p":[309,63,63],"s":[5,2,3],"l":1,"c":9012870,"t":5},{"p":[309,62,63],"s":[4,1,2],"l":1,"c":0,"e":16767098,"t":5},{"p":[198,0,242],"s":[123,42,120],"c":5799880,"t":5,"bo":1},{"p":[198,42,242],"s":[130,2,128],"c":8553090,"t":5,"bo":1},{"p":[167,0,311],"s":[30,61,18],"c":7368816,"t":5,"bo":1},{"p":[303,6,186],"s":[23,27,23],"l":1,"c":4743462,"t":5},{"p":[331,10,205],"s":[31,30,30],"l":1,"c":7576379,"t":5},{"p":[-121,0,322],"s":[123,60,120],"c":12951902,"t":5,"bo":1},{"p":[-121,60,322],"s":[130,2,126],"c":6908265,"t":5,"bo":1},{"p":[-58,35,356],"s":[3,1,14],"l":1,"c":6250335,"t":5},{"p":[-58,36,356],"s":[1,12,1],"l":1,"c":6250335,"t":5},{"p":[-59,36,362],"s":[2,12,1],"l":1,"c":6250335,"t":5},{"p":[-59,36,350],"s":[2,12,1],"l":1,"c":6250335,"t":5},{"p":[-59,48,356],"s":[3,1,14],"l":1,"c":6250335,"t":5},{"p":[-59,36,356],"s":[1,12,11],"l":1,"c":0,"e":16767098,"t":5},{"p":[-112,35,261],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[-112,36,262],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-106,36,262],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-118,36,262],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-112,48,262],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[-112,36,262],"s":[11,12,1],"l":1,"c":0,"e":16767098,"t":5},{"p":[77,49,-131],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[77,50,-132],"s":[11,12,1],"l":1,"c":0,"e":16767098,"t":5},{"p":[71,50,-132],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[83,50,-132],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[77,62,-132],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[77,50,-132],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[95,47,-163],"s":[3,1,14],"l":1,"c":6250335,"t":5},{"p":[94,48,-163],"s":[1,12,11],"l":1,"c":0,"e":16767098,"t":5},{"p":[93,48,-157],"s":[4,13,1],"l":1,"c":6250335,"t":5},{"p":[94,60,-163],"s":[3,1,14],"l":1,"c":6250335,"t":5},{"p":[93,48,-169],"s":[4,13,1],"l":1,"c":6250335,"t":5},{"p":[93,48,-163],"s":[4,13,1],"l":1,"c":6250335,"t":5},{"p":[32,0,-109],"s":[23,2,6],"c":7368816,"t":5},{"p":[113,-1,298],"s":[4,28,4],"c":6574655,"t":5},{"p":[114,22,298],"s":[26,28,28],"c":5204775,"t":5,"bo":1},{"p":[-121,0,322],"s":[135,8,133],"c":6193707,"t":5},{"p":[124,11,-198],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[418,15,-183],"s":[26,33,28],"l":1,"c":7247414,"t":5},{"p":[163,2,422],"s":[113,78,116],"c":12927811,"t":5,"bo":1},{"p":[165,0,419],"s":[134,8,126],"c":6193707,"t":5},{"p":[85,0,498],"s":[2,73,2],"l":1,"c":7368816,"t":5},{"p":[79,71,498],"s":[10,2,2],"l":1,"c":7368816,"t":5},{"p":[75,70,188],"s":[10,2,4],"c":7368816,"t":5},{"p":[75,69,498],"s":[9,1,3],"l":1,"c":0,"e":16767098,"t":5},{"p":[163,80,422],"s":[123,3,125],"l":1,"c":5921370,"t":5,"bo":1},{"p":[106,54,387],"s":[1,12,11],"l":1,"c":0,"e":16767098,"t":5},{"p":[105,53,387],"s":[3,1,14],"l":1,"c":6250335,"t":5},{"p":[105,66,387],"s":[3,1,14],"l":1,"c":6250335,"t":5},{"p":[106,54,393],"s":[2,12,1],"l":1,"c":6250335,"t":5},{"p":[106,54,381],"s":[2,12,1],"l":1,"c":6250335,"t":5},{"p":[106,54,387],"s":[2,12,1],"l":1,"c":6250335,"t":5},{"p":[106,54,452],"s":[1,12,11],"l":1,"c":0,"e":16767098,"t":5},{"p":[105,53,452],"s":[3,1,14],"l":1,"c":6250335,"t":5},{"p":[105,66,452],"s":[3,1,14],"l":1,"c":6250335,"t":5},{"p":[106,54,446],"s":[2,12,1],"l":1,"c":6250335,"t":5},{"p":[106,54,458],"s":[2,12,1],"l":1,"c":6250335,"t":5},{"p":[106,54,452],"s":[2,12,1],"l":1,"c":6250335,"t":5},{"p":[253,-1,376],"s":[4,28,4],"l":1,"c":6574655,"t":5},{"p":[253,22,376],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[-224,19,248],"s":[26,28,28],"l":1,"c":7709238,"t":5},{"p":[-224,-1,248],"s":[4,23,4],"l":1,"c":6574655,"t":5},{"p":[-89,0,470],"s":[104,135,116],"c":10658466,"t":5},{"p":[-30,-1,392],"s":[4,31,4],"c":6574655,"t":5},{"p":[-30,23,392],"s":[27,28,24],"c":6193707,"t":5},{"p":[-89,135,470],"s":[110,3,122],"l":1,"c":5921370,"t":5},{"p":[-89,65,470],"s":[111,5,124],"c":5921370,"t":5},{"p":[-27,0,651],"s":[2,73,2],"l":1,"c":7368816,"t":5},{"p":[-21,71,651],"s":[10,2,2],"l":1,"c":7368816,"t":5},{"p":[-17,70,651],"s":[10,2,4],"l":1,"c":7368816,"t":5},{"p":[-17,69,651],"s":[9,1,3],"l":1,"c":0,"e":16767098,"t":5},{"p":[107,-1,504],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[107,21,504],"s":[27,28,24],"l":1,"c":6193707,"t":5},{"p":[156,0,621],"s":[123,84,120],"l":1,"c":12951902,"t":5},{"p":[-97,0,686],"s":[123,52,120],"l":1,"c":5799880,"t":5},{"p":[-97,52,686],"s":[131,4,132],"l":1,"c":5723991,"t":5},{"p":[156,84,621],"s":[131,5,132],"l":1,"c":5723991,"t":5},{"p":[489,22,19],"s":[26,28,28],"l":1,"c":6324784,"t":5},{"p":[427,18,111],"s":[26,28,28],"l":1,"c":6324784,"t":5},{"p":[446,15,26],"s":[27,30,30],"l":1,"c":7576379,"t":5},{"p":[387,13,187],"s":[23,27,23],"l":1,"c":4743462,"t":5},{"p":[458,18,69],"s":[23,24,27],"l":1,"c":4743462,"t":5},{"p":[727,0,-41],"s":[104,74,79],"l":1,"c":10658466,"t":5},{"p":[687,74,-41],"s":[24,48,26],"l":1,"c":10658466,"t":5},{"p":[727,74,-41],"s":[105,6,76],"l":1,"c":10658466,"t":5},{"p":[687,121,-41],"s":[31,6,32],"l":1,"c":7890002,"t":5},{"p":[687,127,-41],"s":[22,13,19],"l":1,"c":7890002,"t":5},{"p":[727,80,-41],"s":[105,6,54],"l":1,"c":10658466,"t":5},{"p":[727,84,-61],"s":[115,6,53],"l":1,"r":[-0.52,0,0],"c":7890002,"t":5},{"p":[681,154,-41],"s":[2,25,2],"l":1,"c":7890002,"t":5},{"p":[681,171,-41],"s":[2,2,14],"l":1,"c":7890002,"t":5},{"p":[687,124,-30],"s":[22,33,11],"l":1,"r":[-0.35,0,0],"c":7890002,"t":5},{"p":[687,124,-52],"s":[22,33,11],"l":1,"r":[0.35,0,0],"c":7890002,"t":5},{"p":[727,84,-22],"s":[115,6,51],"l":1,"r":[0.53,0,0],"c":7890002,"t":5},{"p":[727,80,-41],"s":[105,12,34],"l":1,"c":10658466,"t":5},{"p":[674,0,-41],"s":[2,57,32],"l":1,"c":7890002,"t":5},{"p":[692,16,-106],"s":[26,31,28],"l":1,"c":6324784,"t":5},{"p":[691,-1,-106],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[648,17,8],"s":[26,34,28],"l":1,"c":6324784,"t":5},{"p":[648,-1,9],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[458,17,-140],"s":[26,31,28],"l":1,"c":6324784,"t":5},{"p":[621,18,-154],"s":[26,28,28],"l":1,"c":6324784,"t":5},{"p":[621,-1,-154],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[208,0,-376],"s":[121,69,83],"l":1,"c":10658466,"t":5},{"p":[674,108,-41],"s":[1,9,9],"l":1,"c":0,"e":16767098,"t":5},{"p":[673,113,-41],"s":[1,4,1],"l":1,"c":2960685,"t":5},{"p":[673,113,-41],"s":[1,4,1],"l":1,"r":[2.09,0,0],"c":2960685,"t":5},{"p":[674,64,-41],"s":[2,19,4],"l":1,"c":2105376,"t":5},{"p":[752,18,167],"s":[39,24,1182],"l":1,"c":4743462,"t":5},{"p":[611,18,-401],"s":[257,31,27],"l":1,"c":6060596,"t":5},{"p":[592,31,-395],"s":[38,34,28],"l":1,"c":6324784,"t":5},{"p":[737,15,-383],"s":[47,36,49],"l":1,"c":6324784,"t":5},{"p":[746,22,-200],"s":[38,28,38],"l":1,"c":6324784,"t":5},{"p":[746,22,-292],"s":[38,33,38],"l":1,"c":6324784,"t":5},{"p":[748,0,-142],"s":[4,23,132],"l":1,"c":6574655,"t":5},{"p":[758,0,-298],"s":[4,23,219],"l":1,"c":6574655,"t":5},{"p":[735,-1,-287],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[27,0,172],"s":[1506,0,1212],"i":4,"c":"#728447","t":5},{"p":[640,0,-405],"s":[307,23,5],"l":1,"c":6574655,"t":5},{"p":[542,-1,-391],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[610,18,-235],"s":[26,28,28],"l":1,"c":6324784,"t":5},{"p":[610,-1,-235],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[460,-1,-324],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[460,18,-324],"s":[26,28,28],"l":1,"c":6324784,"t":5},{"p":[748,0,331],"s":[4,23,852],"l":1,"c":6574655,"t":5},{"p":[501,17,-113],"s":[26,28,28],"l":1,"c":6324784,"t":5},{"p":[459,9,-102],"s":[25,26,25],"l":1,"c":5732402,"t":5},{"p":[451,22,93],"s":[26,24,25],"l":1,"c":6984507,"t":5},{"p":[439,10,60],"s":[26,28,29],"l":1,"c":6324784,"t":5},{"p":[424,15,135],"s":[30,28,27],"l":1,"c":4743462,"t":5},{"p":[501,16,-8],"s":[29,25,29],"l":1,"c":4941357,"t":5},{"p":[530,9,-52],"s":[29,25,29],"l":1,"c":5732402,"t":5},{"p":[595,9,107],"s":[29,25,29],"l":1,"c":5732402,"t":5},{"p":[418,13,183],"s":[29,25,29],"l":1,"c":5732402,"t":5},{"p":[477,20,166],"s":[27,30,30],"l":1,"c":7576379,"t":5},{"p":[746,22,77],"s":[38,28,44],"l":1,"c":6324784,"t":5},{"p":[746,22,140],"s":[38,29,41],"l":1,"c":6588720,"t":5},{"p":[746,23,254],"s":[38,28,34],"l":1,"c":6324784,"t":5},{"p":[746,18,349],"s":[38,29,74],"l":1,"c":6324784,"t":5},{"p":[450,14,-177],"s":[25,30,25],"l":1,"c":5732402,"t":5},{"p":[166,0,-429],"s":[1786,23,5],"l":1,"c":5917499,"t":5},{"p":[-81,19,-418],"s":[1233,31,27],"l":1,"c":6060596,"t":5},{"p":[436,16,-407],"s":[38,37,28],"l":1,"c":5665581,"t":5},{"p":[319,17,-407],"s":[38,37,28],"l":1,"c":5665581,"t":5},{"p":[437,-1,-401],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[318,-1,-401],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[291,-1,-412],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[371,-1,-412],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[376,31,-439],"s":[38,33,28],"l":1,"c":5665581,"t":5},{"p":[291,-1,-234],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[291,8,-237],"s":[31,33,28],"l":1,"c":6324784,"t":5},{"p":[208,69,-376],"s":[128,3,89],"l":1,"c":6381921,"t":5},{"p":[399,-1,45],"s":[4,26,4],"c":7692103,"t":5},{"p":[408,-1,-415],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[242,47,-334],"s":[11,12,1],"l":1,"c":0,"e":16767098,"t":5},{"p":[173,47,-334],"s":[11,12,1],"l":1,"c":0,"e":16767098,"t":5},{"p":[173,46,-333],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[173,59,-333],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[242,59,-333],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[242,46,-333],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[167,47,-334],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[179,47,-334],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[236,47,-334],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[248,47,-334],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[242,47,-334],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[173,47,-334],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-24,112,468],"s":[2,9,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-27,66,470],"s":[14,57,3],"l":1,"c":5921370,"t":5},{"p":[-30,112,468],"s":[2,9,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-27,116,468],"s":[4,2,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-24,101,468],"s":[2,9,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-30,101,468],"s":[2,9,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-27,101,468],"s":[4,2,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-27,108,468],"s":[4,2,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-27,90,468],"s":[2,9,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-27,97,468],"s":[8,2,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-25,79,468],"s":[2,9,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-27,86,468],"s":[6,2,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-27,79,468],"s":[6,2,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-27,82,468],"s":[6,2,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-25,68,468],"s":[2,9,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-28,68,468],"s":[6,2,1],"l":1,"c":5723991,"e":16711680,"t":5},{"p":[-37,108,470],"s":[6,3,3],"l":1,"c":5921370,"t":5},{"p":[-37,77,470],"s":[6,3,3],"l":1,"c":5921370,"t":5},{"p":[65,1,654],"s":[51,15,20],"i":7,"l":1,"r":[0,-1.57,0]},{"p":[32,0,814],"s":[79,135,116],"l":1,"c":10658466,"t":5},{"p":[32,135,814],"s":[87,3,124],"l":1,"c":6052956,"t":5},{"p":[88,-1,709],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[90,17,708],"s":[27,28,24],"l":1,"c":6193707,"t":5},{"p":[-33,-1,770],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[-34,16,770],"s":[27,28,24],"l":1,"c":6193707,"t":5},{"p":[115,-2,958],"s":[113,65,116],"l":1,"c":12927811,"t":5},{"p":[115,63,958],"s":[124,5,126],"l":1,"c":5066061,"t":5},{"p":[-63,-18,928],"s":[123,112,120],"l":1,"c":12951902,"t":5},{"p":[-63,93,928],"s":[131,4,127],"l":1,"c":7368816,"t":5},{"p":[-155,-75,1251],"s":[79,289,61],"l":1,"c":10658466,"t":5},{"p":[151,-31,1120],"s":[108,142,61],"l":1,"c":10658466,"t":5},{"p":[308,0,1120],"s":[79,220,61],"l":1,"c":10658466,"t":5},{"p":[-269,-31,1008],"s":[108,142,113],"l":1,"c":10658466,"t":5},{"p":[437,0,747],"s":[677,23,5],"l":1,"c":6574655,"t":5},{"p":[609,21,751],"s":[315,24,44],"l":1,"c":4743462,"t":5},{"p":[269,21,751],"s":[374,27,53],"l":1,"c":4743462,"t":5},{"p":[525,20,744],"s":[38,29,41],"l":1,"c":6588720,"t":5},{"p":[744,18,739],"s":[43,35,46],"l":1,"c":6588720,"t":5},{"p":[333,22,743],"s":[38,32,41],"l":1,"c":6588720,"t":5},{"p":[636,20,744],"s":[38,29,41],"l":1,"c":6588720,"t":5},{"p":[746,23,557],"s":[38,28,34],"l":1,"c":6324784,"t":5},{"p":[443,24,258],"s":[23,24,23],"l":1,"c":4743462,"t":5},{"p":[359,11,197],"s":[24,24,30],"l":1,"c":6390324,"t":5},{"p":[313,13,245],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[369,60,323],"s":[132,3,130],"l":1,"c":6250335,"t":5},{"p":[369,-4,323],"s":[123,64,120],"l":1,"c":12951902,"t":5},{"p":[252,12,-209],"s":[26,28,28],"l":1,"c":4940075,"t":5},{"p":[208,-1,-370],"s":[137,10,89],"c":6984507,"t":5},{"p":[373,18,-259],"s":[26,28,28],"l":1,"c":6324784,"t":5},{"p":[247,24,743],"s":[38,32,41],"l":1,"c":6588720,"t":5},{"p":[571,-57,1262],"s":[79,220,61],"l":1,"c":10658466,"t":5},{"p":[563,13,53],"s":[29,25,29],"l":1,"c":5732402,"t":5},{"p":[439,5,10],"s":[29,25,29],"l":1,"c":5732402,"t":5},{"p":[288,9,-185],"s":[25,26,25],"l":1,"c":5732402,"t":5},{"p":[337,14,-183],"s":[25,26,25],"l":1,"c":6720572,"t":5},{"p":[164,6,-221],"s":[25,30,25],"l":1,"c":5732402,"t":5},{"p":[213,12,-250],"s":[21,25,21],"l":1,"c":5732402,"t":5},{"p":[368,15,-183],"s":[26,27,28],"l":1,"c":6324784,"t":5},{"p":[392,11,-194],"s":[25,26,25],"l":1,"c":5666099,"t":5},{"p":[316,5,-203],"s":[25,26,25],"l":1,"c":5666099,"t":5},{"p":[439,8,83],"s":[29,25,29],"l":1,"c":5732402,"t":5},{"p":[212,18,-319],"s":[26,28,28],"l":1,"c":6324784,"t":5},{"p":[51,31,-439],"s":[38,33,28],"l":1,"c":5665581,"t":5},{"p":[111,17,-407],"s":[38,37,28],"l":1,"c":5665581,"t":5},{"p":[25,-1,-412],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[111,-1,-401],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[73,-1,-407],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[-92,17,-407],"s":[38,37,28],"l":1,"c":5665581,"t":5},{"p":[-175,27,-427],"s":[38,33,28],"l":1,"c":5665581,"t":5},{"p":[-175,27,-427],"s":[38,33,28],"l":1,"c":5665581,"t":5},{"p":[-90,-1,-400],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[-174,-1,-418],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[-67,22,-274],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[-66,-1,-273],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[-12,50,-132],"s":[11,12,1],"l":1,"c":0,"e":16767098,"t":5},{"p":[-12,49,-131],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[-12,62,-132],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[-18,50,-132],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-6,50,-132],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-12,50,-132],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-63,10,-181],"s":[25,30,25],"l":1,"c":6851648,"t":5},{"p":[32,26,-126],"s":[16,13,22],"c":12958048,"t":5,"bo":1},{"p":[125,-1,2],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[128,0,89],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[88,-1,82],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[142,-1,128],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[-37,-1,-55],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[239,3,-66],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":9671571,"t":5},{"p":[-38,3,157],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":9671571,"t":5},{"p":[-247,-1,-414],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[-341,-1,-413],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[-252,15,-427],"s":[51,58,28],"l":1,"c":5665581,"t":5},{"p":[-372,15,-411],"s":[48,41,35],"l":1,"c":5665581,"t":5},{"p":[-212,10,-177],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[-156,-1,235],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[-157,15,235],"s":[26,28,28],"l":1,"c":7709238,"t":5},{"p":[165,-1,-213],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[203,-1,-186],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[124,-1,-188],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[285,-1,-185],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[250,-1,-202],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[-125,-1,-105],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[-262,-1,-17],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[-245,-1,190],"s":[4,2,6],"c":7368816,"t":5},{"p":[392,-1,40],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[265,-1,-65],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[109,-1,-146],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[213,-1,-318],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[213,-1,-248],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[55,-1,-407],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[24,1,395],"s":[51,15,20],"i":7,"l":1,"r":[3.14,-1.22,3.14]},{"p":[-259,17,231],"s":[26,28,28],"l":1,"c":7709238,"t":5},{"p":[-203,18,291],"s":[26,26,28],"l":1,"c":6193707,"t":5},{"p":[-203,-1,292],"s":[4,23,4],"l":1,"c":6574655,"t":5},{"p":[-155,-75,1251],"s":[4,341,4],"l":1,"c":10658466,"t":5},{"p":[308,85,1120],"s":[4,189,2],"l":1,"c":10658466,"t":5},{"p":[-102,-1,-180],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[-64,-1,-180],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[-285,-1,-78],"s":[4,2,4],"l":1,"c":7368816,"t":5},{"p":[-39,-1,-141],"s":[4,2,4],"l":1,"c":7368816,"t":5},{"p":[350,-1,5],"s":[4,2,4],"l":1,"c":7368816,"t":5},{"p":[427,-1,-136],"s":[4,2,4],"l":1,"c":7368816,"t":5},{"p":[327,-1,154],"s":[4,2,4],"l":1,"c":7368816,"t":5},{"p":[200,-1,121],"s":[4,2,4],"c":7368816,"t":5},{"p":[-11,0,-75],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[133,0,15],"s":[1,15,3],"l":1,"r":[0,0,-0.17],"c":7692103,"t":5},{"p":[133,0,11],"s":[1,15,3],"l":1,"r":[0,0,-0.17],"c":7692103,"t":5},{"p":[-47,2,22],"s":[4,36,76],"c":5799880,"t":5},{"p":[-253,16,-176],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[-182,0,-245],"s":[121,51,83],"c":13619151,"t":5},{"p":[-209,-1,-176],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[-183,66,-58],"s":[4,1,1],"l":1,"c":9012870,"t":5},{"p":[-185,64,-58],"s":[4,2,3],"l":1,"c":9012870,"t":5},{"p":[-185,63,-58],"s":[3,1,2],"l":1,"c":0,"e":16767098,"t":5},{"p":[-182,51,-245],"s":[130,3,95],"c":7039851,"t":5},{"p":[-173,31,-203],"s":[11,12,1],"l":1,"c":0,"e":16767098,"t":5},{"p":[-179,31,-203],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-167,31,-203],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-173,31,-203],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-173,30,-203],"s":[14,1,4],"l":1,"c":6250335,"t":5},{"p":[-173,43,-203],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[-392,0,747],"s":[677,23,5],"l":1,"c":6574655,"t":5},{"p":[-385,21,751],"s":[691,27,53],"l":1,"c":4743462,"t":5},{"p":[-405,0,-51],"s":[123,60,120],"c":12951902,"t":5},{"p":[-403,60,-51],"s":[130,2,130],"c":5263440,"t":5},{"p":[-316,15,11],"s":[26,30,28],"l":1,"c":7709238,"t":5},{"p":[-320,-1,173],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[-707,19,165],"s":[44,31,1300],"l":1,"c":6060596,"t":5},{"p":[-694,0,183],"s":[1,23,1208],"l":1,"c":6574655,"t":5},{"p":[-343,40,-83],"s":[1,12,11],"l":1,"c":0,"e":16767098,"t":5},{"p":[-344,52,-83],"s":[4,1,13],"l":1,"c":6250335,"t":5},{"p":[-343,39,-83],"s":[4,1,14],"l":1,"c":6250335,"t":5},{"p":[-344,40,-89],"s":[4,12,1],"l":1,"c":6250335,"t":5},{"p":[-344,40,-77],"s":[4,12,1],"l":1,"c":6250335,"t":5},{"p":[-344,40,-83],"s":[4,12,1],"l":1,"c":6250335,"t":5},{"p":[-315,5,-45],"s":[26,30,28],"l":1,"c":6786608,"t":5},{"p":[-371,-25,16],"s":[27,105,15],"c":6579300,"t":5},{"p":[-310,16,-166],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[-310,-1,-167],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[-290,11,-213],"s":[26,30,28],"l":1,"c":7709238,"t":5},{"p":[-270,16,-274],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[-269,-1,-271],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[-334,16,-216],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[-328,-1,-219],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[-42,0,25],"s":[6,9,78],"c":6984507,"t":5},{"p":[17,2,-126],"s":[14,37,22],"c":12958048,"t":5,"bo":1},{"p":[32,2,-119],"s":[16,24,2],"pe":1,"c":7692103,"t":5,"bo":1},{"p":[47,2,-126],"s":[14,37,22],"c":12958048,"t":5,"bo":1},{"p":[-255,-1,230],"s":[4,23,4],"l":1,"c":6574655,"t":5},{"p":[275,-1,183],"s":[4,28,4],"l":1,"c":6574655,"t":5},{"p":[32,42,-132],"s":[29,18,1],"l":1,"c":0,"e":16767098,"t":5},{"p":[17,42,-132],"s":[1,18,2],"l":1,"c":6250335,"t":5},{"p":[32,42,-132],"s":[1,18,2],"l":1,"c":6250335,"t":5},{"p":[32,60,-132],"s":[31,1,3],"l":1,"c":6250335,"t":5},{"p":[11,42,-116],"s":[2,8,2],"l":1,"c":5263440,"t":5},{"p":[53,42,-116],"s":[2,8,2],"l":1,"c":5263440,"t":5},{"p":[53,42,-131],"s":[2,8,2],"l":1,"c":5263440,"t":5},{"p":[11,42,-131],"s":[2,8,2],"l":1,"c":5263440,"t":5},{"p":[11,42,-123],"s":[1,7,1],"l":1,"c":5263440,"t":5},{"p":[53,42,-124],"s":[1,7,1],"l":1,"c":5263440,"t":5},{"p":[46,42,-116],"s":[1,7,1],"l":1,"c":5263440,"t":5},{"p":[18,42,-116],"s":[1,7,1],"l":1,"c":5263440,"t":5},{"p":[27,42,-116],"s":[1,7,1],"l":1,"c":5263440,"t":5},{"p":[36,42,-116],"s":[1,7,1],"l":1,"c":5263440,"t":5},{"p":[32,49,-116],"s":[42,1,2],"l":1,"c":5263440,"t":5},{"p":[53,49,-124],"s":[2,1,14],"l":1,"c":5263440,"t":5},{"p":[11,49,-123],"s":[2,1,14],"l":1,"c":5263440,"t":5},{"p":[-183,36,-58],"s":[4,2,20],"c":7368816,"t":5},{"p":[306,36,64],"s":[4,2,20],"c":7368816,"t":5},{"p":[47,42,-132],"s":[1,18,2],"l":1,"c":6250335,"t":5},{"p":[340,-1,-182],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[369,-1,-182],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[419,-1,-183],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[391,-1,-193],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[-70,2,160],"s":[3,6,6],"l":1,"c":12927811,"t":5},{"p":[-70,7,162],"s":[1,3,1],"l":1,"c":8882055,"t":5},{"p":[98,2,-212],"s":[14,100,25],"c":7368816,"t":11},{"p":[-397,16,-128],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[-389,-1,-128],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[-689,15,-307],"s":[48,41,58],"l":1,"c":5665581,"t":5},{"p":[-689,17,-208],"s":[48,41,41],"l":1,"c":5665581,"t":5},{"p":[-574,17,-413],"s":[48,41,35],"l":1,"c":5665581,"t":5},{"p":[-404,17,-176],"s":[26,31,28],"l":1,"c":5204775,"t":5},{"p":[-405,-1,-177],"s":[4,34,4],"l":1,"c":6574655,"t":5},{"p":[-460,15,-411],"s":[36,43,35],"l":1,"c":5665581,"t":5},{"p":[369,39,263],"s":[11,12,1],"l":1,"c":0,"e":16767098,"t":5},{"p":[369,38,262],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[369,51,263],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[375,39,263],"s":[1,12,3],"l":1,"c":6250335,"t":5},{"p":[363,39,263],"s":[1,12,3],"l":1,"c":6250335,"t":5},{"p":[369,39,263],"s":[1,12,3],"l":1,"c":6250335,"t":5},{"p":[-372,0,98],"s":[104,106,116],"l":1,"c":10658466,"t":5},{"p":[-372,105,98],"s":[115,3,126],"l":1,"c":7368816,"t":5},{"p":[-366,17,737],"s":[48,41,41],"l":1,"c":5665581,"t":5},{"p":[-489,17,737],"s":[66,36,41],"l":1,"c":5665581,"t":5},{"p":[-205,17,737],"s":[66,36,41],"l":1,"c":5665581,"t":5},{"p":[-624,17,737],"s":[66,39,41],"l":1,"c":5665581,"t":5},{"p":[-689,17,202],"s":[48,41,41],"l":1,"c":5665581,"t":5},{"p":[-689,17,318],"s":[48,41,41],"l":1,"c":5665581,"t":5},{"p":[-306,23,205],"s":[26,26,28],"l":1,"c":6193707,"t":5},{"p":[-306,-1,205],"s":[4,31,4],"l":1,"c":6574655,"t":5},{"p":[-290,12,243],"s":[26,28,28],"l":1,"c":8695624,"t":5},{"p":[-288,-1,249],"s":[4,23,4],"l":1,"c":6574655,"t":5},{"p":[126,0,60],"s":[2,37,2],"pe":1,"c":7692103,"t":5},{"p":[126,0,98],"s":[2,37,2],"pe":1,"c":7692103,"t":5},{"p":[-161,-1,205],"s":[4,26,4],"c":7692103,"t":5},{"p":[-290,-1,-49],"s":[4,26,4],"c":7692103,"t":5},{"p":[238,-1,-156],"s":[4,26,4],"c":7692103,"t":5},{"p":[182,-1,159],"s":[4,26,4],"c":7692103,"t":5},{"p":[296,-1,159],"s":[4,26,4],"c":7692103,"t":5},{"p":[1009,10,134],"s":[65,76,76],"l":1,"c":6324784,"t":5},{"p":[995,21,-386],"s":[65,53,76],"l":1,"c":6324784,"t":5},{"p":[555,21,-559],"s":[137,54,76],"l":1,"c":6324784,"t":5},{"p":[924,10,606],"s":[74,74,87],"l":1,"c":6324784,"t":5},{"p":[-289,-7,309],"s":[82,106,86],"l":1,"c":10658466,"t":5},{"p":[849,-8,-520],"s":[65,84,76],"l":1,"c":6324784,"t":5},{"p":[661,-4,165],"s":[123,64,120],"l":1,"c":12951902,"t":5},{"p":[661,60,165],"s":[132,4,131],"l":1,"c":6381921,"t":5},{"p":[-289,99,309],"s":[89,4,93],"l":1,"c":7895160,"t":5},{"p":[-345,18,247],"s":[26,26,28],"l":1,"c":6193707,"t":5},{"p":[-431,14,166],"s":[26,26,28],"l":1,"c":6193707,"t":5},{"p":[-269,74,266],"s":[11,12,1],"l":1,"c":0,"e":16767098,"t":5},{"p":[-269,73,265],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[-269,86,266],"s":[14,1,3],"l":1,"c":6250335,"t":5},{"p":[-263,74,266],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-275,74,266],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[-269,74,266],"s":[1,12,2],"l":1,"c":6250335,"t":5},{"p":[995,17,-153],"s":[65,68,47],"l":1,"c":6324784,"t":5},{"p":[-136,3,-80],"s":[7,32,23],"c":8355711,"t":5},{"p":[-130,3,-80],"s":[7,29,23],"c":8355711,"t":5},{"p":[-124,3,-80],"s":[7,26,23],"c":8355711,"t":5},{"p":[-118,3,-80],"s":[7,23,23],"c":8355711,"t":5},{"p":[-112,3,-80],"s":[7,20,23],"c":8355711,"t":5},{"p":[-106,3,-80],"s":[7,17,23],"c":8355711,"t":5},{"p":[-100,3,-80],"s":[7,14,23],"c":8355711,"t":5},{"p":[-94,3,-80],"s":[7,11,23],"c":8355711,"t":5},{"p":[-88,3,-80],"s":[7,8,23],"c":8355711,"t":5},{"p":[-82,3,-80],"s":[7,5,23],"c":8355711,"t":5},{"p":[-76,2,-80],"s":[7,3,23],"c":8355711,"t":5},{"p":[-102,2,-80],"s":[72,36,24],"i":9,"v":1,"t":5,"d":2},{"p":[-125,3,54],"s":[4,0,5],"i":4,"l":1,"r":[0,1.04,0],"c":11184810,"t":5},{"p":[251,3,98],"s":[7,32,23],"c":8355711,"t":5},{"p":[244,3,98],"s":[7,29,23],"c":8355711,"t":5},{"p":[237,3,98],"s":[7,26,23],"c":8355711,"t":5},{"p":[230,3,98],"s":[7,23,23],"c":8355711,"t":5},{"p":[223,3,98],"s":[7,20,23],"c":8355711,"t":5},{"p":[216,3,98],"s":[7,17,23],"c":8355711,"t":5},{"p":[209,3,98],"s":[7,14,23],"c":8355711,"t":5},{"p":[202,3,98],"s":[7,11,23],"c":8355711,"t":5},{"p":[195,3,98],"s":[7,8,23],"c":8355711,"t":5},{"p":[188,3,98],"s":[7,5,23],"c":8355711,"t":5},{"p":[181,2,98],"s":[7,3,23],"c":8355711,"t":5},{"p":[212,2,98],"s":[84,36,24],"i":9,"v":1,"t":5},{"p":[137,-1,-156],"s":[4,26,4],"c":7692103,"t":5},{"p":[119,0,-15],"s":[12,12,12],"i":1},{"p":[-47,-1,357],"s":[38,24,2],"c":7692103,"t":10,"bo":1},{"p":[116,-1,275],"s":[41,24,2],"pe":1,"c":7692103,"t":10,"bo":1},{"p":[70,2,357],"s":[4,0,5],"i":4,"l":1,"r":[0,-1.23,0],"c":10329501,"t":5},{"p":[-12,2,249],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":10329501,"t":5},{"p":[-49,-1,265],"s":[21,24,2],"c":7692103,"t":10,"bo":1},{"p":[-29,-1,357],"s":[4,26,4],"c":7692103,"t":5},{"p":[41,-1,365],"s":[3,12,1],"l":1,"r":[0.35,0,0],"c":13158600,"t":5},{"p":[58,9,369],"s":[40,3,1],"l":1,"c":13158600,"t":5},{"p":[41,-1,373],"s":[3,12,1],"l":1,"r":[-0.35,0,0],"c":13158600,"t":5},{"p":[75,-1,365],"s":[3,12,1],"l":1,"r":[0.35,0,0],"c":13158600,"t":5},{"p":[75,-1,373],"s":[3,12,1],"l":1,"r":[-0.35,0,0],"c":13158600,"t":5},{"p":[3,9,369],"s":[40,3,1],"l":1,"c":13158600,"t":5},{"p":[-14,-1,365],"s":[3,12,1],"l":1,"r":[0.35,0,0],"c":13158600,"t":5},{"p":[20,-1,365],"s":[3,12,1],"l":1,"r":[0.35,0,0],"c":13158600,"t":5},{"p":[-14,-1,373],"s":[3,12,1],"l":1,"r":[-0.35,0,0],"c":13158600,"t":5},{"p":[20,-1,373],"s":[3,12,1],"l":1,"r":[-0.35,0,0],"c":13158600,"t":5},{"p":[58,1,382],"s":[12,12,12],"i":1},{"p":[-31,0,369],"s":[12,12,12],"i":1},{"p":[-5,1,377],"s":[12,12,12],"i":1},{"p":[47,1,378],"s":[6,8,6],"i":2},{"p":[34,1,368],"s":[6,8,6],"i":2},{"p":[89,0,373],"s":[12,12,12],"i":1},{"p":[73,2,406],"s":[4,0,5],"i":4,"l":1,"r":[3.14,-1.39,3.14],"c":10329501,"t":5},{"p":[75,2,282],"s":[4,0,5],"i":4,"l":1,"r":[0,-1.4,0],"c":10329501,"t":5},{"p":[90,0,266],"s":[6,8,6],"i":2},{"p":[100,-1,348],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[164,-1,342],"s":[2,27,48],"pe":1,"c":7692103,"t":10,"bo":1},{"p":[133,0,292],"s":[6,8,6],"i":2},{"p":[24,-1,428],"s":[168,13,119],"v":1,"t":5,"bo":1},{"p":[-47,-1,363],"s":[37,13,14],"v":1,"t":5,"bo":1},{"p":[-20,1,372],"s":[6,8,6],"i":2},{"p":[188,-1,339],"s":[4,28,4],"l":1,"c":6574655,"t":5},{"p":[189,22,341],"s":[26,28,28],"l":1,"c":5204775,"t":5},{"p":[221,-1,351],"s":[1,7,1],"l":1,"c":6984507,"t":5},{"p":[289,-1,366],"s":[1,7,1],"l":1,"c":6984507,"t":5},{"p":[113,3,-37],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":9671571,"t":5},{"p":[167,3,-75],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":9671571,"t":5},{"p":[164,39,-13],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":9671571,"t":5},{"p":[249,39,47],"s":[4,0,5],"i":4,"l":1,"r":[0,-0.53,0],"c":9671571,"t":5},{"p":[-142,2,25],"s":[12,12,12],"i":1},{"p":[-175,2,-28],"s":[2,4,2],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-175,4,-28],"s":[1,4,1],"l":1,"pe":1,"c":5211204,"t":5},{"p":[243,2,8],"s":[1,17,3],"l":1,"r":[0,0,0.17],"c":7692103,"t":5},{"p":[-129,2,12],"s":[1,17,3],"l":1,"r":[0,0,0.17],"c":7692103,"t":5},{"p":[-139,2,74],"s":[1,17,3],"l":1,"r":[0,0,0.17],"c":7692103,"t":5},{"p":[-139,2,81],"s":[1,17,3],"l":1,"r":[0,0,0.17],"c":7692103,"t":5},{"p":[158,38,-22],"s":[2,4,2],"l":1,"pe":1,"c":5211204,"t":5},{"p":[158,40,-22],"s":[1,4,1],"l":1,"pe":1,"c":5211204,"t":5},{"p":[202,38,77],"s":[4,22,2],"l":1,"r":[0.17,0,0],"c":7692103,"t":5},{"p":[209,38,77],"s":[4,22,2],"l":1,"r":[0.17,0,0],"c":7692103,"t":5},{"p":[145,2,-22],"s":[2,4,2],"l":1,"pe":1,"c":5211204,"t":5},{"p":[145,4,-22],"s":[1,4,1],"l":1,"pe":1,"c":5211204,"t":5},{"p":[188,8,88],"s":[2,4,2],"l":1,"pe":1,"c":5211204,"t":5},{"p":[188,10,88],"s":[1,4,1],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-93,14,-70],"s":[2,4,2],"l":1,"pe":1,"c":5211204,"t":5},{"p":[-93,16,-70],"s":[1,4,1],"l":1,"pe":1,"c":5211204,"t":5},{"p":[145,39,105],"s":[4,0,5],"i":4,"l":1,"r":[0,1.39,0],"c":9671571,"t":5},{"p":[168,38,106],"s":[4,22,2],"l":1,"r":[0.17,0,0],"c":7692103,"t":5},{"p":[35,1,304],"s":[12,12,12],"i":1},{"p":[23,1,304],"s":[12,12,12],"i":1},{"p":[29,13,304],"s":[12,12,12],"i":1},{"p":[-92,32,-2],"s":[7,2,7],"c":9012870,"t":5},{"p":[-92,34,-2],"s":[3,2,3],"c":9012870,"t":5},{"p":[-92,31,-2],"s":[3,1,3],"l":1,"c":0,"e":16767098,"t":5},{"p":[-92,74,-2],"s":[3,2,3],"c":9012870,"t":5},{"p":[-92,72,-2],"s":[7,2,7],"c":9012870,"t":5},{"p":[-92,71,-2],"s":[3,1,3],"l":1,"c":0,"e":16767098,"t":5},{"p":[183,74,39],"s":[3,2,3],"c":9012870,"t":5},{"p":[183,72,39],"s":[7,2,7],"c":9012870,"t":5},{"p":[183,71,39],"s":[3,1,3],"l":1,"c":0,"e":16767098,"t":5},{"p":[183,34,39],"s":[3,2,3],"c":9012870,"t":5},{"p":[272,32,39],"s":[7,2,7],"c":9012870,"t":5},{"p":[183,31,39],"s":[3,1,3],"l":1,"c":0,"e":16767098,"t":5},{"p":[272,34,39],"s":[3,2,3],"c":9012870,"t":5},{"p":[183,32,39],"s":[7,2,7],"c":9012870,"t":5},{"p":[272,31,39],"s":[3,1,3],"l":1,"c":0,"e":16767098,"t":5},{"p":[294,2,23],"s":[12,12,12],"i":1},{"p":[288,3,9],"s":[4,0,5],"i":4,"l":1,"r":[-3.14,1.4,-3.14],"c":9671571,"t":5},{"p":[-163,32,-2],"s":[7,2,7],"c":9012870,"t":5},{"p":[-163,34,-2],"s":[3,2,3],"c":9012870,"t":5},{"p":[-163,31,-2],"s":[3,1,3],"l":1,"c":0,"e":16767098,"t":5},{"p":[28,1,305],"s":[72,50,63],"i":14,"l":1},{"p":[-89,38,-8],"s":[61,38,65],"i":14,"l":1},{"p":[184,2,37],"s":[61,33,59],"i":14,"l":1},{"p":[367,0,32],"s":[24,36,24],"i":23,"l":1,"tm":0},{"p":[-215,0,35],"s":[24,36,24],"i":23,"l":1,"tm":"1"},{"p":[-100,14,70],"s":[12,12,12],"i":1},{"p":[-100,2,70],"s":[12,12,12],"i":8},{"p":[-35,-1,-18],"s":[3,2,3],"l":1,"c":7368816,"t":5},{"p":[-35,-1,-28],"s":[3,2,3],"l":1,"c":7368816,"t":5},{"p":[-35,-1,-23],"s":[4,2,5],"l":1,"c":7368816,"t":5},{"p":[-29,-1,-28],"s":[5,2,4],"l":1,"c":7368816,"t":5},{"p":[-29,-1,-18],"s":[5,2,4],"l":1,"c":7368816,"t":5},{"p":[-29,-1,-23],"s":[3,2,3],"l":1,"c":7368816,"t":5},{"p":[127,-1,39],"s":[4,2,3],"l":1,"c":7368816,"t":5},{"p":[127,-1,49],"s":[4,2,3],"l":1,"c":7368816,"t":5},{"p":[127,-1,44],"s":[4,2,5],"l":1,"c":7368816,"t":5},{"p":[109,-1,40],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[121,-1,48],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[115,-1,44],"s":[4,2,5],"l":1,"c":7368816,"t":5},{"p":[103,-1,44],"s":[4,2,5],"l":1,"c":7368816,"t":5},{"p":[121,-1,40],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[109,-1,48],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[115,-1,49],"s":[4,2,3],"l":1,"c":7368816,"t":5},{"p":[115,-1,39],"s":[4,2,3],"l":1,"c":7368816,"t":5},{"p":[97,-1,48],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[97,-1,40],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[91,-1,44],"s":[4,2,5],"l":1,"c":7368816,"t":5},{"p":[85,-1,40],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[85,-1,48],"s":[4,2,6],"l":1,"c":7368816,"t":5},{"p":[103,-1,49],"s":[4,2,3],"l":1,"c":7368816,"t":5},{"p":[91,-1,49],"s":[4,2,3],"l":1,"c":7368816,"t":5},{"p":[91,-1,39],"s":[4,2,3],"l":1,"c":7368816,"t":5},{"p":[103,-1,39],"s":[4,2,3],"l":1,"c":7368816,"t":5},{"p":[-251,-1,141],"s":[4,26,4],"pe":1,"c":7692103,"t":5},{"p":[-251,-1,118],"s":[4,26,4],"pe":1,"c":7692103,"t":5},{"p":[220,82,43],"s":[178,4,152],"r":[0.09,0,0],"c":5263440,"t":5,"bo":1},{"p":[302,84,-1],"s":[4,3,46],"c":12927811,"t":5,"bo":1},{"p":[302,87,-13],"s":[4,3,22],"c":12927811,"t":5},{"p":[302,38,91],"s":[4,38,38],"c":12927811,"t":5,"bo":1},{"p":[302,76,91],"s":[4,3,38],"c":12927811,"t":5},{"p":[138,66,81],"s":[4,15,34],"c":12927811,"t":5,"bo":1},{"p":[138,87,-14],"s":[4,1,4],"c":12927811,"t":5},{"p":[56,1,115],"s":[6,8,6],"i":2},{"p":[56,6,111],"s":[1,3,1],"c":8882055,"t":5},{"p":[56,1,109],"s":[3,6,6],"c":12927811,"t":5},{"p":[40,10,48],"s":[24,2,100],"pe":1,"c":2899797,"t":5},{"p":[40,37,48],"s":[28,2,100],"pe":1,"c":"#2c3f55","t":5},{"p":[40,3,38],"s":[27,4,4],"c":8551805,"t":5},{"p":[40,3,22],"s":[27,4,4],"c":8551805,"t":5},{"p":[29,1,22],"s":[4,8,8],"c":1447446,"t":5},{"p":[29,1,38],"s":[4,8,8],"c":1447446,"t":5},{"p":[34,1,38],"s":[4,8,8],"c":1447446,"t":5},{"p":[34,1,22],"s":[4,8,8],"c":1447446,"t":5},{"p":[51,1,38],"s":[4,8,8],"c":1447446,"t":5},{"p":[46,1,38],"s":[4,8,8],"c":1447446,"t":5},{"p":[51,1,22],"s":[4,8,8],"c":1447446,"t":5},{"p":[46,1,22],"s":[4,8,8],"c":1447446,"t":5},{"p":[40,12,97],"s":[24,25,2],"pe":1,"c":"#2c3f55","t":5},{"p":[40,6,59],"s":[5,4,85],"c":8551805,"t":5},{"p":[40,6,-1],"s":[24,4,3],"c":8551805,"t":5},{"p":[47,12,-2],"s":[12,25,2],"pe":1,"c":"#6b6b6b","t":5},{"p":[26,12,3],"s":[2,25,12],"c":"#6b6b6b","t":5},{"p":[40,5,-1],"s":[27,1,4],"c":8551805,"t":5},{"p":[40,3,110],"s":[27,4,4],"c":8551805,"t":5},{"p":[51,1,110],"s":[4,8,8],"c":1447446,"t":5},{"p":[29,1,110],"s":[4,8,8],"c":1447446,"t":5},{"p":[50,7,-2],"s":[2,2,2],"l":1,"c":16730880,"e":16711680,"o":0.8,"t":5},{"p":[30,7,-2],"s":[2,2,2],"l":1,"c":"#ff4b00","e":16711680,"o":0.8,"t":5},{"p":[40,5,102],"s":[24,28,4],"c":"#bbbbbb","t":5},{"p":[40,5,118],"s":[24,24,4],"c":"#bbbbbb","t":5},{"p":[40,6,111],"s":[17,6,14],"c":"#595959","t":5},{"p":[40,5,121],"s":[25,6,3],"c":"#5c5c5c","t":5},{"p":[40,17,122],"s":[22,10,1],"l":1,"c":"#22272d","t":5},{"p":[40,11,121],"s":[24,6,2],"c":"#bbbbbb","t":5},{"p":[40,17,121],"s":[24,11,2],"l":1,"c":"#bbbbbb","t":5},{"p":[40,17,121],"s":[24,11,2],"v":1,"c":"#213041","t":5},{"p":[50,12,122],"s":[2,2,2],"l":1,"e":16765184,"o":0.8,"t":5},{"p":[30,12,122],"s":[2,2,2],"l":1,"e":16765184,"o":0.8,"t":5},{"p":[40,12,122],"s":[14,4,2],"c":"#6e6e6e","t":5},{"p":[40,20,118],"s":[28,4,1],"c":"#6e6e6e","t":5},{"p":[40,3,86],"s":[22,6,22],"c":8551805,"t":5},{"p":[30,12,100],"s":[1,25,1],"c":"#666666","e":1579032,"t":5},{"p":[50,12,100],"s":[1,25,1],"c":"#666666","e":1579032,"t":5},{"p":[40,8,49],"s":[28,2,98],"pe":1,"v":1,"c":2899797,"t":5},{"p":[40,20,113],"s":[25,8,8],"c":"#22272d","t":5},{"p":[40,12,111],"s":[24,18,14],"c":"#bbbbbb","t":5},{"p":[45,12,46],"s":[6,2,92],"l":1,"c":7035206,"t":2},{"p":[47,12,-3],"s":[4,25,2],"i":3,"t":2,"d":3},{"p":[11,1,22],"s":[4,7,4],"i":16,"l":1},{"p":[56,1,-12],"s":[4,7,4],"i":16,"l":1},{"p":[23,1,-12],"s":[4,7,4],"i":16,"l":1},{"p":[35,12,87],"s":[12,12,12],"i":8},{"p":[27,10,78],"s":[2,27,40],"pe":1,"c":"#2c3f55","t":5},{"p":[27,10,19],"s":[2,27,42],"pe":1,"c":"#2c3f55","t":5},{"p":[53,10,89],"s":[2,27,18],"pe":1,"c":"#2c3f55","t":5},{"p":[53,10,30],"s":[2,27,64],"pe":1,"c":"#2c3f55","t":5},{"p":[53,32,71],"s":[1,5,18],"c":"#ffffff","t":10},{"p":[27,32,49],"s":[1,5,18],"c":"#ffffff","t":10},{"p":[53,10,71],"s":[2,2,18],"c":"#2c3f55","t":5},{"p":[27,10,49],"s":[2,2,18],"c":"#2c3f55","t":5},{"p":[18,1,75],"s":[6,2,92],"c":8678483,"t":2},{"p":[11,1,74],"s":[6,2,92],"c":7692103,"t":2},{"p":[4,1,76],"s":[6,2,92],"c":5259054,"t":2},{"p":[6,3,75],"s":[6,2,92],"c":7692103,"t":2},{"p":[14,3,76],"s":[6,2,92],"c":7692103,"t":2},{"p":[10,5,76],"s":[6,2,92],"c":7035206,"t":2},{"p":[11,1,125],"s":[4,7,4],"i":16,"l":1},{"p":[-34,0,61],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[-37,0,-3],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[-26,0,37],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[-26,0,-44],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[-39,0,-96],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[-14,0,-105],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[-5,0,-102],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[6,0,-127],"s":[7,6,8],"i":18,"l":1},{"p":[36,-1,-101],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[60,0,-124],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[90,0,-128],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[99,0,-136],"s":[7,6,8],"i":18,"l":1,"r":[0,0.79,0],"c":"#d1f777"},{"p":[106,0,-118],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[106,0,-84],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[85,0,-29],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[131,-1,-22],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[84,0,12],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[131,0,27],"s":[7,6,8],"i":18,"l":1},{"p":[83,0,59],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[86,0,119],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[158,0,-153],"s":[7,6,8],"i":18,"l":1},{"p":[90,0,166],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[87,0,238],"s":[7,6,8],"i":18,"l":1},{"p":[-27,0,237],"s":[7,6,8],"i":18,"l":1},{"p":[-33,0,202],"s":[7,6,8],"i":18,"l":1},{"p":[-31,0,149],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[-25,0,122],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[-69,0,174],"s":[7,6,8],"i":18,"l":1},{"p":[-96,0,201],"s":[7,6,8],"i":18,"l":1},{"p":[-67,0,201],"s":[7,6,8],"i":18,"l":1},{"p":[-170,0,201],"s":[7,6,8],"i":18,"l":1},{"p":[-147,0,174],"s":[7,6,8],"i":18,"l":1},{"p":[-216,0,180],"s":[7,6,8],"i":18,"l":1},{"p":[-216,0,172],"s":[7,6,8],"i":18,"l":1},{"p":[-247,0,198],"s":[7,6,8],"i":18,"l":1},{"p":[-247,0,118],"s":[7,6,8],"i":18,"l":1},{"p":[-180,0,68],"s":[7,6,8],"i":18,"l":1},{"p":[-151,0,69],"s":[7,6,8],"i":18,"l":1},{"p":[-151,0,125],"s":[7,6,8],"i":18,"l":1},{"p":[-243,0,50],"s":[7,6,8],"i":18,"l":1},{"p":[-241,0,79],"s":[7,6,8],"i":18,"l":1},{"p":[-215,0,-5],"s":[7,6,8],"i":18,"l":1},{"p":[-184,0,-46],"s":[7,6,8],"i":18,"l":1},{"p":[-257,0,-12],"s":[7,6,8],"i":18,"l":1},{"p":[-254,0,-128],"s":[7,6,8],"i":18,"l":1},{"p":[-218,0,-88],"s":[7,6,8],"i":18,"l":1},{"p":[-196,0,-147],"s":[7,6,8],"i":18,"l":1},{"p":[-204,0,-143],"s":[7,6,8],"i":18,"l":1},{"p":[-134,0,-149],"s":[7,6,8],"i":18,"l":1},{"p":[-99,0,-113],"s":[7,6,8],"i":18,"l":1},{"p":[-158,0,-100],"s":[7,6,8],"i":18,"l":1},{"p":[-35,0,-153],"s":[7,6,8],"i":18,"l":1},{"p":[-65,0,-118],"s":[7,6,8],"i":18,"l":1},{"p":[-28,0,308],"s":[7,6,8],"i":18,"l":1},{"p":[103,0,279],"s":[7,6,8],"i":18,"l":1},{"p":[109,0,302],"s":[7,6,8],"i":18,"l":1},{"p":[85,0,338],"s":[7,6,8],"i":18,"l":1},{"p":[94,0,362],"s":[7,6,8],"i":18,"l":1},{"p":[144,0,353],"s":[7,6,8],"i":18,"l":1},{"p":[160,0,323],"s":[7,6,8],"i":18,"l":1},{"p":[-26,-1,381],"s":[7,6,8],"i":18,"l":1},{"p":[-33,-1,413],"s":[7,6,8],"i":18,"l":1},{"p":[84,-1,414],"s":[7,6,8],"i":18,"l":1},{"p":[133,0,69],"s":[7,6,8],"i":18,"l":1},{"p":[132,0,112],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[151,0,131],"s":[7,6,8],"i":18,"l":1},{"p":[189,0,132],"s":[7,6,8],"i":18,"l":1},{"p":[229,0,156],"s":[7,6,8],"i":18,"l":1},{"p":[271,0,118],"s":[7,6,8],"i":18,"l":1},{"p":[286,0,156],"s":[7,6,8],"i":18,"l":1},{"p":[334,0,156],"s":[7,6,8],"i":18,"l":1},{"p":[308,0,114],"s":[7,6,8],"i":18,"l":1},{"p":[308,0,59],"s":[7,6,8],"i":18,"l":1},{"p":[349,0,38],"s":[7,6,8],"i":18,"l":1},{"p":[371,0,135],"s":[7,6,8],"i":18,"l":1},{"p":[395,0,116],"s":[7,6,8],"i":18,"l":1},{"p":[391,0,22],"s":[7,6,8],"i":18,"l":1},{"p":[396,0,-1],"s":[7,6,8],"i":18,"l":1},{"p":[307,0,-18],"s":[7,6,8],"i":18,"l":1},{"p":[296,0,-34],"s":[7,6,8],"i":18,"l":1},{"p":[260,0,-35],"s":[7,6,8],"i":18,"l":1},{"p":[260,0,-72],"s":[7,6,8],"i":18,"l":1},{"p":[394,0,-43],"s":[7,6,8],"i":18,"l":1},{"p":[404,0,-49],"s":[7,6,8],"i":18,"l":1},{"p":[429,0,-60],"s":[7,6,8],"i":18,"l":1},{"p":[405,0,-153],"s":[7,6,8],"i":18,"l":1},{"p":[292,0,-154],"s":[7,6,8],"i":18,"l":1},{"p":[206,0,-125],"s":[7,6,8],"i":18,"l":1},{"p":[177,0,-154],"s":[7,6,8],"i":18,"l":1},{"p":[177,0,-147],"s":[7,6,8],"i":18,"l":1},{"p":[-10,0,-108],"s":[7,6,8],"i":18,"l":1},{"p":[64,0,-126],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[-287,0,-54],"s":[7,6,8],"i":18,"l":1},{"p":[108,-1,118],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[99,-1,152],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[124,0,151],"s":[7,6,8],"i":18,"l":1},{"p":[110,0,144],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[90,0,179],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[88,0,264],"s":[7,6,8],"i":18,"l":1},{"p":[-31,0,265],"s":[7,6,8],"i":18,"l":1},{"p":[-32,0,255],"s":[7,6,8],"i":18,"l":1},{"p":[-33,0,223],"s":[7,6,8],"i":18,"l":1},{"p":[105,-1,82],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[109,0,10],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[95,0,-62],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[74,-1,-113],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[96,0,-103],"s":[7,6,8],"i":18,"l":1,"c":"#d1f777"},{"p":[136,0,-148],"s":[7,6,8],"i":18,"l":1},{"p":[99,0,-154],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.61,0],"c":"#d1f777"},{"p":[170,0,-126],"s":[7,6,8],"i":18,"l":1},{"p":[211,0,-154],"s":[7,6,8],"i":18,"l":1},{"p":[243,0,-126],"s":[7,6,8],"i":18,"l":1},{"p":[262,0,-152],"s":[7,6,8],"i":18,"l":1},{"p":[308,0,-118],"s":[7,6,8],"i":18,"l":1},{"p":[287,0,-89],"s":[7,6,8],"i":18,"l":1},{"p":[325,0,-36],"s":[7,6,8],"i":18,"l":1},{"p":[333,0,-105],"s":[7,6,8],"i":18,"l":1},{"p":[307,0,-64],"s":[7,6,8],"i":18,"l":1},{"p":[359,0,-76],"s":[7,6,8],"i":18,"l":1},{"p":[364,0,-30],"s":[7,6,8],"i":18,"l":1},{"p":[376,0,55],"s":[7,6,8],"i":18,"l":1},{"p":[358,0,113],"s":[7,6,8],"i":18,"l":1},{"p":[386,0,155],"s":[7,6,8],"i":18,"l":1},{"p":[363,0,-118],"s":[7,6,8],"i":18,"l":1},{"p":[378,0,-148],"s":[7,6,8],"i":18,"l":1},{"p":[423,0,-148],"s":[7,6,8],"i":18,"l":1},{"p":[429,0,-105],"s":[7,6,8],"i":18,"l":1},{"p":[405,0,-98],"s":[7,6,8],"i":18,"l":1},{"p":[392,0,-121],"s":[7,6,8],"i":18,"l":1},{"p":[391,0,-99],"s":[7,6,8],"i":18,"l":1},{"p":[391,0,-79],"s":[7,6,8],"i":18,"l":1},{"p":[340,0,0],"s":[7,6,8],"i":18,"l":1},{"p":[339,0,55],"s":[7,6,8],"i":18,"l":1},{"p":[338,0,86],"s":[7,6,8],"i":18,"l":1},{"p":[-131,0,200],"s":[7,6,8],"i":18,"l":1},{"p":[-213,0,200],"s":[7,6,8],"i":18,"l":1},{"p":[-171,0,172],"s":[7,6,8],"i":18,"l":1},{"p":[-202,0,131],"s":[7,6,8],"i":18,"l":1},{"p":[-180,0,107],"s":[7,6,8],"i":18,"l":1},{"p":[-211,0,70],"s":[7,6,8],"i":18,"l":1},{"p":[-215,0,18],"s":[7,6,8],"i":18,"l":1},{"p":[-284,0,102],"s":[7,6,8],"i":18,"l":1},{"p":[-260,0,102],"s":[7,6,8],"i":18,"l":1},{"p":[-288,0,142],"s":[7,6,8],"i":18,"l":1},{"p":[-289,0,191],"s":[7,6,8],"i":18,"l":1},{"p":[-264,0,202],"s":[7,6,8],"i":18,"l":1},{"p":[-254,0,179],"s":[7,6,8],"i":18,"l":1},{"p":[-258,0,153],"s":[7,6,8],"i":18,"l":1},{"p":[-183,2,46],"s":[7,6,8],"i":18,"l":1},{"p":[-185,0,6],"s":[7,6,8],"i":18,"l":1},{"p":[-256,0,15],"s":[7,6,8],"i":18,"l":1},{"p":[-255,0,38],"s":[7,6,8],"i":18,"l":1},{"p":[-288,0,36],"s":[7,6,8],"i":18,"l":1},{"p":[-287,0,1],"s":[7,6,8],"i":18,"l":1},{"p":[-287,0,-30],"s":[7,6,8],"i":18,"l":1},{"p":[-258,0,-81],"s":[7,6,8],"i":18,"l":1},{"p":[-234,0,-43],"s":[7,6,8],"i":18,"l":1},{"p":[-208,0,-44],"s":[7,6,8],"i":18,"l":1},{"p":[-197,0,-88],"s":[7,6,8],"i":18,"l":1},{"p":[-268,0,-113],"s":[7,6,8],"i":18,"l":1},{"p":[-278,0,-139],"s":[7,6,8],"i":18,"l":1},{"p":[-165,0,-124],"s":[7,6,8],"i":18,"l":1},{"p":[-91,0,-134],"s":[7,6,8],"i":18,"l":1},{"p":[-47,0,350],"s":[7,6,8],"i":18,"l":1},{"p":[-113,85,-16],"s":[137,10,159],"i":12,"l":1},{"p":[219,85,43],"s":[170,10,146],"i":12,"l":1},{"p":[208,50,-78],"s":[93,10,87],"i":12,"l":1},{"p":[-105,50,119],"s":[87,10,99],"i":12,"l":1},{"p":[-89,103,411],"s":[90,0,43],"i":11,"l":1,"r":[1.57,0,-3.14],"sad":1},{"p":[-318,74,96],"s":[90,0,43],"i":11,"l":1,"r":[1.57,0,1.57],"sad":1},{"p":[410,41,71],"s":[78,0,31],"i":11,"l":1,"r":[1.57,0,-1.57],"sad":1},{"p":[415,-1,34],"s":[4,62,4],"c":7692103,"t":5},{"p":[412,24,71],"s":[2,34,82],"c":7692103,"t":5},{"p":[415,-1,108],"s":[4,62,4],"c":7692103,"t":5},{"p":[-320,50,97],"s":[2,48,96],"l":1,"c":"#636363","t":5},{"p":[-89,80,412],"s":[94,46,1],"l":1,"c":"#636363","t":5},{"p":[33,102,-146],"s":[86,0,39],"i":11,"l":1,"r":[1.57,0,0],"sad":1},{"p":[-2,78,-149],"s":[5,50,4],"l":1,"c":7692103,"t":5},{"p":[69,78,-149],"s":[5,50,4],"l":1,"c":7692103,"t":5},{"p":[33,81,-147],"s":[91,43,1],"c":7692103,"t":5}]};
    
    /***/ }),
    
    /***/ "./maps/lostworld.json":
    /*!*****************************!*\
      !*** ./maps/lostworld.json ***!
      \*****************************/
    /*! exports provided: name, ambInd, skyDome, skyDomeCol0, skyDomeCol1, skyDomeCol2, shadowR, ambient, light, sky, fog, fogD, dthY, camPos, spawns, modes, ambO, ambS, shadLength, shadWidth, skyDomeSize, deathHeight, shadScale, objects, default */
    /***/ (function(module) {
    
    module.exports = {"name":"Lostworld","ambInd":"3","skyDome":true,"skyDomeCol0":"#83b3b6","skyDomeCol1":"#52756f","skyDomeCol2":"#ffffff","shadowR":4096,"ambient":12500670,"light":13158600,"sky":10007744,"fog":7966360,"fogD":1077.995864208168,"dthY":75,"camPos":[-160,131,-13],"spawns":[[301,109,12,0,3,0],[-55,115,-170,0,1,0],[-55,109,76,0,1,0],[101,109,-48,0,0,0],[-341,92,-37,0,0,0],[-208,109,-58,0,0,0],[107,115,-107,0,3,0],[266,86,-102,0,0,0],[-224,109,81,0,1,0]],"modes":[0,1],"ambO":0.7,"ambS":5,"shadLength":1000,"shadWidth":767,"skyDomeSize":2000,"deathHeight":-100,"shadScale":170,"objects":[{"p":[126,145,-154],"s":[84,4,138],"f":[1,1,1,1,1,0],"c":"#7d7d61","e":"#282828","bo":1},{"p":[124,89,-132],"s":[76,20,90],"c":"#7d7d61","e":"#282828"},{"p":[-164,99,-87],"s":[40,10,40],"f":[0,0,1,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-169,99,-7],"s":[90,10,120],"f":[0,0,1,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-72,59,-138],"s":[76,56,30],"f":[1,1,1,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[121,49,-23],"s":[506,10,450],"f":[0,0,1,0,0,0],"c":"#374130","t":1},{"p":[-274,79,-274],"s":[120,30,80],"f":[0,0,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-117,59,-187],"s":[14,86,68],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-131,144,-76],"s":[10,4,22],"l":1,"r":[0,0,-0.17],"c":"#7d7d61","e":"#282828"},{"p":[-202,59,-87],"s":[36,78,40],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[164,89,-154],"s":[4,56,134],"f":[1,1,1,1,1,0],"c":"#7d7d61","e":"#282828"},{"p":[304,59,-102],"s":[36,50,30],"f":[0,1,1,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[104,109,-94],"s":[36,36,14],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[157,109,-94],"s":[10,36,14],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-79,145,-134],"s":[94,4,178],"c":"#7d7d61","e":"#282828","bo":1},{"p":[311,89,-147],"s":[50,95,60],"f":[1,1,0,1,1,0],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-179,144,-87],"s":[36,4,42],"c":"#7d7d61","e":"#282828","bo":1},{"p":[93,115,-165],"s":[14,30,24],"f":[1,1,0,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[93,115,-112],"s":[14,30,22],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[26,112,-148],"s":[120,1,2],"pe":1,"c":"#505050","t":2},{"p":[26,112,-128],"s":[120,1,2],"pe":1,"c":"#505050","t":2},{"p":[82,113,-138],"s":[4,1,27],"pe":1,"c":"#505050","t":2},{"p":[76,113,-138],"s":[4,1,25],"pe":1,"c":"#757575","t":2},{"p":[70,113,-138],"s":[4,1,27],"pe":1,"c":"#505050","t":2},{"p":[64,113,-138],"s":[4,1,27],"pe":1,"c":"#505050","t":2},{"p":[58,113,-137],"s":[4,1,27],"pe":1,"c":"#727272","t":2},{"p":[52,113,-138],"s":[4,1,27],"pe":1,"c":"#505050","t":2},{"p":[46,113,-139],"s":[4,1,26],"pe":1,"c":"#666666","t":2},{"p":[40,113,-138],"s":[4,1,27],"pe":1,"c":"#505050","t":2},{"p":[34,113,-138],"s":[4,1,27],"pe":1,"c":"#727272","t":2},{"p":[28,113,-137],"s":[4,1,27],"pe":1,"c":"#505050","t":2},{"p":[22,113,-138],"s":[4,1,27],"pe":1,"c":"#707070","t":2},{"p":[16,113,-138],"s":[4,1,26],"pe":1,"c":"#505050","t":2},{"p":[10,113,-138],"s":[4,1,27],"pe":1,"c":"#454545","t":2},{"p":[4,113,-137],"s":[4,1,26],"pe":1,"c":"#505050","t":2},{"p":[-2,113,-138],"s":[4,1,27],"pe":1,"c":"#7a7a7a","t":2},{"p":[-8,113,-138],"s":[4,1,25],"pe":1,"c":"#505050","t":2},{"p":[-14,113,-138],"s":[4,1,27],"pe":1,"c":"#505050","t":2},{"p":[-20,113,-138],"s":[4,1,26],"pe":1,"c":"#707070","t":2},{"p":[-26,113,-137],"s":[4,1,27],"pe":1,"c":"#505050","t":2},{"p":[-31,113,-138],"s":[4,1,27],"pe":1,"c":"#505050","t":2},{"p":[122,109,-99],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[122,109,-89],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[152,109,-89],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[152,109,-99],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[137,144,-99],"s":[28,2,2],"l":1,"c":"#505050","t":2},{"p":[137,144,-89],"s":[28,2,2],"l":1,"c":"#505050","t":2},{"p":[126,141,-89],"s":[12,2,1],"l":1,"pe":1,"r":[0,0,0.7],"c":"#505050","t":2},{"p":[126,141,-99],"s":[12,2,1],"l":1,"pe":1,"r":[0,0,0.7],"c":"#505050","t":2},{"p":[149,140,-89],"s":[14,2,1],"l":1,"pe":1,"r":[0,0,-0.7],"c":"#505050","t":2},{"p":[149,140,-99],"s":[14,2,1],"l":1,"pe":1,"r":[0,0,-0.7],"c":"#505050","t":2},{"p":[98,109,-123],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[88,109,-123],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[98,109,-153],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[88,109,-153],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[88,144,-138],"s":[2,2,28],"l":1,"c":"#505050","t":2},{"p":[98,144,-138],"s":[2,2,28],"l":1,"c":"#505050","t":2},{"p":[98,141,-127],"s":[1,2,12],"l":1,"pe":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[88,141,-127],"s":[1,2,12],"l":1,"pe":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[98,141,-149],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[88,141,-149],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-46,109,-153],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-36,109,-153],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-36,109,-123],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-46,109,-123],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-36,144,-138],"s":[2,2,28],"l":1,"c":"#505050","t":2},{"p":[-46,144,-138],"s":[2,2,28],"l":1,"c":"#505050","t":2},{"p":[-36,141,-127],"s":[1,2,12],"l":1,"pe":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[-46,141,-127],"s":[1,2,12],"l":1,"pe":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[-46,141,-149],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-36,141,-149],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-107,109,-54],"s":[6,36,14],"c":"#7d7d61","e":"#282828"},{"p":[-61,109,-54],"s":[26,36,14],"c":"#7d7d61","e":"#282828"},{"p":[-184,109,-70],"s":[2,35,2],"l":1,"c":"#505050","t":2},{"p":[-184,109,-104],"s":[2,35,2],"l":1,"c":"#505050","t":2},{"p":[-184,109,-87],"s":[2,35,2],"l":1,"c":"#505050","t":2},{"p":[-144,109,-87],"s":[2,35,2],"l":1,"c":"#505050","t":2},{"p":[-144,109,-70],"s":[2,35,2],"l":1,"c":"#505050","t":2},{"p":[-144,109,-104],"s":[2,35,2],"l":1,"c":"#505050","t":2},{"p":[-164,143,-70],"s":[38,2,2],"l":1,"c":"#505050","t":2},{"p":[-164,142,-87],"s":[38,2,2],"l":1,"c":"#505050","t":2},{"p":[-164,142,-104],"s":[38,2,2],"l":1,"c":"#505050","t":2},{"p":[-176,138,-104],"s":[20,2,1],"l":1,"pe":1,"r":[0,0,0.7],"c":"#505050","t":2},{"p":[-151,137,-104],"s":[20,2,1],"l":1,"pe":1,"r":[0,0,-0.7],"c":"#505050","t":2},{"p":[-151,137,-87],"s":[20,2,1],"l":1,"pe":1,"r":[0,0,-0.7],"c":"#505050","t":2},{"p":[-151,137,-70],"s":[20,2,1],"l":1,"pe":1,"r":[0,0,-0.7],"c":"#505050","t":2},{"p":[-176,138,-87],"s":[20,2,1],"l":1,"pe":1,"r":[0,0,0.7],"c":"#505050","t":2},{"p":[-176,138,-70],"s":[20,2,1],"l":1,"pe":1,"r":[0,0,0.7],"c":"#505050","t":2},{"p":[-14,49,158],"s":[20,30,70],"f":[1,0,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[22,52,203],"s":[52,30,20],"f":[0,0,0,0,0,1],"c":"#000000","t":5},{"p":[22,52,169],"s":[52,30,48],"f":[0,0,0,0,0,1],"c":"#000000","o":0.8,"t":5},{"p":[26,66,-19],"s":[600,10,600],"l":1,"f":[0,0,1,0,0,0],"c":"#212e23","o":0.61,"t":5},{"p":[-179,136,-70],"s":[8,2,2],"l":1,"pe":1,"c":"#505050","t":2},{"p":[-149,136,-70],"s":[8,2,2],"l":1,"pe":1,"c":"#505050","t":2},{"p":[-149,136,-104],"s":[8,2,2],"l":1,"pe":1,"c":"#505050","t":2},{"p":[-179,136,-104],"s":[8,2,2],"l":1,"pe":1,"c":"#505050","t":2},{"p":[339,113,-71],"s":[34,24,90],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[361,113,-36],"s":[10,24,20],"c":"#7d7d61","e":"#282828"},{"p":[361,113,-71],"s":[10,24,20],"c":"#7d7d61","e":"#282828"},{"p":[361,113,-106],"s":[10,24,20],"c":"#7d7d61","e":"#282828"},{"p":[352,117,-71],"s":[20,20,60],"f":[1,0,0,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[344,137,-71],"s":[50,4,96],"c":"#7d7d61","e":"#282828","bo":1},{"p":[311,182,-147],"s":[54,4,64],"f":[1,1,0,1,1,0],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-179,148,-87],"s":[34,8,40],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11,"bo":1},{"p":[-79,149,-134],"s":[90,10,174],"c":"#7d7d61","e":"#282828","t":11},{"p":[-79,159,-134],"s":[94,4,178],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-34,109,178],"s":[20,41,10],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-27,109,150],"s":[2,26,15],"pe":1,"c":"#505050","t":2},{"p":[-34,135,158],"s":[20,15,30],"f":[1,1,1,1,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-34,109,99],"s":[20,41,88],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-114,109,101],"s":[20,41,12],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[71,133,215],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,139,217],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,145,219],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,151,221],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,157,223],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,163,225],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,169,227],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,175,229],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,181,231],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,187,233],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,193,235],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[93,101,202],"s":[14,120,40],"l":1,"r":[0.35,0,0],"c":"#7d7d61","e":"#282828"},{"p":[49,102,201],"s":[14,120,40],"l":1,"r":[0.35,0,0],"c":"#7d7d61","e":"#282828"},{"p":[115,109,208],"s":[30,12,30],"c":"#7d7d61","e":"#282828","bo":1},{"p":[71,109,250],"s":[130,60,80],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[146,109,263],"s":[20,46,80],"f":[1,0,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-4,109,263],"s":[20,46,80],"f":[0,1,1,0,0,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[71,109,266],"s":[86,104,70],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,169,261],"s":[110,22,80],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,209,262],"s":[60,26,60],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[206,109,-27],"s":[140,30,20],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[113,109,-20],"s":[15,26,2],"pe":1,"c":"#505050","t":2},{"p":[121,135,-27],"s":[30,4,20],"f":[0,0,0,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-179,156,-87],"s":[36,4,42],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-145,147,-87],"s":[28,8,40],"r":[0,0,0.17],"c":"#7d7d61","e":"#282828","t":11,"bo":1},{"p":[-134,59,-87],"s":[20,85,40],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[181,139,-27],"s":[194,4,24],"f":[1,0,1,1,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[179,143,-27],"s":[186,14,20],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[178,157,-27],"s":[184,4,24],"f":[1,0,1,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[68,49,158],"s":[40,30,70],"f":[0,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[126,159,-154],"s":[84,4,138],"f":[1,1,1,1,1,0],"c":"#7d7d61","e":"#282828","bo":1},{"p":[26,145,-198],"s":[116,4,50],"f":[1,1,1,1,1,0],"c":"#7d7d61","e":"#282828","bo":1},{"p":[84,59,-84],"s":[4,132,26],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11,"bo":1},{"p":[183,109,-85],"s":[48,6,4],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[261,109,-85],"s":[50,6,4],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[87,138,-73],"s":[2,36,2],"l":1,"pe":1,"r":[0,0,0.87],"c":"#505050","t":2},{"p":[87,138,-47],"s":[2,36,2],"l":1,"pe":1,"r":[0,0,0.87],"c":"#505050","t":2},{"p":[70,160,-73],"s":[30,2,2],"pe":1,"c":"#505050","t":2},{"p":[70,160,-47],"s":[30,2,2],"pe":1,"c":"#505050","t":2},{"p":[137,109,-97],"s":[30,2,8],"c":"#7d7d61","e":"#282828"},{"p":[137,111,-99],"s":[30,2,4],"c":"#7d7d61","e":"#282828"},{"p":[-81,59,-92],"s":[66,56,62],"f":[0,0,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[88,109,76],"s":[4,6,102],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[21,143,11],"s":[130,14,56],"f":[1,1,0,0,1,0],"c":"#7d7d61","e":"#282828","t":11},{"p":[-195,137,-87],"s":[22,7,40],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[21,89,31],"s":[130,26,12],"f":[0,1,1,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[78,115,31],"s":[10,24,10],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-36,115,31],"s":[10,24,10],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[21,139,11],"s":[134,4,60],"c":"#7d7d61","e":"#282828","bo":1},{"p":[40,115,31],"s":[10,24,10],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[2,115,31],"s":[10,24,10],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[21,89,4],"s":[130,20,42],"f":[0,0,1,1,0,0],"c":"#7d7d61","e":"#282828"},{"p":[22,53,126],"s":[1,28,1],"c":"#000000","t":5},{"p":[16,53,126],"s":[1,22,1],"c":"#000000","t":5},{"p":[10,53,126],"s":[1,13,1],"c":"#000000","t":5},{"p":[4,53,126],"s":[1,28,1],"c":"#000000","t":5},{"p":[-2,53,126],"s":[1,28,1],"c":"#000000","t":5},{"p":[28,53,126],"s":[1,28,1],"c":"#000000","t":5},{"p":[34,53,126],"s":[1,28,1],"c":"#000000","t":5},{"p":[40,71,126],"s":[1,9,1],"c":"#000000","t":5},{"p":[46,53,126],"s":[1,28,1],"c":"#000000","t":5},{"p":[-74,59,212],"s":[100,91,58],"f":[1,0,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-114,59,168],"s":[20,91,30],"f":[1,0,0,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-104,109,-49],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-104,109,-59],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-74,109,-49],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-74,109,-59],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-89,144,-59],"s":[28,2,2],"l":1,"c":"#505050","t":2},{"p":[-89,144,-49],"s":[28,2,2],"l":1,"c":"#505050","t":2},{"p":[-196,109,-223],"s":[28,1,46],"l":1,"f":[1,1,1,0,1,0],"c":"#467532","t":1},{"p":[-197,109,-120],"s":[26,1,26],"l":1,"f":[1,1,1,0,0,1],"c":"#467532","t":1},{"p":[-216,105,-184],"s":[4,2,34],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-127,109,-193],"s":[26,1,70],"l":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[-299,105,11],"s":[34,2,4],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-194,109,87],"s":[20,40,40],"f":[1,1,0,0,1,0],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-194,109,145],"s":[20,40,16],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-201,109,130],"s":[2,26,15],"pe":1,"c":"#505050","t":2},{"p":[-164,149,87],"s":[80,5,40],"f":[0,1,1,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-164,149,160],"s":[80,5,46],"f":[0,1,1,1,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-154,154,143],"s":[88,5,20],"c":"#7d7d61","e":"#282828"},{"p":[-154,154,101],"s":[88,5,20],"c":"#7d7d61","e":"#282828"},{"p":[-154,159,105],"s":[84,5,20],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-154,159,139],"s":[84,5,20],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-194,135,122],"s":[20,29,30],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-303,88,186],"s":[120,69,60],"f":[1,0,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[84,59,-36],"s":[4,132,26],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11,"bo":1},{"p":[-89,109,-57],"s":[30,2,8],"c":"#7d7d61","e":"#282828"},{"p":[-89,111,-59],"s":[30,2,4],"c":"#7d7d61","e":"#282828"},{"p":[-18,160,-47],"s":[30,2,2],"pe":1,"c":"#505050","t":2},{"p":[-18,160,-73],"s":[30,2,2],"pe":1,"c":"#505050","t":2},{"p":[-8,161,-73],"s":[2,36,2],"l":1,"pe":1,"r":[0,0,2.27],"c":"#505050","t":2},{"p":[-8,161,-47],"s":[2,36,2],"l":1,"pe":1,"r":[0,0,2.27],"c":"#505050","t":2},{"p":[56,143,-73],"s":[1,17,1],"l":1,"pe":1,"c":"#505050","t":2},{"p":[56,137,-47],"s":[1,23,1],"l":1,"pe":1,"c":"#505050","t":2},{"p":[-73,150,79],"s":[102,4,52],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-34,150,142],"s":[24,4,74],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-42,154,141],"s":[22,4,58],"c":"#7d7d61","e":"#282828"},{"p":[-74,154,202],"s":[86,4,64],"c":"#7d7d61","e":"#282828"},{"p":[-74,154,100],"s":[86,4,24],"c":"#7d7d61","e":"#282828"},{"p":[-106,154,141],"s":[22,4,58],"c":"#7d7d61","e":"#282828"},{"p":[-104,150,142],"s":[4,4,74],"c":"#7d7d61","e":"#282828"},{"p":[-74,158,104],"s":[70,4,32],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-74,158,178],"s":[70,4,32],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-50,158,141],"s":[22,4,42],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-98,158,141],"s":[22,4,42],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-205,109,-7],"s":[30,1,120],"l":1,"f":[1,0,1,0,1,1],"c":"#467532","t":1},{"p":[-125,109,-60],"s":[32,1,46],"l":1,"f":[1,1,1,0,1,0],"c":"#467532","t":1},{"p":[71,162,-60],"s":[4,1,30],"pe":1,"c":"#505050","t":2},{"p":[64,162,-61],"s":[4,1,30],"pe":1,"r":[0,0.17,0],"c":"#505050","t":2},{"p":[56,162,-60],"s":[4,1,30],"pe":1,"c":"#505050","t":2},{"p":[55,133,-57],"s":[1,4,30],"l":1,"r":[-0.52,0,0],"c":"#505050","t":2},{"p":[-15,162,-60],"s":[4,1,30],"pe":1,"r":[0,-0.17,0],"c":"#505050","t":2},{"p":[344,99,-71],"s":[46,18,92],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[340,59,-147],"s":[24,31,41],"f":[0,1,0,0,0,0],"c":"#000000","t":5},{"p":[344,141,-71],"s":[46,10,92],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[311,49,-172],"s":[50,40,10],"f":[1,1,0,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[311,49,-122],"s":[50,40,10],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[167,109,122],"s":[20,28,280],"i":9,"c":"#467532","t":1},{"p":[266,109,53],"s":[20,33,140],"c":"#7d7d61","e":"#282828"},{"p":[-361,109,-37],"s":[22,26,500],"i":9,"c":"#467532","t":1,"d":2},{"p":[435,95,-67],"s":[162,28,220],"f":[0,0,1,0,0,0],"c":"#467532","t":1},{"p":[367,96,43],"s":[196,2,5],"c":"#ffffff","e":"#282828","t":5,"bo":1},{"p":[352,96,4],"s":[10,2,66],"c":"#ffffff","e":"#282828","t":5,"bo":1},{"p":[163,106,111],"s":[6,2,255],"c":"#ffffff","e":"#282828","t":5,"bo":1},{"p":[27,109,208],"s":[30,12,30],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-156,109,71],"s":[66,40,38],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[300,109,-63],"s":[24,36,24],"i":23,"l":1,"tm":0},{"p":[-299,91,-55],"s":[24,36,24],"i":23,"l":1,"tm":"1"},{"p":[-234,111,-112],"s":[30,24,20],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-234,111,-35],"s":[30,24,20],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-234,111,42],"s":[30,24,20],"f":[1,1,0,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-234,111,3],"s":[30,24,20],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-234,111,-73],"s":[30,24,20],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-234,135,-35],"s":[30,12,174],"f":[1,1,0,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-234,147,-35],"s":[38,4,178],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-234,151,-35],"s":[34,12,174],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[-234,163,-35],"s":[38,4,178],"c":"#7d7d61","e":"#282828"},{"p":[54,121,-11],"s":[12,12,12],"i":8},{"p":[54,109,-11],"s":[12,12,12],"i":8},{"p":[-234,111,-35],"s":[24,24,140],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-248,111,-103],"s":[6,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-250,111,-81],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-250,111,-65],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-250,111,-43],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-250,111,-27],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-250,111,-5],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-250,111,11],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-248,111,32],"s":[6,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-250,135,-92],"s":[3,4,28],"f":[0,1,1,1,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-250,135,-54],"s":[3,4,28],"f":[0,1,1,1,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-250,135,-16],"s":[3,4,28],"f":[0,1,1,1,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-250,135,22],"s":[3,4,28],"f":[0,1,1,1,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-284,88,83],"s":[160,21,140],"f":[0,0,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-219,109,62],"s":[60,38,20],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-220,147,64],"s":[66,4,20],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-201,147,52],"s":[28,4,4],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-221,151,62],"s":[60,12,20],"c":"#7d7d61","e":"#282828","t":11},{"p":[-223,163,64],"s":[60,4,20],"c":"#7d7d61","e":"#282828"},{"p":[-204,163,52],"s":[22,4,4],"c":"#7d7d61","e":"#282828"},{"p":[-204,109,-249],"s":[400,36,26],"i":9,"c":"#467532","t":1,"d":3},{"p":[-352,106,5],"s":[5,2,340],"c":"#ffffff","e":"#282828","t":5,"bo":1},{"p":[-114,109,145],"s":[20,41,16],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[129,144,-138],"s":[4,1,3],"c":"#000000","t":5},{"p":[129,143,-138],"s":[3,1,2],"l":1,"c":"#000000","e":"#ffe9a6","t":5},{"p":[-79,144,-150],"s":[4,1,3],"c":"#000000","t":5},{"p":[-79,143,-150],"s":[3,1,2],"l":1,"c":"#000000","e":"#ffe9a6","t":5},{"p":[-490,159,-55],"s":[120,10,120],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-490,169,-55],"s":[100,10,100],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-490,179,-55],"s":[80,10,80],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-490,189,-55],"s":[60,10,60],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-490,199,-55],"s":[40,10,40],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-490,169,-55],"s":[110,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-490,179,-55],"s":[90,5,24],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-490,189,-55],"s":[70,5,24],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-490,199,-55],"s":[50,5,24],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-490,209,-55],"s":[20,5,20],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-490,159,-55],"s":[130,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[201,109,-45],"s":[80,1,18],"l":1,"f":[1,1,1,0,0,1],"c":"#467532","t":1},{"p":[154,109,-43],"s":[14,1,12],"l":1,"f":[0,1,1,0,0,1],"c":"#467532","t":1},{"p":[-26,154,148],"s":[4,14,186],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[-26,168,148],"s":[8,4,190],"c":"#7d7d61","e":"#282828"},{"p":[413,54,-202],"s":[200,102,50],"f":[0,1,0,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[311,196,-147],"s":[54,4,64],"f":[1,1,0,1,1,0],"c":"#7d7d61","e":"#282828"},{"p":[413,156,-202],"s":[204,4,54],"f":[0,1,1,1,1,0],"c":"#7d7d61","e":"#282828","bo":1},{"p":[230,114,-206],"s":[180,2,50],"f":[0,0,1,0,0,0],"c":"#467532","t":1},{"p":[129,109,187],"s":[70,1,24],"l":1,"f":[0,1,1,0,0,1],"c":"#467532","t":1},{"p":[8,109,193],"s":[70,1,20],"l":1,"f":[0,0,1,0,0,1],"c":"#467532","t":1},{"p":[144,109,186],"s":[12,12,12],"i":8},{"p":[37,109,133],"s":[12,12,12],"i":8},{"p":[25,109,133],"s":[12,12,12],"i":8},{"p":[-220,111,32],"s":[6,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-218,111,11],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-218,135,22],"s":[3,4,28],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-218,111,-5],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-218,111,-43],"s":[2,23,4],"c":"#7d7d61","e":"#282828"},{"p":[-218,111,-65],"s":[2,19,4],"c":"#7d7d61","e":"#282828"},{"p":[-218,111,-27],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[-218,135,-16],"s":[3,4,28],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-218,133,-53],"s":[3,4,28],"l":1,"r":[-0.17,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-246,109,61],"s":[60,1,80],"l":1,"f":[0,1,1,0,1,1],"c":"#467532","t":1},{"p":[-209,109,87],"s":[14,1,34],"l":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[-148,78,-238],"s":[500,2,5],"c":"#ffffff","e":"#282828","t":5,"bo":1},{"p":[-121,78,-246],"s":[5,2,50],"c":"#ffffff","e":"#282828","t":5,"bo":1},{"p":[-74,162,167],"s":[46,1,10],"l":1,"c":"#467532","t":1},{"p":[-74,151,162],"s":[2,12,1],"l":1,"c":"#467532","t":1},{"p":[-68,154,162],"s":[1,9,1],"l":1,"c":"#467532","t":1},{"p":[-81,155,162],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-77,156,162],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-79,160,162],"s":[3,3,1],"l":1,"c":"#467532","t":1},{"p":[-71,161,162],"s":[4,2,1],"l":1,"c":"#467532","t":1},{"p":[-63,156,162],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-66,157,162],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[-65,160,162],"s":[6,3,1],"l":1,"c":"#467532","t":1},{"p":[-80,143,120],"s":[2,20,1],"l":1,"c":"#467532","t":1},{"p":[-74,162,115],"s":[46,1,10],"l":1,"c":"#467532","t":1},{"p":[-69,155,120],"s":[1,8,1],"l":1,"c":"#467532","t":1},{"p":[-65,153,120],"s":[2,10,1],"l":1,"c":"#467532","t":1},{"p":[-67,157,120],"s":[3,6,1],"l":1,"c":"#467532","t":1},{"p":[-74,153,120],"s":[1,10,1],"l":1,"c":"#467532","t":1},{"p":[-76,156,120],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-75,160,120],"s":[1,3,1],"l":1,"c":"#467532","t":1},{"p":[-85,156,120],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-84,159,120],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[-82,161,120],"s":[3,2,1],"l":1,"c":"#467532","t":1},{"p":[-106,109,137],"s":[2,27,2],"l":1,"c":"#505050","t":2},{"p":[-122,109,137],"s":[2,27,2],"l":1,"c":"#505050","t":2},{"p":[-122,109,107],"s":[2,27,2],"l":1,"c":"#505050","t":2},{"p":[-106,109,107],"s":[2,27,2],"l":1,"c":"#505050","t":2},{"p":[-122,134,122],"s":[2,2,28],"l":1,"c":"#505050","t":2},{"p":[-106,134,122],"s":[2,2,28],"l":1,"c":"#505050","t":2},{"p":[-92,162,141],"s":[10,1,42],"l":1,"c":"#467532","t":1},{"p":[-56,162,141],"s":[10,1,42],"l":1,"c":"#467532","t":1},{"p":[-84,158,162],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[-72,159,120],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[-62,159,120],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[-122,130,110],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-106,130,110],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-106,130,134],"s":[1,2,12],"l":1,"pe":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[-122,130,134],"s":[1,2,12],"l":1,"pe":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[413,170,-202],"s":[204,4,54],"f":[0,1,1,1,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-209,141,-74],"s":[10,6,10],"l":1,"r":[0,0,0.69],"c":"#7d7d61","e":"#282828"},{"p":[-61,156,128],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-61,152,132],"s":[1,11,1],"l":1,"c":"#467532","t":1},{"p":[-61,153,152],"s":[1,10,1],"l":1,"c":"#467532","t":1},{"p":[-61,157,155],"s":[1,6,1],"l":1,"c":"#467532","t":1},{"p":[-61,160,149],"s":[1,3,5],"l":1,"c":"#467532","t":1},{"p":[-61,157,139],"s":[1,6,1],"l":1,"c":"#467532","t":1},{"p":[-61,161,137],"s":[1,2,3],"l":1,"c":"#467532","t":1},{"p":[-61,155,135],"s":[1,8,1],"l":1,"c":"#467532","t":1},{"p":[-61,159,144],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[-61,160,124],"s":[1,3,7],"l":1,"c":"#467532","t":1},{"p":[-61,156,160],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-61,161,158],"s":[1,2,3],"l":1,"c":"#467532","t":1},{"p":[-87,156,151],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-87,152,132],"s":[1,11,1],"l":1,"c":"#467532","t":1},{"p":[-87,155,134],"s":[1,8,1],"l":1,"c":"#467532","t":1},{"p":[-87,160,129],"s":[1,3,5],"l":1,"c":"#467532","t":1},{"p":[-87,159,126],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[-87,148,147],"s":[1,15,1],"l":1,"c":"#467532","t":1},{"p":[-87,161,145],"s":[1,2,3],"l":1,"c":"#467532","t":1},{"p":[-87,160,140],"s":[1,3,1],"l":1,"c":"#467532","t":1},{"p":[-87,160,136],"s":[1,3,1],"l":1,"c":"#467532","t":1},{"p":[-87,160,157],"s":[1,3,1],"l":1,"c":"#467532","t":1},{"p":[-154,164,111],"s":[70,1,8],"l":1,"c":"#467532","t":1},{"p":[-154,164,133],"s":[70,1,8],"l":1,"c":"#467532","t":1},{"p":[-133,156,129],"s":[1,9,1],"l":1,"c":"#467532","t":1},{"p":[-146,157,129],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-142,158,129],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-144,162,129],"s":[3,3,1],"l":1,"c":"#467532","t":1},{"p":[-135,163,129],"s":[4,2,1],"l":1,"c":"#467532","t":1},{"p":[-128,158,129],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-130,162,129],"s":[6,3,1],"l":1,"c":"#467532","t":1},{"p":[-149,160,129],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[-165,153,129],"s":[2,12,1],"l":1,"c":"#467532","t":1},{"p":[-159,156,129],"s":[1,9,1],"l":1,"c":"#467532","t":1},{"p":[-172,157,129],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-168,158,129],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-170,162,129],"s":[3,3,1],"l":1,"c":"#467532","t":1},{"p":[-162,163,129],"s":[4,2,1],"l":1,"c":"#467532","t":1},{"p":[-154,158,129],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-156,162,129],"s":[6,3,1],"l":1,"c":"#467532","t":1},{"p":[-175,160,129],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[-163,156,115],"s":[1,9,1],"l":1,"c":"#467532","t":1},{"p":[-176,157,115],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-172,158,115],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-174,162,115],"s":[3,3,1],"l":1,"c":"#467532","t":1},{"p":[-166,163,115],"s":[4,2,1],"l":1,"c":"#467532","t":1},{"p":[-158,158,115],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-160,162,115],"s":[6,3,1],"l":1,"c":"#467532","t":1},{"p":[-179,160,115],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[-137,153,115],"s":[2,12,1],"l":1,"c":"#467532","t":1},{"p":[-131,156,115],"s":[1,9,1],"l":1,"c":"#467532","t":1},{"p":[-144,157,115],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-140,158,115],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-142,162,115],"s":[3,3,1],"l":1,"c":"#467532","t":1},{"p":[-134,163,115],"s":[4,2,1],"l":1,"c":"#467532","t":1},{"p":[-126,158,115],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-128,162,115],"s":[6,3,1],"l":1,"c":"#467532","t":1},{"p":[-147,160,115],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[-154,153,115],"s":[2,12,1],"l":1,"c":"#467532","t":1},{"p":[-152,160,115],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[-180,156,129],"s":[1,9,1],"l":1,"c":"#467532","t":1},{"p":[-282,109,163],"s":[180,26,20],"i":9,"c":"#467532","t":1,"d":1},{"p":[-228,95,223],"s":[240,40,100],"f":[0,0,1,0,0,0],"c":"#467532","t":1},{"p":[-250,106,155],"s":[92,2,5],"c":"#ffffff","e":"#282828","t":5,"bo":1},{"p":[-344,109,124],"s":[12,12,12],"i":8},{"p":[-332,109,126],"s":[12,12,12],"i":8},{"p":[-268,109,30],"s":[12,12,12],"i":8},{"p":[328,116,-238],"s":[30,28,50],"i":9,"c":"#467532","t":1},{"p":[55,136,-320],"s":[780,42,36],"i":9,"c":"#467532","t":1,"d":3},{"p":[-389,135,155],"s":[6,44,6],"pe":1,"f":[1,0,0,0,0,1],"c":"#505050","t":2},{"p":[-389,158,148],"s":[2,2,10],"pe":1,"c":"#505050","t":2},{"p":[-377,147,155],"s":[10,10,10],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-382,150,155],"s":[10,2,2],"pe":1,"c":"#505050","t":2},{"p":[-388,154,142],"s":[10,10,10],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-389,173,155],"s":[60,34,50],"l":1,"pe":1,"f":[1,0,0,1,0,1],"c":"#467532","t":1},{"p":[-426,156,114],"s":[20,13,17],"l":1,"pe":1,"f":[1,0,1,0,1,1],"c":"#467532","t":1},{"p":[-419,151,80],"s":[20,13,17],"l":1,"pe":1,"f":[1,0,1,0,1,1],"c":"#467532","t":1},{"p":[-414,147,99],"s":[20,13,17],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-411,139,123],"s":[20,16,17],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-419,148,136],"s":[20,16,17],"l":1,"pe":1,"f":[1,0,1,0,1,1],"c":"#467532","t":1},{"p":[-418,144,-136],"s":[20,21,17],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-425,149,-122],"s":[18,21,17],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-457,153,52],"s":[18,21,17],"l":1,"pe":1,"f":[1,0,1,0,1,1],"c":"#467532","t":1},{"p":[-436,148,19],"s":[18,21,17],"l":1,"pe":1,"f":[1,0,1,0,1,1],"c":"#467532","t":1},{"p":[-424,147,-151],"s":[18,21,17],"l":1,"pe":1,"c":"#467532","t":1},{"p":[182,135,250],"s":[8,44,8],"pe":1,"f":[1,1,0,0,0,1],"c":"#505050","t":2},{"p":[182,169,247],"s":[78,48,78],"l":1,"pe":1,"f":[1,1,0,1,0,1],"c":"#467532","t":1},{"p":[-487,93,178],"s":[90,104,180],"f":[1,0,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-487,183,178],"s":[94,4,184],"f":[1,0,0,1,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-487,197,178],"s":[94,4,184],"f":[1,0,0,1,0,1],"c":"#7d7d61","e":"#282828"},{"p":[517,121,-171],"s":[8,64,8],"pe":1,"f":[0,1,0,0,1,0],"c":"#505050","t":2},{"p":[517,179,-171],"s":[76,50,76],"l":1,"pe":1,"f":[0,1,0,1,1,0],"c":"#467532","t":1},{"p":[315,133,-257],"s":[24,30,24],"l":1,"pe":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[292,123,-268],"s":[24,30,24],"l":1,"pe":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[231,114,-244],"s":[300,30,30],"i":9,"c":"#467532","t":1,"d":3},{"p":[361,122,26],"s":[1,33,1],"pe":1,"c":"#505050","t":2},{"p":[371,122,26],"s":[1,33,1],"pe":1,"c":"#505050","t":2},{"p":[371,122,6],"s":[1,33,1],"pe":1,"c":"#505050","t":2},{"p":[361,122,6],"s":[1,37,1],"pe":1,"c":"#505050","t":2},{"p":[361,122,-4],"s":[1,33,1],"pe":1,"c":"#505050","t":2},{"p":[371,122,-4],"s":[1,42,1],"pe":1,"c":"#505050","t":2},{"p":[366,151,11],"s":[12,1,32],"pe":1,"c":"#505050","t":2},{"p":[366,146,-5],"s":[12,1,1],"pe":1,"c":"#505050","t":2},{"p":[366,141,-5],"s":[12,1,1],"pe":1,"c":"#505050","t":2},{"p":[366,136,-5],"s":[12,1,1],"pe":1,"c":"#505050","t":2},{"p":[366,131,-5],"s":[12,1,1],"pe":1,"c":"#505050","t":2},{"p":[366,139,16],"s":[12,1,22],"pe":1,"c":"#505050","t":2},{"p":[-410,140,54],"s":[6,44,6],"pe":1,"f":[1,0,0,0,1,1],"c":"#505050","t":2},{"p":[-410,177,54],"s":[62,38,62],"l":1,"pe":1,"f":[1,0,0,1,1,1],"c":"#467532","t":1},{"p":[-299,91,-5],"s":[32,18,36],"i":9,"v":1,"c":"#a7a793","d":1},{"p":[-299,103,9],"s":[34,2,8],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-299,101,7],"s":[34,2,12],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-299,99,5],"s":[34,2,16],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-299,97,3],"s":[34,2,20],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-299,95,1],"s":[34,2,24],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-299,93,-1],"s":[34,2,28],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-299,91,-3],"s":[34,2,32],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-218,103,-184],"s":[8,2,34],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-220,101,-184],"s":[12,2,34],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-222,99,-184],"s":[16,2,34],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-224,97,-184],"s":[20,2,34],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-226,95,-184],"s":[24,2,34],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-228,93,-184],"s":[28,2,34],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-230,91,-184],"s":[32,2,34],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-89,109,-54],"s":[30,6,14],"i":9,"v":1,"c":"#a7a793","d":3},{"p":[335,117,-238],"s":[24,30,24],"l":1,"pe":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[-240,134,-327],"s":[7,80,7],"pe":1,"f":[1,1,0,0,1,0],"c":"#505050","t":2},{"p":[-46,176,-298],"s":[74,42,74],"l":1,"pe":1,"f":[1,1,0,1,1,0],"c":"#467532","t":1},{"p":[-25,162,-60],"s":[4,1,30],"pe":1,"c":"#505050","t":2},{"p":[-4,151,-47],"s":[1,9,1],"l":1,"pe":1,"c":"#505050","t":2},{"p":[-6,151,-66],"s":[4,1,30],"l":1,"r":[1.05,0,0],"c":"#505050","t":2},{"p":[254,109,-44],"s":[26,1,14],"l":1,"f":[1,0,1,0,0,1],"c":"#467532","t":1},{"p":[-79,144,-82],"s":[4,1,3],"c":"#000000","t":5},{"p":[-79,143,-82],"s":[3,1,2],"l":1,"c":"#000000","e":"#ffe9a6","t":5},{"p":[-188,109,-22],"s":[4,1,54],"l":1,"f":[1,0,1,0,1,1],"c":"#467532","t":1},{"p":[97,59,-86],"s":[22,32,22],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[-84,59,-180],"s":[74,56,54],"f":[0,0,1,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-247,91,-77],"s":[70,1,180],"l":1,"f":[0,1,1,0,0,1],"c":"#467532","t":1},{"p":[-261,91,-236],"s":[110,1,70],"l":1,"f":[1,1,1,0,1,0],"c":"#467532","t":1},{"p":[-201,109,-144],"s":[18,1,22],"l":1,"f":[1,1,1,0,0,1],"c":"#467532","t":1},{"p":[-397,156,54],"s":[20,4,4],"pe":1,"c":"#505050","t":2},{"p":[-389,160,54],"s":[4,4,4],"pe":1,"c":"#505050","t":2},{"p":[-387,163,54],"s":[22,10,14],"l":1,"pe":1,"c":"#467532","t":1},{"p":[546,140,80],"s":[8,70,8],"pe":1,"f":[0,1,0,0,0,1],"c":"#505050","t":2},{"p":[546,186,80],"s":[86,52,86],"l":1,"pe":1,"f":[0,1,0,1,0,1],"c":"#467532","t":1},{"p":[82,94,-60],"s":[1,4,30],"l":1,"r":[0.17,0,0],"c":"#939393","t":2},{"p":[82,86,-60],"s":[1,4,30],"l":1,"c":"#505050","t":2},{"p":[-173,119,233],"s":[60,30,100],"i":9,"c":"#467532","t":1},{"p":[98,109,86],"s":[20,1,60],"l":1,"f":[1,0,1,0,1,1],"c":"#467532","t":1},{"p":[96,109,121],"s":[14,1,10],"l":1,"f":[1,0,1,0,1,0],"c":"#467532","t":1},{"p":[152,109,155],"s":[16,1,40],"l":1,"f":[0,1,1,0,0,1],"c":"#467532","t":1},{"p":[155,109,120],"s":[12,1,30],"l":1,"f":[0,1,1,0,0,1],"c":"#467532","t":1},{"p":[-13,111,253],"s":[900,64,78],"i":9,"c":"#467532","t":1,"d":1},{"p":[541,123,-59],"s":[50,40,398],"i":9,"c":"#467532","t":1},{"p":[566,147,-205],"s":[30,30,30],"l":1,"pe":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[576,144,-180],"s":[30,30,30],"l":1,"pe":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[566,136,-162],"s":[30,30,30],"l":1,"pe":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[541,127,93],"s":[40,40,40],"l":1,"pe":1,"f":[0,1,1,0,0,1],"c":"#467532","t":1},{"p":[572,135,60],"s":[40,40,40],"l":1,"pe":1,"f":[0,1,1,0,0,1],"c":"#467532","t":1},{"p":[-337,109,105],"s":[40,1,120],"l":1,"f":[1,0,1,0,0,1],"c":"#467532","t":1},{"p":[-345,109,35],"s":[40,1,20],"l":1,"f":[1,0,1,0,0,1],"c":"#467532","t":1},{"p":[398,144,-310],"s":[40,30,44],"l":1,"pe":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[541,121,-251],"s":[60,40,40],"l":1,"pe":1,"f":[0,0,1,0,1,0],"c":"#467532","t":1},{"p":[141,106,224],"s":[59,2,5],"c":"#ffffff","e":"#282828","t":5,"bo":1},{"p":[480,136,-289],"s":[120,60,100],"f":[0,1,0,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[480,210,-289],"s":[124,4,104],"f":[0,1,0,1,1,0],"c":"#7d7d61","e":"#282828"},{"p":[480,196,-289],"s":[124,4,104],"f":[0,1,0,1,1,0],"c":"#7d7d61","e":"#282828"},{"p":[218,155,-308],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,161,-310],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,167,-312],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,173,-314],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,179,-316],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,185,-318],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,191,-320],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,197,-322],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,203,-324],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,209,-326],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,215,-328],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,221,-330],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,137,-358],"s":[130,60,80],"r":[-3.14,0,-3.14],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[143,137,-358],"s":[20,40,80],"r":[-3.14,0,-3.14],"f":[1,0,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[293,137,-358],"s":[20,40,80],"r":[-3.14,0,-3.14],"f":[0,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[218,140,-360],"s":[64,100,70],"r":[-3.14,0,-3.14],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[218,197,-358],"s":[100,20,60],"r":[-3.14,0,-3.14],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[218,237,-363],"s":[40,20,50],"r":[-3.14,0,-3.14],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[260,137,-307],"s":[30,30,30],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,137,-303],"s":[62,26,29],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[241,132,-292],"s":[16,102,40],"l":1,"r":[2.79,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[195,132,-292],"s":[16,102,40],"l":1,"r":[2.79,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,149,-306],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,143,-304],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[218,137,-302],"s":[30,6,50],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[134,130,-284],"s":[6,44,6],"pe":1,"f":[1,1,0,0,1,0],"c":"#505050","t":2},{"p":[134,172,-284],"s":[60,38,60],"l":1,"f":[1,1,0,1,1,0],"c":"#467532","t":1},{"p":[363,149,-336],"s":[40,40,44],"l":1,"pe":1,"f":[1,1,1,0,1,0],"c":"#467532","t":1},{"p":[276,104,-284],"s":[400,40,50],"f":[0,0,1,0,0,0],"c":"#467532","t":1},{"p":[-99,141,-49],"s":[12,2,1],"l":1,"pe":1,"r":[0,0,0.7],"f":[0,0,1,1,1,1],"c":"#505050","t":2},{"p":[-99,141,-59],"s":[12,2,1],"l":1,"pe":1,"r":[0,0,0.7],"f":[0,0,1,1,1,1],"c":"#505050","t":2},{"p":[-78,140,-49],"s":[14,2,1],"l":1,"pe":1,"r":[0,0,-0.7],"f":[0,0,1,1,1,1],"c":"#505050","t":2},{"p":[-78,140,-59],"s":[14,2,1],"l":1,"pe":1,"r":[0,0,-0.7],"f":[0,0,1,1,1,1],"c":"#505050","t":2},{"p":[-176,109,-227],"s":[12,1,34],"l":1,"f":[1,0,1,0,1,0],"c":"#467532","t":1},{"p":[93,109,47],"s":[7,1,18],"l":1,"f":[1,0,1,0,0,1],"c":"#467532","t":1},{"p":[-114,135,122],"s":[20,29,30],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-301,109,155],"s":[32,1,20],"l":1,"f":[1,0,1,0,0,1],"c":"#467532","t":1},{"p":[-432,109,-55],"s":[120,26,600],"f":[0,0,1,0,0,0],"c":"#467532","t":1},{"p":[32,109,125],"s":[37,6,4],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[91,161,-33],"s":[10,30,32],"c":"#7d7d61","e":"#282828","bo":1},{"p":[89,191,-107],"s":[18,4,172],"f":[1,1,0,1,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[91,161,-131],"s":[10,30,120],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-39,109,-33],"s":[10,82,32],"c":"#7d7d61","e":"#282828","bo":1},{"p":[22,191,-20],"s":[100,4,10],"f":[1,0,0,1,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[89,195,-109],"s":[14,10,164],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[89,205,-115],"s":[18,4,156],"f":[1,1,0,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[19,195,-20],"s":[98,10,6],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[19,205,-20],"s":[94,4,10],"f":[1,1,0,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-32,59,-84],"s":[4,132,26],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11,"bo":1},{"p":[-32,59,-36],"s":[4,132,26],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11,"bo":1},{"p":[-39,161,-131],"s":[10,30,120],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-37,191,-104],"s":[18,4,178],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-37,205,-104],"s":[18,4,178],"f":[1,1,0,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-37,195,-104],"s":[14,10,174],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[-30,168,-60],"s":[1,4,26],"pe":1,"c":"#505050","t":2},{"p":[-30,185,-60],"s":[1,4,26],"pe":1,"c":"#505050","t":2},{"p":[-30,177,-60],"s":[1,4,26],"pe":1,"r":[0.17,0,0],"c":"#505050","t":2},{"p":[-350,88,-57],"s":[4,21,140],"c":"#7d7d61","e":"#282828"},{"p":[-364,133,-172],"s":[10,50,10],"pe":1,"f":[1,0,0,0,1,1],"c":"#505050","t":2},{"p":[-364,174,-172],"s":[110,58,110],"l":1,"pe":1,"f":[1,0,0,1,1,1],"c":"#467532","t":1},{"p":[85,161,1],"s":[13,5,7],"l":1,"r":[0,0.35,0],"c":"#7d7d61","e":"#282828"},{"p":[21,183,-20],"s":[110,8,6],"f":[1,0,0,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-46,144,256],"s":[8,44,8],"pe":1,"f":[1,1,0,0,0,1],"c":"#505050","t":2},{"p":[-46,179,256],"s":[62,40,62],"l":1,"pe":1,"f":[1,1,0,1,0,1],"c":"#467532","t":1},{"p":[71,235,264],"s":[34,16,50],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,199,237],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[218,227,-332],"s":[30,6,50],"r":[-3.14,0,-3.14],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-138,144,-103],"s":[6,4,10],"l":1,"c":"#7d7d61","e":"#282828"},{"p":[-234,167,-81],"s":[26,22,26],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-240,189,-89],"s":[14,10,10],"c":"#7d7d61","e":"#282828"},{"p":[-229,187,-84],"s":[8,6,12],"c":"#7d7d61","e":"#282828"},{"p":[-220,171,-58],"s":[12,4,12],"l":1,"r":[0.87,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-234,167,-65],"s":[26,12,6],"c":"#7d7d61","e":"#282828"},{"p":[-234,167,37],"s":[32,8,42],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-234,175,42],"s":[30,4,32],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-243,167,-2],"s":[8,6,12],"c":"#7d7d61","e":"#282828"},{"p":[-41,59,-187],"s":[14,86,68],"f":[1,1,0,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[5,59,-177],"s":[18,86,4],"f":[1,1,0,0,1,0],"c":"#7d7d61","e":"#282828","t":11},{"p":[47,59,-177],"s":[18,86,4],"f":[1,1,0,0,1,0],"c":"#7d7d61","e":"#282828","t":11},{"p":[-34,88,-159],"s":[2,34,8],"i":3,"c":"#505050","t":2},{"p":[26,89,-20],"s":[120,94,6],"f":[0,0,1,1,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[91,109,-62],"s":[10,52,50],"f":[1,1,1,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[55,154,-60],"s":[1,4,30],"l":1,"r":[0.17,0,0],"c":"#505050","t":2},{"p":[55,147,-60],"s":[1,4,30],"pe":1,"c":"#505050","t":2},{"p":[96,109,-27],"s":[20,30,20],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[82,103,-60],"s":[1,4,30],"l":1,"c":"#505050","t":2},{"p":[82,112,-60],"s":[1,4,30],"l":1,"r":[-0.17,0,0],"c":"#7c7c7c","t":2},{"p":[124,109,-139],"s":[76,6,76],"c":"#7d7d61","e":"#282828"},{"p":[-164,99,103],"s":[80,10,100],"f":[0,0,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-29,103,-138],"s":[10,8,22],"f":[1,0,1,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[81,103,-138],"s":[10,8,22],"f":[0,1,1,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-38,98,-138],"s":[10,14,20],"l":1,"r":[0,0,-0.87],"c":"#7d7d61","e":"#282828"},{"p":[90,98,-138],"s":[10,14,20],"l":1,"r":[0,0,0.87],"c":"#7d7d61","e":"#282828"},{"p":[137,109,-94],"s":[30,6,14],"i":9,"v":1,"c":"#a7a793","d":3},{"p":[-74,59,119],"s":[100,50,128],"f":[1,0,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-84,59,-8],"s":[80,50,90],"f":[0,0,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-77,59,46],"s":[86,50,18],"f":[1,0,1,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-66,109,62],"s":[44,41,14],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-128,109,51],"s":[1,64,1],"pe":1,"c":"#505050","t":2},{"p":[-128,109,41],"s":[1,62,1],"pe":1,"c":"#505050","t":2},{"p":[-141,152,46],"s":[30,1,12],"pe":1,"c":"#505050","t":2,"bo":1},{"p":[-155,109,41],"s":[1,62,1],"pe":1,"c":"#505050","t":2},{"p":[-155,109,51],"s":[1,62,1],"pe":1,"c":"#505050","t":2},{"p":[-171,135,46],"s":[34,1,12],"pe":1,"c":"#505050","t":2,"bo":1},{"p":[-187,109,41],"s":[1,42,1],"pe":1,"c":"#505050","t":2},{"p":[-187,109,51],"s":[1,42,1],"pe":1,"c":"#505050","t":2},{"p":[-154,147,46],"s":[1,1,12],"pe":1,"c":"#505050","t":2},{"p":[-129,131,46],"s":[1,1,12],"pe":1,"c":"#505050","t":2,"bo":1},{"p":[-129,163,46],"s":[1,1,12],"pe":1,"c":"#505050","t":2},{"p":[-156,157,46],"s":[1,1,12],"pe":1,"c":"#505050","t":2},{"p":[-186,143,46],"s":[1,1,12],"pe":1,"c":"#505050","t":2},{"p":[-157,109,42],"s":[66,1,24],"l":1,"f":[0,0,1,0,0,1],"c":"#467532","t":1},{"p":[-117,109,75],"s":[14,41,40],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-56,109,-37],"s":[28,1,24],"l":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[-117,109,45],"s":[14,26,20],"f":[1,1,0,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-104,109,32],"s":[40,27,6],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-104,135,45],"s":[42,4,36],"f":[1,1,1,1,0,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-86,109,35],"s":[2,27,2],"l":1,"c":"#505050","t":2},{"p":[-86,109,55],"s":[2,27,2],"l":1,"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[-86,134,45],"s":[2,2,18],"l":1,"f":[1,1,1,1,0,0],"c":"#505050","t":2},{"p":[-86,131,52],"s":[1,2,12],"l":1,"pe":1,"r":[0.7,0,0],"f":[1,1,1,1,0,0],"c":"#505050","t":2},{"p":[-86,131,38],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"f":[1,1,1,1,0,0],"c":"#505050","t":2},{"p":[-98,134,45],"s":[4,1,3],"c":"#000000","t":5},{"p":[-98,133,45],"s":[3,1,2],"l":1,"c":"#000000","e":"#ffe9a6","t":5},{"p":[-73,154,57],"s":[90,14,4],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[-72,168,57],"s":[84,4,8],"f":[0,1,1,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-116,109,26],"s":[34,1,8],"l":1,"f":[1,1,1,0,0,1],"c":"#467532","t":1},{"p":[-83,130,35],"s":[1,10,3],"l":1,"c":"#467532","t":1},{"p":[-83,125,33],"s":[1,15,1],"l":1,"c":"#467532","t":1},{"p":[-24,59,81],"s":[2,91,18],"f":[1,0,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[21,157,11],"s":[134,4,60],"f":[1,1,1,1,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-30,86,-60],"s":[1,4,30],"l":1,"c":"#505050","t":2},{"p":[-30,96,-61],"s":[1,4,30],"l":1,"r":[0.35,0,0],"c":"#7a7a7a","t":2},{"p":[-30,110,-60],"s":[1,4,30],"l":1,"c":"#505050","t":2},{"p":[-184,109,-234],"s":[1,54,1],"pe":1,"c":"#505050","t":2},{"p":[-79,115,-119],"s":[57,28,110],"i":14,"l":1},{"p":[35,109,165],"s":[113,49,73],"i":14,"l":1},{"p":[-125,109,153],"s":[2,40,2],"l":1,"c":"#505050","t":2},{"p":[-183,109,153],"s":[2,40,2],"l":1,"c":"#505050","t":2},{"p":[-144,109,153],"s":[2,40,2],"l":1,"c":"#505050","t":2},{"p":[-164,109,153],"s":[2,40,2],"l":1,"c":"#505050","t":2},{"p":[-183,109,90],"s":[2,40,2],"l":1,"c":"#505050","t":2},{"p":[-164,109,90],"s":[2,40,2],"l":1,"c":"#505050","t":2},{"p":[-144,109,90],"s":[2,40,2],"l":1,"c":"#505050","t":2},{"p":[-125,109,90],"s":[2,40,2],"l":1,"c":"#505050","t":2},{"p":[-144,135,156],"s":[1,20,2],"l":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-125,135,156],"s":[1,20,2],"l":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-164,135,156],"s":[1,20,2],"l":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-183,135,156],"s":[1,20,2],"l":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-183,138,90],"s":[1,20,2],"l":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[-164,138,90],"s":[1,20,2],"l":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[-144,138,90],"s":[1,20,2],"l":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[-125,138,90],"s":[1,20,2],"l":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[-85,109,30],"s":[3,27,3],"l":1,"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[-123,109,30],"s":[3,27,3],"l":1,"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[-88,139,33],"s":[9,1,12],"l":1,"c":"#467532","t":1},{"p":[-83,134,27],"s":[1,6,1],"l":1,"c":"#467532","t":1},{"p":[-83,137,29],"s":[1,3,3],"l":1,"c":"#467532","t":1},{"p":[71,205,239],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,211,241],"s":[30,6,50],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,217,243],"s":[30,6,50],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,223,245],"s":[30,6,50],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-368,91,-223],"s":[96,30,200],"f":[1,0,0,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[96,142,-56],"s":[1,20,1],"l":1,"c":"#505050","t":2},{"p":[96,144,-64],"s":[1,18,1],"l":1,"c":"#505050","t":2},{"p":[97,158,-60],"s":[1,2,10],"l":1,"c":"#505050","t":2},{"p":[94,161,-56],"s":[5,1,1],"l":1,"c":"#505050","t":2},{"p":[94,161,-64],"s":[5,1,1],"l":1,"c":"#505050","t":2},{"p":[97,151,-60],"s":[1,2,10],"l":1,"r":[-0.09,0,0],"c":"#505050","t":2},{"p":[204,59,53],"s":[236,50,280],"f":[0,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[31,79,158],"s":[110,30,70],"f":[0,0,1,1,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-154,141,46],"s":[1,1,12],"pe":1,"c":"#505050","t":2},{"p":[-7,109,209],"s":[44,10,30],"i":9,"c":"#467532","t":1,"d":1},{"p":[93,109,210],"s":[14,6,50],"v":1,"c":"#7d7d61","e":"#282828","bo":1},{"p":[93,115,212],"s":[14,6,50],"v":1,"c":"#7d7d61","e":"#282828","bo":1},{"p":[93,121,214],"s":[14,6,50],"v":1,"c":"#7d7d61","e":"#282828","bo":1},{"p":[93,127,217],"s":[14,6,50],"v":1,"c":"#7d7d61","e":"#282828","bo":1},{"p":[49,127,216],"s":[14,6,50],"v":1,"c":"#7d7d61","e":"#282828","bo":1},{"p":[49,121,213],"s":[14,6,50],"v":1,"c":"#7d7d61","e":"#282828","bo":1},{"p":[49,115,211],"s":[14,6,50],"v":1,"c":"#7d7d61","e":"#282828","bo":1},{"p":[49,109,209],"s":[14,6,50],"v":1,"c":"#7d7d61","e":"#282828","bo":1},{"p":[71,127,213],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[71,121,211],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,115,209],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[71,109,207],"s":[30,6,50],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[161,109,227],"s":[62,28,60],"i":9,"c":"#467532","t":1,"d":1},{"p":[119,125,197],"s":[4,14,4],"r":[0.17,0,0],"c":"#7d7d61","e":"#282828"},{"p":[113,125,202],"s":[4,14,4],"r":[-0.17,0,0],"c":"#7d7d61","e":"#282828"},{"p":[116,139,200],"s":[10,14,6],"c":"#7d7d61","e":"#282828"},{"p":[116,153,200],"s":[7,7,7],"c":"#7d7d61","e":"#282828"},{"p":[122,149,201],"s":[3,8,4],"l":1,"r":[-0.69,0,0],"c":"#7d7d61","e":"#282828"},{"p":[122,154,196],"s":[3,8,4],"c":"#7d7d61","e":"#282828"},{"p":[30,125,198],"s":[4,14,4],"r":[0.17,0,0],"c":"#7d7d61","e":"#282828"},{"p":[24,125,202],"s":[4,14,4],"r":[-0.17,0,0],"c":"#7d7d61","e":"#282828"},{"p":[27,139,200],"s":[10,14,6],"c":"#7d7d61","e":"#282828"},{"p":[27,153,200],"s":[7,7,7],"c":"#7d7d61","e":"#282828"},{"p":[21,144,202],"s":[3,8,4],"l":1,"r":[-0.35,0,0],"c":"#7d7d61","e":"#282828"},{"p":[21,140,197],"s":[3,8,4],"l":1,"r":[0.7,0,0],"c":"#7d7d61","e":"#282828"},{"p":[33,144,202],"s":[3,8,4],"l":1,"r":[-0.35,0,0],"c":"#7d7d61","e":"#282828"},{"p":[33,140,197],"s":[3,8,4],"l":1,"r":[0.7,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-351,91,-112],"s":[70,1,300],"l":1,"f":[1,0,1,0,0,1],"c":"#467532","t":1},{"p":[115,121,208],"s":[32,4,32],"c":"#7d7d61","e":"#282828","bo":1},{"p":[27,121,208],"s":[32,4,32],"c":"#7d7d61","e":"#282828","bo":1},{"p":[393,119,164],"s":[220,40,220],"f":[0,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[519,119,76],"s":[30,30,30],"l":1,"pe":1,"f":[0,1,1,0,0,1],"c":"#467532","t":1},{"p":[393,159,164],"s":[180,30,180],"f":[0,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[393,219,164],"s":[100,30,100],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[393,249,164],"s":[50,30,50],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[393,159,164],"s":[224,4,224],"f":[0,1,1,1,0,1],"c":"#7d7d61","e":"#282828"},{"p":[393,189,164],"s":[184,4,184],"f":[0,1,1,1,0,1],"c":"#7d7d61","e":"#282828"},{"p":[393,219,164],"s":[144,4,144],"f":[0,1,0,1,0,1],"c":"#7d7d61","e":"#282828"},{"p":[393,249,164],"s":[104,4,104],"f":[1,1,0,1,0,1],"c":"#7d7d61","e":"#282828"},{"p":[393,279,164],"s":[54,4,54],"f":[1,1,0,1,0,1],"c":"#7d7d61","e":"#282828"},{"p":[393,119,54],"s":[4,40,3],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[343,119,54],"s":[4,40,3],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[293,119,54],"s":[4,40,3],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[443,119,54],"s":[4,40,3],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[493,119,54],"s":[4,40,3],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[266,149,64],"s":[20,8,100],"c":"#7d7d61","e":"#282828","t":11},{"p":[266,139,55],"s":[24,4,140],"f":[1,0,1,1,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[266,157,72],"s":[24,4,100],"c":"#7d7d61","e":"#282828"},{"p":[281,123,76],"s":[20,36,22],"i":9,"c":"#467532","t":1,"d":1},{"p":[215,137,63],"s":[76,20,160],"f":[1,1,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[184,157,-8],"s":[10,22,10],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[184,157,136],"s":[10,30,10],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[184,157,100],"s":[10,30,10],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[184,157,64],"s":[10,30,10],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[184,157,28],"s":[10,30,10],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[223,157,75],"s":[56,30,132],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[215,187,75],"s":[76,4,136],"c":"#7d7d61","e":"#282828"},{"p":[215,191,75],"s":[72,10,132],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[215,201,75],"s":[76,4,136],"f":[1,1,0,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[186,179,-5],"s":[6,5,4],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[181,179,-6],"s":[4,2,6],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[223,157,3],"s":[56,18,12],"f":[1,1,1,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[223,162,-17],"s":[14,26,12],"r":[0.52,0,0],"c":"#7d7d61","e":"#282828"},{"p":[259,150,-9],"s":[6,12,6],"r":[0,0,0.35],"c":"#7d7d61","e":"#282828"},{"p":[264,149,-1],"s":[6,2,3],"c":"#7d7d61","e":"#282828"},{"p":[241,132,194],"s":[80,28,160],"i":9,"c":"#467532","t":1},{"p":[-234,59,-35],"s":[37,52,176],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-207,105,-287],"s":[420,40,50],"f":[0,0,1,0,0,0],"c":"#467532","t":1},{"p":[176,137,-307],"s":[30,30,30],"r":[-3.14,0,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[192,137,166],"s":[10,30,10],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[192,137,193],"s":[10,42,10],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[192,137,166],"s":[14,4,14],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[191,179,190],"s":[20,4,22],"c":"#7d7d61","e":"#282828"},{"p":[191,183,190],"s":[16,10,18],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[192,137,193],"s":[14,4,14],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[191,193,190],"s":[20,4,22],"f":[1,1,0,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[156,109,158],"s":[5,3,9],"l":1,"c":"#7d7d61","e":"#282828"},{"p":[179,137,216],"s":[7,5,11],"r":[0,0.7,0],"c":"#7d7d61","e":"#282828"},{"p":[1,142,-315],"s":[24,25,24],"l":1,"pe":1,"c":"#467532","t":1},{"p":[8,153,-333],"s":[28,31,30],"l":1,"pe":1,"f":[1,1,0,0,1,0],"c":"#467532","t":1},{"p":[-147,153,45],"s":[12,12,12],"i":8,"l":1,"r":[0,-0.52,0]},{"p":[539,126,-80],"s":[30,24,20],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[539,126,-3],"s":[30,24,20],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[539,126,-42],"s":[30,24,20],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[554,150,-61],"s":[60,33,136],"f":[0,1,0,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[523,126,-12],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[523,126,-34],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[523,150,-23],"s":[3,4,28],"c":"#7d7d61","e":"#282828"},{"p":[523,126,-50],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[523,126,-88],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[523,126,-110],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[523,126,-72],"s":[2,24,4],"c":"#7d7d61","e":"#282828"},{"p":[523,150,-61],"s":[3,4,28],"c":"#7d7d61","e":"#282828"},{"p":[539,126,-119],"s":[30,24,20],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[523,150,-99],"s":[3,4,28],"c":"#7d7d61","e":"#282828"},{"p":[554,180,-61],"s":[64,4,140],"f":[0,1,1,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[554,194,-61],"s":[64,4,140],"f":[0,1,0,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[533,124,-188],"s":[30,30,30],"l":1,"pe":1,"c":"#467532","t":1},{"p":[562,129,10],"s":[51,36,36],"l":1,"pe":1,"f":[0,1,1,0,1,1],"c":"#467532","t":1},{"p":[-66,150,212],"s":[88,4,66],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-99,139,62],"s":[22,11,14],"f":[0,0,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-99,135,66],"s":[22,4,6],"f":[0,0,1,1,1,1],"c":"#7d7d61","e":"#282828"},{"p":[31,121,133],"s":[12,12,12],"i":8},{"p":[126,149,-154],"s":[80,10,134],"f":[1,1,0,0,1,0],"c":"#7d7d61","e":"#282828","t":11},{"p":[311,186,-147],"s":[50,10,60],"f":[1,1,0,0,1,0],"c":"#7d7d61","e":"#282828","t":11},{"p":[413,160,-202],"s":[200,10,50],"f":[0,1,0,0,1,0],"c":"#7d7d61","e":"#282828","t":11},{"p":[480,200,-289],"s":[120,10,100],"f":[0,1,0,0,1,0],"c":"#7d7d61","e":"#282828","t":11},{"p":[554,184,-61],"s":[60,10,136],"f":[0,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[266,143,53],"s":[20,6,140],"c":"#7d7d61","e":"#282828","t":11},{"p":[344,151,-71],"s":[50,4,96],"c":"#7d7d61","e":"#282828"},{"p":[-28,115,32],"s":[6,23,2],"pe":1,"c":"#818181","t":2},{"p":[-17,118,32],"s":[28,1,3],"pe":1,"c":"#505050","t":2},{"p":[-22,115,32],"s":[6,22,1],"pe":1,"c":"#505050","t":2},{"p":[-17,115,32],"s":[4,23,1],"pe":1,"c":"#707070","t":2},{"p":[-12,115,32],"s":[6,21,2],"pe":1,"c":"#7a7a7a","t":2},{"p":[-7,115,32],"s":[7,22,1],"pe":1,"c":"#505050","t":2},{"p":[26,149,-198],"s":[120,10,46],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[26,159,-198],"s":[116,4,50],"c":"#7d7d61","e":"#282828","bo":1},{"p":[5,97,-282],"s":[170,58,120],"f":[1,0,1,0,0,0],"c":"#467532","t":1},{"p":[173,116,-197],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[-420,140,-55],"s":[40,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-411,128,-37],"s":[50,20,12],"l":1,"r":[0,0,-0.69],"c":"#7d7d61","e":"#282828"},{"p":[-424,145,-55],"s":[40,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-428,150,-55],"s":[40,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-416,135,-55],"s":[40,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-407,135,-33],"s":[20,26,600],"i":9,"c":"#467532","t":1,"d":2},{"p":[-370,109,-55],"s":[40,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-374,114,-55],"s":[40,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-378,119,-55],"s":[40,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-382,124,-55],"s":[40,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[110,140,200],"s":[3,12,4],"c":"#7d7d61","e":"#282828"},{"p":[-299,81,-120],"s":[200,10,300],"f":[0,0,1,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[179,116,-217],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[192,116,-204],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[209,116,-191],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[212,116,-216],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[226,116,-208],"s":[7,6,8],"i":18,"l":1,"r":[0,0.87,0],"c":"#acdc56"},{"p":[193,116,-187],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[240,116,-190],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#acdc56"},{"p":[255,116,-217],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[280,116,-203],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[261,116,-196],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#acdc56"},{"p":[293,116,-189],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#acdc56"},{"p":[301,116,-219],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[272,116,-187],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[233,116,-194],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[251,116,-204],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[116,160,200],"s":[8,2,8],"c":"#7d7d61","e":"#282828"},{"p":[116,162,200],"s":[7,4,7],"c":"#7d7d61","e":"#282828","t":11},{"p":[116,166,200],"s":[8,2,8],"c":"#7d7d61","e":"#282828"},{"p":[27,160,200],"s":[8,2,8],"c":"#7d7d61","e":"#282828"},{"p":[27,162,200],"s":[7,4,7],"c":"#7d7d61","e":"#282828","t":11},{"p":[27,166,200],"s":[8,2,8],"c":"#7d7d61","e":"#282828"},{"p":[222,137,-44],"s":[10,14,6],"c":"#7d7d61","e":"#282828","bo":1},{"p":[222,151,-44],"s":[7,7,7],"c":"#7d7d61","e":"#282828"},{"p":[222,158,-44],"s":[8,2,8],"c":"#7d7d61","e":"#282828"},{"p":[222,160,-44],"s":[7,4,7],"c":"#7d7d61","e":"#282828","t":11},{"p":[222,164,-44],"s":[8,2,8],"c":"#7d7d61","e":"#282828"},{"p":[225,123,-44],"s":[4,14,4],"c":"#7d7d61","e":"#282828","bo":1},{"p":[219,123,-44],"s":[4,14,4],"c":"#7d7d61","e":"#282828","bo":1},{"p":[239,109,-40],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[159,110,-41],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[176,110,-46],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[155,110,116],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[153,110,178],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[101,110,182],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[156,110,171],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[93,110,114],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[92,110,56],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[187,144,-270],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[166,144,-288],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[231,144,-275],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[260,144,-265],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[269,144,-285],"s":[7,6,8],"i":18,"l":1,"r":[0,1.05,0],"c":"#acdc56"},{"p":[150,144,-269],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[144,144,-288],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[363,123,-8],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[360,123,8],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[489,123,46],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.17,0],"c":"#acdc56"},{"p":[439,123,49],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[337,123,51],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[156,109,-1],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[30,110,190],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[-20,110,189],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[165,118,38],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[161,111,77],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[176,134,135],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[171,126,221],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[146,118,219],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#acdc56"},{"p":[157,111,207],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[183,137,185],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[208,137,246],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[236,143,180],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[227,139,221],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#acdc56"},{"p":[-47,109,-30],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[-133,110,-55],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[-126,110,-44],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[-195,110,-64],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[-204,110,-40],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[-157,109,44],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[-211,110,11],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#acdc56"},{"p":[-127,110,28],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[-150,110,49],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[-198,110,-144],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[-162,81,-184],"s":[104,28,154],"f":[0,1,1,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-411,128,-73],"s":[50,20,12],"l":1,"r":[0,0,-0.69],"c":"#7d7d61","e":"#282828"},{"p":[-372,106,-37],"s":[26,20,12],"l":1,"r":[0,0,-0.86],"c":"#7d7d61","e":"#282828"},{"p":[-373,106,-73],"s":[26,20,12],"l":1,"r":[0,0,-0.86],"c":"#7d7d61","e":"#282828"},{"p":[-1,116,221],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[-13,113,209],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#acdc56"},{"p":[32,114,137],"s":[2,3,6],"l":1,"c":"#5f5f5f","t":11},{"p":[30,114,137],"s":[2,3,6],"l":1,"c":"#8e8e8e","t":11},{"p":[31,115,138],"s":[1,1,5],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-186,115,-157],"s":[2,3,6],"l":1,"c":"#5f5f5f","t":11},{"p":[-188,115,-157],"s":[2,3,6],"l":1,"c":"#8e8e8e","t":11},{"p":[-187,116,-158],"s":[1,1,5],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-187,109,-151],"s":[16,16,16],"c":"#ffffff","t":2},{"p":[-187,111,-151],"s":[17,1,17],"l":1,"c":"#393939","t":5},{"p":[-187,122,-151],"s":[17,1,17],"l":1,"c":"#393939","t":5},{"p":[-165,109,-245],"s":[94,1,34],"l":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[-192,109,-226],"s":[14,16,14],"c":"#ffffff","t":2},{"p":[-184,109,-226],"s":[1,50,1],"pe":1,"c":"#505050","t":2},{"p":[-164,134,-230],"s":[42,1,10],"pe":1,"c":"#505050","t":2},{"p":[-144,109,-234],"s":[1,47,1],"pe":1,"c":"#505050","t":2},{"p":[-144,109,-226],"s":[1,53,1],"pe":1,"c":"#505050","t":2},{"p":[-162,109,-226],"s":[1,51,1],"pe":1,"c":"#505050","t":2},{"p":[-162,109,-234],"s":[1,53,1],"pe":1,"c":"#505050","t":2},{"p":[-206,109,-229],"s":[12,12,12],"i":8},{"p":[-163,109,-235],"s":[53,32,1],"l":1,"r":[-0.17,0,0],"c":"#1e798e","t":5},{"p":[-190,109,-235],"s":[1,32,2],"l":1,"r":[-0.17,0,0],"c":"#505050","t":5},{"p":[-136,109,-235],"s":[1,32,2],"l":1,"r":[-0.17,0,0],"c":"#505050","t":5},{"p":[-163,140,-240],"s":[55,1,2],"l":1,"r":[-0.17,0,0],"c":"#505050","t":5},{"p":[-185,145,-230],"s":[1,1,10],"pe":1,"c":"#505050","t":2},{"p":[-185,140,-230],"s":[1,1,10],"pe":1,"c":"#505050","t":2},{"p":[-143,150,-230],"s":[1,1,10],"pe":1,"c":"#505050","t":2},{"p":[-143,145,-230],"s":[1,1,10],"pe":1,"c":"#505050","t":2},{"p":[-143,140,-230],"s":[1,1,10],"pe":1,"c":"#505050","t":2},{"p":[-143,117,-230],"s":[1,1,10],"pe":1,"c":"#505050","t":2},{"p":[-143,125,-230],"s":[1,1,10],"pe":1,"c":"#505050","t":2},{"p":[-179,109,-230],"s":[9,18,9],"c":"#898989","t":11},{"p":[-177,135,-226],"s":[11,9,1],"l":1,"r":[-0.17,0,0],"c":"#ffffff","t":5},{"p":[96,109,64],"s":[12,14,10],"c":"#ffffff","t":2},{"p":[-303,157,186],"s":[124,4,64],"f":[1,0,1,1,0,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-303,161,186],"s":[120,10,60],"f":[1,0,0,0,0,1],"c":"#7d7d61","e":"#282828","t":11},{"p":[-303,171,186],"s":[124,4,64],"f":[1,0,1,1,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-130,109,-203],"s":[12,12,12],"i":8},{"p":[-363,99,-55],"s":[40,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-358,94,-55],"s":[40,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-353,89,-55],"s":[40,5,24],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-8,109,209],"s":[1,18,1],"pe":1,"c":"#505050","t":2},{"p":[-8,118,208],"s":[14,8,1],"pe":1,"c":"#ffffff","t":5},{"p":[-132,109,-190],"s":[14,22,14],"c":"#ffffff","t":2},{"p":[-132,128,-190],"s":[15,1,15],"l":1,"c":"#393939","t":5},{"p":[-132,111,-190],"s":[15,1,15],"l":1,"c":"#393939","t":5},{"p":[-176,110,-221],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[-202,110,-218],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[-129,109,-171],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[-368,121,-223],"s":[100,4,204],"f":[1,0,1,1,1,0],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-368,125,-223],"s":[96,10,200],"f":[1,0,0,0,1,0],"c":"#7d7d61","e":"#282828","t":11},{"p":[-368,135,-223],"s":[100,4,204],"f":[1,0,0,1,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-368,139,-223],"s":[100,2,204],"f":[1,0,1,1,1,0],"c":"#467532","t":1},{"p":[-278,161,-335],"s":[18,21,17],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-342,129,-263],"s":[18,21,17],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-391,134,-164],"s":[18,21,17],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-389,131,-223],"s":[18,21,17],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-343,128,-140],"s":[15,18,15],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-355,132,-135],"s":[15,18,15],"l":1,"pe":1,"c":"#467532","t":1},{"p":[-412,138,-250],"s":[7,50,7],"pe":1,"f":[1,0,0,0,1,0],"c":"#505050","t":2},{"p":[-412,159,-250],"s":[54,36,54],"l":1,"pe":1,"f":[1,0,0,1,1,0],"c":"#467532","t":1},{"p":[-325,141,-231],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[-353,141,-184],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#acdc56"},{"p":[-337,141,-170],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[-330,141,-206],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#acdc56"},{"p":[-333,141,-132],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[-364,141,-152],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#acdc56"},{"p":[-389,141,-136],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[-364,141,-220],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[-146,127,-345],"s":[120,30,120],"f":[1,1,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-146,171,-345],"s":[80,14,80],"f":[1,1,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-146,185,-345],"s":[60,14,60],"f":[1,1,0,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-146,199,-345],"s":[40,14,40],"f":[1,1,0,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-146,120,-276],"s":[20,100,40],"r":[-0.7,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-240,185,-327],"s":[80,46,80],"l":1,"pe":1,"f":[1,1,0,1,1,0],"c":"#467532","t":1},{"p":[-46,127,-297],"s":[7,80,7],"pe":1,"f":[1,1,0,0,1,0],"c":"#505050","t":2},{"p":[-386,135,29],"s":[10,16,10],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-218,91,-138],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[-223,92,-162],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.79,0],"c":"#acdc56"},{"p":[-244,92,-204],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[-316,92,-212],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[-343,92,-95],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[-266,91,-104],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.61,3.14],"c":"#acdc56"},{"p":[-258,91,-33],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#acdc56"},{"p":[-350,110,31],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.17,0],"c":"#acdc56"},{"p":[-335,110,116],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[-342,110,111],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[-257,108,55],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[-209,109,95],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[-290,110,153],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[-271,109,99],"s":[20,13,14],"c":"#ffffff","t":2},{"p":[-324,110,69],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[-279,109,99],"s":[1,14,15],"l":1,"c":"#393939","t":5},{"p":[-263,109,99],"s":[1,14,15],"l":1,"c":"#393939","t":5},{"p":[-285,109,98],"s":[8,15,8],"c":"#898989","t":11},{"p":[-146,157,-345],"s":[100,14,100],"f":[1,1,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-392,135,148],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[-382,135,127],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[-392,135,108],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[-387,135,101],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[-377,135,78],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[-379,135,37],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[-387,135,21],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#acdc56"},{"p":[-388,135,-29],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[-378,135,-56],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[-379,135,-7],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[-393,135,-83],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#acdc56"},{"p":[-377,135,-118],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.17,0],"c":"#acdc56"},{"p":[-205,133,191],"s":[8,44,8],"pe":1,"f":[1,1,0,0,0,1],"c":"#505050","t":2},{"p":[-205,156,191],"s":[56,36,56],"l":1,"pe":1,"f":[1,1,1,1,0,1],"c":"#467532","t":1},{"p":[-211,135,182],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[-216,135,188],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[-235,135,185],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[-164,59,168],"s":[80,90,30],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828","bo":1},{"p":[222,109,-43],"s":[14,12,14],"f":[1,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[222,121,-43],"s":[15,2,15],"f":[1,1,1,1,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-21,119,226],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#acdc56"},{"p":[-129,110,-234],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[-210,145,-293],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[-170,145,-281],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#acdc56"},{"p":[-140,145,-269],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[-104,145,-270],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[114,144,-275],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[367,144,-269],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[-363,135,-342],"s":[160,60,100],"f":[1,0,0,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-363,195,-342],"s":[164,4,104],"f":[1,0,0,1,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-363,199,-342],"s":[160,10,100],"f":[1,0,0,0,1,0],"c":"#7d7d61","e":"#282828","t":11},{"p":[-363,209,-342],"s":[164,4,104],"f":[1,0,0,1,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-281,145,-288],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#acdc56"},{"p":[-260,145,-281],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#acdc56"},{"p":[-235,145,-270],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#acdc56"},{"p":[-267,150,-329],"s":[18,21,21],"l":1,"pe":1,"c":"#467532","t":1},{"p":[393,189,164],"s":[140,30,140],"f":[0,1,0,0,0,1],"c":"#7d7d61","e":"#282828"},{"p":[-91,133,27],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-88,136,27],"s":[5,4,1],"l":1,"c":"#467532","t":1},{"p":[215,109,123],"s":[76,28,260],"f":[0,0,1,0,0,0],"c":"#467532","t":1},{"p":[396,95,93],"s":[257,28,100],"f":[0,0,1,0,0,0],"c":"#467532","t":1},{"p":[-232,91,-184],"s":[36,18,34],"i":9,"v":1,"c":"#a7a793"},{"p":[64,57,-199],"s":[196,88,44],"f":[0,0,0,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[8,110,196],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#acdc56"},{"p":[-14,75,110],"s":[4,2,23],"l":1,"pe":1,"r":[0,0.61,0],"c":"#505050","t":2},{"p":[-117,59,-85],"s":[14,86,76],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-41,59,-85],"s":[14,86,76],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-123,109,-35],"s":[24,1,4],"l":1,"f":[1,1,1,0,1,0],"c":"#467532","t":1},{"p":[-39,59,7],"s":[10,30,60],"f":[1,0,0,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-163,96,-265],"s":[45,40,50],"f":[1,1,1,0,0,0],"c":"#467532","t":1},{"p":[-175,136,-245],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[-152,136,-252],"s":[7,6,8],"i":18,"l":1,"c":"#acdc56"},{"p":[-143,109,-188],"s":[6,1,32],"l":1,"f":[0,1,1,0,1,1],"c":"#467532","t":1},{"p":[-102,109,-271],"s":[44,46,100],"i":9,"c":"#467532","t":1},{"p":[227,123,-47],"s":[5,1,7],"l":1,"c":"#467532","t":1},{"p":[230,117,-46],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[230,120,-50],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[230,122,-48],"s":[1,2,3],"l":1,"c":"#467532","t":1},{"p":[230,121,-45],"s":[1,3,1],"l":1,"c":"#467532","t":1},{"p":[215,110,-42],"s":[1,3,5],"l":1,"c":"#467532","t":1},{"p":[215,110,-38],"s":[1,8,3],"l":1,"c":"#467532","t":1},{"p":[215,113,-40],"s":[1,2,1],"l":1,"c":"#467532","t":1},{"p":[215,110,-46],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[215,113,-42],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[364,152,21],"s":[6,8,6],"i":2,"l":1,"r":[0,-0.52,0]},{"p":[364,123,43],"s":[5,1,21],"l":1,"r":[-3.14,1.05,-3.14],"c":"#505050","t":2},{"p":[369,123,-11],"s":[4,1,29],"l":1,"r":[0,0.96,0],"c":"#505050","t":2},{"p":[129,134,-138],"s":[16,12,16],"i":32,"l":1,"c":"#ffe9a6","o":0.5},{"p":[-79,135,-150],"s":[16,10,16],"i":32,"l":1,"c":"#ffe9a6","o":0.5},{"p":[-79,135,-82],"s":[16,10,16],"i":32,"l":1,"c":"#ffe9a6","o":0.5},{"p":[-98,125,45],"s":[16,11,16],"i":32,"l":1,"c":"#ffe9a6","o":0.5},{"p":[96,109,82],"s":[13,15,1],"l":1,"c":"#393939","t":5},{"p":[96,109,62],"s":[13,15,1],"l":1,"c":"#393939","t":5},{"p":[-122,109,-123],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-112,109,-123],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-122,109,-153],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-112,109,-153],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-79,109,-199],"s":[62,36,44],"f":[0,0,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-328,145,-274],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#acdc56"},{"p":[-122,144,-138],"s":[2,2,28],"l":1,"c":"#505050","t":2},{"p":[-112,144,-138],"s":[2,2,28],"l":1,"c":"#505050","t":2},{"p":[-112,141,-148],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-122,141,-148],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-112,141,-128],"s":[1,2,12],"l":1,"pe":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[-122,141,-128],"s":[1,2,12],"l":1,"pe":1,"r":[0.7,0,0],"c":"#505050","t":2},{"p":[-114,100,-138],"s":[1,40,32],"pe":1,"c":"#ffffff","t":2},{"p":[-289,91,-231],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.17,0],"c":"#acdc56"},{"p":[-114,114,-138],"s":[2,4,34],"l":1,"c":"#505050","t":2},{"p":[-114,127,-139],"s":[2,5,34],"l":1,"r":[0.35,0,0],"c":"#505050","t":2},{"p":[-315,91,-205],"s":[1,26,4],"l":1,"r":[0,0,0.17],"c":"#505050","t":2},{"p":[-317,91,-198],"s":[1,15,5],"l":1,"r":[0,0,0.17],"c":"#505050","t":2},{"p":[-317,91,-190],"s":[6,8,6],"i":2},{"p":[-316,91,-157],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[-296,92,-220],"s":[3,1,17],"l":1,"r":[0,-0.52,0],"c":"#505050","t":2},{"p":[-477,135,-55],"s":[120,26,600],"f":[0,0,1,0,0,0],"c":"#467532","t":1},{"p":[325,117,-117],"s":[6,20,2],"f":[0,1,0,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[333,117,-116],"s":[6,20,2],"f":[1,0,0,0,0,0],"c":"#7d7d61","e":"#282828"},{"p":[-303,136,154],"s":[66,0,31],"i":11,"l":1,"r":[1.57,0,3.14],"sad":1},{"p":[-303,119,158],"s":[71,34,6],"l":1,"pe":1,"f":[1,1,1,1,0,1],"c":"#39291f","t":5},{"p":[164,181,-133],"s":[59,0,26],"i":11,"l":1,"r":[1.57,0,1.57],"sad":1},{"p":[162,166,-133],"s":[2,30,64],"pe":1,"c":"#39291f","t":5},{"p":[-317,91,-124],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[27,182,27],"s":[64,0,28],"i":11,"l":1,"r":[1.57,0,0],"sad":1},{"p":[27,165,25],"s":[71,34,2],"pe":1,"c":"#39291f","t":5},{"p":[57,161,22],"s":[4,41,4],"l":1,"pe":1,"c":"#39291f","t":5},{"p":[-1,161,22],"s":[4,41,4],"l":1,"pe":1,"c":"#39291f","t":5},{"p":[95,109,98],"s":[5,3,9],"l":1,"c":"#7d7d61","e":"#282828"},{"p":[154,109,10],"s":[5,3,9],"l":1,"c":"#7d7d61","e":"#282828"},{"p":[-16,109,194],"s":[6,3,6],"l":1,"c":"#7d7d61","e":"#282828"},{"p":[36,109,181],"s":[5,3,9],"l":1,"c":"#7d7d61","e":"#282828"},{"p":[-28,58,23],"s":[5,3,9],"l":1,"c":"#7d7d61","e":"#282828"},{"p":[80,58,-62],"s":[5,3,9],"l":1,"r":[0,0.44,0],"c":"#7d7d61","e":"#282828"},{"p":[71,75,-62],"s":[4,2,23],"l":1,"pe":1,"r":[0,0.17,0],"c":"#505050","t":2},{"p":[-17,75,-48],"s":[4,2,23],"l":1,"pe":1,"r":[0,-0.62,0],"c":"#505050","t":2},{"p":[37,58,-62],"s":[6,4,6],"l":1,"c":"#7d7d61","e":"#282828"},{"p":[12,51,20],"s":[6,4,6],"l":1,"c":"#7d7d61","e":"#282828"},{"p":[7,51,121],"s":[6,4,6],"l":1,"c":"#7d7d61","e":"#282828"},{"p":[-220,185,-19],"s":[57,0,25],"i":11,"l":1,"r":[1.57,0,1.57],"sad":1},{"p":[-222,171,-19],"s":[2,28,62],"pe":1,"c":"#39291f","t":5},{"p":[-225,161,6],"s":[4,41,4],"l":1,"pe":1,"c":"#39291f","t":5},{"p":[-225,161,-44],"s":[4,41,4],"l":1,"pe":1,"c":"#39291f","t":5},{"p":[41,109,-13],"s":[4,21,1],"l":1,"r":[-0.17,0,0],"c":"#505050","t":2},{"p":[34,109,-13],"s":[4,18,1],"l":1,"r":[-0.17,0,0],"c":"#505050","t":2},{"p":[98,109,-14],"s":[4,18,1],"l":1,"r":[-0.17,0,0],"c":"#505050","t":2},{"p":[-109,110,25],"s":[4,18,1],"l":1,"r":[0.18,0,0],"c":"#505050","t":2},{"p":[-20,109,131],"s":[6,8,6],"i":2},{"p":[234,109,-81],"s":[4,1,13],"l":1,"pe":1,"r":[0,0.78,0],"c":"#505050","t":2},{"p":[-42,109,-16],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[2,109,-16],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[-42,136,-11],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[2,136,-11],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[2,109,18],"s":[14,22,14],"c":"#ffffff","t":2,"bo":1},{"p":[2,128,18],"s":[15,1,15],"l":1,"c":"#393939","t":5},{"p":[2,111,18],"s":[15,1,15],"l":1,"c":"#393939","t":5},{"p":[-14,109,19],"s":[4,1,13],"l":1,"pe":1,"r":[-3.14,0.88,-3.14],"c":"#505050","t":2},{"p":[82,109,-16],"s":[2,36,2],"l":1,"c":"#505050","t":2},{"p":[82,136,-11],"s":[1,2,12],"l":1,"pe":1,"r":[-0.7,0,0],"c":"#505050","t":2},{"p":[-105,114,-67],"s":[4,3,7],"l":1,"r":[0,0.44,0],"c":"#7d7d61","e":"#282828"},{"p":[-51,114,-153],"s":[3,3,7],"l":1,"r":[0,0.44,0],"c":"#7d7d61","e":"#282828"},{"p":[-58,116,-167],"s":[4,1,13],"l":1,"pe":1,"r":[0.01,1.3,0],"c":"#505050","t":2},{"p":[-102,116,-150],"s":[4,1,13],"l":1,"pe":1,"r":[-3.13,-0.17,3.14],"c":"#505050","t":2},{"p":[-79,112,-104],"s":[18,19,16],"c":"#ffffff","t":2},{"p":[-79,117,-104],"s":[19,1,17],"l":1,"c":"#393939","t":5},{"p":[-79,128,-104],"s":[19,1,17],"l":1,"c":"#393939","t":5},{"p":[169,117,-196],"s":[1,46,1],"pe":1,"c":"#505050","t":2},{"p":[196,117,-196],"s":[1,46,1],"pe":1,"c":"#505050","t":2},{"p":[196,117,-183],"s":[1,46,1],"pe":1,"c":"#505050","t":2},{"p":[169,117,-183],"s":[1,46,1],"pe":1,"c":"#505050","t":2},{"p":[183,152,-189],"s":[30,1,16],"pe":1,"c":"#505050","t":2,"bo":1},{"p":[182,141,-189],"s":[30,1,16],"pe":1,"c":"#505050","t":2,"bo":1},{"p":[-167,109,-162],"s":[80,49,105],"i":14,"l":1},{"p":[103,114,-174],"s":[3,3,7],"l":1,"r":[0,-0.43,0],"c":"#7d7d61","e":"#282828"},{"p":[157,114,-105],"s":[3,3,7],"l":1,"r":[0,-0.69,0],"c":"#7d7d61","e":"#282828"},{"p":[106,115,-108],"s":[4,1,13],"l":1,"pe":1,"r":[0,0.78,0],"c":"#505050","t":2},{"p":[209,109,-82],"s":[4,2,7],"l":1,"r":[0,-0.87,0],"c":"#7d7d61","e":"#282828"},{"p":[280,109,26],"s":[1,19,3],"l":1,"pe":1,"r":[0,0,0.17],"c":"#505050","t":2},{"p":[279,109,20],"s":[6,8,6],"i":2},{"p":[318,128,49],"s":[14,8,1],"pe":1,"c":"#ffffff","t":5},{"p":[318,119,50],"s":[1,18,1],"pe":1,"c":"#505050","t":2},{"p":[238,116,-209],"s":[16,16,16],"c":"#ffffff","t":2},{"p":[-79,121,-96],"s":[4,3,2],"l":1,"c":"#8e8e8e","t":11},{"p":[-78,122,-95],"s":[1,1,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[159,162,-110],"s":[4,38,4],"l":1,"pe":1,"c":"#39291f","t":5},{"p":[159,162,-160],"s":[4,38,4],"l":1,"pe":1,"c":"#39291f","t":5},{"p":[171,119,-137],"s":[11,1,43],"pe":1,"c":"#505050","t":2},{"p":[175,120,-117],"s":[1,20,1],"pe":1,"c":"#505050","t":2},{"p":[175,120,-157],"s":[1,19,1],"pe":1,"c":"#505050","t":2},{"p":[171,137,-137],"s":[11,1,43],"pe":1,"c":"#505050","t":2,"bo":1},{"p":[164,112,-157],"s":[1,14,1],"l":1,"pe":1,"r":[0,0,-0.96],"c":"#505050","t":2},{"p":[164,112,-117],"s":[1,14,1],"l":1,"pe":1,"r":[0,0,-0.96],"c":"#505050","t":2},{"p":[238,115,-85],"s":[5,1,5],"l":1,"c":"#467532","t":1},{"p":[236,112,-87],"s":[1,3,1],"l":1,"c":"#467532","t":1},{"p":[236,111,-83],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[238,114,-85],"s":[3,1,5],"l":1,"c":"#467532","t":1},{"p":[236,114,-85],"s":[1,1,3],"l":1,"c":"#467532","t":1},{"p":[524,129,-99],"s":[3,22,18],"l":1,"c":"#7a7a7a","t":2},{"p":[238,128,-209],"s":[17,1,17],"l":1,"c":"#393939","t":5},{"p":[280,109,-9],"s":[4,2,7],"l":1,"r":[0,0.35,0],"c":"#7d7d61","e":"#282828"},{"p":[-273,116,92],"s":[4,3,2],"l":1,"c":"#8e8e8e","t":11},{"p":[-274,117,91],"s":[1,1,1],"l":1,"c":"#ff0000","e":"#ff0000","t":5},{"p":[-324,92,6],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[-258,92,9],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[-332,91,-41],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.17,-3.14],"c":"#acdc56"},{"p":[15,109,132],"s":[6,2,3],"l":1,"r":[-3.14,0.7,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[42,109,177],"s":[24,1,12],"l":1,"f":[1,1,1,0,0,1],"c":"#467532","t":1},{"p":[41,110,179],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#acdc56"},{"p":[-20,58,91],"s":[4,2,7],"l":1,"r":[0,-0.52,0],"c":"#7d7d61","e":"#282828"},{"p":[105,110,63],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.05,0],"c":"#acdc56"},{"p":[272,118,-179],"s":[49,1,5],"l":1,"c":"#467532","t":1},{"p":[249,113,-177],"s":[2,5,1],"l":1,"c":"#467532","t":1},{"p":[249,108,-177],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[254,116,-177],"s":[8,2,1],"l":1,"c":"#467532","t":1},{"p":[251,114,-177],"s":[2,2,1],"l":1,"c":"#467532","t":1},{"p":[255,115,-177],"s":[3,1,1],"l":1,"c":"#467532","t":1},{"p":[170,118,-179],"s":[13,1,5],"l":1,"c":"#467532","t":1},{"p":[175,113,-177],"s":[2,5,1],"l":1,"c":"#467532","t":1},{"p":[175,108,-177],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[170,116,-177],"s":[8,2,1],"l":1,"c":"#467532","t":1},{"p":[173,114,-177],"s":[2,2,1],"l":1,"c":"#467532","t":1},{"p":[-208,109,88],"s":[1,19,3],"l":1,"pe":1,"r":[0,0,-0.18],"c":"#505050","t":2},{"p":[524,129,-24],"s":[3,22,18],"l":1,"c":"#7a7a7a","t":2},{"p":[524,129,-61],"s":[3,22,18],"l":1,"c":"#7a7a7a","t":2},{"p":[102,109,-81],"s":[26,1,52],"l":1,"f":[1,0,1,0,1,0],"c":"#467532","t":1},{"p":[109,108,-61],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.61,3.14],"c":"#acdc56"},{"p":[157,109,1],"s":[26,1,52],"l":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[156,109,36],"s":[16,1,18],"l":1,"f":[0,1,1,0,1,0],"c":"#467532","t":1},{"p":[-74,109,138],"s":[36,1,48],"l":1,"f":[1,1,1,0,1,1],"c":"#467532","t":1},{"p":[-85,109,156],"s":[4,3,7],"l":1,"r":[0,0.96,0],"c":"#7d7d61","e":"#282828"},{"p":[-82,110,151],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.39,-3.14],"c":"#acdc56"},{"p":[-64,110,119],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.78,-3.14],"c":"#acdc56"},{"p":[-74,109,112],"s":[25,1,4],"l":1,"f":[1,1,1,0,1,1],"c":"#467532","t":1},{"p":[-71,109,164],"s":[25,1,4],"l":1,"f":[1,1,1,0,1,1],"c":"#467532","t":1},{"p":[-60,110,159],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.43,-3.14],"c":"#acdc56"},{"p":[-62,110,123],"s":[1,3,1],"l":1,"r":[0,0.96,0],"c":"#f9fcbd"},{"p":[-62,112,123],"s":[3,2,3],"l":1,"r":[0,0.96,0],"c":"#8e6849"},{"p":[-87,109,119],"s":[2,2,3],"l":1,"r":[0,0.96,0],"c":"#7d7d61","e":"#282828"},{"p":[-86,109,123],"s":[3,3,4],"l":1,"r":[-3.14,1.22,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[-73,109,76],"s":[14,22,14],"c":"#ffffff","t":2},{"p":[-73,128,76],"s":[15,1,15],"l":1,"c":"#393939","t":5},{"p":[-73,111,76],"s":[15,1,15],"l":1,"c":"#393939","t":5},{"p":[-180,109,96],"s":[4,2,6],"l":1,"r":[-3.14,0.96,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[-95,109,176],"s":[4,1,13],"l":1,"pe":1,"r":[0,1.39,0],"c":"#505050","t":2},{"p":[-176,109,146],"s":[4,1,13],"l":1,"pe":1,"r":[0,0.78,0],"c":"#505050","t":2},{"p":[-226,116,160],"s":[7,6,8],"i":18,"l":1,"r":[-0.35,-0.52,0],"c":"#acdc56"},{"p":[-245,108,76],"s":[7,6,8],"i":18,"l":1,"r":[0,0.09,0],"c":"#acdc56"},{"p":[-272,109,87],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.13,0],"c":"#acdc56"},{"p":[-320,91,9],"s":[4,17,1],"l":1,"r":[0.18,0,0],"c":"#505050","t":2},{"p":[-325,91,10],"s":[4,13,1],"l":1,"r":[0.18,0,0],"c":"#505050","t":2},{"p":[-279,91,0],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.35,-3.14],"c":"#acdc56"},{"p":[-216,91,-214],"s":[1,17,4],"l":1,"r":[0,0,-0.09],"c":"#505050","t":2},{"p":[-220,91,-206],"s":[11,14,9],"c":"#ffffff","t":2},{"p":[-220,94,-206],"s":[12,1,10],"l":1,"c":"#393939","t":5},{"p":[-220,102,-206],"s":[12,1,10],"l":1,"c":"#393939","t":5},{"p":[-216,91,-164],"s":[1,17,4],"l":1,"r":[0,0,-0.09],"c":"#505050","t":2},{"p":[-276,91,8],"s":[11,14,9],"c":"#ffffff","t":2},{"p":[-276,102,8],"s":[12,1,10],"l":1,"c":"#393939","t":5},{"p":[-276,94,8],"s":[12,1,10],"l":1,"c":"#393939","t":5},{"p":[-218,91,-156],"s":[7,9,10],"c":"#ffffff","t":2},{"p":[-218,98,-156],"s":[8,1,11],"l":1,"c":"#393939","t":5},{"p":[-218,93,-156],"s":[8,1,11],"l":1,"c":"#393939","t":5},{"p":[-218,100,-158],"s":[6,8,6],"i":2},{"p":[-276,92,-162],"s":[7,6,8],"i":18,"l":1,"r":[0,0.26,0],"c":"#acdc56"},{"p":[-129,109,148],"s":[3,2,6],"l":1,"r":[-3.14,0.78,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[-258,92,-121],"s":[3,2,6],"l":1,"r":[-3.14,0.78,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[-278,92,-155],"s":[2,1,4],"l":1,"r":[0.01,1.23,0],"c":"#7d7d61","e":"#282828"},{"p":[-313,91,-155],"s":[6,1,92],"l":1,"f":[1,0,1,0,1,0],"c":"#467532","t":1},{"p":[-333,92,-72],"s":[3,2,6],"l":1,"r":[0,0.97,0],"c":"#7d7d61","e":"#282828"},{"p":[-153,109,121],"s":[40,1,40],"l":1,"f":[1,1,1,0,1,1],"c":"#467532","t":1},{"p":[-137,109,138],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.78,-3.14],"c":"#acdc56"},{"p":[-168,109,136],"s":[3,2,4],"l":1,"r":[0,0.7,0],"c":"#7d7d61","e":"#282828"},{"p":[-167,110,108],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0],"c":"#acdc56"},{"p":[138,115,-170],"s":[14,16,14],"c":"#ffffff","t":2},{"p":[138,128,-170],"s":[15,1,15],"l":1,"c":"#393939","t":5},{"p":[138,117,-170],"s":[15,1,15],"l":1,"c":"#393939","t":5},{"p":[96,107,77],"s":[12,16,16],"c":"#ffffff","t":2},{"p":[-337,91,-120],"s":[7,6,8],"i":18,"l":1,"r":[0,0.87,0],"c":"#acdc56"},{"p":[-345,91,10],"s":[7,6,8],"i":18,"l":1,"r":[0,0.87,0],"c":"#acdc56"},{"p":[-211,109,48],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.44,3.14],"c":"#acdc56"},{"p":[190,118,-179],"s":[14,2,4],"l":1,"f":[1,1,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[229,118,-179],"s":[20,2,4],"l":1,"f":[1,1,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[136,58,-94],"s":[5,3,9],"l":1,"r":[-3.14,1.05,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[89,75,-169],"s":[4,2,15],"l":1,"pe":1,"r":[0,1.04,0],"c":"#505050","t":2},{"p":[152,75,-98],"s":[4,2,15],"l":1,"pe":1,"r":[0,0.69,0],"c":"#505050","t":2},{"p":[157,54,-158],"s":[4,3,6],"l":1,"r":[-2.97,0,3.12],"c":"#7d7d61","e":"#282828"},{"p":[-39,109,46],"s":[10,6,18],"c":"#7d7d61","e":"#282828"},{"p":[-39,115,53],"s":[1,22,5],"pe":1,"c":"#777777","t":2},{"p":[-39,115,38],"s":[2,20,5],"pe":1,"c":"#505050","t":2},{"p":[-39,115,43],"s":[1,21,5],"pe":1,"c":"#868686","t":2},{"p":[-39,115,48],"s":[2,20,5],"pe":1,"c":"#505050","t":2},{"p":[-39,118,45],"s":[3,1,20],"pe":1,"c":"#505050","t":2},{"p":[-39,132,45],"s":[3,1,20],"pe":1,"c":"#505050","t":2},{"p":[-48,109,46],"s":[4,1,13],"l":1,"pe":1,"r":[-3.14,-0.08,-3.14],"c":"#505050","t":2},{"p":[-17,133,32],"s":[28,1,3],"pe":1,"c":"#505050","t":2},{"p":[-333,110,52],"s":[3,2,6],"l":1,"r":[-3.14,1.12,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[-327,110,56],"s":[2,1,4],"l":1,"r":[0.01,1.24,0],"c":"#7d7d61","e":"#282828"},{"p":[-279,92,-48],"s":[2,1,4],"l":1,"r":[0.01,1.23,0],"c":"#7d7d61","e":"#282828"},{"p":[-278,91,-82],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#acdc56"},{"p":[-129,108,-112],"s":[3,2,6],"l":1,"r":[-3.14,0.78,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[-50,109,-41],"s":[3,2,6],"l":1,"r":[-3.14,-0.44,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[160,115,-146],"s":[1,19,3],"l":1,"pe":1,"r":[0,0,-0.09],"c":"#505050","t":2},{"p":[160,115,-141],"s":[1,11,3],"l":1,"pe":1,"r":[0,0,-0.18],"c":"#505050","t":2},{"p":[280,109,11],"s":[14,1,64],"l":1,"f":[1,0,1,0,0,1],"c":"#467532","t":1},{"p":[282,109,-15],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[281,109,12],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#acdc56"},{"p":[318,109,-31],"s":[3,2,5],"l":1,"r":[0,0.09,0],"c":"#7d7d61","e":"#282828"},{"p":[158,59,-176],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[158,59,-88],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[121,59,-88],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[121,59,-176],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[90,59,-176],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[90,59,-98],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[90,82,-98],"s":[2,15,2],"l":1,"r":[-0.87,0,0],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[121,82,-88],"s":[2,15,2],"l":1,"r":[-0.87,0,0],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[158,82,-88],"s":[2,15,2],"l":1,"r":[-0.87,0,0],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[158,82,-176],"s":[2,15,2],"l":1,"r":[0.79,0,0],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[121,82,-176],"s":[2,15,2],"l":1,"r":[0.79,0,0],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[90,82,-176],"s":[2,15,2],"l":1,"r":[0.79,0,0],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[272,116,-201],"s":[14,4,14],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[272,118,-201],"s":[10,23,9],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[358,158,-109],"s":[9,17,9],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[358,155,-109],"s":[12,3,11],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[25,133,-26],"s":[66,0,31],"i":11,"l":1,"r":[1.57,0,3.14],"sad":1},{"p":[25,116,-22],"s":[71,34,6],"l":1,"pe":1,"f":[1,1,1,1,0,1],"c":"#39291f","t":5},{"p":[55,150,-24],"s":[13,1,5],"l":1,"c":"#467532","t":1},{"p":[35,150,-24],"s":[9,1,5],"l":1,"c":"#467532","t":1},{"p":[-4,150,-24],"s":[15,1,5],"l":1,"c":"#467532","t":1},{"p":[61,142,-24],"s":[1,8,3],"l":1,"c":"#467532","t":1},{"p":[57,144,-25],"s":[1,6,3],"l":1,"c":"#467532","t":1},{"p":[59,147,-25],"s":[3,3,3],"l":1,"c":"#467532","t":1},{"p":[31,144,-25],"s":[1,6,3],"l":1,"c":"#467532","t":1},{"p":[38,147,-25],"s":[3,3,3],"l":1,"c":"#467532","t":1},{"p":[34,149,-25],"s":[6,1,3],"l":1,"c":"#467532","t":1},{"p":[-2,148,-25],"s":[6,2,3],"l":1,"c":"#467532","t":1},{"p":[-8,147,-25],"s":[6,3,3],"l":1,"c":"#467532","t":1},{"p":[-11,142,-25],"s":[1,8,3],"l":1,"c":"#467532","t":1},{"p":[-3,144,-25],"s":[1,4,3],"l":1,"c":"#467532","t":1},{"p":[21,57,-88],"s":[10,22,10],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[21,58,-88],"s":[13,5,12],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[19,79,-86],"s":[6,2,6],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[11,58,-77],"s":[4,3,5],"l":1,"r":[0,0.7,0],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[33,58,-95],"s":[4,3,8],"l":1,"r":[0,0.35,0],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[24,78,-88],"s":[5,2,11],"l":1,"c":"#467532","t":1},{"p":[26,72,-93],"s":[1,6,1],"l":1,"c":"#467532","t":1},{"p":[26,74,-83],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[26,76,-86],"s":[1,2,5],"l":1,"c":"#467532","t":1},{"p":[25,77,-83],"s":[3,1,1],"l":1,"c":"#467532","t":1},{"p":[-273,119,-95],"s":[10,14,6],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-273,133,-95],"s":[7,7,7],"c":"#7d7d61","e":"#282828"},{"p":[-279,120,-95],"s":[3,12,4],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-273,140,-95],"s":[8,2,8],"c":"#7d7d61","e":"#282828"},{"p":[-273,142,-95],"s":[7,4,7],"c":"#7d7d61","e":"#282828","t":11},{"p":[-273,146,-95],"s":[8,2,8],"c":"#7d7d61","e":"#282828"},{"p":[-270,105,-95],"s":[4,14,4],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-276,105,-95],"s":[4,14,4],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-267,120,-95],"s":[3,12,4],"c":"#7d7d61","e":"#282828","bo":1},{"p":[-273,91,-94],"s":[14,12,14],"f":[1,1,0,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[-273,103,-94],"s":[15,2,15],"c":"#7d7d61","e":"#282828"},{"p":[-268,105,-98],"s":[5,1,7],"l":1,"c":"#467532","t":1},{"p":[-265,99,-97],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[-265,102,-101],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[-265,104,-99],"s":[1,2,3],"l":1,"c":"#467532","t":1},{"p":[-265,103,-96],"s":[1,3,1],"l":1,"c":"#467532","t":1},{"p":[-280,92,-93],"s":[1,3,5],"l":1,"c":"#467532","t":1},{"p":[-280,92,-89],"s":[1,8,3],"l":1,"c":"#467532","t":1},{"p":[-280,95,-91],"s":[1,2,1],"l":1,"c":"#467532","t":1},{"p":[-280,92,-97],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[-280,95,-93],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[273,59,-102],"s":[33,27,30],"c":"#7d7d61","e":"#282828"},{"p":[282,86,-115],"s":[9,4,4],"c":"#7d7d61","e":"#282828"},{"p":[286,86,-101],"s":[2,23,8],"i":3,"c":"#505050","t":2,"d":2},{"p":[284,115,-85],"s":[5,1,5],"l":1,"c":"#467532","t":1},{"p":[285,114,-85],"s":[3,1,5],"l":1,"c":"#467532","t":1},{"p":[286,111,-83],"s":[1,3,1],"l":1,"c":"#467532","t":1},{"p":[286,112,-87],"s":[1,2,1],"l":1,"c":"#467532","t":1},{"p":[313,109,-112],"s":[4,1,13],"l":1,"pe":1,"r":[0,1.39,0],"c":"#505050","t":2},{"p":[-300,109,86],"s":[94,49,131],"i":14,"l":1},{"p":[97,152,-60],"s":[2,9,8],"i":3,"v":1,"c":"#505050","t":2},{"p":[338,109,8],"s":[32,14,70],"i":9,"c":"#467532","t":1},{"p":[304,109,36],"s":[100,14,14],"i":9,"c":"#467532","t":1,"d":1},{"p":[368,123,-22],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[361,122,37],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.4,0],"c":"#acdc56"},{"p":[337,114,28],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.31,-3.14],"c":"#acdc56"},{"p":[322,109,-1],"s":[14,1,73],"l":1,"f":[0,1,1,0,1,1],"c":"#467532","t":1},{"p":[301,109,26],"s":[28,1,9],"l":1,"f":[0,1,1,0,1,1],"c":"#467532","t":1},{"p":[320,109,-22],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.39,0],"c":"#acdc56"},{"p":[317,109,-104],"s":[3,2,5],"l":1,"r":[0,0.61,0],"c":"#7d7d61","e":"#282828"},{"p":[137,109,-42],"s":[4,1,13],"l":1,"pe":1,"r":[-3.14,1.05,-3.14],"c":"#505050","t":2},{"p":[289,56,-166],"s":[3,33,3],"pe":1,"c":"#505050","t":2},{"p":[289,56,-128],"s":[3,33,3],"pe":1,"c":"#505050","t":2},{"p":[320,56,-128],"s":[3,33,3],"pe":1,"c":"#505050","t":2},{"p":[320,56,-166],"s":[3,33,3],"pe":1,"c":"#505050","t":2},{"p":[289,82,-166],"s":[2,15,2],"l":1,"r":[0.79,0,0],"c":"#505050","t":2},{"p":[320,82,-166],"s":[2,15,2],"l":1,"r":[0.79,0,0],"c":"#505050","t":2},{"p":[289,82,-127],"s":[2,15,2],"l":1,"r":[-0.87,0,0],"c":"#505050","t":2},{"p":[320,82,-127],"s":[2,15,2],"l":1,"r":[-0.87,0,0],"c":"#505050","t":2},{"p":[286,140,-146],"s":[22,18,17],"f":[1,1,0,1,1,0],"c":"#0b0b0b","t":5},{"p":[282,137,-146],"s":[12,24,23],"c":"#66664e","e":"#282828","bo":1},{"p":[274,137,-136],"s":[4,24,3],"c":"#66664e","e":"#282828","bo":1},{"p":[274,137,-156],"s":[4,24,3],"c":"#66664e","e":"#282828","bo":1},{"p":[274,137,-146],"s":[4,3,17],"c":"#66664e","e":"#282828","bo":1},{"p":[274,158,-146],"s":[4,3,17],"c":"#66664e","e":"#282828","bo":1},{"p":[270,76,-146],"s":[4,66,17],"l":1,"c":"#668b6b","e":"#0b130d","o":0.9,"t":2,"ts":12,"td":1},{"p":[280,90,-115],"s":[6,1,5],"l":1,"c":"#467532","t":1},{"p":[277,84,-117],"s":[1,7,1],"l":1,"c":"#467532","t":1},{"p":[277,87,-113],"s":[1,4,1],"l":1,"c":"#467532","t":1},{"p":[173,120,-117],"s":[9,1,5],"l":1,"c":"#467532","t":1},{"p":[177,115,-115],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[177,119,-117],"s":[1,1,3],"l":1,"c":"#467532","t":1},{"p":[175,119,-115],"s":[3,1,1],"l":1,"c":"#467532","t":1},{"p":[173,117,-115],"s":[1,3,1],"l":1,"c":"#467532","t":1},{"p":[177,118,-119],"s":[1,2,1],"l":1,"c":"#467532","t":1},{"p":[173,138,-157],"s":[9,1,5],"l":1,"c":"#467532","t":1},{"p":[177,133,-159],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[177,136,-155],"s":[1,2,1],"l":1,"c":"#467532","t":1},{"p":[70,115,32],"s":[7,22,1],"pe":1,"c":"#505050","t":2},{"p":[53,115,32],"s":[4,23,1],"pe":1,"c":"#7f7f7f","t":2},{"p":[64,115,32],"s":[6,21,2],"pe":1,"c":"#8e8e8e","t":2},{"p":[48,115,32],"s":[6,22,1],"pe":1,"c":"#505050","t":2},{"p":[58,115,32],"s":[6,22,1],"pe":1,"c":"#505050","t":2},{"p":[59,118,32],"s":[28,1,3],"pe":1,"c":"#505050","t":2},{"p":[59,133,32],"s":[28,1,3],"pe":1,"c":"#757575","t":2},{"p":[319,109,-97],"s":[1,17,3],"l":1,"pe":1,"r":[0,0,-0.09],"c":"#505050","t":2},{"p":[-55,115,-71],"s":[4,1,13],"l":1,"pe":1,"r":[-3.13,0.44,3.14],"c":"#505050","t":2},{"p":[224,59,-179],"s":[124,59,4],"f":[0,0,1,0,1,0],"c":"#7d7d61","e":"#282828","bo":1},{"p":[278,89,-116],"s":[3,2,3],"l":1,"c":"#467532","t":1},{"p":[283,88,-117],"s":[1,3,1],"l":1,"c":"#467532","t":1},{"p":[262,86,-111],"s":[3,2,4],"l":1,"r":[-3.14,0.79,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[259,86,-115],"s":[6,1,5],"l":1,"c":"#467532","t":1},{"p":[256,82,-117],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[256,84,-113],"s":[1,3,1],"l":1,"c":"#467532","t":1},{"p":[257,85,-116],"s":[3,2,3],"l":1,"c":"#467532","t":1},{"p":[264,86,-94],"s":[4,1,13],"l":1,"pe":1,"r":[3.14,-0.95,3.14],"c":"#505050","t":2},{"p":[247,57,-98],"s":[8,7,10],"l":1,"r":[-3.14,0.44,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[170,75,-169],"s":[3,2,24],"l":1,"pe":1,"r":[-3.14,1.14,3.14],"c":"#505050","t":2},{"p":[246,75,-116],"s":[4,2,13],"l":1,"pe":1,"r":[-3.14,1.15,-3.14],"c":"#505050","t":2},{"p":[-14,58,115],"s":[8,5,7],"l":1,"r":[0,0.27,0],"c":"#7d7d61","e":"#282828"},{"p":[78,58,61],"s":[10,7,13],"l":1,"r":[-0.01,0.02,-0.07],"c":"#7d7d61","e":"#282828"},{"p":[47,109,131],"s":[6,3,4],"l":1,"r":[-3.14,-0.61,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[-20,109,125],"s":[9,6,4],"f":[1,0,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[83,109,125],"s":[6,6,4],"f":[0,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[40,58,117],"s":[10,7,13],"l":1,"r":[0.03,-1.11,0.04],"c":"#7d7d61","e":"#282828"},{"p":[80,58,73],"s":[4,2,7],"l":1,"r":[0,0.61,0],"c":"#7d7d61","e":"#282828"},{"p":[85,59,-15],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[-33,59,33],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[85,59,9],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[-33,59,9],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[-33,59,-15],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[85,59,33],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[85,83,-15],"s":[2,11,2],"l":1,"pe":1,"r":[0,0,0.79],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[85,83,33],"s":[2,12,2],"l":1,"pe":1,"r":[0,0,0.79],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[85,83,9],"s":[2,10,2],"l":1,"pe":1,"r":[0,0,0.79],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[-33,83,33],"s":[2,12,2],"l":1,"pe":1,"r":[0,0,-0.78],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[-33,83,9],"s":[2,12,2],"l":1,"pe":1,"r":[0,0,-0.78],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[-33,83,-15],"s":[2,12,2],"l":1,"pe":1,"r":[0,0,-0.78],"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[-10,75,-66],"s":[4,2,23],"l":1,"pe":1,"r":[0,0.61,0],"c":"#434343","t":2},{"p":[-22,58,-166],"s":[10,7,13],"l":1,"r":[-0.05,-0.5,-0.08],"c":"#7d7d61","e":"#282828"},{"p":[274,56,-165],"s":[10,7,13],"l":1,"r":[2.97,-0.89,2.98],"c":"#7d7d61","e":"#282828"},{"p":[185,58,-94],"s":[5,3,9],"l":1,"r":[0,1.04,0],"c":"#7d7d61","e":"#282828"},{"p":[196,58,-93],"s":[3,3,4],"l":1,"r":[0,-0.09,0],"c":"#7d7d61","e":"#282828"},{"p":[171,58,-166],"s":[8,3,10],"l":1,"r":[0,0.61,0],"c":"#7d7d61","e":"#282828"},{"p":[29,63,77],"s":[10,20,10],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[27,83,79],"s":[6,2,6],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[29,58,77],"s":[13,5,12],"f":[1,1,1,0,1,1],"c":"#7d7d61","e":"#282828"},{"p":[40,58,84],"s":[5,3,8],"l":1,"r":[0,-0.35,0],"c":"#7d7d61","e":"#282828"},{"p":[59,56,3],"s":[10,7,13],"l":1,"r":[-0.35,-1.36,-0.35],"c":"#7d7d61","e":"#282828"},{"p":[-157,109,-12],"s":[16,16,16],"c":"#ffffff","t":2},{"p":[-157,122,-12],"s":[17,1,17],"l":1,"c":"#393939","t":5},{"p":[-157,111,-12],"s":[17,1,17],"l":1,"c":"#393939","t":5},{"p":[-37,109,-17],"s":[28,1,16],"l":1,"f":[1,1,1,0,1,0],"c":"#467532","t":1},{"p":[-37,109,-13],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#acdc56"},{"p":[101,109,-81],"s":[11,14,12],"c":"#ffffff","t":2},{"p":[101,120,-81],"s":[12,1,13],"l":1,"c":"#393939","t":5},{"p":[101,112,-81],"s":[12,1,13],"l":1,"c":"#393939","t":5},{"p":[112,109,-82],"s":[7,6,8],"i":18,"l":1,"r":[0,0.79,0],"c":"#acdc56"},{"p":[-224,109,-235],"s":[7,2,2],"l":1,"f":[1,1,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-296,109,-235],"s":[12,2,2],"l":1,"f":[1,1,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-258,109,-235],"s":[13,1,2],"l":1,"f":[1,1,1,0,1,0],"c":"#7d7d61","e":"#282828"},{"p":[-168,109,112],"s":[1,3,1],"l":1,"r":[0,0.96,0],"c":"#f9fcbd"},{"p":[-168,112,112],"s":[3,2,3],"l":1,"r":[0,0.96,0],"c":"#8e6849"},{"p":[201,109,-44],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.44,3.14],"c":"#acdc56"},{"p":[152,108,39],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.4,-3.14],"c":"#acdc56"},{"p":[-217,115,-16],"s":[1,3,22],"l":1,"r":[0.09,0,0],"c":"#acacac","t":2},{"p":[-217,121,-16],"s":[1,4,26],"l":1,"c":"#cacaca","t":2},{"p":[-220,111,-16],"s":[1,25,19],"l":1,"c":"#000000","t":5},{"p":[-217,128,-16],"s":[1,3,22],"l":1,"c":"#a9a9a9","t":2},{"p":[-220,111,21],"s":[1,25,19],"l":1,"c":"#000000","t":5},{"p":[-220,111,-54],"s":[1,25,19],"l":1,"c":"#000000","t":5},{"p":[-218,111,-48],"s":[2,2,4],"l":1,"r":[0,0.35,0],"c":"#7d7d61","e":"#282828"},{"p":[-213,109,-64],"s":[3,3,5],"l":1,"r":[0,-0.26,0],"c":"#7d7d61","e":"#282828"},{"p":[-211,109,-42],"s":[4,3,6],"l":1,"r":[0,-0.26,0],"c":"#7d7d61","e":"#282828"},{"p":[76,75,34],"s":[4,2,23],"l":1,"pe":1,"r":[0,-0.35,0],"c":"#757575","t":2},{"p":[75,75,110],"s":[4,2,15],"l":1,"pe":1,"r":[0,-0.18,0],"c":"#7f7f7f","t":2},{"p":[32,82,77],"s":[5,2,11],"l":1,"c":"#467532","t":1},{"p":[34,80,80],"s":[1,2,5],"l":1,"c":"#467532","t":1},{"p":[34,77,72],"s":[1,5,1],"l":1,"c":"#467532","t":1},{"p":[31,81,82],"s":[3,1,1],"l":1,"c":"#467532","t":1},{"p":[33,81,74],"s":[3,1,5],"l":1,"c":"#467532","t":1},{"p":[32,58,63],"s":[4,2,7],"l":1,"r":[0,1.22,0],"c":"#7d7d61","e":"#282828"},{"p":[18,57,86],"s":[6,3,8],"l":1,"r":[-3.14,-0.61,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[5,75,53],"s":[4,2,15],"l":1,"pe":1,"r":[-3.14,0.96,-3.14],"c":"#757575","t":2},{"p":[-109,109,66],"s":[2,27,2],"l":1,"f":[1,1,0,0,1,1],"c":"#505050","t":2},{"p":[-106,132,66],"s":[12,2,1],"l":1,"pe":1,"r":[0,0,0.7],"f":[0,0,1,1,1,1],"c":"#505050","t":2},{"p":[-143,109,-230],"s":[2,42,8],"i":3,"v":1,"c":"#505050","t":2},{"p":[-185,125,-230],"s":[2,27,8],"i":3,"v":1,"c":"#505050","t":2,"d":2},{"p":[-179,135,-231],"s":[6,8,6],"i":2},{"p":[-177,135,-227],"s":[11,9,2],"pe":1,"v":1,"c":"#ffffff"},{"p":[88,109,132],"s":[5,3,9],"l":1,"r":[-3.14,1.22,-3.14],"c":"#7d7d61","e":"#282828"},{"p":[97,145,-60],"s":[1,2,10],"l":1,"r":[0.17,0,0],"c":"#505050","t":2},{"p":[105,109,-68],"s":[3,2,10],"l":1,"pe":1,"r":[-3.14,0.44,-3.14],"c":"#505050","t":2},{"p":[59,138,8],"s":[4,1,3],"l":1,"c":"#000000","t":5},{"p":[59,129,8],"s":[16,10,16],"i":32,"l":1,"c":"#ffe9a6","o":0.5},{"p":[59,137,8],"s":[3,1,2],"l":1,"c":"#000000","e":"#ffe9a6","t":5},{"p":[-7,107,203],"s":[37,3,4],"c":"#ffffff","e":"#282828","t":5,"bo":1},{"p":[115,108,208],"s":[32,1,33],"c":"#ffffff","bo":1},{"p":[216,148,-44],"s":[3,8,4],"l":1,"r":[-0.69,0,0],"c":"#7d7d61","e":"#282828"},{"p":[216,152,-49],"s":[3,8,4],"l":1,"r":[0.01,0,0],"c":"#7d7d61","e":"#282828"},{"p":[228,138,-44],"s":[3,12,4],"c":"#7d7d61","e":"#282828","bo":1},{"p":[1,59,-15],"s":[3,26,3],"pe":1,"c":"#505050","t":2},{"p":[46,59,-15],"s":[3,31,3],"pe":1,"c":"#505050","t":2},{"p":[0,59,33],"s":[3,30,3],"pe":1,"c":"#505050","t":2},{"p":[45,59,33],"s":[3,20,3],"pe":1,"c":"#505050","t":2},{"p":[175,134,-9],"s":[7,6,8],"i":18,"l":1,"r":[0,0,0.09],"c":"#acdc56"},{"p":[175,132,69],"s":[7,6,8],"i":18,"l":1,"r":[0,0,0.26],"c":"#acdc56"}]};
    
    /***/ }),
    
    /***/ "./maps/sandstorm.json":
    /*!*****************************!*\
      !*** ./maps/sandstorm.json ***!
      \*****************************/
    /*! exports provided: name, ambInd, skyDome, skyDomeCol0, skyDomeCol1, skyDomeCol2, ambient, light, sky, fog, fogD, modes, camPos, spawns, ambO, ambS, shadLength, shadWidth, objects, default */
    /***/ (function(module) {
    
    module.exports = {"name":"Sandstorm","ambInd":3,"skyDome":true,"skyDomeCol0":"#7bd7ff","skyDomeCol1":"#f7d4b4","skyDomeCol2":"#dce8ed","ambient":10654352,"light":16777215,"sky":14477549,"fog":12294553,"fogD":633.4396002067896,"modes":[0],"camPos":[-124,62,-269],"spawns":[[0,13,-3,0,0,0],[-77,33,-347,0,1,0],[278,33,122,0,2,0],[-105,48,86,0,1,0],[241,33,-322,0,1,0],[-42,48,48,0,0,0],[-39,33,-210,0,3,0]],"ambO":0.7,"ambS":5,"shadLength":387,"shadWidth":425,"objects":[{"p":[-5,12,0],"s":[94,1,114],"t":1},{"p":[-67,12,0],"s":[30,1,44],"t":1},{"p":[-178,32,0],"s":[122,1,150],"t":1},{"p":[-163,14,157],"s":[154,34,56],"t":1},{"p":[-28,9,104],"s":[312,39,50],"t":1},{"p":[1,47,-26],"s":[104,1,210],"t":1},{"p":[194,-4,56],"s":[216,37,221],"t":1},{"p":[-175,19,-137],"s":[53,25,64],"t":1},{"p":[64,13,-4],"s":[44,20,36],"i":9,"t":1},{"p":[-208,33,101],"s":[36,15,56],"i":9,"t":1,"d":1},{"p":[-174,33,-89],"s":[48,11,32],"i":9,"t":1,"d":3},{"p":[-175,33,-185],"s":[53,11,32],"i":9,"t":1,"d":1},{"p":[80,33,-106],"s":[54,15,49],"i":9,"t":1,"d":2},{"p":[110,33,54],"s":[36,15,50],"i":9,"t":1,"d":1},{"p":[-138,26,76],"s":[104,29,6],"c":"#9d8672","t":11},{"p":[-187,26,104],"s":[6,29,50],"c":"#9d8672","t":11},{"p":[159,32,103],"s":[38,1,55],"t":1},{"p":[-50,16,-225],"s":[6,22,25],"c":"#9d8672","t":11},{"p":[-50,16,-246],"s":[6,36,7],"c":"#9d8672","t":11},{"p":[-50,31,-207],"s":[6,19,11],"c":"#9d8672","t":11},{"p":[-50,38,-216],"s":[6,4,7],"c":"#9d8672","t":11},{"p":[220,33,125],"s":[12,12,12],"i":1},{"p":[-103,32,-128],"s":[96,2,111],"l":1,"c":"#393939","t":11},{"p":[-103,109,-129],"s":[100,3,117],"c":"#393939","t":11,"bo":1},{"p":[61,87,-245],"s":[87,4,77],"c":4868682,"t":11,"bo":1},{"p":[20,87,-167],"s":[169,4,79],"c":4868682,"t":11,"bo":1},{"p":[61,30,-242],"s":[82,4,79],"l":1,"c":"#4a4a4a","t":11},{"p":[20,30,-166],"s":[164,4,73],"l":1,"c":"#4a4a4a","t":2},{"p":[20,32,-166],"s":[162,55,71],"c":"#ffd5b1","bo":1},{"p":[-33,51,-202],"s":[15,1,1],"c":4868682,"t":2},{"p":[-40,34,-202],"s":[1,17,1],"c":4868682,"t":2},{"p":[-26,34,-202],"s":[1,17,1],"c":4868682,"t":2},{"p":[-33,34,-201],"s":[13,17,2],"l":1,"c":8221547,"t":2},{"p":[-147,112,-120],"s":[35,3,15],"c":5263440,"t":2,"bo":1},{"p":[-133,33,-194],"s":[36,1,21],"l":1,"c":"#4a4a4a","t":11},{"p":[-159,40,-308],"s":[87,1,57],"t":1},{"p":[-187,33,-268],"s":[31,8,23],"i":9,"t":1,"d":3},{"p":[-141,40,-270],"s":[51,1,19],"t":1},{"p":[-169,17,-270],"s":[5,29,19],"c":"#9d8672","t":11},{"p":[-141,17,-258],"s":[61,29,5],"c":"#9d8672","t":11},{"p":[-113,17,-299],"s":[5,29,77],"c":"#9d8672","t":11},{"p":[-103,17,-129],"s":[94,92,112],"c":"#ffd5b1","bo":1},{"p":[-97,33,-349],"s":[12,12,12],"i":1},{"p":[-197,44,-155],"s":[1,19,6],"l":1,"r":[0,0,0.17],"c":8684676,"t":2},{"p":[-229,32,-162],"s":[56,45,111],"c":"#ffd5b1","bo":1},{"p":[-229,77,-162],"s":[61,3,115],"c":4868682,"t":11,"bo":1},{"p":[-248,32,-309],"s":[94,94,112],"c":"#ffd5b1","bo":1},{"p":[-248,126,-309],"s":[102,3,117],"c":5723991,"t":11,"bo":1},{"p":[-241,32,-237],"s":[56,33,111],"c":"#9d8672","t":11,"bo":1},{"p":[-241,65,-237],"s":[62,3,111],"c":4868682,"t":11,"bo":1},{"p":[-241,31,-236],"s":[58,3,35],"l":1,"c":"#4a4a4a","t":11},{"p":[-229,31,-162],"s":[58,3,112],"l":1,"c":4868682,"t":2},{"p":[-340,32,-199],"s":[91,73,116],"c":"#ffd5b1"},{"p":[-197,44,-163],"s":[1,19,6],"l":1,"r":[0,0,0.17],"c":8684676,"t":2},{"p":[-63,32,-411],"s":[81,85,112],"c":"#ffd5b1","bo":1},{"p":[-170,97,-392],"s":[140,4,120],"c":4408131,"t":11,"bo":1},{"p":[-110,82,-335],"s":[4,4,8],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[-170,32,-392],"s":[133,65,112],"c":"#ffd5b1","bo":1},{"p":[-63,117,-411],"s":[87,4,119],"c":5066061,"t":11,"bo":1},{"p":[-63,154,-411],"s":[58,3,56],"c":4868682,"t":11},{"p":[22,61,-381],"s":[91,32,88],"c":"#ffd5b1"},{"p":[-203,134,-483],"s":[97,5,94],"c":5395026,"t":11},{"p":[-103,84,-129],"s":[95,2,113],"l":1,"c":"#393939","t":11},{"p":[-103,59,-129],"s":[96,2,113],"l":1,"c":"#393939","t":11},{"p":[-63,123,-411],"s":[52,32,49],"c":"#ffd5b1"},{"p":[61,32,-241],"s":[80,55,79],"c":"#ffd5b1","bo":1},{"p":[-63,89,-411],"s":[83,2,113],"l":1,"c":"#4a4a4a","t":11},{"p":[-63,59,-411],"s":[83,2,113],"l":1,"c":"#4a4a4a","t":11},{"p":[-250,82,-309],"s":[100,2,113],"l":1,"c":"#4a4a4a","t":11},{"p":[61,59,-242],"s":[82,2,79],"l":1,"c":"#4a4a4a","t":11},{"p":[20,59,-166],"s":[164,2,73],"l":1,"c":"#4a4a4a","t":11},{"p":[-63,32,-411],"s":[83,2,113],"l":1,"c":"#4a4a4a","t":11},{"p":[-151,82,-335],"s":[4,4,9],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[-189,82,-335],"s":[4,4,10],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[-133,32,-194],"s":[34,27,18],"c":"#ffd5b1"},{"p":[15,45,-208],"s":[12,12,12],"i":1},{"p":[15,33,-220],"s":[12,12,12],"i":1},{"p":[-204,32,-485],"s":[91,102,87],"c":"#ffd5b1"},{"p":[22,90,-381],"s":[98,4,93],"c":"#525252","t":11,"bo":1},{"p":[22,59,-381],"s":[92,2,89],"l":1,"c":"#525252","t":11},{"p":[22,32,-381],"s":[93,2,89],"l":1,"c":"#525252","t":11},{"p":[253,32,-160],"s":[64,53,72],"c":"#ffd5b1","bo":1},{"p":[193,95,-293],"s":[70,3,117],"c":"#4a4a4a","t":11,"bo":1},{"p":[193,54,-292],"s":[69,2,115],"l":1,"c":"#4a4a4a","t":11},{"p":[193,32,-285],"s":[70,2,101],"l":1,"c":"#4a4a4a","t":11},{"p":[154,59,-273],"s":[18,2,44],"pe":1,"c":9539985,"t":2},{"p":[147,33,-293],"s":[2,29,2],"pe":1,"c":9539985,"t":2},{"p":[147,33,-253],"s":[2,29,2],"pe":1,"c":9539985,"t":2},{"p":[158,33,-244],"s":[1,38,4],"i":3,"t":2,"d":2},{"p":[129,32,-403],"s":[124,73,93],"c":"#ffd5b1"},{"p":[129,105,-404],"s":[132,4,115],"c":"#525252","t":11,"bo":1},{"p":[168,33,-404],"s":[44,1,115],"l":1,"c":"#4a4a4a","t":11},{"p":[129,33,-355],"s":[37,36,6],"c":8553090,"t":2,"bo":1},{"p":[236,32,-367],"s":[90,32,61],"c":"#ffd5b1","bo":1},{"p":[236,64,-367],"s":[97,5,68],"c":5395026,"t":2,"bo":1},{"p":[236,29,-367],"s":[92,5,63],"l":1,"c":"#4a4a4a","t":11},{"p":[74,33,-341],"s":[12,12,12],"i":1},{"p":[57,33,-288],"s":[12,12,12],"i":1},{"p":[261,33,-330],"s":[12,12,12],"i":1},{"p":[273,33,-330],"s":[12,12,12],"i":1},{"p":[-213,59,-246],"s":[10,4,4],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[-213,59,-225],"s":[10,4,4],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[-59,33,-336],"s":[12,12,12],"i":1},{"p":[-59,33,-348],"s":[12,12,12],"i":1},{"p":[-50,16,-360],"s":[6,40,15],"c":"#9d8672","t":11},{"p":[-50,16,-270],"s":[6,40,41],"c":"#9d8672","t":11},{"p":[-50,16,-240],"s":[6,29,5],"c":"#9d8672","t":11},{"p":[-50,38,-234],"s":[6,2,7],"c":"#9d8672","t":11},{"p":[-50,50,-204],"s":[6,6,5],"c":"#9d8672","t":11},{"p":[-50,56,-286],"s":[6,3,9],"c":"#9d8672","t":11},{"p":[-50,56,-270],"s":[6,2,9],"c":"#9d8672","t":11},{"p":[-50,56,-254],"s":[6,3,9],"c":"#9d8672","t":11},{"p":[-50,56,-200],"s":[6,3,9],"c":"#9d8672","t":11},{"p":[-50,56,-319],"s":[6,2,9],"c":"#9d8672","t":11},{"p":[-50,56,-334],"s":[6,3,7],"c":"#9d8672","t":11},{"p":[15,33,-208],"s":[12,12,12],"i":1},{"p":[3,33,-208],"s":[12,12,12],"i":1},{"p":[-9,33,-208],"s":[12,12,12],"i":1},{"p":[-158,41,-330],"s":[12,12,12],"i":1},{"p":[-146,41,-330],"s":[12,12,12],"i":1},{"p":[-124,41,-269],"s":[12,12,12],"i":1},{"p":[169,32,-352],"s":[44,73,9],"c":"#ffd5b1","bo":1},{"p":[90,32,-352],"s":[46,73,9],"c":"#ffd5b1","bo":1},{"p":[130,69,-352],"s":[34,36,9],"c":"#ffd5b1","bo":1},{"p":[86,33,-341],"s":[12,12,12],"i":1},{"p":[319,32,-317],"s":[79,58,183],"c":"#ffd5b1","bo":1},{"p":[319,90,-317],"s":[87,4,189],"c":"#4a4a4a","t":11,"bo":1},{"p":[319,60,-281],"s":[80,2,112],"l":1,"c":"#4a4a4a","t":11},{"p":[319,32,-281],"s":[81,2,113],"l":1,"c":"#4a4a4a","t":11},{"p":[281,70,-240],"s":[4,14,9],"l":1,"c":8553090,"t":2},{"p":[281,70,-270],"s":[4,14,9],"l":1,"c":8553090,"t":2},{"p":[282,69,-270],"s":[7,1,10],"l":1,"c":5066061,"t":2},{"p":[282,69,-240],"s":[7,1,10],"l":1,"c":5066061,"t":2},{"p":[126,43,-355],"s":[3,5,8],"c":"#464646","t":5},{"p":[327,32,-470],"s":[142,99,87],"c":"#ffd5b1"},{"p":[328,130,-470],"s":[152,4,96],"c":4868682,"t":11},{"p":[191,32,-555],"s":[109,76,87],"c":"#ffd5b1"},{"p":[191,105,-557],"s":[113,5,100],"c":5395026,"t":11},{"p":[325,32,-186],"s":[80,77,79],"c":"#ffd5b1","bo":1},{"p":[326,109,-185],"s":[88,3,86],"c":4868682,"t":11,"bo":1},{"p":[326,86,-186],"s":[83,2,80],"l":1,"c":"#4a4a4a","t":11},{"p":[326,60,-186],"s":[83,2,80],"l":1,"c":"#4a4a4a","t":11},{"p":[168,62,-160],"s":[20,2,44],"c":"#7d7d7d","t":2,"bo":1},{"p":[176,64,-180],"s":[2,7,2],"c":"#7d7d7d","t":2},{"p":[176,71,-160],"s":[3,1,44],"c":"#7d7d7d","t":2},{"p":[171,71,-181],"s":[7,1,2],"c":"#7d7d7d","t":2},{"p":[167,64,-160],"s":[1,17,13],"l":1,"c":8221547,"t":2},{"p":[167,81,-160],"s":[2,1,15],"l":1,"c":4868682,"t":2},{"p":[167,64,-167],"s":[2,17,1],"l":1,"c":4868682,"t":2},{"p":[299,32,-100],"s":[52,63,93],"c":"#ffd5b1","bo":1},{"p":[326,32,-185],"s":[84,2,79],"l":1,"c":"#4a4a4a","t":11},{"p":[299,95,-100],"s":[57,3,97],"c":5395026,"t":11,"bo":1},{"p":[278,29,-100],"s":[12,5,95],"l":1,"c":"#4a4a4a","t":11},{"p":[265,39,-256],"s":[3,1,30],"c":9539985,"t":2},{"p":[265,33,-256],"s":[1,6,30],"c":9539985,"t":2},{"p":[241,33,-281],"s":[1,6,30],"c":9539985,"t":2},{"p":[241,39,-281],"s":[3,1,30],"c":9539985,"t":2},{"p":[233,63,-265],"s":[20,2,4],"l":1,"r":[0,0,-0.18],"c":4399894,"t":5},{"p":[233,63,-269],"s":[20,2,4],"l":1,"r":[0,0,-0.18],"c":6710886,"t":5},{"p":[233,63,-277],"s":[20,2,4],"l":1,"r":[0,0,-0.18],"c":6710886,"t":5},{"p":[233,63,-293],"s":[20,2,4],"l":1,"r":[0,0,-0.18],"c":6710886,"t":5},{"p":[233,63,-273],"s":[20,2,4],"l":1,"r":[0,0,-0.18],"c":4399894,"t":5},{"p":[233,63,-281],"s":[20,2,4],"l":1,"r":[0,0,-0.18],"c":4399894,"t":5},{"p":[233,63,-289],"s":[20,2,4],"l":1,"r":[0,0,-0.18],"c":4399894,"t":5},{"p":[233,63,-297],"s":[20,2,4],"l":1,"r":[0,0,-0.18],"c":4399894,"t":5},{"p":[-133,59,-195],"s":[36,2,19],"l":1,"c":"#4a4a4a","t":11},{"p":[-133,60,-194],"s":[34,1,19],"pe":1,"v":1,"c":4408131,"t":2},{"p":[215,33,-179],"s":[12,12,12],"i":1},{"p":[215,33,-167],"s":[12,12,12],"i":1},{"p":[199,33,-86],"s":[12,12,12],"i":1},{"p":[173,30,-341],"s":[2,8,2],"l":1,"c":5988172,"t":5},{"p":[325,32,-14],"s":[80,55,79],"c":"#ffd5b1","bo":1},{"p":[319,32,135],"s":[68,76,115],"c":"#ffd5b1","bo":1},{"p":[325,87,-14],"s":[86,3,85],"c":"#525252","t":11,"bo":1},{"p":[325,29,-14],"s":[82,5,81],"l":1,"c":"#4a4a4a","t":11},{"p":[304,32,30],"s":[13,43,9],"c":"#ffd5b1","bo":1},{"p":[304,32,73],"s":[13,43,9],"c":"#ffd5b1","bo":1},{"p":[304,75,51],"s":[13,9,53],"c":"#ffd5b1","bo":1},{"p":[302,43,47],"s":[3,8,3],"c":"#4d4d4d","t":5,"bo":1},{"p":[302,33,51],"s":[1,42,39],"c":8553090,"t":2,"bo":1},{"p":[325,60,-14],"s":[81,2,80],"l":1,"c":"#4a4a4a","t":11},{"p":[304,77,51],"s":[26,4,4],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[304,77,62],"s":[26,4,4],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[304,77,72],"s":[26,4,4],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[304,77,40],"s":[26,4,4],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[304,77,30],"s":[26,4,4],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[431,12,-96],"s":[92,102,160],"c":"#ffd5b1"},{"p":[431,113,-96],"s":[99,4,165],"c":4868682,"t":11},{"p":[319,108,135],"s":[74,3,121],"c":5395026,"t":11,"bo":1},{"p":[319,83,135],"s":[69,2,116],"l":1,"c":"#4a4a4a","t":11},{"p":[319,56,135],"s":[69,2,116],"l":1,"c":"#4a4a4a","t":11},{"p":[94,-2,-52],"s":[80,114,60],"c":"#ffd5b1","bo":1},{"p":[180,32,-48],"s":[92,40,64],"c":"#ffd5b1","bo":1},{"p":[180,72,-48],"s":[95,4,66],"c":4868682,"t":11,"bo":1},{"p":[94,111,-52],"s":[88,4,67],"c":4868682,"t":11,"bo":1},{"p":[94,32,-52],"s":[82,2,61],"l":1,"c":"#393939","t":11},{"p":[180,32,-48],"s":[94,2,65],"l":1,"c":"#4a4a4a","t":11},{"p":[319,32,135],"s":[70,2,117],"l":1,"c":"#4a4a4a","t":11},{"p":[92,33,-404],"s":[44,1,115],"l":1,"c":"#4a4a4a","t":11},{"p":[-144,32,-345],"s":[83,2,20],"l":1,"c":"#4a4a4a","t":11},{"p":[269,29,-76],"s":[6,5,25],"l":1,"c":"#4a4a4a","t":11},{"p":[-156,44,-136],"s":[12,12,12],"i":1},{"p":[280,33,0],"s":[1,23,6],"l":1,"r":[0,0,-0.18],"c":8684676,"t":2},{"p":[281,33,10],"s":[1,18,6],"l":1,"r":[0,0,-0.18],"c":8684676,"t":2},{"p":[240,32,163],"s":[92,51,64],"c":"#ffd5b1","bo":1},{"p":[240,83,163],"s":[97,3,70],"c":5395026,"t":11,"bo":1},{"p":[239,56,163],"s":[91,2,65],"l":1,"c":"#4a4a4a","t":11},{"p":[240,32,163],"s":[90,2,66],"l":1,"c":"#4a4a4a","t":11},{"p":[235,57,123],"s":[49,2,17],"pe":1,"c":"#616161","t":2},{"p":[213,32,117],"s":[2,28,2],"pe":1,"c":"#616161","t":2},{"p":[257,32,117],"s":[2,28,2],"pe":1,"c":"#616161","t":2},{"p":[205,33,130],"s":[5,34,1],"i":3,"t":2,"d":3},{"p":[94,59,-52],"s":[81,2,61],"l":1,"c":"#393939","t":11},{"p":[94,86,-52],"s":[81,2,61],"l":1,"c":"#393939","t":11},{"p":[226,34,-67],"s":[1,17,13],"l":1,"c":8221547,"t":2},{"p":[226,34,-60],"s":[2,17,1],"l":1,"c":4868682,"t":2},{"p":[226,51,-67],"s":[2,1,15],"l":1,"c":4868682,"t":2},{"p":[226,34,-74],"s":[2,17,1],"l":1,"c":4868682,"t":2},{"p":[-159,76,-120],"s":[2,38,2],"l":1,"c":12303291,"t":2},{"p":[158,32,72],"s":[60,68,93],"c":"#ffd5b1","bo":1},{"p":[158,67,72],"s":[61,2,94],"l":1,"c":"#393939","t":11},{"p":[142,75,31],"s":[5,14,9],"l":1,"c":8553090,"t":2},{"p":[142,74,31],"s":[6,1,10],"l":1,"c":5066061,"t":2},{"p":[194,33,34],"s":[12,12,12],"i":1},{"p":[149,38,158],"s":[70,60,79],"c":"#ffd5b1","bo":1},{"p":[77,32,169],"s":[74,69,80],"c":"#ffd5b1","bo":1},{"p":[192,33,125],"s":[6,1,15],"l":1,"c":"#4a4a4a","t":11},{"p":[77,101,169],"s":[81,4,87],"c":"#525252","t":11,"bo":1},{"p":[77,76,169],"s":[74,2,81],"l":1,"c":"#393939","t":11},{"p":[77,47,169],"s":[74,2,81],"l":1,"c":"#393939","t":11},{"p":[154,33,115],"s":[47,1,5],"l":1,"c":5395026,"t":2},{"p":[115,33,-16],"s":[12,12,12],"i":1},{"p":[127,33,-16],"s":[12,12,12],"i":1},{"p":[79,61,14],"s":[10,1,2],"l":1,"c":5066061,"t":2},{"p":[182,79,32],"s":[5,14,9],"l":1,"c":8553090,"t":2},{"p":[182,78,32],"s":[6,1,10],"l":1,"c":5066061,"t":2},{"p":[-97,33,-199],"s":[30,6,1],"c":9539985,"t":2},{"p":[-113,33,-199],"s":[2,25,2],"c":9539985,"t":2},{"p":[-81,33,-199],"s":[2,25,2],"c":9539985,"t":2},{"p":[-97,39,-199],"s":[30,1,3],"c":9539985,"t":2},{"p":[-81,58,-193],"s":[4,2,20],"l":1,"r":[-0.17,0,0],"c":4081241,"t":5},{"p":[-113,58,-193],"s":[4,2,20],"l":1,"r":[-0.17,0,0],"c":4081241,"t":5},{"p":[-85,58,-193],"s":[4,2,20],"l":1,"r":[-0.17,0,0],"c":8026746,"t":5},{"p":[-109,58,-193],"s":[4,2,20],"l":1,"r":[-0.17,0,0],"c":8026746,"t":5},{"p":[-105,58,-193],"s":[4,2,20],"l":1,"r":[-0.17,0,0],"c":4081241,"t":5},{"p":[-101,58,-193],"s":[4,2,20],"l":1,"r":[-0.17,0,0],"c":8026746,"t":5},{"p":[-97,58,-193],"s":[4,2,20],"l":1,"r":[-0.17,0,0],"c":4081241,"t":5},{"p":[-89,58,-193],"s":[4,2,20],"l":1,"r":[-0.17,0,0],"c":4081241,"t":5},{"p":[-93,58,-193],"s":[4,2,20],"l":1,"r":[-0.17,0,0],"c":8026746,"t":5},{"p":[65,91,51],"s":[58,4,80],"c":4868682,"t":11,"bo":1},{"p":[133,33,22],"s":[4,17,1],"l":1,"r":[0.17,0,0],"c":8684676,"t":2},{"p":[140,33,22],"s":[4,17,1],"l":1,"r":[0.17,0,0],"c":8684676,"t":2},{"p":[65,54,51],"s":[55,2,75],"l":1,"c":"#393939","t":11},{"p":[79,62,16],"s":[9,14,5],"l":1,"c":8553090,"t":2},{"p":[-102,34,-17],"s":[42,61,62],"c":"#ffd5b1","bo":1},{"p":[-102,92,-17],"s":[47,4,67],"c":4868682,"t":11,"bo":1},{"p":[-102,32,-18],"s":[44,2,62],"l":1,"c":"#393939","t":11},{"p":[206,13,-15],"s":[15,74,7],"c":"#ffd5b1","bo":1},{"p":[206,32,-13],"s":[17,2,5],"l":1,"c":"#4a4a4a","t":11},{"p":[180,30,115],"s":[2,9,2],"l":1,"c":5988172,"t":5},{"p":[-87,100,47],"s":[67,4,72],"c":4868682,"t":11,"bo":1},{"p":[-87,102,48],"s":[45,10,55],"c":"#ffd5b1"},{"p":[-87,112,48],"s":[51,4,61],"c":"#4a4a4a","t":11},{"p":[-87,76,47],"s":[63,2,67],"l":1,"c":"#393939","t":11},{"p":[-87,52,47],"s":[63,2,67],"l":1,"c":"#393939","t":11},{"p":[-67,84,26],"s":[9,14,7],"l":1,"c":8553090,"t":2},{"p":[-67,83,23],"s":[10,1,2],"l":1,"c":5066061,"t":2},{"p":[73,32,52],"s":[40,2,78],"l":1,"c":"#393939","t":11},{"p":[65,13,51],"s":[54,79,74],"c":"#ffd5b1","bo":1},{"p":[28,12,-46],"s":[169,2,54],"c":"#6e6e6e","t":2},{"p":[27,12,37],"s":[167,2,52],"c":"#6e6e6e","t":2},{"p":[-52,46,-32],"s":[8,31,210],"c":"#9d8672","t":11},{"p":[50,46,-28],"s":[8,31,117],"c":"#9d8672","t":11},{"p":[50,77,-80],"s":[8,2,13],"l":1,"c":"#9d8672","t":11},{"p":[50,77,-58],"s":[8,3,15],"l":1,"c":"#9d8672","t":11},{"p":[50,77,-36],"s":[8,5,13],"l":1,"c":"#9d8672","t":11},{"p":[50,77,-14],"s":[8,3,16],"l":1,"c":"#9d8672","t":11},{"p":[50,77,8],"s":[8,4,13],"l":1,"c":"#9d8672","t":11},{"p":[-52,77,8],"s":[8,4,13],"l":1,"c":"#9d8672","t":11},{"p":[-52,77,30],"s":[8,4,13],"l":1,"c":"#9d8672","t":11},{"p":[-52,77,74],"s":[8,4,14],"l":1,"c":"#9d8672","t":11},{"p":[-52,77,52],"s":[8,3,13],"l":1,"c":"#9d8672","t":11},{"p":[-52,77,-14],"s":[8,2,13],"l":1,"c":"#9d8672","t":11},{"p":[-52,77,-36],"s":[8,4,13],"l":1,"c":"#9d8672","t":11},{"p":[-52,77,-58],"s":[8,3,16],"l":1,"c":"#9d8672","t":11},{"p":[-52,77,-80],"s":[8,4,10],"l":1,"c":"#9d8672","t":11},{"p":[-52,77,-102],"s":[8,3,13],"l":1,"c":"#9d8672","t":11},{"p":[-52,77,-124],"s":[8,4,13],"l":1,"c":"#9d8672","t":11},{"p":[-1,12,19],"s":[110,34,14],"c":"#786555","t":11},{"p":[-1,11,-51],"s":[110,35,62],"c":"#786555","t":11},{"p":[-1,46,-2],"s":[94,1,57],"c":"#9d8672","t":11},{"p":[-51,32,188],"s":[73,76,116],"c":"#ffd5b1","bo":1},{"p":[-124,32,215],"s":[73,76,62],"c":"#ffd5b1","bo":1},{"p":[-197,32,217],"s":[73,52,79],"c":"#ffd5b1","bo":1},{"p":[13,47,163],"s":[60,2,81],"l":1,"c":"#393939","t":11},{"p":[-52,47,157],"s":[73,2,56],"l":1,"c":"#393939","t":11},{"p":[-126,47,211],"s":[75,2,55],"l":1,"c":"#393939","t":11},{"p":[-265,-3,183],"s":[63,104,108],"c":"#ffd5b1","bo":1},{"p":[-268,62,74],"s":[84,55,111],"c":"#ffd5b1"},{"p":[-268,32,-10],"s":[73,56,60],"c":"#ffd5b1","bo":1},{"p":[-232,61,-73],"s":[68,49,68],"c":"#ffd5b1"},{"p":[-51,108,187],"s":[81,3,121],"c":"#393939","t":11,"bo":1},{"p":[-128,108,214],"s":[73,3,68],"c":5395026,"t":11,"bo":1},{"p":[-70,32,127],"s":[28,64,10],"c":"#ffd5b1","bo":1},{"p":[-70,47,125],"s":[30,2,8],"l":1,"c":"#393939","t":11},{"p":[-51,77,157],"s":[75,2,56],"l":1,"c":"#393939","t":11},{"p":[-126,77,211],"s":[75,2,55],"l":1,"c":"#393939","t":11},{"p":[-117,50,154],"s":[25,1,25],"c":"#9d9d9d","t":1},{"p":[-14,24,-245],"s":[29,13,3],"c":"#9d8672","t":11},{"p":[-117,24,168],"s":[31,28,3],"c":"#9d8672","t":11},{"p":[-103,24,154],"s":[3,28,25],"c":"#9d8672","t":11},{"p":[-131,24,154],"s":[3,28,25],"c":"#9d8672","t":11},{"p":[-196,47,180],"s":[73,2,7],"l":1,"c":"#393939","t":11},{"p":[-242,47,154],"s":[19,2,57],"l":1,"c":"#393939","t":11},{"p":[-242,73,154],"s":[19,2,57],"l":1,"h":190,"c":"#393939","t":11},{"p":[-196,84,214],"s":[80,3,81],"c":5395026,"t":11,"bo":1},{"p":[67,33,-285],"s":[6,8,6],"i":2,"r":[0,-1.57,0]},{"p":[-265,101,178],"s":[70,3,124],"c":5395026,"t":11,"bo":1},{"p":[-228,32,49],"s":[5,2,62],"l":1,"c":"#393939","t":11},{"p":[-234,32,-9],"s":[7,2,63],"l":1,"c":"#393939","t":11},{"p":[-214,32,-71],"s":[34,2,65],"l":1,"c":"#393939","t":11},{"p":[-265,117,74],"s":[86,3,119],"c":"#393939","t":11,"bo":1},{"p":[431,40,-96],"s":[66,102,125],"c":"#ffd5b1"},{"p":[431,141,-96],"s":[77,4,135],"c":4868682,"t":11},{"p":[-266,78,-11],"s":[78,3,59],"c":5395026,"t":11,"bo":1},{"p":[-232,109,-73],"s":[74,3,72],"c":"#393939","t":11,"bo":1},{"p":[-239,62,74],"s":[27,2,112],"l":1,"c":"#393939","t":11},{"p":[-268,88,74],"s":[85,2,112],"l":1,"c":"#393939","t":11},{"p":[-232,60,-73],"s":[69,2,69],"l":1,"c":"#393939","t":11},{"p":[-232,84,-73],"s":[69,2,69],"l":1,"c":"#393939","t":11},{"p":[-227,48,171],"s":[12,12,12],"i":1},{"p":[-215,48,171],"s":[12,12,12],"i":1},{"p":[-78,48,86],"s":[12,12,12],"i":1},{"p":[-176,48,87],"s":[12,12,12],"i":1},{"p":[-125,33,67],"s":[12,12,12],"i":1},{"p":[-137,33,67],"s":[12,12,12],"i":1},{"p":[-90,48,86],"s":[12,12,12],"i":1},{"p":[-225,33,-34],"s":[12,12,12],"i":1},{"p":[-213,33,-34],"s":[12,12,12],"i":1},{"p":[-129,33,-33],"s":[12,12,12],"i":1},{"p":[-179,48,174],"s":[6,19,1],"l":1,"r":[0.17,0,0],"c":8684676,"t":2},{"p":[-189,48,174],"s":[6,19,1],"l":1,"r":[0.17,0,0],"c":8684676,"t":2},{"p":[-228,120,42],"s":[35,3,15],"c":5263440,"t":2,"bo":1},{"p":[-217,69,42],"s":[2,53,2],"l":1,"c":12303291,"t":2},{"p":[-232,34,3],"s":[2,17,13],"l":1,"c":8221547,"t":2},{"p":[-231,34,-4],"s":[1,17,1],"c":"#a5a5a5","t":2},{"p":[-231,34,10],"s":[1,17,1],"c":"#a5a5a5","t":2},{"p":[-231,51,3],"s":[1,1,15],"c":"#a5a5a5","t":2},{"p":[-232,72,14],"s":[10,3,3],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[-232,72,-11],"s":[10,3,3],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[-232,72,1],"s":[10,3,3],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[-232,72,-24],"s":[10,3,3],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[-232,72,-35],"s":[10,3,3],"pe":1,"c":7039851,"t":2,"bo":1},{"p":[-222,32,59],"s":[1,23,4],"l":1,"r":[0,0,0.17],"c":8684676,"t":2},{"p":[-222,33,52],"s":[1,16,4],"l":1,"r":[0,0,0.17],"c":8684676,"t":2},{"p":[-55,13,-19],"s":[4,34,2],"l":1,"c":"#575757","t":2},{"p":[-55,45,-4],"s":[4,2,28],"l":1,"c":"#575757","t":2},{"p":[47,48,123],"s":[12,12,12],"i":1},{"p":[110,48,125],"s":[6,8,6],"i":2,"r":[0,1.57,0]},{"p":[40,48,-78],"s":[12,12,12],"i":1},{"p":[29,47,-28],"s":[2,31,2],"pe":1,"c":9539985,"t":2},{"p":[29,47,4],"s":[2,31,2],"pe":1,"c":9539985,"t":2},{"p":[36,78,4],"s":[21,2,4],"l":1,"r":[0,0,0.17],"c":5385783,"t":5},{"p":[36,78,-4],"s":[21,2,4],"l":1,"r":[0,0,0.17],"c":5385783,"t":5},{"p":[36,78,0],"s":[21,2,4],"l":1,"r":[0,0,0.17],"c":7237230,"t":5},{"p":[36,78,-8],"s":[21,2,4],"l":1,"r":[0,0,0.17],"c":7237230,"t":5},{"p":[36,78,-12],"s":[21,2,4],"l":1,"r":[0,0,0.17],"c":5385783,"t":5},{"p":[36,78,-16],"s":[21,2,4],"l":1,"r":[0,0,0.17],"c":7237230,"t":5},{"p":[36,78,-20],"s":[21,2,4],"l":1,"r":[0,0,0.17],"c":5385783,"t":5},{"p":[36,78,-24],"s":[21,2,4],"l":1,"r":[0,0,0.17],"c":7237230,"t":5},{"p":[36,78,-28],"s":[21,2,4],"l":1,"r":[0,0,0.17],"c":5385783,"t":5},{"p":[29,47,-12],"s":[1,7,30],"pe":1,"c":9539985,"t":2},{"p":[29,54,-12],"s":[3,1,30],"pe":1,"c":9539985,"t":2},{"p":[40,48,-66],"s":[12,12,12],"i":1},{"p":[46,47,4],"s":[2,33,2],"l":1,"c":9539985,"t":2},{"p":[46,47,-28],"s":[2,33,2],"l":1,"c":9539985,"t":2},{"p":[-30,47,8],"s":[2,31,2],"pe":1,"c":9539985,"t":2},{"p":[-38,78,8],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":3030610,"t":5},{"p":[-38,78,12],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":7895160,"t":5},{"p":[-38,78,20],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":7895160,"t":5},{"p":[-38,78,16],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":3030610,"t":5},{"p":[-38,78,24],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":3030610,"t":5},{"p":[-38,78,28],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":7895160,"t":5},{"p":[-38,78,32],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":3030610,"t":5},{"p":[-38,78,36],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":7895160,"t":5},{"p":[-38,78,40],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":3030610,"t":5},{"p":[-30,47,40],"s":[2,31,2],"pe":1,"c":9539985,"t":2},{"p":[-30,47,24],"s":[1,7,30],"pe":1,"c":9539985,"t":2},{"p":[-30,54,24],"s":[3,1,30],"pe":1,"c":9539985,"t":2},{"p":[-48,47,8],"s":[2,33,2],"l":1,"c":9539985,"t":2},{"p":[-48,47,40],"s":[2,33,2],"l":1,"c":9539985,"t":2},{"p":[-30,47,-59],"s":[2,31,2],"pe":1,"c":9539985,"t":2},{"p":[-38,78,-59],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":5849386,"t":5},{"p":[-38,78,-63],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":7895160,"t":5},{"p":[-38,78,-67],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":5849386,"t":5},{"p":[-38,78,-71],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":7895160,"t":5},{"p":[-38,78,-75],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":5849386,"t":5},{"p":[-38,78,-79],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":7895160,"t":5},{"p":[-38,78,-83],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":5849386,"t":5},{"p":[-38,78,-87],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":7895160,"t":5},{"p":[-38,78,-91],"s":[22,2,4],"l":1,"r":[0,0,-0.18],"c":5849386,"t":5},{"p":[-30,47,-91],"s":[2,31,2],"pe":1,"c":9539985,"t":2},{"p":[-48,47,-59],"s":[2,33,2],"l":1,"c":9539985,"t":2},{"p":[-48,47,-91],"s":[2,33,2],"l":1,"c":9539985,"t":2},{"p":[-30,47,-75],"s":[1,7,30],"pe":1,"c":9539985,"t":2},{"p":[-30,54,-75],"s":[3,1,30],"pe":1,"c":9539985,"t":2},{"p":[-44,47,-17],"s":[1,23,5],"l":1,"r":[0,0,0.17],"c":8684676,"t":2},{"p":[-44,47,-8],"s":[1,23,5],"l":1,"r":[0,0,0.17],"c":8684676,"t":2},{"p":[35,91,-143],"s":[12,12,12],"i":1,"l":1,"r":[0,-0.35,0]},{"p":[32,48,43],"s":[12,12,12],"i":1},{"p":[32,48,67],"s":[12,12,12],"i":1},{"p":[32,48,55],"s":[12,12,12],"i":1},{"p":[-40,46,77],"s":[32,31,8],"c":"#9d8672","t":11},{"p":[26,46,77],"s":[24,31,8],"c":"#9d8672","t":11},{"p":[-46,77,77],"s":[4,4,8],"l":1,"c":"#9d8672","t":11},{"p":[-30,77,77],"s":[8,3,12],"l":1,"r":[0,-1.57,0],"c":"#9d8672","t":11},{"p":[20,77,77],"s":[8,2,12],"l":1,"r":[0,-1.57,0],"c":"#9d8672","t":11},{"p":[36,77,77],"s":[4,2,8],"l":1,"c":"#9d8672","t":11},{"p":[-42,48,67],"s":[12,12,12],"i":1},{"p":[227,33,-297],"s":[3,32,2],"l":1,"c":9539985,"t":2},{"p":[227,33,-265],"s":[3,32,2],"l":1,"c":9539985,"t":2},{"p":[280,33,-240],"s":[4,32,2],"l":1,"c":9539985,"t":2},{"p":[-159,41,-308],"s":[83,50,55],"i":14,"l":1},{"p":[240,33,106],"s":[87,50,45],"i":14,"l":1},{"p":[-151,48,104],"s":[64,50,48],"i":14,"l":1},{"p":[-1,48,-23],"s":[89,50,72],"i":14,"l":1},{"p":[-1,48,-35],"s":[12,12,12],"i":1},{"p":[-1,48,-23],"s":[12,12,12],"i":1},{"p":[-195,41,-309],"s":[12,12,12],"i":1},{"p":[-195,53,-309],"s":[12,12,12],"i":1},{"p":[158,100,72],"s":[67,3,101],"c":4868682,"t":11,"bo":1},{"p":[158,32,72],"s":[62,2,95],"l":1,"c":"#393939","t":11},{"p":[126,41,94],"s":[6,48,24],"c":"#ffd5b1","bo":1},{"p":[169,32,-341],"s":[22,2,11],"l":1,"c":"#4a4a4a","t":11},{"p":[153,33,-325],"s":[12,12,12],"i":1},{"p":[188,32,-222],"s":[291,1,335],"t":1},{"p":[134,32,-160],"s":[66,76,72],"c":"#ffd5b1","bo":1},{"p":[193,54,-292],"s":[68,43,114],"c":"#ffd5b1"},{"p":[273,63,-240],"s":[20,2,4],"l":1,"r":[0,0,0.17],"c":6116223,"t":1},{"p":[273,63,-244],"s":[20,2,4],"l":1,"r":[0,0,0.17],"c":7895160,"t":5},{"p":[273,63,-252],"s":[20,2,4],"l":1,"r":[0,0,0.17],"c":7895160,"t":5},{"p":[273,63,-248],"s":[20,2,4],"l":1,"r":[0,0,0.17],"c":6116223,"t":1},{"p":[273,63,-256],"s":[20,2,4],"l":1,"r":[0,0,0.17],"c":6116223,"t":1},{"p":[273,63,-264],"s":[20,2,4],"l":1,"r":[0,0,0.17],"c":6116223,"t":1},{"p":[273,63,-260],"s":[20,2,4],"l":1,"r":[0,0,0.17],"c":7895160,"t":5},{"p":[273,63,-272],"s":[20,2,4],"l":1,"r":[0,0,0.17],"c":6116223,"t":1},{"p":[273,63,-268],"s":[20,2,4],"l":1,"r":[0,0,0.17],"c":7895160,"t":5},{"p":[280,33,-272],"s":[4,32,2],"l":1,"c":9539985,"t":2},{"p":[134,108,-160],"s":[71,4,77],"c":"#4a4a4a","t":11,"bo":1},{"p":[246,29,-160],"s":[52,5,74],"l":1,"c":"#4a4a4a","t":11},{"p":[278,29,-174],"s":[12,5,46],"l":1,"c":5395026,"t":2},{"p":[252,60,-160],"s":[63,2,73],"l":1,"c":"#4a4a4a","t":11},{"p":[284,60,-160],"s":[1,2,73],"l":1,"c":5395026,"t":2},{"p":[253,85,-160],"s":[67,3,75],"c":"#4a4a4a","t":11,"bo":1},{"p":[135,29,-160],"s":[66,5,74],"l":1,"c":"#4a4a4a","t":11},{"p":[135,59,-160],"s":[66,2,73],"l":1,"c":"#4a4a4a","t":11},{"p":[101,59,-126],"s":[2,2,5],"l":1,"c":"#4a4a4a","t":11},{"p":[101,59,-129],"s":[2,2,1],"l":1,"c":"#4a4a4a","t":11},{"p":[134,84,-160],"s":[67,2,73],"l":1,"c":"#4a4a4a","t":11},{"p":[176,64,-140],"s":[2,7,2],"c":"#393939","t":2},{"p":[171,71,-139],"s":[7,1,2],"c":"#7d7d7d","t":2},{"p":[167,64,-153],"s":[2,17,1],"l":1,"c":4868682,"t":2},{"p":[171,33,-155],"s":[1,20,6],"l":1,"r":[0,0,0.17],"c":"#616161","t":2},{"p":[171,33,-142],"s":[1,20,6],"l":1,"r":[0,0,0.17],"c":"#616161","t":2},{"p":[144,33,-202],"s":[12,12,12],"i":1},{"p":[144,45,-202],"s":[12,12,12],"i":1},{"p":[181,33,-229],"s":[12,12,12],"i":1},{"p":[267,33,-118],"s":[12,12,12],"i":1},{"p":[21,33,-331],"s":[12,12,12],"i":1},{"p":[21,45,-331],"s":[12,12,12],"i":1},{"p":[-41,33,-349],"s":[12,12,12],"i":1},{"p":[-14,35,-258],"s":[23,1,23],"c":"#9d9d9d","t":1},{"p":[-117,24,140],"s":[31,28,3],"c":"#9d8672","t":11},{"p":[-27,24,-258],"s":[3,13,23],"c":"#9d8672","t":11},{"p":[-14,24,-271],"s":[29,13,3],"c":"#9d8672","t":11},{"p":[-1,24,-258],"s":[3,13,23],"c":"#9d8672","t":11},{"p":[281,32,80],"s":[9,14,4],"c":"#9d8672","t":11},{"p":[218,32,80],"s":[5,16,5],"c":"#9d8672"},{"p":[148,33,-118],"s":[12,12,12],"i":1},{"p":[233,63,-285],"s":[20,2,4],"l":1,"r":[0,0,-0.18],"c":6710886,"t":5},{"p":[279,33,108],"s":[12,12,12],"i":1},{"p":[203,32,80],"s":[30,15,4],"c":"#9d8672","t":11},{"p":[255,32,80],"s":[5,16,5],"c":"#9d8672"},{"p":[-166,48,85],"s":[6,8,6],"i":2},{"p":[-229,48,134],"s":[6,8,6],"i":2},{"p":[-229,48,141],"s":[6,8,6],"i":2},{"p":[-229,48,148],"s":[6,8,6],"i":2},{"p":[-147,33,69],"s":[6,8,6],"i":2},{"p":[-41,13,8],"s":[6,8,6],"i":2},{"p":[-34,13,8],"s":[6,8,6],"i":2},{"p":[-92,48,180],"s":[6,8,6],"i":2},{"p":[-92,48,173],"s":[6,8,6],"i":2},{"p":[-153,44,-127],"s":[6,8,6],"i":2},{"p":[-134,41,-267],"s":[6,8,6],"i":2},{"p":[-198,41,-299],"s":[6,8,6],"i":2},{"p":[-208,33,-249],"s":[6,8,6],"i":2},{"p":[-208,33,-242],"s":[6,8,6],"i":2},{"p":[-30,33,-350],"s":[6,8,6],"i":2},{"p":[11,33,-333],"s":[6,8,6],"i":2},{"p":[96,33,-343],"s":[6,8,6],"i":2},{"p":[154,33,-282],"s":[6,8,6],"i":2},{"p":[154,33,-275],"s":[6,8,6],"i":2},{"p":[191,33,-231],"s":[6,8,6],"i":2},{"p":[280,33,-201],"s":[6,8,6],"i":2},{"p":[280,33,-208],"s":[6,8,6],"i":2},{"p":[257,33,-120],"s":[6,8,6],"i":2},{"p":[189,33,-84],"s":[6,8,6],"i":2},{"p":[230,33,-36],"s":[6,8,6],"i":2},{"p":[230,33,-29],"s":[6,8,6],"i":2},{"p":[193,33,44],"s":[6,8,6],"i":2},{"p":[230,33,127],"s":[6,8,6],"i":2},{"p":[237,33,127],"s":[6,8,6],"i":2},{"p":[-68,48,84],"s":[6,8,6],"i":2},{"p":[22,48,69],"s":[6,8,6],"i":2},{"p":[-44,48,57],"s":[6,8,6],"i":2},{"p":[-44,48,-26],"s":[6,8,6],"i":2},{"p":[-44,48,-114],"s":[6,8,6],"i":2},{"p":[9,48,-24],"s":[6,8,6],"i":2},{"p":[395,7,103],"s":[80,88,59],"c":"#ffd5b1"},{"p":[396,95,104],"s":[88,4,67],"c":4868682,"t":11},{"p":[184,32,235],"s":[102,76,49],"c":"#ffd5b1"},{"p":[184,108,235],"s":[109,5,57],"c":5395026,"t":11},{"p":[-89,33,-137],"s":[54,1,97],"l":1,"c":"#4a4a4a","t":11},{"p":[-121,32,14],"s":[6,2,2],"l":1,"c":"#393939","t":11},{"p":[-68,32,47],"s":[26,2,68],"l":1,"c":4868682,"t":2},{"p":[-102,62,-17],"s":[43,2,63],"l":1,"c":"#393939","t":11},{"p":[-123,34,0],"s":[1,17,13],"l":1,"c":8221547,"t":2},{"p":[-122,34,-7],"s":[4,17,1],"c":4868682,"t":2},{"p":[-122,34,7],"s":[4,17,1],"c":4868682,"t":2},{"p":[-122,51,0],"s":[4,1,15],"c":4868682,"t":2},{"p":[-60,24,-69],"s":[6,8,6],"i":2},{"p":[-84,43,-34],"s":[7,14,9],"l":1,"c":8553090,"t":2},{"p":[-84,42,-34],"s":[8,1,10],"l":1,"c":5066061,"t":2},{"p":[-111,10,-62],"s":[12,23,43],"t":1},{"p":[-93,24,-62],"s":[24,9,28],"i":9,"t":1,"d":2},{"p":[241,33,-297],"s":[2,30,2],"c":9539985,"t":2,"bo":1},{"p":[241,33,-265],"s":[2,30,2],"c":9539985,"t":2,"bo":1},{"p":[265,33,-272],"s":[2,30,2],"c":9539985,"t":2,"bo":1},{"p":[265,33,-240],"s":[2,30,2],"c":9539985,"t":2,"bo":1},{"p":[-61,3,-61],"s":[40,21,26],"t":1},{"p":[-69,13,-35],"s":[26,11,26],"i":9,"t":1,"d":3},{"p":[-85,32,-318],"s":[255,1,281],"c":"#ffffff","t":1},{"p":[52,33,-106],"s":[2,14,50],"t":1},{"p":[302,43,57],"s":[3,8,3],"c":"#4d4d4d","t":5,"bo":1},{"p":[134,43,-355],"s":[3,5,8],"c":"#464646","t":5},{"p":[-40,33,-219],"s":[4,2,3],"l":1,"r":[0,0.52,0],"c":"#9d8672"},{"p":[-59,33,-230],"s":[6,2,4],"l":1,"r":[0,-0.52,0],"c":"#9d8672"},{"p":[-64,33,-223],"s":[4,2,4],"l":1,"c":"#9d8672"},{"p":[400,123,-68],"s":[5,14,9],"l":1,"c":8553090,"t":2},{"p":[400,122,-68],"s":[6,1,10],"l":1,"c":5066061,"t":2},{"p":[236,33,101],"s":[24,36,24],"i":23,"l":1,"tm":0},{"p":[-144,41,-301],"s":[24,36,24],"i":23,"l":1,"tm":"1"},{"p":[-205,32,-237],"s":[7,6,8],"i":18,"l":1,"r":[0,0.96,0],"c":"#d2b559"},{"p":[-208,32,-224],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.13,-3.14],"c":"#d2b559"},{"p":[-65,32,-191],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.13,-3.14]},{"p":[-78,32,-198],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.62,-3.14]},{"p":[-57,32,-205],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.62,-3.14]},{"p":[-100,32,-340],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.62,-3.14]},{"p":[-67,32,-351],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.3,0]},{"p":[-87,32,-352],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0]},{"p":[-50,16,-326],"s":[6,40,23],"c":"#9d8672","t":11},{"p":[-50,16,-345],"s":[6,34,15],"c":"#9d8672","t":11},{"p":[-28,32,-343],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0]},{"p":[-19,32,-206],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0]},{"p":[-22,35,-252],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.6,0]},{"p":[-9,35,-265],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.97,3.14]},{"p":[-191,39,-300],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.61,-3.14]},{"p":[-167,40,-331],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.61,-3.14]},{"p":[-136,41,-332],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.61,-3.14]},{"p":[-197,40,-333],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.61,-3.14]},{"p":[-120,40,-278],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.61,-3.14]},{"p":[-134,40,-273],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.05,-3.14]},{"p":[-152,32,-205],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.36,-3.14]},{"p":[23,32,-286],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0]},{"p":[4,32,-217],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0]},{"p":[16,32,-229],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.16,0]},{"p":[-107,32,-258],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.88,-3.14]},{"p":[-106,33,-296],"s":[6,2,4],"l":1,"r":[0,-1.39,0],"c":"#9d8672"},{"p":[5,32,-333],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0]},{"p":[12,32,-326],"s":[7,6,8],"i":18,"l":1,"r":[0,0.1,0]},{"p":[31,32,-333],"s":[7,6,8],"i":18,"l":1,"r":[0,0.71,0]},{"p":[48,32,-291],"s":[7,6,8],"i":18,"l":1,"r":[0,0.71,0]},{"p":[68,32,-333],"s":[7,6,8],"i":18,"l":1,"r":[0,0.71,0]},{"p":[73,32,-284],"s":[7,6,8],"i":18,"l":1,"r":[0,0.71,0]},{"p":[156,32,-316],"s":[7,6,8],"i":18,"l":1,"r":[0,0.71,0]},{"p":[149,32,-278],"s":[7,6,8],"i":18,"l":1,"r":[0,0.8,0]},{"p":[156,32,-344],"s":[7,6,8],"i":18,"l":1,"r":[0,0.71,0]},{"p":[103,32,-282],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.08,0]},{"p":[105,32,-249],"s":[7,6,8],"i":18,"l":1,"r":[0,0.97,0]},{"p":[-70,96,130],"s":[30,4,23],"l":1,"r":[-0.52,0,0],"c":5395026,"t":11},{"p":[-70,69,123],"s":[15,1,6],"l":1,"c":5066061,"t":2},{"p":[-70,68,121],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[39,32,-283],"s":[25,2,9],"l":1,"c":"#4a4a4a","t":11},{"p":[39,14,-282],"s":[24,64,10],"c":"#ffd5b1","bo":1},{"p":[39,79,-278],"s":[25,3,22],"r":[-0.35,0,0],"c":5395026,"t":11,"bo":1},{"p":[38,51,-286],"s":[15,1,7],"l":1,"c":5066061,"t":2},{"p":[38,50,-288],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[263,14,-197],"s":[24,64,10],"c":"#ffd5b1","bo":1},{"p":[263,79,-193],"s":[26,3,22],"l":1,"r":[-0.35,0,0],"c":5395026,"t":11},{"p":[262,51,-201],"s":[15,1,7],"l":1,"c":5066061,"t":2},{"p":[262,50,-203],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-146,87,185],"s":[15,1,6],"l":1,"c":5066061,"t":2},{"p":[-146,86,183],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[100,82,130],"s":[15,1,6],"l":1,"c":5066061,"t":2},{"p":[100,81,128],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-82,91,-184],"s":[15,1,6],"l":1,"c":5066061,"t":2},{"p":[-82,90,-186],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-133,37,-188],"s":[28,64,10],"c":"#ffd5b1","bo":1},{"p":[-133,52,-190],"s":[30,2,8],"l":1,"c":"#a5a5a5","t":2},{"p":[-133,101,-185],"s":[30,4,23],"l":1,"r":[-0.52,0,0],"c":5395026,"t":11},{"p":[-133,74,-192],"s":[15,1,6],"l":1,"c":5066061,"t":2},{"p":[-133,73,-194],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[87,66,-281],"s":[15,1,4],"l":1,"c":5066061,"t":2},{"p":[87,65,-282],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[13,32,160],"s":[55,110,60],"c":"#ffd5b1"},{"p":[13,37,128],"s":[56,64,10],"c":"#ffd5b1","bo":1},{"p":[13,98,126],"s":[59,4,14],"l":1,"r":[-0.52,0,0],"c":5395026,"t":11},{"p":[27,74,124],"s":[15,1,6],"l":1,"c":5066061,"t":2},{"p":[27,73,122],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[13,141,160],"s":[58,3,62],"c":"#393939","t":11},{"p":[-2,73,122],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-2,74,124],"s":[15,1,6],"l":1,"c":5066061,"t":2},{"p":[-43,131,149],"s":[58,1,34],"c":"#393939","t":11},{"p":[-43,111,149],"s":[58,5,34],"c":"#ffd5b1"},{"p":[-69,111,135],"s":[2,22,2],"c":"#393939","t":2},{"p":[-17,111,135],"s":[2,22,2],"c":"#393939","t":2},{"p":[-44,111,135],"s":[2,22,2],"c":"#393939","t":2},{"p":[-44,111,164],"s":[2,22,2],"c":"#393939","t":2},{"p":[-69,111,163],"s":[2,22,2],"c":"#393939","t":2},{"p":[-17,111,163],"s":[2,22,2],"c":"#393939","t":2},{"p":[-29,116,133],"s":[11,1,3],"l":1,"c":"#d28181","t":2},{"p":[-29,112,131],"s":[11,5,1],"l":1,"c":"#d28181","t":2},{"p":[-60,125,131],"s":[8,8,1],"l":1,"c":"#b2d4b2","t":2},{"p":[-60,132,133],"s":[8,1,3],"l":1,"c":"#b2d4b2","t":2},{"p":[-75,111,131],"s":[6,8,6],"i":2,"l":1,"r":[0,-0.17,0]},{"p":[-86,111,132],"s":[6,8,6],"i":2,"l":1,"r":[0,0.52,0]},{"p":[13,113,126],"s":[40,2,9],"c":"#393939","t":2},{"p":[31,113,123],"s":[2,8,2],"c":"#393939","t":2},{"p":[-5,113,123],"s":[2,8,2],"c":"#393939","t":2},{"p":[13,121,123],"s":[40,1,3],"c":"#393939","t":2},{"p":[31,121,129],"s":[3,1,9],"c":"#393939","t":2},{"p":[-5,121,129],"s":[3,1,9],"c":"#393939","t":2},{"p":[20,116,131],"s":[13,17,3],"l":1,"c":8221547,"t":2},{"p":[13,116,130],"s":[1,17,2],"l":1,"c":"#a5a5a5","t":2},{"p":[27,116,130],"s":[1,17,2],"l":1,"c":"#a5a5a5","t":2},{"p":[20,133,130],"s":[15,1,2],"l":1,"c":"#a5a5a5","t":2},{"p":[20,115,130],"s":[15,1,2],"l":1,"c":"#a5a5a5","t":2},{"p":[5,108,121],"s":[6,14,1],"l":1,"c":"#dec28f","t":2},{"p":[1,108,121],"s":[2,14,1],"l":1,"c":"#a4be8d","t":2},{"p":[1,122,123],"s":[2,1,5],"l":1,"c":"#a4be8d","t":2},{"p":[5,122,123],"s":[6,1,5],"l":1,"c":"#dec28f","t":2},{"p":[40,102,143],"s":[8,50,14],"c":"#ffd5b1"},{"p":[-8,161,157],"s":[1,7,1],"l":1,"r":[0,0,0.17],"c":"#2f2f2f","t":5},{"p":[-21,132,142],"s":[6,8,6],"i":2,"l":1,"r":[0,-0.17,0]},{"p":[76,103,141],"s":[2,22,2],"c":"#393939","t":2},{"p":[76,123,141],"s":[1,1,9],"c":"#393939","t":2},{"p":[59,123,137],"s":[33,1,1],"c":"#393939","t":2},{"p":[65,113,142],"s":[6,11,1],"l":1,"c":"#d28181","t":2},{"p":[52,113,136],"s":[7,11,1],"l":1,"c":"#7ec382","t":2},{"p":[65,124,139],"s":[6,1,7],"l":1,"c":"#d28181","t":2},{"p":[65,121,136],"s":[6,3,1],"l":1,"c":"#d28181","t":2},{"p":[52,124,139],"s":[7,1,7],"l":1,"c":"#7ec382","t":2},{"p":[52,122,142],"s":[7,2,1],"c":"#7ec382","t":2},{"p":[59,123,141],"s":[33,1,1],"c":"#393939","t":2},{"p":[59,123,145],"s":[33,1,1],"c":"#393939","t":2},{"p":[-212,119,247],"s":[120,3,33],"l":1,"r":[-0.52,0,0],"c":"#393939","t":11},{"p":[-212,80,257],"s":[120,35,45],"c":"#ffd5b1"},{"p":[-212,115,257],"s":[120,20,15],"c":"#ffd5b1"},{"p":[-212,136,256],"s":[121,3,17],"l":1,"r":[-0.52,0,0],"c":"#393939","t":11},{"p":[-132,52,254],"s":[40,89,40],"c":"#9d8672","t":11},{"p":[-118,143,254],"s":[12,14,40],"c":"#9d8672","t":11},{"p":[-132,158,254],"s":[40,8,40],"c":"#9d8672","t":11},{"p":[-132,141,254],"s":[41,2,41],"c":"#313131","t":11},{"p":[-132,165,254],"s":[41,2,41],"c":"#313131","t":11},{"p":[-146,143,254],"s":[12,14,40],"c":"#9d8672","t":11},{"p":[-145,167,241],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-145,167,267],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-119,167,267],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-119,167,240],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-132,157,254],"s":[41,2,41],"c":"#313131","t":11},{"p":[-131,137,228],"s":[4,4,15],"c":"#7d7d7d","t":2},{"p":[-131,134,232],"s":[3,2,13],"l":1,"r":[0.7,0,0],"c":"#7d7d7d","t":2},{"p":[-292,52,254],"s":[40,91,40],"c":"#9d8672","t":11},{"p":[-292,143,254],"s":[40,23,40],"c":"#9d8672","t":11},{"p":[-292,141,254],"s":[41,2,41],"c":"#313131","t":11},{"p":[-292,165,254],"s":[41,2,41],"c":"#313131","t":11},{"p":[-305,167,241],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-305,167,267],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-279,167,267],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-279,167,240],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-292,157,254],"s":[41,2,41],"c":"#313131","t":11},{"p":[115,97,-102],"s":[2,2,69],"l":1,"c":"#7d7d7d","t":2},{"p":[123,97,-102],"s":[2,2,66],"l":1,"c":"#7d7d7d","t":2},{"p":[131,97,-102],"s":[2,2,65],"l":1,"c":"#7d7d7d","t":2},{"p":[118,99,-104],"s":[11,1,12],"l":1,"c":"#acb1af","e":"#502323","t":2},{"p":[127,99,-90],"s":[11,1,12],"l":1,"c":"#868785","e":"#0e110b","t":2},{"p":[132,81,-90],"s":[1,18,12],"l":1,"c":"#868785","e":"#0e110b","t":2},{"p":[126,99,-116],"s":[11,1,6],"l":1,"c":"#617187","e":"#0f1b2d","t":2},{"p":[121,86,-116],"s":[1,13,6],"l":1,"c":"#617187","e":"#0f1b2d","t":2},{"p":[113,90,-104],"s":[1,9,12],"l":1,"c":"#acb1af","e":"#502323","t":2},{"p":[-111,68,-64],"s":[2,2,69],"c":"#7d7d7d","t":2},{"p":[-103,68,-64],"s":[2,2,66],"c":"#7d7d7d","t":2},{"p":[-108,70,-64],"s":[11,1,8],"c":"#bb5d5d","t":2},{"p":[-100,70,-82],"s":[11,1,6],"l":1,"c":"#617187","e":"#0f1b2d","t":2},{"p":[-105,65,-82],"s":[1,5,6],"l":1,"c":"#617187","e":"#0f1b2d","t":2},{"p":[-113,61,-64],"s":[1,9,8],"l":1,"c":"#bb5d5d","t":2},{"p":[-268,33,74],"s":[84,31,111],"c":"#9d8672","t":11,"bo":1},{"p":[-119,26,154],"s":[65,109,54],"i":15,"l":1,"r":[0,0.35,0],"c":"#7f6e38"},{"p":[-175,47,171],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[-229,47,154],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.04,3.14]},{"p":[-155,47,179],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[-159,47,84],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[-179,47,97],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0]},{"p":[-101,47,87],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[-88,47,127],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[-52,47,125],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[-60,47,83],"s":[7,6,8],"i":18,"l":1,"r":[0,0.88,0]},{"p":[31,47,85],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0]},{"p":[36,47,119],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0]},{"p":[-19,47,125],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0]},{"p":[-56,45,-47],"s":[2,2,54],"l":1,"c":"#393939","t":11},{"p":[-232,32,-73],"s":[68,28,67],"c":"#9d8672","t":11,"bo":1},{"p":[-8,142,157],"s":[1,19,1],"c":"#2f2f2f","t":5},{"p":[-24,45,129],"s":[2,58,2],"c":"#2f2f2f","t":5},{"p":[-41,103,129],"s":[36,2,2],"c":"#2f2f2f","t":5},{"p":[-58,105,129],"s":[2,9,2],"c":"#2f2f2f","t":5},{"p":[-87,34,47],"s":[62,66,66],"c":"#ffd5b1","bo":1},{"p":[-87,13,47],"s":[62,19,66],"c":"#9d8672","t":11},{"p":[-102,13,-17],"s":[42,19,62],"c":"#9d8672","t":11},{"p":[-340,105,-199],"s":[93,4,119],"c":"#393939","t":11},{"p":[22,32,-381],"s":[91,27,88],"c":"#9d8672","t":11,"bo":1},{"p":[-292,52,112],"s":[40,89,40],"c":"#9d8672","t":11},{"p":[-292,143,98],"s":[40,14,12],"c":"#9d8672","t":11},{"p":[-292,158,112],"s":[40,8,40],"c":"#9d8672","t":11},{"p":[-292,141,112],"s":[41,2,41],"c":"#313131","t":11},{"p":[-292,165,112],"s":[41,2,41],"c":"#313131","t":11},{"p":[-305,167,99],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-305,167,125],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-279,167,125],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-279,167,98],"s":[12,6,12],"c":"#9d8672","t":11},{"p":[-292,157,112],"s":[41,2,41],"c":"#313131","t":11},{"p":[-268,137,111],"s":[15,4,4],"c":"#7d7d7d","t":2},{"p":[-292,143,126],"s":[40,14,12],"c":"#9d8672","t":11},{"p":[-285,119,184],"s":[120,3,33],"l":1,"r":[-1.57,-1.05,-1.57],"c":"#393939","t":11},{"p":[-296,115,190],"s":[15,20,120],"c":"#ffd5b1"},{"p":[-296,136,187],"s":[121,3,17],"l":1,"r":[-1.57,-1.05,-1.57],"c":"#393939","t":11},{"p":[-295,80,187],"s":[45,35,120],"c":"#ffd5b1"},{"p":[-226,45,122],"s":[2,58,2],"l":1,"c":"#2f2f2f","t":5},{"p":[-226,103,124],"s":[2,2,6],"l":1,"c":"#2f2f2f","t":5},{"p":[-226,105,126],"s":[2,18,2],"l":1,"c":"#2f2f2f","t":5},{"p":[164,34,142],"s":[60,105,48],"c":"#ffd5b1","bo":1},{"p":[164,139,142],"s":[63,5,51],"c":"#313131","t":11},{"p":[164,144,142],"s":[56,21,40],"c":"#ffd5b1"},{"p":[164,165,142],"s":[30,35,30],"c":"#ffd5b1"},{"p":[164,200,142],"s":[34,6,34],"c":"#9d8672","t":11},{"p":[164,206,142],"s":[29,6,28],"c":"#9d8672","t":11},{"p":[164,212,142],"s":[23,6,22],"c":"#9d8672","t":11},{"p":[164,218,142],"s":[17,6,16],"c":"#9d8672","t":11},{"p":[164,224,142],"s":[5,13,9],"c":"#ffd5b1"},{"p":[164,237,142],"s":[3,32,4],"c":"#ffd5b1"},{"p":[164,165,142],"s":[58,3,42],"c":"#313131","t":11},{"p":[164,165,157],"s":[10,20,1],"c":"#3c3c3c"},{"p":[142,129,142],"s":[4,4,58],"c":"#7d7d7d","t":2},{"p":[186,129,142],"s":[4,4,58],"c":"#7d7d7d","t":2},{"p":[164,129,128],"s":[68,4,4],"c":"#7d7d7d","t":2},{"p":[164,129,156],"s":[68,4,4],"c":"#7d7d7d","t":2},{"p":[164,50,165],"s":[16,2,8],"l":1,"c":"#7d7d7d","t":2},{"p":[164,94,165],"s":[16,2,8],"l":1,"c":"#7d7d7d","t":2},{"p":[161,34,26],"s":[13,17,3],"l":1,"c":8221547,"t":2},{"p":[154,34,25],"s":[1,17,2],"l":1,"c":"#a5a5a5","t":2},{"p":[168,34,25],"s":[1,17,2],"l":1,"c":"#a5a5a5","t":2},{"p":[161,51,25],"s":[15,1,2],"l":1,"c":"#a5a5a5","t":2},{"p":[161,33,25],"s":[15,1,2],"l":1,"c":"#a5a5a5","t":2},{"p":[149,96,158],"s":[71,4,81],"c":"#525252","t":11},{"p":[-119,57,31],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[-117,58,31],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[-119,57,62],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[-117,58,62],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[-151,89,-90],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[-149,90,-90],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[-216,90,233],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-216,91,235],"s":[15,1,6],"l":1,"c":5066061,"t":2},{"p":[-177,90,233],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-177,91,235],"s":[15,1,6],"l":1,"c":5066061,"t":2},{"p":[-216,89,-38],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[-216,90,-40],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[-197,89,-93],"s":[1,17,17],"i":22,"l":1},{"p":[-199,90,-93],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[-225,32,15],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.04,3.14]},{"p":[-203,32,-35],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.04,3.14]},{"p":[-128,32,-23],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0]},{"p":[-123,32,18],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0]},{"p":[-123,32,55],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.39,0]},{"p":[-149,32,61],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.39,0]},{"p":[-187,32,69],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[-222,32,44],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[-153,32,-72],"s":[7,6,8],"i":18,"l":1,"r":[0,0.18,0]},{"p":[-140,33,-72],"s":[2,45,2],"l":1,"c":"#2f2f2f","t":5},{"p":[-132,89,-72],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[-132,90,-74],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[-143,78,-72],"s":[8,2,2],"l":1,"c":"#2f2f2f","t":5},{"p":[-146,80,-72],"s":[2,34,2],"l":1,"c":"#2f2f2f","t":5},{"p":[-197,33,-44],"s":[2,82,2],"l":1,"c":"#2f2f2f","t":5},{"p":[573,13,-162],"s":[55,40,60],"c":"#ffd5b1"},{"p":[573,52,-162],"s":[58,3,62],"c":"#393939","t":11},{"p":[517,42,-173],"s":[58,1,34],"c":"#393939","t":11},{"p":[517,22,-173],"s":[58,5,34],"c":"#ffd5b1"},{"p":[491,22,-187],"s":[2,22,2],"c":"#393939","t":2},{"p":[543,22,-187],"s":[2,22,2],"c":"#393939","t":2},{"p":[516,22,-187],"s":[2,22,2],"c":"#393939","t":2},{"p":[516,22,-158],"s":[2,22,2],"c":"#393939","t":2},{"p":[491,22,-159],"s":[2,22,2],"c":"#393939","t":2},{"p":[543,22,-159],"s":[2,22,2],"c":"#393939","t":2},{"p":[531,27,-189],"s":[11,1,3],"c":"#e63f3f","t":2},{"p":[531,23,-191],"s":[11,5,1],"c":"#e63f3f","t":2},{"p":[500,36,-191],"s":[8,8,1],"c":"#a1e1a1","t":2},{"p":[500,43,-189],"s":[8,1,3],"c":"#a1e1a1","t":2},{"p":[511,27,-187],"s":[6,8,6],"i":2,"r":[0,-0.17,0]},{"p":[573,24,-196],"s":[40,2,9],"c":"#393939","t":2},{"p":[591,24,-199],"s":[2,8,2],"c":"#393939","t":2},{"p":[555,24,-199],"s":[2,8,2],"c":"#393939","t":2},{"p":[573,32,-199],"s":[40,1,3],"c":"#393939","t":2},{"p":[591,32,-193],"s":[3,1,9],"c":"#393939","t":2},{"p":[555,32,-193],"s":[3,1,9],"c":"#393939","t":2},{"p":[580,27,-191],"s":[13,17,3],"l":1,"c":8221547,"t":2},{"p":[573,27,-192],"s":[1,17,2],"l":1,"c":"#a5a5a5","t":2},{"p":[587,27,-192],"s":[1,17,2],"l":1,"c":"#a5a5a5","t":2},{"p":[580,44,-192],"s":[15,1,2],"l":1,"c":"#a5a5a5","t":2},{"p":[580,26,-192],"s":[15,1,2],"l":1,"c":"#a5a5a5","t":2},{"p":[565,19,-201],"s":[6,14,1],"c":"#e6ab3e","t":2},{"p":[561,19,-201],"s":[2,14,1],"c":"#8de63e","t":2},{"p":[561,33,-199],"s":[2,1,5],"c":"#8de63e","t":2},{"p":[565,33,-199],"s":[6,1,5],"c":"#e6ab3e","t":2},{"p":[552,72,-165],"s":[1,7,1],"r":[0,0,0.17],"c":"#2f2f2f","t":5},{"p":[539,43,-180],"s":[6,8,6],"i":2,"r":[0,-0.17,0]},{"p":[552,53,-165],"s":[1,19,1],"c":"#2f2f2f","t":5},{"p":[306,88,-169],"s":[54,44,56],"c":"#ffd5b1"},{"p":[306,130,-169],"s":[58,3,62],"c":"#393939","t":11},{"p":[250,108,-180],"s":[58,1,34],"c":"#393939","t":11},{"p":[250,88,-180],"s":[58,5,34],"c":"#ffd5b1"},{"p":[224,88,-194],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[276,88,-194],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[249,88,-194],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[249,88,-165],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[224,88,-166],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[276,88,-166],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[264,93,-196],"s":[11,1,3],"c":"#dc7c7c","t":2},{"p":[264,85,-198],"s":[11,9,1],"c":"#d26262","t":2},{"p":[221,102,-173],"s":[1,8,7],"c":"#e63f3f","t":2},{"p":[244,93,-194],"s":[6,8,6],"i":2,"l":1,"r":[0,-0.17,0]},{"p":[285,149,-172],"s":[1,7,1],"l":1,"r":[0,0,0.17],"c":"#2f2f2f","t":5},{"p":[272,109,-187],"s":[6,8,6],"i":2,"l":1,"r":[0,-0.17,0]},{"p":[285,131,-172],"s":[1,19,1],"c":"#2f2f2f","t":5},{"p":[223,109,-173],"s":[3,1,7],"c":"#e63f3f","t":2},{"p":[136,84,-198],"s":[40,2,9],"c":"#7d7d7d","t":2,"bo":1},{"p":[154,84,-201],"s":[2,8,2],"c":"#7d7d7d","t":2},{"p":[118,84,-201],"s":[2,8,2],"c":"#7d7d7d","t":2},{"p":[136,92,-201],"s":[40,1,3],"c":"#7d7d7d","t":2,"bo":1},{"p":[154,92,-195],"s":[3,1,9],"c":"#7d7d7d","t":2},{"p":[118,92,-195],"s":[3,1,9],"c":"#7d7d7d","t":2},{"p":[124,79,-203],"s":[5,14,1],"l":1,"c":"#8de63e","t":2},{"p":[124,93,-201],"s":[5,1,5],"l":1,"c":"#8de63e","t":2},{"p":[272,88,-156],"s":[12,12,12],"i":1,"l":1},{"p":[272,100,-156],"s":[12,12,12],"i":1,"l":1},{"p":[136,86,-197],"s":[1,17,1],"l":1,"c":"#393939","t":2},{"p":[150,86,-197],"s":[1,17,1],"l":1,"c":"#393939","t":2},{"p":[143,103,-197],"s":[15,1,1],"l":1,"c":"#393939","t":2},{"p":[143,86,-196],"s":[13,17,2],"l":1,"c":8221547,"t":2},{"p":[-232,80,145],"s":[1,17,17],"i":22,"l":1},{"p":[-234,81,145],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[-225,95,101],"s":[1,17,17],"i":22,"l":1},{"p":[-227,96,101],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[127,88,94],"s":[8,3,26],"l":1,"r":[0,0,0.35],"c":"#525252","t":11},{"p":[122,66,94],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[124,67,94],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[-13,11,-257],"s":[65,109,54],"i":15,"l":1,"r":[3.14,-0.35,3.14],"c":"#846d22"},{"p":[111,78,28],"s":[47,2,2],"c":"#7d7d7d","t":2},{"p":[111,78,36],"s":[47,2,2],"c":"#7d7d7d","t":2},{"p":[119,80,32],"s":[8,1,11],"l":1,"c":"#d28d8d","t":2},{"p":[119,71,27],"s":[8,9,1],"l":1,"c":"#d28d8d","t":2},{"p":[99,71,37],"s":[3,9,1],"l":1,"c":"#bbd9bb","t":2},{"p":[99,80,32],"s":[3,1,11],"l":1,"c":"#bbd9bb","t":2},{"p":[99,75,27],"s":[3,5,1],"l":1,"c":"#bbd9bb","t":2},{"p":[119,77,37],"s":[8,3,1],"l":1,"c":"#d28d8d","t":2},{"p":[-200,95,-276],"s":[1,17,17],"i":22,"l":1},{"p":[-202,96,-276],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[-200,95,-312],"s":[1,17,17],"i":22,"l":1},{"p":[-202,96,-312],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[-124,68,-33],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[-122,69,-33],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[20,65,-225],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[22,66,-225],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[158,70,-318],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[160,71,-318],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[-42,96,-354],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[-42,97,-356],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[-8,67,-336],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[-8,68,-338],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[90,78,-346],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[90,79,-348],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[-55,13,11],"s":[4,34,2],"l":1,"c":"#575757","t":2},{"p":[53,13,-19],"s":[4,34,2],"l":1,"c":"#575757","t":2},{"p":[53,13,11],"s":[4,34,2],"l":1,"c":"#575757","t":2},{"p":[53,45,-4],"s":[4,2,28],"l":1,"c":"#575757","t":2},{"p":[-1,13,11],"s":[4,34,2],"l":1,"c":"#575757","t":2},{"p":[-1,13,-19],"s":[4,34,2],"l":1,"c":"#575757","t":2},{"p":[-1,45,-4],"s":[4,2,28],"l":1,"c":"#575757","t":2},{"p":[-112,45,81],"s":[2,66,2],"l":1,"c":"#2f2f2f","t":5},{"p":[-225,103,-128],"s":[43,2,72],"c":"#393939","t":11},{"p":[-225,80,-128],"s":[43,8,72],"c":"#ffd5b1"},{"p":[-206,88,-162],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[-206,88,-109],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[-244,88,-162],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[-244,88,-109],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[-244,88,-136],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[-206,88,-136],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[-201,124,-104],"s":[1,7,1],"l":1,"r":[0,0,0.17],"c":"#2f2f2f","t":5},{"p":[-201,105,-104],"s":[1,19,1],"c":"#2f2f2f","t":5},{"p":[-213,105,-113],"s":[6,8,6],"i":2,"l":1,"r":[0,0.52,0]},{"p":[-205,80,-169],"s":[6,8,6],"i":2,"l":1,"r":[0,0.52,0]},{"p":[-216,80,-170],"s":[12,12,12],"i":1,"l":1},{"p":[-207,105,-145],"s":[9,1,13],"l":1,"c":"#6383ed","t":2},{"p":[-203,95,-145],"s":[1,10,13],"l":1,"c":"#6383ed","t":2},{"p":[-200,33,-258],"s":[2,83,2],"l":1,"c":"#2f2f2f","t":5},{"p":[-200,116,-262],"s":[2,18,2],"l":1,"c":"#2f2f2f","t":5},{"p":[-200,116,-259],"s":[2,2,4],"l":1,"c":"#2f2f2f","t":5},{"p":[-226,68,-244],"s":[12,12,12],"i":1,"l":1,"r":[0,-0.35,0]},{"p":[-218,68,-234],"s":[6,8,6],"i":2,"l":1,"r":[0,0.52,0]},{"p":[270,34,-76],"s":[6,48,24],"c":"#ffd5b1","bo":1},{"p":[271,81,-76],"s":[12,3,26],"l":1,"r":[0,0,0.35],"c":"#525252","t":11},{"p":[266,59,-76],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[268,60,-76],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[284,62,94],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[286,63,94],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[284,65,3],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[286,66,3],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[189,75,97],"s":[1,17,17],"i":22,"l":1},{"p":[187,76,97],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[189,75,51],"s":[1,17,17],"i":22,"l":1},{"p":[187,76,51],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[220,65,-181],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[222,66,-181],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[193,34,-292],"s":[68,20,113],"c":"#9d8672","t":11,"bo":1},{"p":[-161,141,263],"s":[17,5,3],"c":"#313131","t":11},{"p":[-263,141,263],"s":[17,5,3],"c":"#313131","t":11},{"p":[-195,141,263],"s":[17,5,3],"c":"#313131","t":11},{"p":[-228,141,263],"s":[17,5,3],"c":"#313131","t":11},{"p":[-304,141,225],"s":[5,5,17],"c":"#313131","t":11},{"p":[-304,141,141],"s":[5,5,17],"c":"#313131","t":11},{"p":[-304,141,179],"s":[5,5,17],"c":"#313131","t":11},{"p":[-319,34,-70],"s":[65,109,54],"i":15,"l":1,"r":[0,0.87,0]},{"p":[-335,46,4],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,1.4,-3.14]},{"p":[-385,50,-47],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.23,0]},{"p":[181,120,-296],"s":[43,2,72],"c":"#393939","t":11},{"p":[181,97,-295],"s":[43,8,72],"c":"#ffd5b1"},{"p":[200,105,-323],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[161,105,-262],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[161,105,-289],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[161,105,-317],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[194,122,-264],"s":[6,8,6],"i":2,"l":1,"r":[0,0.52,0]},{"p":[201,97,-330],"s":[6,8,6],"i":2,"r":[0,0.52,0]},{"p":[190,97,-331],"s":[12,12,12],"i":1},{"p":[163,122,-306],"s":[9,1,13],"l":1,"c":"#3661f0","t":2},{"p":[159,112,-306],"s":[1,10,13],"l":1,"c":"#3661f0","t":2},{"p":[172,122,-266],"s":[9,1,13],"l":1,"c":"#66b18e","t":2},{"p":[172,110,-260],"s":[9,12,1],"l":1,"c":"#66b18e","t":2},{"p":[181,95,-346],"s":[44,32,54],"c":"#ffd5b1"},{"p":[181,127,-346],"s":[46,2,56],"c":"#525252","t":11},{"p":[201,105,-289],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[201,105,-262],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[200,105,-317],"s":[2,19,2],"c":"#7d7d7d","t":2},{"p":[197,98,-253],"s":[12,12,12],"i":1,"l":1},{"p":[164,105,-266],"s":[6,8,6],"i":2,"l":1,"r":[0,-1.05,0]},{"p":[158,33,-341],"s":[2,80,2],"l":1,"c":"#2f2f2f","t":5},{"p":[158,113,-331],"s":[2,19,2],"l":1,"c":"#2f2f2f","t":5},{"p":[158,113,-337],"s":[2,2,10],"l":1,"c":"#2f2f2f","t":5},{"p":[177,125,-346],"s":[1,19,1],"c":"#2f2f2f","t":5},{"p":[177,144,-346],"s":[1,6,1],"l":1,"r":[0.35,0,0],"c":"#2f2f2f","t":5},{"p":[177,149,-344],"s":[1,3,1],"l":1,"c":"#2f2f2f","t":5},{"p":[166,48,-80],"s":[15,1,4],"l":1,"c":5066061,"t":2},{"p":[166,47,-81],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[70,92,-82],"s":[15,1,4],"l":1,"c":5066061,"t":2},{"p":[70,91,-83],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[268,62,131],"s":[15,1,4],"l":1,"c":5066061,"t":2},{"p":[268,61,130],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-67,82,14],"s":[15,1,4],"l":1,"c":5066061,"t":2},{"p":[-67,81,13],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-80,71,-19],"s":[1,17,17],"i":22,"l":1},{"p":[-82,72,-19],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[135,90,-39],"s":[1,17,17],"i":22,"l":1},{"p":[133,91,-39],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[102,65,-262],"s":[1,17,17],"i":22,"l":1},{"p":[100,66,-262],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[228,70,-316],"s":[1,17,17],"i":22,"l":1},{"p":[226,71,-316],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[151,64,-123],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[151,65,-125],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[233,65,-123],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[233,66,-125],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[151,48,-15],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[151,49,-17],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[211,67,-234],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[210,68,-236],"s":[6,1,16],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[-200,54,-204],"s":[1,17,17],"i":22,"l":1},{"p":[-202,55,-204],"s":[6,1,15],"l":1,"r":[-3.14,0,-3.14],"c":5066061,"t":2},{"p":[68,91,-21],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[68,92,-23],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[53,91,-54],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[55,92,-54],"s":[6,1,15],"l":1,"c":5066061,"t":2},{"p":[63,64,-129],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[63,65,-131],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[16,64,-129],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[16,65,-131],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[-79,64,-72],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[-79,65,-74],"s":[6,1,15],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[-28,33,-130],"s":[2,61,2],"l":1,"c":"#2f2f2f","t":5},{"p":[284,33,23],"s":[2,43,2],"l":1,"c":"#2f2f2f","t":5},{"p":[284,78,17],"s":[2,15,2],"l":1,"c":"#2f2f2f","t":5},{"p":[284,76,20],"s":[2,2,8],"l":1,"c":"#2f2f2f","t":5},{"p":[219,33,-81],"s":[2,47,2],"l":1,"c":"#2f2f2f","t":5},{"p":[220,32,-132],"s":[2,40,2],"l":1,"c":"#2f2f2f","t":5},{"p":[220,72,-135],"s":[2,2,8],"l":1,"c":"#2f2f2f","t":5},{"p":[220,74,-138],"s":[2,16,2],"l":1,"c":"#2f2f2f","t":5},{"p":[-140,34,-203],"s":[1,17,2],"l":1,"c":"#a5a5a5","t":2},{"p":[-126,34,-203],"s":[1,17,2],"l":1,"c":"#a5a5a5","t":2},{"p":[-133,51,-203],"s":[15,1,2],"l":1,"c":"#a5a5a5","t":2},{"p":[-133,34,-202],"s":[13,17,3],"l":1,"c":8221547,"t":2},{"p":[353,21,-77],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,-0.17,-3.14]},{"p":[360,29,-127],"s":[65,109,54],"i":15,"l":1,"r":[-0.01,-1.4,-0.01]},{"p":[266,11,231],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,-0.17,-3.14]},{"p":[226,0,-434],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,-0.17,-3.14]},{"p":[-156,43,-147],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.13,-3.14]},{"p":[-155,43,-164],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.79,-3.14]},{"p":[-198,43,-113],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.79,-3.14]},{"p":[-160,43,-124],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.79,-3.14]},{"p":[-196,43,-147],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.79,-3.14]},{"p":[105,32,-203],"s":[7,6,8],"i":18,"l":1,"r":[0,0.97,0]},{"p":[132,32,-203],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.08,-3.14]},{"p":[172,32,-231],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.97,-3.14]},{"p":[154,32,-200],"s":[7,6,8],"i":18,"l":1,"r":[0,0.8,0]},{"p":[191,32,-225],"s":[7,6,8],"i":18,"l":1,"r":[0,0.8,0]},{"p":[199,32,-231],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.45,3.14]},{"p":[216,32,-191],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.45,3.14]},{"p":[247,32,-201],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.97,3.14]},{"p":[273,32,-206],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.97,3.14]},{"p":[280,32,-221],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.97,3.14]},{"p":[264,32,-237],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.95,0]},{"p":[230,32,-234],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.47,-3.14]},{"p":[239,32,-262],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.47,-3.14]},{"p":[275,32,-271],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.97,-3.14]},{"p":[240,32,-301],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.97,-3.14]},{"p":[275,32,-320],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.97,-3.14]},{"p":[253,32,-331],"s":[7,6,8],"i":18,"l":1,"r":[0,0.62,0]},{"p":[172,32,-161],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.45,3.14]},{"p":[216,32,-157],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.77,0]},{"p":[171,32,-137],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.59,-3.14]},{"p":[189,32,-91],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.59,-3.14]},{"p":[182,32,-84],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.98,-3.14]},{"p":[158,32,-120],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.98,-3.14]},{"p":[225,32,-84],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.59,-3.14]},{"p":[216,32,-128],"s":[7,6,8],"i":18,"l":1,"r":[-3.12,-1.5,-3.12]},{"p":[250,32,-119],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.59,0]},{"p":[257,32,-112],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.11,0]},{"p":[269,32,-109],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.24,0]},{"p":[266,32,-90],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.41,0]},{"p":[230,32,-43],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.41,-3.14]},{"p":[270,32,-61],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.41,-3.14]},{"p":[280,32,-49],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.41,-3.14]},{"p":[280,32,-6],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.11,0]},{"p":[231,32,-23],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.06,0]},{"p":[218,32,-12],"s":[7,6,8],"i":18,"l":1,"r":[0,0.81,0]},{"p":[294,32,31],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.76,0]},{"p":[294,32,72],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.76,0]},{"p":[251,32,77],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.28,0]},{"p":[199,32,43],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.58,-3.14]},{"p":[191,32,25],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.58,-3.14]},{"p":[192,32,74],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.58,-3.14]},{"p":[192,32,85],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.58,-3.14]},{"p":[194,32,113],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.58,-3.14]},{"p":[210,32,126],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.82,-3.14]},{"p":[197,32,126],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.82,-3.14]},{"p":[228,32,120],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.34,-3.14]},{"p":[242,32,127],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.75,0]},{"p":[217,32,115],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.34,-3.14]},{"p":[279,32,98],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.34,-3.14]},{"p":[282,32,86],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.75,0]},{"p":[137,32,-12],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.58,-3.14]},{"p":[144,32,21],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.58,-3.14]},{"p":[96,32,26],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.99,-3.14]},{"p":[106,32,-17],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.99,-3.14]},{"p":[57,47,124],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0]},{"p":[103,47,125],"s":[7,6,8],"i":18,"l":1,"r":[0,0.88,0]},{"p":[123,47,116],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.34,0]},{"p":[94,47,87],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0]},{"p":[-48,68,24],"s":[2,2,30],"l":1,"c":9539985,"t":2},{"p":[-45,55,-25],"s":[2,3,2],"l":1,"c":"#571f1f","t":5},{"p":[46,68,-12],"s":[2,2,30],"l":1,"c":9539985,"t":2},{"p":[23,55,70],"s":[2,2,2],"l":1,"c":"#571f1f","t":5},{"p":[21,55,70],"s":[2,1,2],"l":1,"c":"#571f1f","t":5},{"p":[22,54,68],"s":[2,3,2],"l":1,"c":"#571f1f","t":5},{"p":[-14,91,-132],"s":[3,25,2],"c":"#7d7d7d","t":2},{"p":[28,91,-132],"s":[3,25,2],"c":"#7d7d7d","t":2},{"p":[7,92,-130],"s":[51,22,1],"c":"#4d4d4d","t":2},{"p":[-42,48,-124],"s":[12,12,12],"i":1},{"p":[47,91,-135],"s":[6,8,6],"i":2,"l":1,"r":[0,0.17,0]},{"p":[-17,91,-135],"s":[6,8,6],"i":2,"l":1,"r":[0,0.69,0]},{"p":[7,92,-130],"s":[53,1,2],"c":"#4d4d4d","t":2},{"p":[38,103,-143],"s":[6,8,6],"i":2,"l":1,"r":[0,0.17,0]},{"p":[-16,98,-136],"s":[6,8,6],"i":2,"l":1,"r":[0,0.69,0]},{"p":[-76,106,-150],"s":[34,20,40],"c":"#ffd5b1"},{"p":[-76,126,-150],"s":[36,3,42],"c":"#393939","t":11},{"p":[-63,122,-135],"s":[1,19,1],"c":"#2f2f2f","t":5},{"p":[-63,141,-135],"s":[1,6,1],"l":1,"r":[0.35,0,0],"c":"#2f2f2f","t":5},{"p":[-63,146,-133],"s":[1,3,1],"l":1,"c":"#2f2f2f","t":5},{"p":[-70,107,25],"s":[1,19,1],"c":"#2f2f2f","t":5},{"p":[-70,126,25],"s":[1,6,1],"r":[0.35,0,0],"c":"#2f2f2f","t":5},{"p":[-70,131,27],"s":[1,3,1],"c":"#2f2f2f","t":5},{"p":[-30,94,-130],"s":[6,2,2],"l":1,"c":"#2f2f2f","t":5},{"p":[-32,96,-130],"s":[2,6,2],"l":1,"c":"#2f2f2f","t":5},{"p":[-250,98,-18],"s":[31,2,72],"c":"#393939","t":11},{"p":[-236,88,-37],"s":[2,13,2],"c":"#7d7d7d","t":2},{"p":[-236,88,16],"s":[2,13,2],"c":"#7d7d7d","t":2},{"p":[-236,88,-10],"s":[2,13,2],"c":"#7d7d7d","t":2},{"p":[-264,88,-10],"s":[2,13,2],"c":"#7d7d7d","t":2},{"p":[-264,88,16],"s":[2,13,2],"c":"#7d7d7d","t":2},{"p":[-263,88,-37],"s":[2,13,2],"c":"#7d7d7d","t":2},{"p":[-244,100,-30],"s":[12,12,12],"i":1,"l":1,"r":[0,-0.35,0]},{"p":[-235,111,-43],"s":[6,8,6],"i":2,"l":1,"r":[0,0.52,0]},{"p":[-239,88,11],"s":[6,8,6],"i":2,"l":1,"r":[0,0.52,0]},{"p":[-166,121,-351],"s":[58,1,34],"c":"#393939","t":11},{"p":[-166,101,-351],"s":[58,5,34],"c":"#ffd5b1"},{"p":[-192,101,-365],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[-140,101,-365],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[-167,101,-365],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[-167,101,-336],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[-192,101,-337],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[-140,101,-337],"s":[2,22,2],"c":"#7d7d7d","t":2},{"p":[-136,115,-344],"s":[1,8,7],"l":1,"c":"#e63f3f","t":2},{"p":[-179,106,-339],"s":[6,8,6],"i":2,"l":1,"r":[0,-0.17,0]},{"p":[-144,122,-358],"s":[6,8,6],"i":2,"l":1,"r":[0,-0.17,0]},{"p":[-138,122,-344],"s":[3,1,7],"l":1,"c":"#e63f3f","t":2},{"p":[-95,121,-383],"s":[12,12,12],"i":1,"l":1},{"p":[-110,101,-353],"s":[12,12,12],"i":1,"l":1},{"p":[-222,101,-362],"s":[54,44,56],"c":"#ffd5b1"},{"p":[-222,143,-362],"s":[58,3,62],"c":"#393939","t":11},{"p":[-43,55,-25],"s":[2,2,2],"l":1,"c":"#571f1f","t":5},{"p":[-45,55,-27],"s":[2,2,2],"l":1,"c":"#571f1f","t":5},{"p":[-43,55,-27],"s":[2,1,2],"l":1,"c":"#571f1f","t":5},{"p":[222,85,132],"s":[3,25,2],"c":"#7d7d7d","t":2},{"p":[264,85,132],"s":[3,25,2],"c":"#7d7d7d","t":2},{"p":[243,87,131],"s":[51,22,1],"c":"#4d4d4d","t":2},{"p":[217,85,134],"s":[6,8,6],"i":2,"l":1,"r":[0,0.69,0]},{"p":[243,87,130],"s":[53,1,2],"c":"#4d4d4d","t":2},{"p":[213,93,137],"s":[6,8,6],"i":2,"l":1,"r":[0,1.21,0]},{"p":[325,57,-4],"s":[18,46,38],"c":"#ffd5b1"},{"p":[325,103,-4],"s":[21,3,40],"c":"#525252","t":11},{"p":[324,95,10],"s":[1,19,1],"c":"#2f2f2f","t":5},{"p":[324,114,10],"s":[1,6,1],"l":1,"r":[0.35,0,0],"c":"#2f2f2f","t":5},{"p":[324,119,12],"s":[1,3,1],"l":1,"c":"#2f2f2f","t":5},{"p":[-83,121,-380],"s":[12,12,12],"i":1,"l":1},{"p":[-204,137,-305],"s":[6,8,6],"i":2,"l":1,"r":[0,0.88,0]},{"p":[-203,129,-304],"s":[6,8,6],"i":2,"l":1,"r":[0,-0.17,0]},{"p":[-204,127,-294],"s":[2,27,2],"c":"#7d7d7d","t":2},{"p":[-203,131,-278],"s":[1,21,46],"c":"#7d7d7d","t":2},{"p":[-203,131,-278],"s":[3,1,46],"c":"#7d7d7d","t":2},{"p":[-204,127,-262],"s":[2,26,2],"c":"#7d7d7d","t":2},{"p":[-202,129,-311],"s":[6,8,6],"i":2,"l":1,"r":[0,0.18,0]},{"p":[-214,129,-259],"s":[12,12,12],"i":1,"l":1,"r":[0,-0.35,0]},{"p":[-227,129,-255],"s":[6,8,6],"i":2,"l":1,"r":[0,-0.17,0]},{"p":[-201,136,-339],"s":[1,19,1],"c":"#2f2f2f","t":5},{"p":[-201,155,-339],"s":[1,6,1],"l":1,"r":[0.35,0,0],"c":"#2f2f2f","t":5},{"p":[-201,160,-337],"s":[1,3,1],"l":1,"c":"#2f2f2f","t":5},{"p":[210,85,138],"s":[6,8,6],"i":2,"l":1,"r":[0,0.34,0]},{"p":[39,12,-16],"s":[7,6,8],"i":18,"l":1,"r":[0,1.16,0]},{"p":[-27,12,7],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.76,-3.14]},{"p":[-61,12,10],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.81,-3.14]},{"p":[-59,22,-63],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.24,0]},{"p":[-77,22,-70],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.41,0]},{"p":[-128,32,-42],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0]},{"p":[-87,32,47],"s":[63,2,67],"l":1,"c":"#393939","t":11},{"p":[-118,24,153],"s":[5,127,6],"v":1,"c":"#9d8672","t":11},{"p":[-14,36,-257],"s":[5,123,6],"v":1,"c":"#9d8672","t":11},{"p":[438,32,66],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,-0.17,-3.14]},{"p":[397,32,15],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.53,0]},{"p":[22,47,63],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0]},{"p":[34,47,34],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0]},{"p":[-32,47,68],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0]},{"p":[-45,47,51],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.86,3.14]},{"p":[-29,47,42],"s":[7,6,8],"i":18,"l":1,"r":[-3.06,1.56,3.06]},{"p":[-42,47,-13],"s":[7,6,8],"i":18,"l":1,"r":[-3.06,1.56,3.06]},{"p":[-42,47,-34],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.86,3.14]},{"p":[9,47,-31],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.86,3.14]},{"p":[-44,47,-91],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.86,3.14]},{"p":[-32,47,-126],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.86,3.14]},{"p":[42,47,-56],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.86,3.14]},{"p":[42,47,-88],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.86,3.14]},{"p":[32,47,-29],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.23,3.14]},{"p":[138,32,-119],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.98,-3.14]},{"p":[138,32,-85],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.98,-3.14]},{"p":[-10,47,-41],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.19,3.14]},{"p":[10,47,-17],"s":[7,6,8],"i":18,"l":1,"r":[0,1.06,0]},{"p":[261,32,80],"s":[9,14,4],"c":"#9d8672","t":11},{"p":[271,32,80],"s":[12,3,4],"c":"#9d8672","t":11},{"p":[271,44,80],"s":[11,3,4],"c":"#7a6a5d","t":11},{"p":[275,35,78],"s":[3,10,1],"pe":1,"c":"#b4b4b4","t":2},{"p":[272,34,78],"s":[3,12,1],"pe":1,"c":"#898989","t":2},{"p":[269,35,78],"s":[3,10,1],"pe":1,"c":"#cacaca","t":2},{"p":[266,35,78],"s":[3,11,1],"pe":1,"c":"#898989","t":2},{"p":[203,47,80],"s":[11,1,4],"c":"#9d8672","t":11},{"p":[-113,46,-319],"s":[5,1,11],"c":"#9d8672","t":11},{"p":[-113,46,-291],"s":[5,2,11],"c":"#9d8672","t":11},{"p":[-104,33,-329],"s":[7,2,4],"l":1,"r":[0,0.36,0],"c":"#9d8672"},{"p":[50,77,-36],"s":[8,1,101],"i":9,"v":1,"b":-0.1},{"p":[-52,77,-25],"s":[8,1,212],"i":9,"v":1,"b":-0.1,"d":2},{"p":[-41,77,77],"s":[34,1,8],"i":9,"v":1,"b":-0.1,"d":1},{"p":[26,77,77],"s":[24,1,8],"i":9,"v":1,"b":-0.1,"d":1},{"p":[176,67,-234],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[176,68,-236],"s":[6,1,16],"l":1,"r":[0,1.57,0],"c":5066061,"t":2},{"p":[-46,90,-195],"s":[1,19,1],"c":"#2f2f2f","t":5},{"p":[-46,109,-195],"s":[1,5,1],"l":1,"r":[-0.44,0,0],"c":"#2f2f2f","t":5},{"p":[-52,12,-18],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.76,-3.14]},{"p":[2,12,-15],"s":[7,6,8],"i":18,"l":1,"r":[0,1.16,0]},{"p":[-217,32,-25],"s":[7,6,8],"i":18,"l":1,"r":[0,0.53,0]},{"p":[-149,32,-252],"s":[7,6,8],"i":18,"l":1,"r":[0,0.62,0],"c":"#d2b559"},{"p":[-110,50,146],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0]},{"p":[-124,50,161],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.26,0]},{"p":[195,32,-12],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.28,0]},{"p":[-225,47,132],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.04,3.14]},{"p":[-135,32,-70],"s":[7,6,8],"i":18,"l":1,"r":[0,0.97,0]},{"p":[164,192,142],"s":[4,4,40],"c":"#7d7d7d","t":2},{"p":[164,192,142],"s":[41,4,4],"c":"#7d7d7d","t":2},{"p":[240,33,-202],"s":[6,2,4],"l":1,"r":[0,-1.39,0],"c":"#9d8672"},{"p":[267,33,-101],"s":[6,2,4],"l":1,"r":[0,-1.39,0],"c":"#9d8672"},{"p":[216,32,-7],"s":[6,2,4],"l":1,"r":[0,-1.39,0],"c":"#9d8672"},{"p":[286,32,31],"s":[6,2,4],"l":1,"r":[0,-1.39,0],"c":"#9d8672"},{"p":[269,32,-53],"s":[6,2,4],"l":1,"r":[0,-1.39,0],"c":"#9d8672"},{"p":[259,32,74],"s":[6,2,4],"l":1,"r":[0,-0.43,0],"c":"#9d8672"},{"p":[-21,12,7],"s":[6,2,4],"l":1,"r":[0,-0.43,0],"c":"#9d8672"},{"p":[8,13,-15],"s":[6,2,4],"l":1,"r":[0,0.27,0],"c":"#9d8672"},{"p":[-157,32,66],"s":[6,2,4],"l":1,"r":[0,-0.43,0],"c":"#9d8672"},{"p":[-221,33,23],"s":[6,2,4],"l":1,"r":[3.14,-1.49,3.14],"c":"#9d8672"},{"p":[-136,48,138],"s":[6,2,4],"l":1,"r":[0,1.14,0],"c":"#9d8672"},{"p":[-129,33,-14],"s":[6,2,4],"l":1,"r":[0,-1.04,0],"c":"#9d8672"},{"p":[-143,33,-251],"s":[4,2,4],"l":1,"c":"#9d8672"},{"p":[-204,33,-231],"s":[4,2,4],"l":1,"c":"#9d8672"},{"p":[153,33,-311],"s":[6,2,4],"l":1,"r":[0,-1.39,0],"c":"#9d8672"},{"p":[124,33,-203],"s":[6,2,4],"l":1,"r":[0,0.09,0],"c":"#9d8672"},{"p":[216,33,-141],"s":[6,2,4],"l":1,"r":[0,-1.39,0],"c":"#9d8672"},{"p":[150,33,21],"s":[4,2,4],"l":1,"r":[0,-1.39,0],"c":"#9d8672"},{"p":[22,48,85],"s":[6,2,4],"l":1,"r":[0,-0.34,0],"c":"#9d8672"},{"p":[-36,48,57],"s":[6,2,4],"l":1,"r":[0,-0.34,0],"c":"#9d8672"},{"p":[-54,48,85],"s":[6,2,4],"l":1,"r":[0,0.18,0],"c":"#9d8672"},{"p":[-40,48,-21],"s":[2,1,2],"l":1,"c":"#571f1f","t":5},{"p":[17,48,71],"s":[2,1,2],"l":1,"c":"#571f1f","t":5},{"p":[10,55,-23],"s":[2,1,2],"l":1,"c":"#571f1f","t":5},{"p":[10,55,-25],"s":[2,2,2],"l":1,"c":"#571f1f","t":5},{"p":[8,53,-24],"s":[2,3,2],"l":1,"c":"#571f1f","t":5},{"p":[-193,32,-41],"s":[4,2,4],"l":1,"r":[0,-0.87,0],"c":"#9d8672"},{"p":[-195,32,-35],"s":[2,2,2],"l":1,"r":[0,-0.43,0],"c":"#9d8672"},{"p":[-133,32,-20],"s":[2,2,2],"l":1,"r":[0,-0.43,0],"c":"#9d8672"},{"p":[-151,33,-208],"s":[4,2,4],"l":1,"c":"#9d8672"},{"p":[223,32,77],"s":[3,2,3],"l":1,"r":[0,-1.39,0],"c":"#9d8672"},{"p":[248,32,75],"s":[2,2,2],"l":1,"r":[0,-1.39,0],"c":"#9d8672"},{"p":[-185,48,132],"s":[3,1,3],"l":1,"r":[0,1.14,0],"c":"#9d8672"},{"p":[-20,48,76],"s":[6,2,4],"l":1,"r":[0,1.49,0],"c":"#9d8672"},{"p":[44,47,-126],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.86,3.14]},{"p":[7,47,-127],"s":[7,6,8],"i":18,"l":1,"r":[0,1.32,0]},{"p":[-202,142,-278],"s":[44,0,18],"i":11,"l":1,"r":[1.57,0,1.57],"sad":1},{"p":[7,104,-129],"s":[48,0,19],"i":11,"l":1,"r":[1.57,0,0],"sad":1},{"p":[243,98,130],"s":[48,0,19],"i":11,"l":1,"r":[1.57,0,3.14],"sad":1}]};
    
    /***/ }),
    
    /***/ "./maps/shipyard.json":
    /*!****************************!*\
      !*** ./maps/shipyard.json ***!
      \****************************/
    /*! exports provided: name, skyDome, skyDomeCol0, skyDomeCol1, skyDomeCol2, ambient, light, sky, fog, fogD, camPos, spawns, objects, default */
    /***/ (function(module) {
    
    module.exports = {"name":"Shipyard","skyDome":true,"skyDomeCol0":"#74a4b9","skyDomeCol1":"#dce8ed","skyDomeCol2":"#dce8ed","ambient":9800065,"light":15390924,"sky":14478324,"fog":13481382,"fogD":666.357503003984,"camPos":[-77,46,45],"spawns":[[15,1,62,0,2,0],[-185,1,52,0,0,0],[-79,1,201,0,2,0],[61,1,207,0,2,0],[-80,27,115,0,0,0],[-179,0,143,0,3,0],[-54,1,-54,0,2,0],[-42,1,129,0,3,0],[15,1,62,0,2,0],[-185,1,52,0,0,0],[-79,1,201,0,2,0],[61,1,207,0,2,0],[-80,27,115,0,0,0],[101,1,-48,0,1,0],[-179,0,143,0,3,0],[-54,1,-54,0,2,0],[-42,1,129,0,3,0]],"objects":[{"p":[-41,-10,86],"s":[338,10,308],"c":"#f0f0f0","t":1},{"p":[0,-1,36],"s":[57,26,25],"i":17},{"p":[0,-1,62],"s":[57,26,25],"i":19,"l":1,"h":500},{"p":[0,25,62],"s":[57,26,25],"i":17},{"p":[0,24,36],"s":[57,26,25],"i":17},{"p":[26,1,70],"s":[5,23,1],"l":1,"pe":1,"c":"#282828","t":5},{"p":[0,0,74],"s":[58,25,1],"pe":1,"v":1},{"p":[-83,-1,36],"s":[57,26,25],"i":17},{"p":[-83,-1,62],"s":[57,26,25],"i":17},{"p":[0,-1,114],"s":[57,26,25],"i":17},{"p":[0,-1,140],"s":[57,26,25],"i":17},{"p":[-83,-1,115],"s":[57,26,25],"i":17},{"p":[-83,24,141],"s":[57,26,25],"i":17},{"p":[-55,-1,-53],"s":[57,26,25],"i":19,"l":1,"h":500},{"p":[-55,0,-41],"s":[57,25,1],"pe":1,"v":1},{"p":[-55,24,-53],"s":[57,1,23],"pe":1,"v":1},{"p":[32,0,121],"s":[6,8,6],"i":2},{"p":[-60,0,237],"s":[57,25,1],"pe":1,"v":1},{"p":[-60,24,225],"s":[57,1,23],"pe":1,"v":1},{"p":[-55,0,-65],"s":[57,25,1],"pe":1,"v":1},{"p":[-42,-1,199],"s":[57,26,25],"i":17},{"p":[-41,0,239],"s":[334,20,2],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[-209,0,190],"s":[2,20,100],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[-179,-1,73],"s":[57,26,25],"i":17},{"p":[-196,0,185],"s":[24,8,2],"c":"#a0998a","e":"#313131","t":11},{"p":[-189,0,230],"s":[38,3,16],"c":"#969696","e":"#373737","t":6},{"p":[-169,0,233],"s":[2,8,10],"c":"#a0998a","e":"#313131","t":11},{"p":[-169,0,224],"s":[2,5,8],"c":"#a0998a","e":"#313131","t":11},{"p":[-158,0,232],"s":[12,12,12],"i":1},{"p":[-252,0,160],"s":[14,54,18],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-247,0,187],"s":[3,26,36],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-247,0,210],"s":[4,54,10],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-247,26,187],"s":[4,7,36],"l":1,"c":"#ffffff","e":"#3e4448","t":6},{"p":[-247,33,187],"s":[2,14,36],"l":1,"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-247,47,187],"s":[4,7,36],"l":1,"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-247,33,191],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,33,183],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,33,175],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,33,199],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,6,233],"s":[3,20,36],"l":1,"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-247,26,233],"s":[4,7,36],"l":1,"c":"#ffffff","e":"#3e4448","t":6},{"p":[-247,33,279],"s":[2,14,36],"l":1,"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-247,33,221],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,33,237],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,33,229],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,33,245],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,0,256],"s":[4,54,10],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-247,26,279],"s":[4,7,36],"l":1,"c":"#ffffff","e":"#3e4448","t":6},{"p":[-247,0,279],"s":[3,26,36],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-247,33,267],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,33,275],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,33,283],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,33,291],"s":[3,14,1],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-247,33,233],"s":[2,14,36],"l":1,"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-247,47,233],"s":[4,7,36],"l":1,"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-247,47,279],"s":[4,7,36],"l":1,"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-209,0,49],"s":[2,20,74],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[-209,5,11],"s":[2,19,1],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-304,-10,86],"s":[188,10,308],"c":"#757370","e":"#373737","t":6},{"p":[-73,-10,313],"s":[650,10,146],"c":"#969696","e":"#373737","t":6},{"p":[-209,5,-15],"s":[2,19,1],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-209,5,-41],"s":[2,19,1],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-209,5,-28],"s":[1,18,77],"l":1,"pe":1,"t":12},{"p":[-209,5,-67],"s":[2,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-209,0,-28],"s":[2,5,80],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[0,0,50],"s":[58,25,1],"pe":1,"v":1},{"p":[-164,0,138],"s":[51,15,20],"i":7,"l":1,"r":[0,-1.57,0]},{"p":[-201,0,54],"s":[12,12,12],"i":1},{"p":[-163,0,138],"s":[16,8,48],"v":1},{"p":[-163,8,143],"s":[16,7,24],"pe":1,"v":1},{"p":[-11,0,202],"s":[2,2,18],"l":1,"t":2},{"p":[-5,0,202],"s":[2,2,18],"l":1,"t":2},{"p":[1,0,202],"s":[2,2,18],"l":1,"t":2},{"p":[7,0,202],"s":[2,2,18],"l":1,"t":2},{"p":[-2,2,210],"s":[20,1,2],"l":1,"t":2},{"p":[-2,2,206],"s":[20,1,2],"l":1,"t":2},{"p":[-2,2,202],"s":[20,1,2],"l":1,"t":2},{"p":[-2,2,198],"s":[20,1,2],"l":1,"t":2},{"p":[-2,2,194],"s":[20,1,2],"l":1,"t":2},{"p":[100,0,177],"s":[2,2,18],"l":1,"t":2},{"p":[108,0,177],"s":[2,2,18],"l":1,"t":2},{"p":[116,0,177],"s":[2,2,18],"l":1,"t":2},{"p":[108,2,185],"s":[18,1,2],"l":1,"t":2},{"p":[108,2,181],"s":[18,1,2],"l":1,"t":2},{"p":[108,2,177],"s":[18,1,2],"l":1,"t":2},{"p":[108,2,173],"s":[18,1,2],"l":1,"t":2},{"p":[108,2,169],"s":[18,1,2],"l":1,"t":2},{"p":[-201,0,-43],"s":[2,2,18],"l":1,"t":2},{"p":[-195,0,-43],"s":[2,2,18],"l":1,"t":2},{"p":[-189,0,-43],"s":[2,2,18],"l":1,"t":2},{"p":[-183,0,-43],"s":[2,2,18],"l":1,"t":2},{"p":[-192,2,-35],"s":[20,1,2],"l":1,"t":2},{"p":[-192,2,-39],"s":[20,1,2],"l":1,"t":2},{"p":[-192,2,-43],"s":[20,1,2],"l":1,"t":2},{"p":[-192,2,-47],"s":[20,1,2],"l":1,"t":2},{"p":[-192,2,-51],"s":[20,1,2],"l":1,"t":2},{"p":[-279,0,47],"s":[2,2,18],"l":1,"t":2},{"p":[-273,0,47],"s":[2,2,18],"l":1,"t":2},{"p":[-267,0,47],"s":[2,2,18],"l":1,"t":2},{"p":[-261,0,47],"s":[2,2,18],"l":1,"t":2},{"p":[-270,2,55],"s":[20,1,2],"l":1,"t":2},{"p":[-270,2,51],"s":[20,1,2],"l":1,"t":2},{"p":[-270,2,47],"s":[20,1,2],"l":1,"t":2},{"p":[-270,2,43],"s":[20,1,2],"l":1,"t":2},{"p":[-270,2,39],"s":[20,1,2],"l":1,"t":2},{"p":[80,0,-24],"s":[2,2,18],"l":1,"t":2},{"p":[88,0,-24],"s":[2,2,18],"l":1,"t":2},{"p":[96,0,-24],"s":[2,2,18],"l":1,"t":2},{"p":[88,2,-16],"s":[18,1,2],"l":1,"t":2},{"p":[88,2,-20],"s":[18,1,2],"l":1,"t":2},{"p":[88,2,-24],"s":[18,1,2],"l":1,"t":2},{"p":[88,2,-28],"s":[18,1,2],"l":1,"t":2},{"p":[88,2,-32],"s":[18,1,2],"l":1,"t":2},{"p":[87,3,-16],"s":[2,2,18],"l":1,"r":[0,1.48,0],"t":2},{"p":[88,3,-24],"s":[2,2,18],"l":1,"r":[0,1.48,0],"t":2},{"p":[92,5,-24],"s":[18,1,2],"l":1,"r":[0,1.48,0],"t":2},{"p":[88,5,-24],"s":[18,1,2],"l":1,"r":[0,1.48,0],"t":2},{"p":[84,5,-24],"s":[18,1,2],"l":1,"r":[0,1.48,0],"t":2},{"p":[80,5,-25],"s":[18,1,2],"l":1,"r":[0,1.48,0],"t":2},{"p":[80,6,-23],"s":[2,2,18],"l":1,"r":[0,0.09,0],"t":2},{"p":[88,6,-24],"s":[2,2,18],"l":1,"r":[0,0.09,0],"t":2},{"p":[96,6,-25],"s":[2,2,18],"l":1,"r":[0,0.09,0],"t":2},{"p":[89,8,-16],"s":[18,1,2],"l":1,"r":[0,0.09,0],"t":2},{"p":[88,8,-20],"s":[18,1,2],"l":1,"r":[0,0.09,0],"t":2},{"p":[88,8,-24],"s":[18,1,2],"l":1,"r":[0,0.09,0],"t":2},{"p":[88,8,-28],"s":[18,1,2],"l":1,"r":[0,0.09,0],"t":2},{"p":[87,8,-32],"s":[18,1,2],"l":1,"r":[0,0.09,0],"t":2},{"p":[88,0,-25],"s":[18,9,18],"l":1,"v":1},{"p":[127,0,131],"s":[2,20,214],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[-209,0,113],"s":[2,5,54],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[-209,5,139],"s":[2,19,1],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-209,5,113],"s":[1,18,51],"pe":1,"t":12},{"p":[-209,5,113],"s":[2,19,1],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[127,0,-2],"s":[2,5,52],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[127,5,24],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[127,5,-28],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[127,5,-2],"s":[1,18,51],"l":1,"pe":1,"t":12},{"p":[127,5,-2],"s":[1,19,1],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[53,0,-31],"s":[12,12,12],"i":8},{"p":[88,0,-40],"s":[12,12,12],"i":8},{"p":[76,0,69],"s":[51,15,20],"i":7,"l":1,"r":[0,-1.57,0]},{"p":[58,0,191],"s":[51,15,20],"i":7,"l":1},{"p":[58,0,191],"s":[47,8,16],"v":1},{"p":[63,8,191],"s":[25,7,16],"pe":1,"v":1},{"p":[-59,-10,-90],"s":[769,10,44],"l":1,"c":"#827c6c"},{"p":[-41,-18,-573],"s":[2011,10,1958],"l":1,"c":"#2a4957","o":0.9,"t":5,"ab":1},{"p":[-277,0,152],"s":[36,26,1],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-300,0,160],"s":[10,54,18],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-323,8,152],"s":[36,23,1],"l":1,"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-277,26,153],"s":[36,7,4],"l":1,"c":"#ffffff","e":"#3e4448","t":6},{"p":[-277,33,154],"s":[36,14,4],"l":1,"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-265,33,153],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-273,33,153],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-281,33,153],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-289,33,153],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-323,26,153],"s":[36,7,4],"l":1,"c":"#ffffff","e":"#3e4448","t":6},{"p":[-323,33,154],"s":[36,14,4],"l":1,"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-335,33,153],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-327,33,153],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-319,33,153],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-311,33,153],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-346,0,153],"s":[10,54,4],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-277,47,153],"s":[36,7,4],"l":1,"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-323,47,153],"s":[36,7,4],"l":1,"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-349,0,233],"s":[4,54,156],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-277,0,314],"s":[36,26,1],"l":1,"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-252,0,306],"s":[14,54,18],"l":1,"c":"#ffffff","e":"#3e4448","t":6},{"p":[-300,0,306],"s":[10,54,18],"l":1,"c":"#ffffff","e":"#3e4448","t":6},{"p":[-346,0,313],"s":[10,54,4],"l":1,"c":"#ffffff","e":"#3e4448","t":6},{"p":[-323,0,314],"s":[36,26,1],"l":1,"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-277,26,313],"s":[36,7,4],"l":1,"c":"#ffffff","e":"#3e4448","t":6},{"p":[-323,26,313],"s":[36,7,4],"l":1,"c":"#ffffff","e":"#3e4448","t":6},{"p":[-323,47,313],"s":[36,7,4],"l":1,"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-277,47,313],"s":[36,7,4],"l":1,"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-277,33,312],"s":[36,14,4],"l":1,"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-265,33,313],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-273,33,313],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-281,33,313],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-289,33,313],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-323,33,312],"s":[36,14,4],"l":1,"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-311,33,313],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-319,33,313],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-327,33,313],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-335,33,313],"s":[1,14,3],"l":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-298,54,233],"s":[112,2,170],"l":1,"c":"#554242","e":"#3e4448","t":6,"ab":1},{"p":[-349,0,43],"s":[2,54,218],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[-14,0,-111],"s":[206,5,2],"l":1,"c":"#706857","e":"#313131","t":11},{"p":[-171,0,-79],"s":[51,15,20],"i":7,"l":1},{"p":[125,16,204],"s":[2,2,14],"l":1,"r":[0,0,-0.09],"t":2},{"p":[124,9,204],"s":[2,2,14],"l":1,"r":[0,0,-0.09],"t":2},{"p":[123,0,204],"s":[2,2,14],"l":1,"r":[0,0,-0.09],"t":2},{"p":[125,9,210],"s":[18,1,2],"l":1,"r":[0,0,-1.66],"t":2},{"p":[125,9,206],"s":[18,1,2],"l":1,"r":[0,0,-1.66],"t":2},{"p":[125,9,202],"s":[18,1,2],"l":1,"r":[0,0,-1.66],"t":2},{"p":[125,9,198],"s":[18,1,2],"l":1,"r":[0,0,-1.66],"t":2},{"p":[125,0,204],"s":[3,18,14],"l":1,"v":1},{"p":[-14,5,-111],"s":[206,2,3],"l":1,"c":"#aca596","e":"#313131"},{"p":[-131,-116,-192],"s":[28,116,160],"l":1,"c":"#827c6c"},{"p":[-323,-84,-192],"s":[28,84,160],"l":1,"c":"#827c6c"},{"p":[103,-176,-192],"s":[28,176,160],"l":1,"c":"#827c6c"},{"p":[188,0,-84],"s":[51,15,20],"i":7,"l":1},{"p":[123,0,-100],"s":[12,12,12],"i":8,"l":1},{"p":[-15,0,-80],"s":[12,12,12],"i":8,"l":1},{"p":[-60,0,-103],"s":[12,12,12],"i":1,"l":1},{"p":[-67,12,-102],"s":[12,12,12],"i":1,"l":1},{"p":[-73,0,-100],"s":[12,12,12],"i":1,"l":1},{"p":[-125,0,-101],"s":[2,2,18],"l":1,"t":2},{"p":[-117,0,-101],"s":[2,2,18],"l":1,"t":2},{"p":[-109,0,-101],"s":[2,2,18],"l":1,"t":2},{"p":[-117,2,-93],"s":[18,1,2],"l":1,"t":2},{"p":[-117,2,-97],"s":[18,1,2],"l":1,"t":2},{"p":[-117,2,-101],"s":[18,1,2],"l":1,"t":2},{"p":[-117,2,-105],"s":[18,1,2],"l":1,"t":2},{"p":[-117,2,-109],"s":[18,1,2],"l":1,"t":2},{"p":[39,0,-98],"s":[6,8,6],"i":2,"l":1},{"p":[-233,0,-106],"s":[6,8,6],"i":2,"l":1},{"p":[220,0,-111],"s":[206,5,2],"l":1,"c":"#706857","e":"#313131","t":11},{"p":[220,5,-111],"s":[206,2,3],"l":1,"c":"#aca596","e":"#313131"},{"p":[-227,0,-111],"s":[164,5,2],"l":1,"c":"#706857","e":"#313131","t":11},{"p":[-227,5,-111],"s":[164,2,3],"l":1,"c":"#aca596","e":"#313131"},{"p":[-687,-10,-192],"s":[487,10,248],"l":1,"c":"#827c6c"},{"p":[-41,5,-67],"s":[334,18,1],"l":1,"pe":1,"t":12},{"p":[-183,5,-67],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-157,5,-67],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-131,5,-67],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-87,5,-67],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-61,5,-67],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-35,5,-67],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-9,5,-67],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[17,5,-67],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-41,0,-67],"s":[334,5,2],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[47,5,-67],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[73,5,-67],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[99,5,-67],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[125,5,-67],"s":[2,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-390,0,-111],"s":[107,5,2],"l":1,"c":"#706857","e":"#313131","t":11},{"p":[-390,5,-111],"s":[107,2,3],"l":1,"c":"#aca596","e":"#313131"},{"p":[25,0,21],"s":[4,7,4],"i":16,"l":1},{"p":[123,0,28],"s":[4,7,4],"i":16,"l":1},{"p":[124,0,214],"s":[4,7,4],"i":16,"l":1},{"p":[-173,3,236],"s":[4,7,4],"i":16,"l":1},{"p":[-215,0,-12],"s":[4,7,4],"i":16,"l":1},{"p":[-269,3,41],"s":[4,7,4],"i":16,"l":1},{"p":[-342,0,94],"s":[12,12,12],"i":1},{"p":[-342,0,106],"s":[12,12,12],"i":1},{"p":[-289,0,72],"s":[12,12,12],"i":1},{"p":[-258,0,141],"s":[12,12,12],"i":1},{"p":[-342,0,135],"s":[12,12,12],"i":1},{"p":[-268,0,137],"s":[4,7,4],"i":16,"l":1},{"p":[-330,1,62],"s":[2,1,1],"l":1,"r":[-0.01,-1.48,-0.02],"c":"#d2cdc3","e":"#313131"},{"p":[-280,0,-67],"s":[140,29,2],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[135,0,289],"s":[14,54,18],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[130,0,262],"s":[3,26,36],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[130,0,239],"s":[4,54,10],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[130,26,262],"s":[4,7,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[130,33,262],"s":[2,14,36],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[130,47,262],"s":[4,7,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[130,33,258],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,33,266],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,33,274],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,33,250],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,0,216],"s":[4,33,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[130,33,170],"s":[2,14,36],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[130,33,228],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,33,212],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,33,220],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,33,204],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,0,193],"s":[4,54,10],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[130,0,170],"s":[4,33,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[130,33,182],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,33,174],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,33,166],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,33,158],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[130,33,216],"s":[2,14,36],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[130,47,216],"s":[4,7,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[130,47,170],"s":[4,7,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[160,0,297],"s":[36,26,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[183,0,289],"s":[10,54,18],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[206,8,297],"s":[36,23,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[160,26,296],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[160,33,295],"s":[36,14,4],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[148,33,296],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[156,33,296],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,296],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[172,33,296],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[206,26,296],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[206,33,295],"s":[36,14,4],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[218,33,296],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[210,33,296],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[202,33,296],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[194,33,296],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[229,0,296],"s":[10,54,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[160,47,296],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[206,47,296],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[232,0,216],"s":[4,54,156],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[160,0,135],"s":[36,26,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[135,0,143],"s":[14,54,18],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[183,0,143],"s":[10,54,18],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[229,0,136],"s":[10,54,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[206,0,135],"s":[36,26,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[160,26,136],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[206,26,136],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[206,47,136],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[160,47,136],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[160,33,137],"s":[36,14,4],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[148,33,136],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[156,33,136],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,136],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[172,33,136],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[206,33,137],"s":[36,14,4],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[194,33,136],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[202,33,136],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[210,33,136],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[218,33,136],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[181,54,216],"s":[112,2,170],"l":1,"r":[-3.14,0,-3.14],"c":"#554242","e":"#3e4448","t":6,"ab":1},{"p":[-145,0,277],"s":[14,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-118,0,272],"s":[3,26,36],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-95,0,272],"s":[4,54,10],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-118,26,272],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-118,33,272],"s":[2,14,36],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-118,47,272],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-114,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-122,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-130,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-106,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-72,0,272],"s":[3,26,36],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-72,26,272],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-26,33,272],"s":[2,14,36],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-84,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-68,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-76,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-60,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-49,0,272],"s":[4,54,10],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-26,26,272],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-26,0,272],"s":[3,26,36],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-38,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-30,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-22,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-14,33,272],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-72,33,272],"s":[2,14,36],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-72,47,272],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-26,47,272],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-153,0,302],"s":[36,26,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-145,0,325],"s":[10,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-153,8,348],"s":[36,23,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-152,26,302],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-151,33,302],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-152,33,290],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-152,33,298],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-152,33,306],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-152,33,314],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-152,26,348],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-151,33,348],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-152,33,360],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-152,33,352],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-152,33,344],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-152,33,336],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-152,0,371],"s":[10,54,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-152,47,302],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-152,47,348],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-72,0,374],"s":[4,54,156],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[9,0,302],"s":[36,26,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[1,0,277],"s":[14,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[1,0,325],"s":[10,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[8,0,371],"s":[10,54,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[9,0,348],"s":[36,26,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[8,26,302],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[8,26,348],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[8,47,348],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[8,47,302],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[7,33,302],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[8,33,290],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[8,33,298],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[8,33,306],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[8,33,314],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[7,33,348],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[8,33,336],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[8,33,344],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[8,33,352],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[8,33,360],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-72,54,323],"s":[112,2,170],"l":1,"r":[0,1.57,0],"c":"#554242","e":"#3e4448","t":6,"ab":1},{"p":[169,0,87],"s":[14,54,18],"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[164,0,60],"s":[3,26,36],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[164,0,37],"s":[4,54,10],"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[164,26,60],"s":[4,7,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[164,33,60],"s":[2,14,36],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[164,47,60],"s":[4,7,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[164,33,56],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,64],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,72],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,48],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,0,14],"s":[3,26,36],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[164,26,14],"s":[4,7,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[164,33,-32],"s":[2,14,36],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[164,33,26],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,10],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,18],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,2],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,0,-9],"s":[4,54,10],"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[164,26,-32],"s":[4,7,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[164,0,-32],"s":[3,26,36],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[164,33,-20],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,-28],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,-36],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,-44],"s":[3,14,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[164,33,14],"s":[2,14,36],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[164,47,14],"s":[4,7,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[164,47,-32],"s":[4,7,36],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[194,0,95],"s":[36,26,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[217,0,87],"s":[10,54,18],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[240,8,95],"s":[36,23,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[194,26,94],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[194,33,93],"s":[36,14,4],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[182,33,94],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[190,33,94],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[198,33,94],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[206,33,94],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[240,26,94],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[240,33,93],"s":[36,14,4],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[252,33,94],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[244,33,94],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[236,33,94],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[228,33,94],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[263,0,94],"s":[10,54,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[194,47,94],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[240,47,94],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[266,0,14],"s":[4,54,156],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[194,0,-67],"s":[36,26,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[169,0,-59],"s":[14,54,18],"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[217,0,-59],"s":[10,54,18],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[263,0,-66],"s":[10,54,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[240,0,-67],"s":[36,26,1],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[194,26,-66],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[240,26,-66],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6},{"p":[240,47,-66],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[194,47,-66],"s":[36,7,4],"l":1,"r":[-3.14,0,-3.14],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[194,33,-65],"s":[36,14,4],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[182,33,-66],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[190,33,-66],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[198,33,-66],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[206,33,-66],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[240,33,-65],"s":[36,14,4],"l":1,"r":[-3.14,0,-3.14],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[228,33,-66],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[236,33,-66],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[244,33,-66],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[252,33,-66],"s":[1,14,3],"l":1,"r":[-3.14,0,-3.14],"c":"#a0998a","e":"#313131","t":6},{"p":[215,54,14],"s":[112,2,170],"l":1,"r":[-3.14,0,-3.14],"c":"#554242","e":"#3e4448","t":6,"ab":1},{"p":[305,-10,168],"s":[42,10,472],"l":1,"c":"#827c6c"},{"p":[324,0,-31],"s":[2,5,162],"l":1,"c":"#706857","e":"#313131","t":11},{"p":[324,5,-33],"s":[2,2,159],"l":1,"c":"#aca596","e":"#313131"},{"p":[266,0,115],"s":[2,29,44],"c":"#a0998a","e":"#313131","t":11},{"p":[249,0,136],"s":[32,29,2],"l":1,"c":"#a0998a","e":"#313131","t":11},{"p":[145,0,-67],"s":[34,20,2],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[171,0,127],"s":[12,12,12],"i":1},{"p":[135,0,47],"s":[12,12,12],"i":8,"l":1},{"p":[99,0,129],"s":[12,12,12],"i":1},{"p":[87,0,129],"s":[12,12,12],"i":1},{"p":[92,12,129],"s":[12,12,12],"i":1},{"p":[-672,-10,159],"s":[548,10,454],"l":1,"c":"#f0f0f0","t":8},{"p":[-346,-10,582],"s":[1200,10,392],"l":1,"c":"#f0f0f0","t":8},{"p":[-289,0,15],"s":[16,24,102],"c":"#c1c2c3","e":"#3e4448","t":6},{"p":[-281,0,-14],"s":[3,20,10],"i":21,"l":1},{"p":[-296,27,-24],"s":[1,17,17],"i":22,"l":1},{"p":[-289,23,15],"s":[18,2,103],"l":1,"r":[0,0,-0.09],"c":"#55504d","e":"#212b31","t":10},{"p":[-314,0,15],"s":[34,46,102],"l":1,"c":"#c1c2c3","e":"#3e4448","t":6},{"p":[-340,0,15],"s":[18,33,102],"l":1,"c":"#c1c2c3","e":"#3e4448","t":6},{"p":[-296,27,54],"s":[1,17,17],"i":22,"l":1},{"p":[-296,27,2],"s":[1,17,17],"i":22,"l":1},{"p":[-296,27,28],"s":[1,17,17],"i":22,"l":1},{"p":[-314,0,66],"s":[27,23,1],"l":1,"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-305,45,15],"s":[18,3,103],"l":1,"r":[0,0,-0.09],"c":"#55504d","e":"#212b31","t":10},{"p":[-323,48,15],"s":[18,3,103],"l":1,"r":[0,0,-3.06],"c":"#55504d","e":"#212b31","t":10},{"p":[-340,34,15],"s":[18,3,103],"l":1,"r":[0,0,-3.06],"c":"#55504d","e":"#212b31","t":10},{"p":[-314,26,67],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[-314,26,-38],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-314,0,-36],"s":[27,23,1],"l":1,"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-342,0,-51],"s":[10,9,18],"l":1,"c":"#ffedde","t":10},{"p":[-342,9,-51],"s":[11,1,20],"l":1,"r":[0,0,-0.09],"c":"#312d2a","t":10},{"p":[-337,3,-51],"s":[1,1,17],"l":1,"c":"#ffedde","t":10,"ab":1},{"p":[-337,6,-51],"s":[1,1,17],"l":1,"c":"#ffedde","t":10,"ab":1},{"p":[-342,6,-60],"s":[11,1,1],"l":1,"c":"#ffedde","t":10,"ab":1},{"p":[-342,3,-60],"s":[11,1,1],"l":1,"c":"#ffedde","t":10,"ab":1},{"p":[-342,3,-42],"s":[11,1,1],"l":1,"c":"#ffedde","t":10,"ab":1},{"p":[-342,6,-42],"s":[11,1,1],"l":1,"c":"#ffedde","t":10,"ab":1},{"p":[-347,3,-51],"s":[1,1,17],"l":1,"c":"#ffedde","t":10,"ab":1},{"p":[-347,6,-51],"s":[1,1,17],"l":1,"c":"#ffedde","t":10,"ab":1},{"p":[-229,0,315],"s":[42,29,2],"c":"#a0998a","e":"#313131","t":11},{"p":[-209,0,277],"s":[2,29,74],"l":1,"c":"#a0998a","e":"#313131","t":11},{"p":[-255,0,-21],"s":[2,2,18],"l":1,"r":[0,0.09,0],"t":2},{"p":[-247,0,-22],"s":[2,2,18],"l":1,"r":[0,0.09,0],"t":2},{"p":[-239,0,-23],"s":[2,2,18],"l":1,"r":[0,0.09,0],"t":2},{"p":[-246,2,-14],"s":[18,1,2],"l":1,"r":[0,0.09,0],"t":2},{"p":[-247,2,-18],"s":[18,1,2],"l":1,"r":[0,0.09,0],"t":2},{"p":[-247,2,-22],"s":[18,1,2],"l":1,"r":[0,0.09,0],"t":2},{"p":[-247,2,-26],"s":[18,1,2],"l":1,"r":[0,0.09,0],"t":2},{"p":[-248,2,-30],"s":[18,1,2],"l":1,"r":[0,0.09,0],"t":2},{"p":[-264,0,-60],"s":[12,12,12],"i":1},{"p":[-218,0,-3],"s":[12,12,12],"i":1},{"p":[-238,0,306],"s":[12,12,12],"i":1},{"p":[-222,0,-59],"s":[12,12,12],"i":8},{"p":[-192,0,58],"s":[4,7,4],"i":16,"l":1},{"p":[-142,0,-64],"s":[4,7,4],"i":16,"l":1},{"p":[-278,0,-1],"s":[6,8,6],"i":2},{"p":[-131,1,-259],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[-131,0,-259],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[-131,5,-259],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[-131,0,-259],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[-321,1,-259],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[-321,0,-259],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[-321,5,-259],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[-321,0,-259],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[-460,1,-301],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[-460,0,-301],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[-460,5,-301],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[-460,0,-301],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[103,1,-259],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[103,0,-259],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[103,5,-259],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[103,0,-259],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[241,0,398],"s":[65,109,54],"i":15,"l":1,"c":"#52452e"},{"p":[7,-15,397],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.7,0],"c":"#52452e"},{"p":[-342,-10,480],"s":[65,109,54],"i":15,"l":1,"r":[0,0.44,0],"c":"#52452e"},{"p":[-376,-2,395],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.13,0],"c":"#52452e"},{"p":[-465,-2,286],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.17,0],"c":"#52452e"},{"p":[-453,-23,157],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.17,0],"c":"#52452e"},{"p":[-584,-2,338],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.87,0],"c":"#52452e"},{"p":[123,-15,463],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.7,0],"c":"#52452e"},{"p":[-516,0,-262],"s":[57,26,25],"i":17,"l":1},{"p":[-516,0,-203],"s":[57,26,25],"i":17,"l":1},{"p":[-516,0,-174],"s":[57,26,25],"i":17,"l":1},{"p":[-517,25,-188],"s":[57,26,25],"i":17,"l":1},{"p":[-619,0,-137],"s":[57,26,25],"i":17,"l":1},{"p":[-614,0,-225],"s":[57,26,25],"i":17,"l":1},{"p":[-471,0,-270],"s":[12,12,12],"i":1,"l":1,"r":[0,-0.18,0]},{"p":[-478,0,-231],"s":[12,12,12],"i":1,"l":1,"r":[0,0.26,0]},{"p":[-474,0,-172],"s":[12,12,12],"i":8,"l":1},{"p":[-253,57,168],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[-253,56,168],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[-253,61,168],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[-253,56,168],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[-253,57,183],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[-253,56,183],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[-253,61,183],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[-253,56,183],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[-253,57,290],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[-253,56,290],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[-253,61,290],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[-253,56,290],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[-309,49,44],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[-309,48,44],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[-309,53,44],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[-309,48,44],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[-147,57,289],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[-147,56,289],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[-147,61,289],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[-147,56,289],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[-135,57,289],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[-135,56,289],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[-135,61,289],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[-135,56,289],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[-5,57,289],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[-5,56,289],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[-5,61,289],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[-5,56,289],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[146,57,282],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[146,56,282],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[146,61,282],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[146,56,282],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[146,57,159],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[146,56,159],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[146,61,159],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[146,56,159],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[146,57,146],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[146,56,146],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[146,61,146],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[146,56,146],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[172,57,84],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[172,56,84],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[172,61,84],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[172,56,84],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[172,57,71],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[172,56,71],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[172,61,71],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[172,56,71],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[172,57,-57],"s":[4,4,4],"l":1,"c":"#483d3d","t":6},{"p":[172,56,-57],"s":[6,1,6],"l":1,"c":"#483d3d","t":6},{"p":[172,61,-57],"s":[6,3,6],"l":1,"r":[0,-0.79,0],"c":"#483d3d","t":6},{"p":[172,56,-57],"s":[8,8,8],"l":1,"v":1,"c":"#483d3d","t":6},{"p":[30,0,-64],"s":[7,6,8],"i":18,"l":1,"c":"#ffc765"},{"p":[-24,0,-43],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.7,-3.14],"c":"#ffffff"},{"p":[45,0,-26],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#ffffff"},{"p":[-14,0,-13],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[20,0,20],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#ffffff"},{"p":[58,0,-24],"s":[7,6,8],"i":18,"l":1,"r":[0,0.61,0],"c":"#ffffff"},{"p":[81,-1,-62],"s":[7,6,8],"i":18,"l":1,"r":[0,0.87,0],"c":"#ffffff"},{"p":[123,0,25],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[77,0,-15],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#ffffff"},{"p":[32,0,22],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[28,0,100],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[87,0,94],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[30,0,128],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[80,0,121],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[123,0,112],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.96,-3.14],"c":"#ffffff"},{"p":[78,0,134],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#ffffff"},{"p":[105,0,135],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[100,0,187],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.61,0],"c":"#ffffff"},{"p":[109,0,177],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[102,0,172],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[58,0,204],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[82,0,201],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[39,0,180],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[4,0,193],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#ffffff"},{"p":[-8,0,210],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.61,0],"c":"#ffffff"},{"p":[-29,0,154],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[29,0,154],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#ffffff"},{"p":[-53,0,155],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-39,0,184],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#ffffff"},{"p":[-12,0,185],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-19,0,215],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-19,0,234],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[33,0,234],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[123,0,235],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.61,0],"c":"#ffffff"},{"p":[-53,0,127],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-50,0,68],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-29,0,101],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-31,0,141],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.79,0],"c":"#ffffff"},{"p":[-30,0,48],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-29,0,22],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.22,0],"c":"#ffffff"},{"p":[-21,0,-12],"s":[7,6,8],"i":18,"l":1,"r":[0,0.44,0],"c":"#ffffff"},{"p":[-75,0,-13],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-112,0,156],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#ffffff"},{"p":[-90,0,211],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-73,0,209],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#ffffff"},{"p":[-151,0,226],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-154,0,163],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-173,0,163],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-164,0,222],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#ffffff"},{"p":[-205,0,140],"s":[7,6,8],"i":18,"l":1,"r":[0,1.05,0],"c":"#ffffff"},{"p":[-202,0,179],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-191,0,181],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-203,0,89],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.61,0],"c":"#ffffff"},{"p":[-170,0,113],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#ffffff"},{"p":[-114,0,127],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-154,0,140],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-150,0,59],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-112,0,76],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-95,0,99],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.79,0],"c":"#ffffff"},{"p":[-54,0,102],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-12,0,78],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-76,0,-27],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-89,0,-62],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.52,0],"c":"#ffffff"},{"p":[-116,0,-65],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-81,0,-36],"s":[7,6,8],"i":18,"l":1,"r":[0,0.7,0],"c":"#ffffff"},{"p":[-93,0,20],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.13,-3.14],"c":"#ffffff"},{"p":[-112,0,23],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-142,0,-17],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-181,0,-33],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-145,0,-62],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-204,0,-7],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.61,0],"c":"#ffffff"},{"p":[-203,0,-59],"s":[7,6,8],"i":18,"l":1,"r":[0,0.61,0],"c":"#ffffff"},{"p":[-187,0,-46],"s":[7,6,8],"i":18,"l":1,"r":[0,0.44,0],"c":"#ffffff"},{"p":[-196,0,-39],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.44,0],"c":"#ffffff"},{"p":[-204,0,45],"s":[7,6,8],"i":18,"l":1,"r":[0,0.79,0],"c":"#ffffff"},{"p":[-114,0,50],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-186,0,55],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-192,0,50],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-205,0,10],"s":[7,6,8],"i":18,"l":1,"r":[0,0.96,0],"c":"#ffffff"},{"p":[73,0,207],"s":[12,12,12],"i":1},{"p":[-300,0,392],"s":[14,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-273,0,387],"s":[3,26,36],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-250,0,387],"s":[4,54,10],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-273,26,387],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-273,33,387],"s":[2,14,36],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-273,47,387],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-269,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-277,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-285,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-261,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-227,0,387],"s":[3,26,36],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-227,26,387],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-181,33,387],"s":[2,14,36],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-239,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-223,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-231,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-215,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-204,0,387],"s":[4,54,10],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-181,26,387],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-181,0,387],"s":[3,26,36],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-193,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-185,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-177,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-169,33,387],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-227,33,387],"s":[2,14,36],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-227,47,387],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-181,47,387],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-308,0,417],"s":[36,26,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-300,0,440],"s":[10,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-308,8,463],"s":[36,23,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-307,26,417],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-306,33,417],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-307,33,405],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-307,33,413],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-307,33,421],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-307,33,429],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-307,26,463],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-306,33,463],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-307,33,475],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-307,33,467],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-307,33,459],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-307,33,451],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-307,0,486],"s":[10,54,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-307,47,417],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-307,47,463],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-227,0,489],"s":[4,54,156],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-146,0,417],"s":[36,26,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-154,0,392],"s":[14,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-154,0,440],"s":[10,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-147,0,486],"s":[10,54,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-146,0,463],"s":[36,26,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[-147,26,417],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-147,26,463],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[-147,47,463],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-147,47,417],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[-148,33,417],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-147,33,405],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-147,33,413],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-147,33,421],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-147,33,429],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-148,33,463],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[-147,33,451],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-147,33,459],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-147,33,467],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-147,33,475],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[-227,54,438],"s":[112,2,170],"l":1,"r":[0,1.57,0],"c":"#554242","e":"#3e4448","t":6,"ab":1},{"p":[127,20,239],"s":[2,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-41,20,239],"s":[335,18,1],"l":1,"pe":1,"t":12},{"p":[101,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[75,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[49,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[23,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-3,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-29,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-55,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-81,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-107,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-133,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-159,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-185,20,239],"s":[1,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-209,20,239],"s":[2,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[53,0,329],"s":[14,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[80,0,324],"s":[3,26,36],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[103,0,324],"s":[4,54,10],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[80,26,324],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[80,33,324],"s":[2,14,36],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[80,47,324],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[84,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[76,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[68,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[92,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[126,0,324],"s":[3,26,36],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[126,26,324],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[172,33,324],"s":[2,14,36],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[114,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[130,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[122,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[138,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[149,0,324],"s":[4,54,10],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[172,26,324],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[172,0,324],"s":[3,26,36],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[160,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[168,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[176,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[184,33,324],"s":[3,14,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[126,33,324],"s":[2,14,36],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[126,47,324],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[172,47,324],"s":[4,7,36],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[45,0,354],"s":[36,26,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[53,0,377],"s":[10,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[45,8,400],"s":[36,23,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[46,26,354],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[47,33,354],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[46,33,342],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[46,33,350],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[46,33,358],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[46,33,366],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[46,26,400],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[47,33,400],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[46,33,412],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[46,33,404],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[46,33,396],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[46,33,388],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[46,0,423],"s":[10,54,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[46,47,354],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[46,47,400],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[126,0,426],"s":[4,54,156],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[207,0,354],"s":[36,26,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[199,0,329],"s":[14,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[199,0,377],"s":[10,54,18],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[206,0,423],"s":[10,54,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[207,0,400],"s":[36,26,1],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#1e1e1e","t":10},{"p":[206,26,354],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[206,26,400],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6},{"p":[206,47,400],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[206,47,354],"s":[36,7,4],"l":1,"r":[0,1.57,0],"c":"#ffffff","e":"#3e4448","t":6,"ab":1},{"p":[205,33,354],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[206,33,342],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[206,33,350],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[206,33,358],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[206,33,366],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[205,33,400],"s":[36,14,4],"l":1,"r":[0,1.57,0],"c":"#1e1a14","e":"#1b1919","o":0.9,"t":10},{"p":[206,33,388],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[206,33,396],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[206,33,404],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[206,33,412],"s":[1,14,3],"l":1,"r":[0,1.57,0],"c":"#a0998a","e":"#313131","t":6},{"p":[126,54,375],"s":[112,2,170],"l":1,"r":[0,1.57,0],"c":"#554242","e":"#3e4448","t":6,"ab":1},{"p":[22,-15,437],"s":[65,109,54],"i":15,"l":1,"r":[0,0.17,0],"c":"#52452e"},{"p":[14,0,415],"s":[51,15,20],"i":7,"l":1},{"p":[-41,0,500],"s":[334,29,2],"l":1,"c":"#a0998a","e":"#313131","t":11},{"p":[268,-10,319],"s":[32,10,158],"l":1,"c":"#827c6c"},{"p":[-542,0,-96],"s":[57,26,25],"i":17,"l":1},{"p":[-623,0,-286],"s":[57,26,25],"i":17,"l":1},{"p":[-433,-23,38],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.17,0],"c":"#52452e"},{"p":[-501,-23,-23],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.17,0],"c":"#52452e"},{"p":[-520,-23,87],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.17,0],"c":"#52452e"},{"p":[-540,-23,201],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.17,0],"c":"#52452e"},{"p":[-553,-23,275],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.17,0],"c":"#52452e"},{"p":[-443,-23,460],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.17,0],"c":"#52452e"},{"p":[-110,-23,517],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.17,0],"c":"#52452e"},{"p":[7,-23,537],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.17,0],"c":"#52452e"},{"p":[127,-23,531],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.17,0],"c":"#52452e"},{"p":[68,0,-94],"s":[51,15,20],"i":7,"l":1},{"p":[-209,5,87],"s":[2,19,2],"l":1,"pe":1,"c":"#a0998a","e":"#313131","t":6},{"p":[-142,0,-22],"s":[6,8,6],"i":2},{"p":[32,0,27],"s":[6,8,6],"i":2},{"p":[-185,0,187],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-83,-1,141],"s":[57,26,25],"i":17},{"p":[-151,0,-8],"s":[12,12,12],"i":1},{"p":[-151,0,-20],"s":[12,12,12],"i":1},{"p":[-158,0,-2],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-44,-1,-27],"s":[57,26,25],"i":17},{"p":[-83,25,115],"s":[57,26,25],"i":19,"l":1,"h":500},{"p":[3,0,154],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#ffffff"},{"p":[-2,0,202],"s":[20,2,18],"v":1,"t":2},{"p":[108,0,177],"s":[18,2,18],"v":1,"t":2},{"p":[-191,0,-43],"s":[18,2,18],"v":1,"t":2},{"p":[88,0,-24],"s":[18,9,18],"pe":1,"v":1,"t":2},{"p":[79,0,-36],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#ffffff"},{"p":[123,0,-8],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#ffffff"},{"p":[41,0,-31],"s":[12,12,12],"i":8},{"p":[206,-10,86],"s":[156,10,308],"c":"#969696","e":"#373737","t":6},{"p":[135,0,-48],"s":[12,12,12],"i":8},{"p":[35,0,112],"s":[12,12,12],"i":1},{"p":[86,0,-49],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#ffffff"},{"p":[65,0,43],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#ffffff"},{"p":[77,0,69],"s":[16,8,48],"v":1},{"p":[77,8,74],"s":[16,7,24],"pe":1,"v":1},{"p":[-60,-1,225],"s":[57,26,25],"i":19,"l":1,"h":500},{"p":[26,1,62],"s":[4,23,23],"pe":1,"c":"#662626","t":5},{"p":[26,1,54],"s":[5,23,1],"l":1,"pe":1,"c":"#282828","t":5},{"p":[26,1,62],"s":[5,23,1],"l":1,"pe":1,"c":"#282828","t":5},{"p":[32,0,48],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#ffffff"},{"p":[32,0,53],"s":[6,8,6],"i":2},{"p":[32,0,71],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#ffffff"},{"p":[-83,25,103],"s":[57,25,1],"pe":1,"v":1},{"p":[-83,50,115],"s":[57,1,25],"pe":1,"v":1},{"p":[-60,-1,213],"s":[57,26,1],"pe":1,"v":1},{"p":[-83,25,115],"s":[57,2,25],"pe":1,"v":1},{"p":[-115,0,31],"s":[3,1,5],"l":1,"c":"#646464","t":5},{"p":[-148,0,65],"s":[3,1,5],"l":1,"c":"#646464","t":5},{"p":[-115,0,119],"s":[3,1,5],"l":1,"c":"#646464","t":5},{"p":[-185,0,179],"s":[3,1,6],"l":1,"c":"#646464","t":5},{"p":[-74,0,191],"s":[3,1,6],"l":1,"c":"#646464","t":5},{"p":[-31,0,148],"s":[3,1,6],"l":1,"c":"#646464","t":5},{"p":[78,0,128],"s":[3,2,6],"l":1,"c":"#646464","t":5},{"p":[76,0,-32],"s":[3,2,6],"l":1,"c":"#646464","t":5},{"p":[74,0,-63],"s":[6,2,4],"l":1,"c":"#646464","t":5},{"p":[14,0,20],"s":[6,2,4],"l":1,"c":"#646464","t":5},{"p":[90,0,87],"s":[6,2,4],"l":1,"c":"#646464","t":5},{"p":[-31,0,41],"s":[3,1,6],"l":1,"c":"#646464","t":5},{"p":[-49,0,-12],"s":[7,6,8],"i":18,"l":1,"r":[0,0.27,0],"c":"#ffffff"},{"p":[-179,0,187],"s":[5,1,4],"l":1,"c":"#646464","t":5},{"p":[-204,0,219],"s":[7,6,8],"i":18,"l":1,"r":[0,0.52,0],"c":"#ffffff"},{"p":[-118,0,235],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#ffffff"},{"p":[-84,0,156],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#ffffff"},{"p":[-120,0,188],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[-120,0,175],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.17,0],"c":"#ffffff"},{"p":[-158,0,222],"s":[5,1,4],"l":1,"c":"#646464","t":5},{"p":[-127,0,190],"s":[5,1,4],"l":1,"c":"#646464","t":5},{"p":[-127,0,181],"s":[12,12,12],"i":1},{"p":[123,0,108],"s":[4,7,4],"i":16,"l":1},{"p":[50,0,180],"s":[4,7,4],"i":16,"l":1},{"p":[-180,0,182],"s":[4,7,4],"i":16,"l":1},{"p":[-157,0,-27],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[55,0,-39],"s":[6,1,3],"l":1,"c":"#646464","t":5},{"p":[48,0,-39],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.87,0],"c":"#ffc765"},{"p":[-178,0,212],"s":[59,50,51],"i":14},{"p":[-167,0,-23],"s":[79,50,81],"i":14},{"p":[74,0,204],"s":[101,50,66],"i":14},{"p":[38,0,27],"s":[6,8,6],"i":2},{"p":[111,0,31],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#ffffff"},{"p":[81,0,36],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#ffffff"},{"p":[98,0,10],"s":[7,6,8],"i":18,"l":1,"r":[0,0.17,0],"c":"#ffffff"},{"p":[88,0,-25],"s":[18,9,18],"l":1,"v":1},{"p":[88,0,-11],"s":[18,2,2],"l":1,"r":[-0.17,0,0],"t":2},{"p":[88,8,-13],"s":[18,2,2],"l":1,"r":[-0.17,0,0],"t":2},{"p":[88,16,-14],"s":[18,2,2],"l":1,"r":[-0.17,0,0],"t":2},{"p":[96,0,-12],"s":[2,18,1],"l":1,"r":[-0.17,0,0],"t":2},{"p":[125,16,-57],"s":[2,2,14],"l":1,"r":[0,0,-0.09],"t":2},{"p":[124,9,-57],"s":[2,2,14],"l":1,"r":[0,0,-0.09],"t":2},{"p":[123,0,-57],"s":[2,2,14],"l":1,"r":[0,0,-0.09],"t":2},{"p":[125,9,-51],"s":[18,1,2],"l":1,"r":[0,0,-1.66],"t":2},{"p":[125,9,-55],"s":[18,1,2],"l":1,"r":[0,0,-1.66],"t":2},{"p":[125,9,-59],"s":[18,1,2],"l":1,"r":[0,0,-1.66],"t":2},{"p":[125,9,-63],"s":[18,1,2],"l":1,"r":[0,0,-1.66],"t":2},{"p":[125,0,-57],"s":[3,18,14],"l":1,"v":1},{"p":[127,0,-48],"s":[2,20,40],"c":"#a0998a","e":"#313131","t":11,"bo":1},{"p":[121,-1,-49],"s":[7,6,8],"i":18,"l":1,"c":"#ffffff"},{"p":[93,0,-25],"s":[64,50,81],"i":14},{"p":[92,0,-12],"s":[2,18,1],"l":1,"r":[-0.17,0,0],"t":2},{"p":[88,0,-12],"s":[2,18,1],"l":1,"r":[-0.17,0,0],"t":2},{"p":[84,0,-12],"s":[2,18,1],"l":1,"r":[-0.17,0,0],"t":2},{"p":[90,0,-13],"s":[2,18,5],"pe":1,"v":1,"t":2},{"p":[80,0,-12],"s":[2,18,1],"l":1,"r":[-0.17,0,0],"t":2},{"p":[92,0,-13],"s":[2,18,5],"v":1,"t":2},{"p":[86,0,-13],"s":[2,18,5],"pe":1,"v":1,"t":2},{"p":[82,0,-13],"s":[2,18,5],"pe":1,"v":1,"t":2},{"p":[94,0,-13],"s":[2,18,5],"pe":1,"v":1,"t":2},{"p":[96,0,-13],"s":[2,18,5],"v":1,"t":2},{"p":[88,0,-13],"s":[2,18,5],"v":1,"t":2},{"p":[84,0,-13],"s":[2,18,5],"v":1,"t":2},{"p":[80,0,-13],"s":[2,18,5],"v":1,"t":2},{"p":[0,24,36],"s":[54,24,23],"l":1,"t":5},{"p":[-44,-1,-27],"s":[54,24,23],"l":1,"t":5},{"p":[0,0,36],"s":[54,24,23],"l":1,"t":5},{"p":[-83,-1,36],"s":[54,24,23],"l":1,"t":5},{"p":[-83,-1,62],"s":[54,24,23],"l":1,"t":5},{"p":[-83,0,115],"s":[54,24,23],"l":1,"t":5},{"p":[-83,0,141],"s":[54,24,23],"l":1,"t":5},{"p":[-42,-1,199],"s":[54,24,23],"l":1,"t":5},{"p":[-83,24,141],"s":[54,24,23],"l":1,"t":5},{"p":[0,-1,140],"s":[54,24,23],"l":1,"t":5},{"p":[0,-1,114],"s":[54,24,23],"l":1,"t":5},{"p":[0,26,62],"s":[54,23,23],"l":1,"t":5},{"p":[-179,-1,73],"s":[54,24,23],"l":1,"t":5},{"p":[88,12,-40],"s":[12,12,12],"i":8},{"p":[-74,76,276],"s":[74,0,30],"i":11,"l":1,"r":[1.57,0,3.14],"sad":1},{"p":[-346,33,107],"s":[67,0,28],"i":11,"l":1,"r":[1.57,0,1.57],"sad":1},{"p":[-74,59,277],"s":[1,34,79],"l":1,"r":[0,1.57,0],"c":"#b4b2b0","t":6,"ab":1},{"p":[-43,56,280],"s":[4,40,5],"l":1,"r":[0,1.57,0],"c":"#b4b2b0","t":6,"ab":1},{"p":[-108,56,279],"s":[3,39,5],"l":1,"r":[0,1.57,0],"c":"#b4b2b0","t":6,"ab":1},{"p":[-347,17,107],"s":[71,32,1],"l":1,"r":[0,1.57,0],"c":"#b4b2b0","t":6,"ab":1}]};
    
    /***/ }),
    
    /***/ "./maps/subzero.json":
    /*!***************************!*\
      !*** ./maps/subzero.json ***!
      \***************************/
    /*! exports provided: name, ambient, light, sky, fog, fogD, camPos, spawns, ambO, ambS, objects, default */
    /***/ (function(module) {
    
    module.exports = {"name":"Subzero","ambient":8555670,"light":16120058,"sky":13883868,"fog":13030361,"fogD":601.943118216585,"camPos":[-13,93,-6],"spawns":[[-41,67,-58,0,0,0],[-187,54,-238,0,2,0],[-299,54,2,0,3,0],[131,67,-203,0,3,0],[187,67,-336,0,1,0],[350,67,-287,0,1,0],[319,86,-59,0,0,0],[178,84,-49,0,0,0],[140,84,-13,0,1,0],[-162,67,63,0,0,0]],"ambO":1,"ambS":5,"objects":[{"p":[-1,64,0],"s":[140,2,142],"l":1,"t":5},{"p":[-100,64,50],"s":[58,2,42],"l":1,"t":5},{"p":[-149,53,8],"s":[40,13,126],"l":1,"t":5},{"p":[-139,51,-111],"s":[172,2,130],"l":1,"t":5},{"p":[-277,51,-77],"s":[104,2,202],"l":1,"t":5},{"p":[5,64,-123],"s":[60,2,104],"l":1,"t":5},{"p":[-54,51,-143],"s":[58,15,42],"l":1,"t":5},{"p":[240,65,-325],"s":[132,2,38],"c":5723991,"t":11},{"p":[213,64,-207],"s":[40,2,63],"l":1,"t":5},{"p":[213,64,-112],"s":[39,20,37],"l":1,"t":5},{"p":[-124,51,-285],"s":[203,2,50],"l":1,"t":5},{"p":[-198,50,-218],"s":[38,2,84],"c":7566195,"t":1},{"p":[343,64,-262],"s":[77,2,72],"l":1,"t":5},{"p":[343,64,-122],"s":[82,2,217],"l":1,"t":5},{"p":[327,64,-11],"s":[140,20,129],"l":1,"t":5},{"p":[-326,11,-77],"s":[9,47,632],"c":10983566,"t":11},{"p":[-2731,11,-77],"s":[5362,31,11525],"l":1,"c":5203837,"t":5},{"p":[-290,51,-217],"s":[78,56,80],"c":9342330,"t":10,"bo":1},{"p":[-252,51,-178],"s":[4,56,4],"c":11513775,"t":2,"bo":1},{"p":[-328,56,-178],"s":[4,51,4],"c":11513775,"t":2,"bo":1},{"p":[-252,51,-256],"s":[4,56,4],"c":11513775,"t":2},{"p":[-290,76,-178],"s":[72,4,4],"c":11513775,"t":2},{"p":[-290,103,-178],"s":[72,4,4],"c":11513775,"t":2,"bo":1},{"p":[-290,51,-178],"s":[4,70,5],"c":11513775,"t":2,"bo":1},{"p":[-252,76,-217],"s":[4,4,74],"c":11513775,"t":2},{"p":[-252,103,-217],"s":[4,4,74],"c":11513775,"t":2},{"p":[-268,113,-217],"s":[45,2,84],"l":1,"r":[0,0,-0.35],"c":7039851,"t":2},{"p":[-312,113,-217],"s":[45,2,84],"l":1,"r":[0,0,0.35],"c":7039851,"t":2},{"p":[-290,107,-217],"s":[77,4,80],"c":9342330,"t":10},{"p":[-290,120,-217],"s":[5,5,89],"c":11513775,"t":2,"bo":1},{"p":[-267,115,-217],"s":[45,2,84],"l":1,"r":[0,0,-0.35],"t":5},{"p":[-313,115,-217],"s":[45,2,84],"l":1,"r":[0,0,0.35],"t":5},{"p":[-290,125,-217],"s":[5,2,89],"t":5},{"p":[-276,51,-178],"s":[2,20,4],"c":11513775,"t":2,"bo":1},{"p":[-264,51,-178],"s":[2,20,4],"c":11513775,"t":2,"bo":1},{"p":[-270,71,-178],"s":[14,2,4],"c":11513775,"t":2,"bo":1},{"p":[-290,111,-217],"s":[55,4,80],"c":9342330,"t":10},{"p":[-290,115,-217],"s":[34,4,80],"c":9342330,"t":10},{"p":[-290,119,-217],"s":[13,2,80],"c":9342330,"t":10},{"p":[-319,56,-198],"s":[9,72,20],"c":8355711,"t":11},{"p":[-234,51,-212],"s":[34,40,96],"c":8882055,"t":11,"bo":1},{"p":[-151,51,-212],"s":[60,40,96],"c":8355711,"t":11,"bo":1},{"p":[-186,90,-212],"s":[128,31,94],"c":8215901,"t":10,"bo":1},{"p":[-249,91,-166],"s":[4,30,4],"c":8684676,"t":2,"bo":1},{"p":[-207,91,-166],"s":[4,26,4],"c":8684676,"t":2,"bo":1},{"p":[-165,91,-166],"s":[4,26,4],"c":8684676,"t":2,"bo":1},{"p":[-123,91,-166],"s":[4,30,4],"c":8684676,"t":2},{"p":[-217,53,-164],"s":[3,31,3],"c":8684676,"t":2,"bo":1},{"p":[-181,53,-164],"s":[3,31,3],"c":8684676,"t":2,"bo":1},{"p":[-199,81,-164],"s":[33,3,3],"c":8684676,"t":2,"bo":1},{"p":[-221,131,-212],"s":[70,3,100],"l":1,"r":[0,0,0.35],"c":7894903,"t":2},{"p":[-186,141,-212],"s":[7,7,108],"c":8684676,"t":2},{"p":[-150,131,-212],"s":[73,3,100],"l":1,"r":[0,0,-0.35],"c":7894903,"t":2},{"p":[-149,134,-212],"s":[73,3,100],"l":1,"r":[0,0,-0.35],"t":5},{"p":[-186,148,-212],"s":[7,3,108],"t":5},{"p":[-165,121,-166],"s":[4,16,4],"c":8684676,"t":2,"bo":1},{"p":[-207,121,-166],"s":[4,17,4],"c":8684676,"t":2,"bo":1},{"p":[-186,121,-212],"s":[125,6,94],"c":8215901,"t":10},{"p":[-186,127,-212],"s":[93,6,94],"c":8215901,"t":10},{"p":[-186,133,-212],"s":[60,6,94],"c":8215901,"t":10},{"p":[-186,139,-212],"s":[32,4,94],"c":8215901,"t":10},{"p":[-135,76,-236],"s":[9,72,20],"c":5723991,"t":11},{"p":[-258,51,-286],"s":[66,58,56],"c":8029580,"t":10,"bo":1},{"p":[-123,91,-258],"s":[4,30,4],"c":8684676,"t":2,"bo":1},{"p":[-249,91,-258],"s":[4,30,4],"c":8684676,"t":2},{"p":[-207,91,-258],"s":[4,26,4],"c":8684676,"t":2,"bo":1},{"p":[-165,91,-258],"s":[4,26,4],"c":8684676,"t":2,"bo":1},{"p":[-207,121,-258],"s":[4,17,4],"c":8684676,"t":2},{"p":[-165,121,-258],"s":[4,17,4],"c":8684676,"t":2},{"p":[-226,53,-261],"s":[4,56,4],"c":11513775,"t":2,"bo":1},{"p":[-226,77,-288],"s":[4,4,50],"c":11513775,"t":2},{"p":[-226,105,-288],"s":[4,4,50],"c":11513775,"t":2,"bo":1},{"p":[-257,118,-287],"s":[72,4,4],"c":11513775,"t":2,"bo":1},{"p":[-257,113,-303],"s":[68,2,32],"l":1,"r":[-0.35,0,0],"c":5723991,"t":2},{"p":[-257,112,-267],"s":[68,2,40],"l":1,"r":[0.35,0,0],"c":5723991,"t":2},{"p":[-258,109,-287],"s":[66,3,56],"c":8029580,"t":10},{"p":[-257,115,-303],"s":[68,2,33],"l":1,"r":[-0.35,0,0],"t":5},{"p":[-257,122,-287],"s":[72,2,4],"t":5},{"p":[-258,112,-286],"s":[66,4,38],"c":8029580,"t":10},{"p":[-258,116,-287],"s":[66,3,21],"c":8029580,"t":10},{"p":[-257,114,-266],"s":[68,2,41],"l":1,"r":[0.35,0,0],"t":5},{"p":[-225,51,-271],"s":[2,20,2],"c":11513775,"t":2,"bo":1},{"p":[-225,51,-283],"s":[2,20,2],"c":11513775,"t":2,"bo":1},{"p":[-225,71,-277],"s":[2,2,14],"c":11513775,"t":2,"bo":1},{"p":[-193,51,-329],"s":[66,38,56],"c":7110518,"t":10,"bo":1},{"p":[-223,53,-302],"s":[4,42,4],"c":9013641,"t":2,"bo":1},{"p":[-161,53,-302],"s":[4,42,4],"c":9013641,"t":2,"bo":1},{"p":[-192,87,-302],"s":[58,8,4],"c":9013641,"t":2,"bo":1},{"p":[-226,53,-315],"s":[4,56,4],"c":11513775,"t":2,"bo":1},{"p":[-192,96,-327],"s":[68,2,57],"l":1,"r":[0.17,0,0],"c":5592405,"t":2},{"p":[-192,98,-327],"s":[68,2,57],"l":1,"r":[0.17,0,0],"t":5},{"p":[-193,89,-329],"s":[66,6,56],"c":7110518,"t":10},{"p":[-193,92,-339],"s":[66,3,36],"c":7110518,"t":5},{"p":[-193,95,-347],"s":[66,3,20],"c":7110518,"t":10},{"p":[-186,51,-302],"s":[2,20,4],"c":11513775,"t":2,"bo":1},{"p":[-174,51,-302],"s":[2,20,4],"c":11513775,"t":2,"bo":1},{"p":[-180,71,-302],"s":[14,2,4],"c":11513775,"t":2,"bo":1},{"p":[-216,51,-254],"s":[19,2,12],"l":1,"t":5},{"p":[-195,51,-257],"s":[12,2,6],"l":1,"t":5},{"p":[-185,51,-254],"s":[8,2,12],"l":1,"t":5},{"p":[-211,51,-183],"s":[12,2,14],"l":1,"t":5},{"p":[-201,51,-179],"s":[8,2,6],"l":1,"t":5},{"p":[-183,51,-182],"s":[8,2,12],"l":1,"t":5},{"p":[-197,51,-62],"s":[56,57,80],"c":8878432,"t":10,"bo":1},{"p":[-224,51,-101],"s":[4,58,4],"c":11513775,"t":2,"bo":1},{"p":[-224,51,-23],"s":[4,58,4],"c":11513775,"t":2,"bo":1},{"p":[-170,51,-23],"s":[4,58,4],"c":11513775,"t":2,"bo":1},{"p":[-170,51,-101],"s":[4,58,4],"c":11513775,"t":2,"bo":1},{"p":[-197,77,-101],"s":[50,4,4],"c":11513775,"t":2},{"p":[-197,105,-101],"s":[50,4,4],"c":11513775,"t":2,"bo":1},{"p":[-197,105,-62],"s":[58,4,74],"c":11513775,"t":2,"bo":1},{"p":[-197,121,-62],"s":[65,6,6],"c":11513775,"t":2,"bo":1},{"p":[-197,116,-84],"s":[63,2,43],"l":1,"r":[-0.35,0,0],"c":6710886,"t":2},{"p":[-197,116,-40],"s":[63,2,44],"l":1,"r":[0.35,0,0],"c":6710886,"t":2},{"p":[-197,118,-39],"s":[63,2,44],"l":1,"r":[0.35,0,0],"t":5},{"p":[-197,118,-85],"s":[63,2,43],"l":1,"r":[-0.35,0,0],"t":5},{"p":[-197,127,-62],"s":[65,2,6],"t":5},{"p":[-197,109,-62],"s":[56,3,82],"c":8878432,"t":10},{"p":[-186,117,-212],"s":[122,4,96],"c":8684676,"t":2,"bo":1},{"p":[-197,112,-62],"s":[56,3,66],"c":8878432,"t":10},{"p":[-197,115,-62],"s":[56,4,50],"c":8878432,"t":10},{"p":[-197,119,-62],"s":[56,4,28],"c":8878432,"t":10},{"p":[-224,51,-62],"s":[5,71,4],"c":11513775,"t":2,"bo":1},{"p":[-170,51,-62],"s":[5,71,4],"c":11513775,"t":2,"bo":1},{"p":[-176,92,-90],"s":[7,39,12],"c":6250335,"t":11},{"p":[-225,51,-36],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[-225,51,-48],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[-225,71,-42],"s":[2,2,10],"c":11513775,"t":2,"bo":1},{"p":[-197,51,14],"s":[74,72,70],"c":6320224,"t":10,"bo":1},{"p":[-233,51,-20],"s":[4,73,4],"c":7895160,"t":2,"bo":1},{"p":[-233,51,48],"s":[4,73,4],"c":7895160,"t":2},{"p":[-161,51,48],"s":[4,73,4],"c":7895160,"t":2,"bo":1},{"p":[-161,51,-20],"s":[4,73,4],"c":7895160,"t":2,"bo":1},{"p":[-197,53,14],"s":[77,12,73],"c":6250335,"t":11},{"p":[-160,91,14],"s":[2,4,64],"l":1,"c":7500402,"t":2},{"p":[-197,120,14],"s":[76,4,64],"c":7500402,"t":2,"bo":1},{"p":[-160,66,-9],"s":[2,20,2],"c":11513775,"t":2,"bo":1},{"p":[-160,66,3],"s":[2,20,2],"c":11513775,"t":2,"bo":1},{"p":[-160,84,-3],"s":[2,2,10],"c":11513775,"t":2,"bo":1},{"p":[-197,120,-20],"s":[68,4,4],"c":7500402,"t":2,"bo":1},{"p":[-197,120,48],"s":[68,4,4],"l":1,"c":7500402,"t":2},{"p":[-197,136,14],"s":[5,5,80],"c":9868950,"t":2},{"p":[-219,130,14],"s":[42,2,77],"l":1,"r":[0,0,0.35],"c":5395026,"t":2},{"p":[-176,130,14],"s":[41,2,77],"l":1,"r":[0,0,-0.35],"c":5395026,"t":2},{"p":[-197,124,14],"s":[74,4,70],"c":6320224,"t":10},{"p":[-176,132,14],"s":[43,2,77],"l":1,"r":[0,0,-0.35],"t":5},{"p":[-219,132,14],"s":[44,2,77],"l":1,"r":[0,0,0.35],"t":5},{"p":[-197,141,14],"s":[5,2,80],"t":5},{"p":[-197,128,14],"s":[53,4,70],"c":6320224,"t":10},{"p":[-197,136,14],"s":[11,3,70],"c":6320224,"t":10},{"p":[-197,132,14],"s":[31,4,70],"c":6320224,"t":10},{"p":[-197,91,-20],"s":[68,4,4],"c":7500402,"t":2},{"p":[-281,51,64],"s":[96,58,80],"c":7558742,"t":10,"bo":1},{"p":[-282,78,25],"s":[88,4,4],"c":9013641,"t":2},{"p":[-282,120,64],"s":[102,7,7],"l":1,"c":11513775,"t":2},{"p":[-282,116,43],"s":[100,2,48],"l":1,"r":[-0.35,0,0],"c":5723991,"t":2},{"p":[-282,115,87],"s":[100,2,49],"l":1,"r":[0.35,0,0],"c":5723991,"t":2},{"p":[-282,118,42],"s":[100,2,48],"l":1,"r":[-0.35,0,0],"t":5},{"p":[-282,117,88],"s":[100,2,49],"l":1,"r":[0.35,0,0],"t":5},{"p":[-282,127,64],"s":[102,2,7],"l":1,"t":5},{"p":[-281,109,64],"s":[96,4,80],"c":6903125,"t":10},{"p":[-281,113,64],"s":[96,4,58],"c":6903125,"t":10},{"p":[-281,117,64],"s":[96,4,35],"c":6903125,"t":10},{"p":[-281,121,64],"s":[96,3,15],"c":6903125,"t":10},{"p":[-264,51,25],"s":[2,22,4],"c":9013384,"t":2,"bo":1},{"p":[-252,51,25],"s":[2,22,4],"c":9013641,"t":2,"bo":1},{"p":[-258,71,25],"s":[10,2,4],"c":9539985,"t":2,"bo":1},{"p":[-326,58,-77],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,-61],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,-93],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,-109],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,-126],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,-143],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,-160],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,-177],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,-44],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,-27],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,-10],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,7],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,58,24],"s":[5,7,5],"c":8223868,"t":11},{"p":[-326,61,-79],"s":[2,2,205],"c":13619151,"t":2,"bo":1},{"p":[-120,51,-159],"s":[4,55,4],"c":9671571,"t":2,"bo":1},{"p":[-24,51,-159],"s":[4,55,4],"c":9013641,"t":2,"bo":1},{"p":[-24,51,-265],"s":[4,55,4],"c":7895160,"t":2,"bo":1},{"p":[-120,51,-265],"s":[4,55,4],"c":8026746,"t":2,"bo":1},{"p":[-72,51,-265],"s":[4,72,5],"c":9539985,"t":2,"bo":1},{"p":[-72,51,-159],"s":[4,72,5],"c":9211020,"t":2,"bo":1},{"p":[-100,114,-212],"s":[56,3,114],"l":1,"r":[0,0,0.35],"c":5395026,"t":2},{"p":[-72,122,-212],"s":[6,6,119],"c":11513775,"t":2,"bo":1},{"p":[-45,114,-212],"s":[56,3,114],"l":1,"r":[0,0,-0.35],"c":5395026,"t":2},{"p":[-72,78,-265],"s":[92,4,4],"c":7697781,"t":2},{"p":[-24,78,-212],"s":[4,4,102],"c":8355711,"t":2},{"p":[-72,78,-159],"s":[92,4,4],"c":9211020,"t":2},{"p":[-120,78,-212],"s":[4,4,102],"l":1,"c":8553090,"t":2},{"p":[-72,102,-159],"s":[92,4,4],"c":9539985,"t":2,"bo":1},{"p":[-72,102,-265],"s":[92,4,4],"c":9671571,"t":2,"bo":1},{"p":[-24,51,-212],"s":[5,55,4],"c":8355711,"t":2,"bo":1},{"p":[-24,102,-212],"s":[4,4,102],"c":7895160,"t":2,"bo":1},{"p":[-120,102,-212],"s":[4,4,102],"c":9013641,"t":2,"bo":1},{"p":[-44,117,-212],"s":[56,3,114],"l":1,"r":[0,0,-0.35],"t":5},{"p":[-101,117,-212],"s":[56,3,114],"l":1,"r":[0,0,0.35],"t":5},{"p":[-72,128,-212],"s":[6,2,119],"t":5},{"p":[-111,51,-265],"s":[2,23,4],"c":11513775,"t":2},{"p":[-99,51,-265],"s":[2,23,4],"c":11513775,"t":2},{"p":[-105,72,-265],"s":[10,2,4],"c":11513775,"t":2},{"p":[-108,51,-356],"s":[102,60,92],"c":8217957,"t":10,"bo":1},{"p":[-58,53,-311],"s":[4,59,4],"c":11513775,"t":2,"bo":1},{"p":[-158,53,-311],"s":[4,59,4],"c":11513775,"t":2,"bo":1},{"p":[-158,53,-357],"s":[4,55,4],"c":11513775,"t":2},{"p":[-124,53,-311],"s":[4,74,5],"c":11513775,"t":2,"bo":1},{"p":[-92,53,-311],"s":[4,75,5],"c":11513775,"t":2,"bo":1},{"p":[-108,79,-311],"s":[96,4,4],"c":11513775,"t":2},{"p":[-108,108,-311],"s":[96,4,4],"c":11513775,"t":2,"bo":1},{"p":[-108,129,-356],"s":[6,6,105],"c":11513775,"t":2,"bo":1},{"p":[-136,121,-356],"s":[57,3,99],"l":1,"r":[0,0,0.35],"c":5855577,"t":2},{"p":[-58,108,-358],"s":[4,4,90],"c":11513775,"t":2,"bo":1},{"p":[-158,108,-355],"s":[4,4,84],"l":1,"c":11513775,"t":2},{"p":[-137,124,-356],"s":[57,2,99],"l":1,"r":[0,0,0.35],"t":5},{"p":[-108,135,-356],"s":[6,2,105],"t":5},{"p":[-79,124,-356],"s":[57,2,99],"l":1,"r":[0,0,-0.35],"t":5},{"p":[-80,121,-356],"s":[57,3,99],"l":1,"r":[0,0,-0.35],"c":6052956,"t":2},{"p":[-108,112,-356],"s":[102,5,92],"c":8217957,"t":10},{"p":[-108,117,-356],"s":[77,5,92],"c":8217957,"t":10},{"p":[-108,122,-356],"s":[49,5,92],"c":8217957,"t":10},{"p":[-108,127,-356],"s":[22,5,92],"c":8217957,"t":10},{"p":[-148,51,-311],"s":[2,22,4],"c":11513775,"t":2},{"p":[-136,51,-311],"s":[2,22,4],"c":11513775,"t":2},{"p":[-142,71,-311],"s":[10,2,4],"c":11513775,"t":2},{"p":[-101,51,-20],"s":[60,62,100],"c":6973550,"t":10,"bo":1},{"p":[-101,130,-20],"s":[5,5,108],"c":9868950,"t":2},{"p":[-130,51,29],"s":[4,63,4],"c":7895160,"t":2,"bo":1},{"p":[-72,51,29],"s":[4,63,4],"c":7895160,"t":2,"bo":1},{"p":[-72,51,-71],"s":[4,63,4],"c":7895160,"t":2,"bo":1},{"p":[-26,51,-71],"s":[4,70,4],"c":7895160,"t":2,"bo":1},{"p":[-26,51,-121],"s":[4,70,4],"c":7895160,"t":2,"bo":1},{"p":[-128,51,-121],"s":[4,70,4],"c":7895160,"t":2,"bo":1},{"p":[-78,51,-121],"s":[4,70,5],"c":7895160,"t":2,"bo":1},{"p":[-72,51,-19],"s":[4,63,4],"c":7895160,"t":2,"bo":1},{"p":[-101,87,29],"s":[54,4,4],"c":7500402,"t":2},{"p":[-101,110,29],"s":[54,4,4],"c":7500402,"t":2,"bo":1},{"p":[-103,91,-121],"s":[46,4,4],"l":1,"c":7500402,"t":2},{"p":[-52,91,-121],"s":[48,4,4],"l":1,"c":7500402,"t":2},{"p":[-49,91,-71],"s":[42,4,4],"c":7500402,"t":2},{"p":[-52,117,-121],"s":[48,4,4],"c":7500402,"t":2,"bo":1},{"p":[-103,117,-121],"s":[46,4,4],"c":7500402,"t":2,"bo":1},{"p":[-101,87,5],"s":[62,4,44],"c":7500402,"t":2},{"p":[-128,91,-95],"s":[4,4,48],"l":1,"c":7500402,"t":2},{"p":[-26,117,-96],"s":[4,4,46],"c":7500402,"t":2,"bo":1},{"p":[-26,91,-96],"s":[4,4,46],"c":7500402,"t":2},{"p":[-84,122,-20],"s":[39,2,105],"l":1,"r":[0,0,-0.52],"c":4737096,"t":2},{"p":[-118,122,-20],"s":[39,2,105],"l":1,"r":[0,0,0.53],"c":4737096,"t":2},{"p":[-52,117,-71],"s":[48,4,4],"c":7500402,"t":2,"bo":1},{"p":[-130,51,-69],"s":[4,63,4],"c":7895160,"t":2,"bo":1},{"p":[-130,51,-19],"s":[5,63,4],"c":7895160,"t":2,"bo":1},{"p":[-101,114,-20],"s":[61,4,100],"c":6973550,"t":10,"bo":1},{"p":[-101,118,-20],"s":[50,4,100],"c":6973550,"t":10},{"p":[-101,122,-20],"s":[35,4,100],"c":6973550,"t":10},{"p":[-101,126,-20],"s":[22,4,100],"c":6973550,"t":10},{"p":[-101,130,-20],"s":[9,1,100],"c":6973550,"t":5},{"p":[-119,124,-20],"s":[39,2,105],"l":1,"r":[0,0,0.53],"t":5},{"p":[-83,124,-20],"s":[39,2,105],"l":1,"r":[0,0,-0.52],"t":5},{"p":[-101,135,-20],"s":[5,2,108],"t":5},{"p":[-77,51,-96],"s":[104,68,52],"c":6254184,"t":10,"bo":1},{"p":[-128,117,-95],"s":[4,4,48],"c":7500402,"t":2,"bo":1},{"p":[-77,119,-96],"s":[104,5,52],"c":6254184,"t":10},{"p":[-77,129,-96],"s":[114,5,5],"l":1,"c":7500402,"t":2},{"p":[-77,125,-112],"s":[108,2,31],"l":1,"r":[-0.35,0,0],"c":5723991,"t":2},{"p":[-77,125,-80],"s":[108,2,31],"l":1,"r":[0.35,0,0],"c":5723991,"t":2},{"p":[-77,127,-113],"s":[108,2,31],"l":1,"r":[-0.35,0,0],"t":5},{"p":[-77,127,-79],"s":[108,2,31],"l":1,"r":[0.35,0,0],"t":5},{"p":[-77,134,-96],"s":[114,2,5],"l":1,"t":5},{"p":[-77,124,-96],"s":[104,4,38],"c":6254184,"t":10},{"p":[-77,128,-96],"s":[104,4,16],"c":6254184,"t":10},{"p":[-46,65,-75],"s":[12,77,6],"c":10658466,"t":11},{"p":[-25,64,-102],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[-25,64,-90],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[-25,84,-96],"s":[2,2,10],"c":11513775,"t":2,"bo":1},{"p":[-92,53,-87],"s":[77,12,73],"c":6250335,"t":11},{"p":[175,66,-254],"s":[6,5,46],"c":10983566,"t":11},{"p":[175,103,-334],"s":[6,21,27],"c":10983566,"t":11,"bo":1},{"p":[242,66,-347],"s":[128,62,7],"c":10983566,"t":11,"bo":1},{"p":[267,66,-236],"s":[78,49,9],"c":10983566,"t":11,"bo":1},{"p":[175,66,-328],"s":[6,37,46],"c":10983566,"t":11,"bo":1},{"p":[183,66,-212],"s":[38,102,38],"c":10983566,"t":11},{"p":[239,65,-259],"s":[125,2,38],"c":5723991,"t":11},{"p":[240,65,-292],"s":[123,2,28],"c":6694952,"t":5},{"p":[-102,66,118],"s":[126,38,94],"c":8215901,"t":10,"bo":1},{"p":[-164,66,72],"s":[4,38,4],"c":11513775,"t":2,"bo":1},{"p":[-40,66,72],"s":[4,38,4],"c":11513775,"t":2,"bo":1},{"p":[-102,66,72],"s":[4,62,5],"c":11513775,"t":2,"bo":1},{"p":[-102,100,72],"s":[120,4,4],"c":11513775,"t":2,"bo":1},{"p":[-102,126,117],"s":[6,6,102],"c":11513775,"t":2},{"p":[-67,115,117],"s":[71,3,99],"l":1,"r":[0,0,-0.35],"c":5263440,"t":2},{"p":[-137,115,117],"s":[69,3,99],"l":1,"r":[0,0,0.35],"c":5263440,"t":2},{"p":[-137,118,117],"s":[71,2,99],"l":1,"r":[0,0,0.35],"t":5},{"p":[-102,132,117],"s":[6,2,102],"t":5},{"p":[-66,118,117],"s":[71,2,99],"l":1,"r":[0,0,-0.35],"t":5},{"p":[-102,104,118],"s":[130,6,94],"c":8215901,"t":10,"bo":1},{"p":[-102,110,118],"s":[97,5,94],"c":8215901,"t":10},{"p":[-102,115,118],"s":[70,5,94],"c":8215901,"t":10},{"p":[-102,120,118],"s":[43,5,94],"c":8215901,"t":10},{"p":[-102,125,118],"s":[17,3,94],"c":8215901,"t":10},{"p":[-127,66,72],"s":[2,21,4],"c":11513775,"t":2,"bo":1},{"p":[-139,66,72],"s":[2,21,4],"c":11513775,"t":2,"bo":1},{"p":[-133,85,72],"s":[10,2,4],"c":11513775,"t":2,"bo":1},{"p":[-194,51,77],"s":[56,49,65],"c":8878432,"t":10,"bo":1},{"p":[-179,105,59],"s":[39,2,105],"l":1,"r":[0,0,-0.52],"c":4737096,"t":2},{"p":[-178,107,59],"s":[39,2,105],"l":1,"r":[0,0,-0.52],"t":5},{"p":[-167,93,60],"s":[4,4,22],"c":11513775,"t":2,"bo":1},{"p":[76,51,-141],"s":[84,62,142],"c":8878432,"t":10,"bo":1},{"p":[158,62,-129],"s":[82,50,128],"c":8217957,"t":10,"bo":1},{"p":[-48,92,88],"s":[7,34,12],"c":6710886,"t":11},{"p":[35,66,-211],"s":[4,48,4],"c":7895160,"t":2,"bo":1},{"p":[117,66,-211],"s":[4,48,4],"c":7895160,"t":2,"bo":1},{"p":[35,66,-71],"s":[4,48,4],"c":7895160,"t":2,"bo":1},{"p":[35,66,-165],"s":[5,69,4],"c":7895160,"t":2,"bo":1},{"p":[35,66,-117],"s":[5,69,4],"c":7895160,"t":2,"bo":1},{"p":[76,66,-211],"s":[4,48,5],"c":7895160,"t":2,"bo":1},{"p":[-197,77,-62],"s":[58,4,74],"c":11513775,"t":2},{"p":[76,87,-211],"s":[78,4,4],"c":7895160,"t":2},{"p":[76,110,-211],"s":[78,4,4],"c":7895160,"t":2,"bo":1},{"p":[35,110,-141],"s":[4,4,136],"c":7895160,"t":2,"bo":1},{"p":[35,87,-141],"s":[4,4,136],"c":7895160,"t":2},{"p":[76,87,-71],"s":[78,4,4],"c":7895160,"t":2},{"p":[76,110,-71],"s":[78,4,4],"c":7895160,"t":2,"bo":1},{"p":[76,138,-141],"s":[102,6,6],"c":7895160,"t":2,"bo":1},{"p":[76,126,-179],"s":[92,3,81],"l":1,"r":[-0.35,0,0],"c":4605253,"t":2},{"p":[76,126,-103],"s":[92,3,81],"l":1,"r":[0.35,0,0],"c":4605253,"t":2},{"p":[76,129,-102],"s":[92,2,81],"l":1,"r":[0.35,0,0],"t":5},{"p":[76,144,-141],"s":[102,2,6],"l":1,"t":5},{"p":[76,114,-141],"s":[84,20,47],"c":8878432,"t":10},{"p":[76,134,-141],"s":[84,5,33],"c":8878432,"t":10},{"p":[76,129,-180],"s":[92,2,81],"l":1,"r":[-0.35,0,0],"t":5},{"p":[-221,134,-212],"s":[72,3,100],"l":1,"r":[0,0,0.35],"t":5},{"p":[117,110,-141],"s":[4,4,136],"l":1,"c":7895160,"t":2},{"p":[198,66,-192],"s":[4,47,4],"c":11513775,"t":2},{"p":[198,66,-66],"s":[4,47,4],"c":11513775,"t":2,"bo":1},{"p":[159,84,-66],"s":[4,51,5],"c":11513775,"t":2,"bo":1},{"p":[198,66,-129],"s":[5,47,4],"c":11513775,"t":2,"bo":1},{"p":[158,66,-158],"s":[85,17,74],"c":7235166,"t":11},{"p":[117,87,-188],"s":[4,4,42],"c":7895160,"t":2},{"p":[159,134,-129],"s":[5,5,140],"c":11513775,"t":2,"bo":1},{"p":[181,124,-129],"s":[50,2,135],"l":1,"r":[0,0,-0.52],"c":6908265,"t":2},{"p":[159,109,-66],"s":[74,4,4],"c":11513775,"t":2,"bo":1},{"p":[159,83,-192],"s":[4,51,5],"c":11513775,"t":2,"bo":1},{"p":[159,109,-192],"s":[74,4,4],"c":11513775,"t":2,"bo":1},{"p":[120,66,-192],"s":[4,47,4],"c":11513775,"t":2,"bo":1},{"p":[136,126,-129],"s":[51,2,135],"l":1,"r":[0,0,0.52],"t":5},{"p":[136,124,-129],"s":[48,2,135],"l":1,"r":[0,0,0.52],"c":6908265,"t":2},{"p":[182,126,-129],"s":[51,2,135],"l":1,"r":[0,0,-0.52],"t":5},{"p":[159,139,-129],"s":[5,2,140],"t":5},{"p":[198,109,-129],"s":[4,4,122],"c":11513775,"t":2,"bo":1},{"p":[158,112,-129],"s":[82,5,128],"l":1,"c":8217957,"t":10},{"p":[158,117,-129],"s":[69,4,128],"l":1,"c":8217957,"t":10},{"p":[158,121,-129],"s":[55,4,128],"l":1,"c":8217957,"t":10},{"p":[158,125,-129],"s":[40,4,128],"l":1,"c":8217957,"t":10},{"p":[158,129,-129],"s":[26,4,128],"l":1,"c":8217957,"t":10},{"p":[158,133,-129],"s":[13,4,128],"l":1,"c":8217957,"t":10},{"p":[34,63,-135],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[34,63,-147],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[34,83,-141],"s":[2,2,10],"c":11513775,"t":2,"bo":1},{"p":[102,64,-212],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[96,84,-212],"s":[10,2,2],"c":11513775,"t":2,"bo":1},{"p":[90,64,-212],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[183,118,-212],"s":[33,102,33],"c":13812408,"t":11},{"p":[183,219,-212],"s":[38,7,38],"c":10983566,"t":11},{"p":[183,256,-212],"s":[3,3,37],"c":10983566,"t":11},{"p":[183,227,-231],"s":[38,39,3],"l":1,"r":[0.52,0,0],"c":6908265,"t":2},{"p":[183,227,-192],"s":[38,39,3],"l":1,"r":[-0.52,0,0],"c":6908265,"t":2},{"p":[203,227,-212],"s":[3,39,38],"l":1,"r":[0,0,0.52],"c":6908265,"t":2},{"p":[163,227,-212],"s":[3,39,38],"l":1,"r":[0,0,-0.52],"c":6908265,"t":2},{"p":[183,227,-212],"s":[37,11,29],"c":10983566,"t":11},{"p":[183,238,-212],"s":[37,6,23],"c":10983566,"t":11},{"p":[183,244,-212],"s":[37,6,16],"c":10983566,"t":11},{"p":[183,250,-212],"s":[37,6,9],"c":10983566,"t":11},{"p":[183,256,-212],"s":[37,5,3],"c":10983566,"t":11},{"p":[183,227,-212],"s":[31,11,37],"c":10983566,"t":11},{"p":[183,238,-212],"s":[24,6,37],"c":10983566,"t":11},{"p":[183,244,-212],"s":[17,6,37],"c":10983566,"t":11},{"p":[183,250,-212],"s":[10,6,37],"c":10983566,"t":11},{"p":[183,118,-212],"s":[36,102,10],"c":9341833,"t":2},{"p":[183,118,-212],"s":[11,102,36],"c":9341833,"t":2},{"p":[183,259,-212],"s":[3,3,41],"c":5066061,"t":2},{"p":[183,259,-212],"s":[40,3,3],"c":5066061,"t":2},{"p":[161,228,-212],"s":[2,39,38],"l":1,"r":[0,0,-0.52],"t":5},{"p":[205,228,-212],"s":[2,39,38],"l":1,"r":[0,0,0.52],"t":5},{"p":[183,228,-233],"s":[38,39,2],"l":1,"r":[0.52,0,0],"t":5},{"p":[183,228,-190],"s":[38,39,2],"l":1,"r":[-0.52,0,0],"t":5},{"p":[183,262,-212],"s":[3,2,41],"t":5},{"p":[183,262,-212],"s":[40,2,3],"t":5},{"p":[183,162,-212],"s":[42,7,42],"c":8220776,"bo":1},{"p":[183,169,-212],"s":[42,2,42],"t":5},{"p":[183,65,-212],"s":[40,69,40],"c":8220776,"t":11,"bo":1},{"p":[175,65,-347],"s":[9,68,10],"c":6050122,"t":11,"bo":1},{"p":[175,65,-237],"s":[9,67,10],"c":6379345,"t":11,"bo":1},{"p":[175,120,-329],"s":[9,5,26],"c":8220776,"t":11,"bo":1},{"p":[199,115,-236],"s":[39,9,12],"c":6575952,"t":11,"bo":1},{"p":[239,120,-347],"s":[119,9,10],"c":7563104,"t":11,"bo":1},{"p":[303,66,-304],"s":[6,44,80],"c":10983566,"t":11,"bo":1},{"p":[303,66,-245],"s":[6,40,6],"c":10983566,"t":11,"bo":1},{"p":[287,65,-292],"s":[29,10,49],"c":9013641,"t":2},{"p":[271,65,-292],"s":[3,8,24],"c":9013641,"t":2},{"p":[265,65,-292],"s":[3,4,24],"c":9013641,"t":2},{"p":[268,65,-292],"s":[3,6,24],"c":9013641,"t":2},{"p":[273,65,-316],"s":[3,11,3],"l":1,"c":7039851,"t":2},{"p":[273,65,-268],"s":[3,11,3],"l":1,"c":7039851,"t":2},{"p":[234,70,-260],"s":[7,1,25],"c":3616550,"t":5},{"p":[234,67,-273],"s":[7,6,1],"c":3616550,"t":5},{"p":[234,67,-247],"s":[7,6,1],"c":3616550,"t":5},{"p":[239,70,-324],"s":[7,1,25],"c":3616550,"t":5},{"p":[207,71,-324],"s":[1,5,25],"pe":1,"c":3616550,"t":5},{"p":[231,71,-260],"s":[1,5,25],"pe":1,"c":3616550,"t":5},{"p":[239,67,-311],"s":[7,6,1],"c":3616550,"t":5},{"p":[239,67,-337],"s":[7,6,1],"c":3616550,"t":5},{"p":[210,70,-324],"s":[7,1,25],"c":3616550,"t":5},{"p":[210,67,-311],"s":[7,6,1],"c":3616550,"t":5},{"p":[210,67,-337],"s":[7,6,1],"c":3616550,"t":5},{"p":[236,71,-324],"s":[1,5,25],"pe":1,"c":3616550,"t":5},{"p":[195,66,-236],"s":[34,52,9],"c":10983566,"t":11,"bo":1},{"p":[303,65,-347],"s":[9,69,10],"c":5919310,"t":11},{"p":[303,65,-236],"s":[9,63,12],"c":6246729,"t":11,"bo":1},{"p":[304,66,-256],"s":[5,1,19],"c":8220776,"t":11},{"p":[220,66,-235],"s":[19,1,10],"c":8220776,"t":11},{"p":[175,65,-305],"s":[7,34,5],"c":7694689,"t":11,"bo":1},{"p":[175,65,-279],"s":[7,34,5],"c":7234139,"t":11,"bo":1},{"p":[175,99,-302],"s":[7,5,11],"c":7233881,"t":11,"bo":1},{"p":[175,66,-292],"s":[7,1,21],"c":8220776,"t":11},{"p":[322,51,-302],"s":[30,71,58],"c":6973550,"t":10,"bo":1},{"p":[364,66,-274],"s":[4,56,4],"c":11513775,"t":2,"bo":1},{"p":[336,66,-274],"s":[4,65,5],"c":11513775,"t":2,"bo":1},{"p":[308,66,-274],"s":[4,56,4],"c":11513775,"t":2,"bo":1},{"p":[336,92,-274],"s":[52,4,4],"c":11513775,"t":2,"bo":1},{"p":[344,64,-296],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[336,130,-302],"s":[6,6,68],"c":11513775,"t":2,"bo":1},{"p":[320,127,-302],"s":[32,2,65],"l":1,"r":[0,0,0.35],"c":5855577,"t":2},{"p":[336,118,-274],"s":[52,4,4],"c":11513775,"t":2,"bo":1},{"p":[356,64,-296],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[350,84,-296],"s":[10,2,2],"c":11513775,"t":2,"bo":1},{"p":[336,122,-302],"s":[58,3,58],"c":6973550,"t":10},{"p":[336,125,-302],"s":[45,3,58],"c":6973550,"t":10},{"p":[336,128,-302],"s":[28,3,58],"c":6973550,"t":10},{"p":[336,131,-302],"s":[15,3,58],"c":6973550,"t":10},{"p":[319,129,-302],"s":[32,2,65],"l":1,"r":[0,0,0.35],"t":5},{"p":[354,129,-302],"s":[32,2,65],"l":1,"r":[0,0,-0.35],"t":5},{"p":[353,127,-302],"s":[32,2,65],"l":1,"r":[0,0,-0.35],"c":5855577,"t":2},{"p":[336,136,-302],"s":[6,2,68],"t":5},{"p":[185,84,-65],"s":[2,20,2],"l":1,"c":11513775,"t":2},{"p":[173,84,-65],"s":[2,20,2],"l":1,"c":11513775,"t":2},{"p":[179,102,-65],"s":[10,2,2],"l":1,"c":11513775,"t":2},{"p":[277,51,-190],"s":[88,63,86],"c":6254184,"t":10,"bo":1},{"p":[320,51,-232],"s":[4,63,4],"c":7895160,"t":2,"bo":1},{"p":[281,51,-110],"s":[106,72,80],"c":8878432,"t":10,"bo":1},{"p":[333,66,-149],"s":[4,58,4],"c":11513775,"t":2,"bo":1},{"p":[320,51,-152],"s":[4,63,4],"c":7895160,"t":2,"bo":1},{"p":[320,51,-192],"s":[5,77,4],"c":7895160,"t":2,"bo":1},{"p":[234,51,-192],"s":[5,77,4],"c":7895160,"t":2,"bo":1},{"p":[234,51,-152],"s":[4,63,4],"c":7895160,"t":2,"bo":1},{"p":[234,51,-232],"s":[4,63,4],"c":7895160,"t":2,"bo":1},{"p":[229,66,-149],"s":[4,58,4],"c":11513775,"t":2,"bo":1},{"p":[280,66,38],"s":[4,65,4],"c":11513775,"t":2,"bo":1},{"p":[229,66,-71],"s":[4,58,4],"c":11513775,"t":2,"bo":1},{"p":[333,66,-110],"s":[5,72,4],"c":11513775,"t":2,"bo":1},{"p":[320,88,-192],"s":[4,4,76],"c":7895160,"t":2},{"p":[320,110,-192],"s":[4,4,76],"c":7895160,"t":2,"bo":1},{"p":[234,88,-192],"s":[4,4,76],"c":7895160,"t":2},{"p":[234,110,-192],"s":[4,4,76],"c":7895160,"t":2,"bo":1},{"p":[301,110,-232],"s":[34,4,4],"c":7895160,"t":2,"bo":1},{"p":[301,88,-232],"s":[34,4,4],"l":1,"c":7895160,"t":2},{"p":[277,127,-192],"s":[102,5,5],"c":7895160,"t":2,"bo":1},{"p":[277,119,-166],"s":[97,2,59],"l":1,"r":[0.35,0,0],"c":5395026,"t":2},{"p":[277,121,-214],"s":[97,2,47],"l":1,"r":[-0.35,0,0],"c":5395026,"t":2},{"p":[277,114,-190],"s":[88,3,86],"c":6254184,"t":10},{"p":[277,117,-190],"s":[88,3,68],"c":6254184,"t":10},{"p":[277,120,-190],"s":[88,3,50],"c":6254184,"t":10},{"p":[277,123,-190],"s":[88,3,30],"c":6254184,"t":10},{"p":[277,126,-190],"s":[88,2,16],"c":6254184,"t":10},{"p":[277,121,-165],"s":[97,2,59],"l":1,"r":[0.35,0,0],"t":5},{"p":[277,123,-215],"s":[97,2,47],"l":1,"r":[-0.35,0,0],"t":5},{"p":[277,132,-192],"s":[102,2,5],"t":5},{"p":[333,93,-110],"s":[4,4,74],"c":11513775,"t":2},{"p":[333,120,-110],"s":[4,4,74],"c":11513775,"t":2,"bo":1},{"p":[11,137,-444],"s":[100,5,5],"c":7895160,"t":2},{"p":[11,142,-444],"s":[100,2,5],"t":5},{"p":[10,128,-416],"s":[97,2,61],"l":1,"r":[0.35,0,0],"c":5395026,"t":2},{"p":[10,130,-416],"s":[97,2,62],"l":1,"r":[0.35,0,0],"t":5},{"p":[43,69,-400],"s":[13,70,7],"c":6381921,"t":11},{"p":[229,66,-110],"s":[5,72,4],"c":11513775,"t":2,"bo":1},{"p":[229,93,-110],"s":[4,4,74],"c":11513775,"t":2},{"p":[229,120,-110],"s":[4,4,74],"c":11513775,"t":2,"bo":1},{"p":[281,120,-149],"s":[100,4,4],"c":11513775,"t":2,"bo":1},{"p":[281,120,-71],"s":[100,4,4],"c":11513775,"t":2,"bo":1},{"p":[281,93,-149],"s":[100,4,4],"l":1,"c":11513775,"t":2},{"p":[281,137,-110],"s":[120,5,5],"c":11513775,"t":2,"bo":1},{"p":[281,131,-132],"s":[113,2,50],"l":1,"r":[-0.35,0,0],"c":6579300,"t":2},{"p":[281,133,-133],"s":[113,2,50],"l":1,"r":[-0.35,0,0],"t":5},{"p":[281,131,-89],"s":[113,2,50],"l":1,"r":[0.35,0,0],"c":6579300,"t":2},{"p":[281,133,-88],"s":[113,2,50],"l":1,"r":[0.35,0,0],"t":5},{"p":[281,142,-110],"s":[120,2,5],"t":5},{"p":[281,124,-110],"s":[106,4,80],"c":8878432,"t":10},{"p":[281,128,-110],"s":[106,3,60],"c":8878432,"t":10},{"p":[281,131,-110],"s":[106,4,43],"c":8878432,"t":10},{"p":[281,135,-110],"s":[106,3,21],"c":8878432,"t":10},{"p":[263,51,-43],"s":[60,62,72],"c":6973550,"t":10,"bo":1},{"p":[263,125,-40],"s":[71,2,70],"l":1,"r":[0,0,0.35],"c":6908265,"t":2},{"p":[262,127,-40],"s":[71,2,70],"l":1,"r":[0,0,0.35],"t":5},{"p":[281,93,-71],"s":[100,4,4],"c":11513775,"t":2},{"p":[292,66,-68],"s":[4,71,4],"c":11513775,"t":2,"bo":1},{"p":[292,66,-8],"s":[4,71,4],"c":11513775,"t":2,"bo":1},{"p":[234,66,-8],"s":[4,47,4],"c":11513775,"t":2,"bo":1},{"p":[234,66,-68],"s":[4,47,4],"c":11513775,"t":2,"bo":1},{"p":[263,109,-8],"s":[54,4,4],"c":11513775,"t":2,"bo":1},{"p":[234,109,-38],"s":[4,4,56],"c":11513775,"t":2,"bo":1},{"p":[292,109,-38],"s":[4,4,56],"l":1,"c":11513775,"t":2},{"p":[262,113,-43],"s":[59,4,72],"c":6973550,"t":10},{"p":[267,117,-43],"s":[50,4,72],"c":6973550,"t":10},{"p":[272,121,-43],"s":[38,4,72],"c":6973550,"t":10},{"p":[277,125,-38],"s":[28,4,62],"c":6973550,"t":10},{"p":[283,129,-38],"s":[17,4,62],"c":6973550,"t":10},{"p":[288,133,-38],"s":[6,3,62],"c":6973550,"t":10},{"p":[292,113,-37],"s":[2,23,61],"c":6973550,"t":10,"bo":1},{"p":[233,84,-32],"s":[2,20,2],"c":11513775,"t":2,"bo":1},{"p":[233,84,-44],"s":[2,20,2],"c":11513775,"t":2,"bo":1},{"p":[233,102,-38],"s":[2,2,10],"c":11513775,"t":2,"bo":1},{"p":[321,66,-166],"s":[2,20,2],"c":11513775,"t":2,"bo":1},{"p":[321,66,-178],"s":[2,20,2],"c":11513775,"t":2,"bo":1},{"p":[321,84,-172],"s":[2,2,10],"c":11513775,"t":2,"bo":1},{"p":[411,66,-212],"s":[90,38,138],"c":8215901,"t":10,"bo":1},{"p":[413,66,-6],"s":[90,50,88],"c":8215901,"t":10,"bo":1},{"p":[208,66,90],"s":[140,80,88],"c":8215901,"t":10,"bo":1},{"p":[20,66,96],"s":[116,53,80],"c":9342330,"t":10,"bo":1},{"p":[425,51,-96],"s":[90,71,92],"c":6973550,"t":10,"bo":1},{"p":[334,51,80],"s":[110,79,86],"c":6254184,"t":10,"bo":1},{"p":[-37,51,57],"s":[4,69,4],"c":7895160,"t":2,"bo":1},{"p":[20,51,57],"s":[4,89,5],"c":7895160,"t":2,"bo":1},{"p":[20,91,57],"s":[110,4,4],"c":7895160,"t":2},{"p":[20,139,96],"s":[5,5,92],"c":7895160,"t":2,"bo":1},{"p":[-11,130,96],"s":[65,2,88],"l":1,"r":[0,0,0.35],"c":4737096,"t":2},{"p":[51,130,96],"s":[65,2,88],"l":1,"r":[0,0,-0.35],"c":4737096,"t":2},{"p":[20,144,96],"s":[5,2,92],"t":5},{"p":[-12,132,96],"s":[65,2,88],"l":1,"r":[0,0,0.35],"t":5},{"p":[52,132,96],"s":[65,2,88],"l":1,"r":[0,0,-0.35],"t":5},{"p":[20,116,57],"s":[110,4,4],"c":7895160,"t":2,"bo":1},{"p":[-37,91,96],"s":[4,4,74],"c":7895160,"t":2},{"p":[-37,116,96],"s":[4,4,74],"c":7895160,"t":2,"bo":1},{"p":[20,119,96],"s":[113,6,80],"c":9342330,"t":10,"bo":1},{"p":[20,125,96],"s":[91,4,80],"c":9342330,"t":10},{"p":[20,129,96],"s":[69,4,80],"c":9342330,"t":10},{"p":[20,133,96],"s":[46,4,80],"c":9342330,"t":10},{"p":[20,137,96],"s":[25,4,80],"c":9342330,"t":10},{"p":[-15,66,57],"s":[2,21,4],"c":11513775,"t":2,"bo":1},{"p":[-3,66,57],"s":[2,21,4],"c":11513775,"t":2,"bo":1},{"p":[-9,85,57],"s":[10,2,4],"c":11513775,"t":2,"bo":1},{"p":[367,66,-144],"s":[4,38,4],"c":7895160,"t":2,"bo":1},{"p":[367,66,-212],"s":[5,62,4],"c":7895160,"t":2,"bo":1},{"p":[367,100,-212],"s":[4,4,132],"c":7895160,"t":2,"bo":1},{"p":[377,100,-144],"s":[16,4,4],"c":7895160,"t":2,"bo":1},{"p":[412,127,-212],"s":[106,5,5],"c":7895160,"t":2,"bo":1},{"p":[412,116,-248],"s":[98,2,75],"l":1,"r":[-0.35,0,0],"c":4605510,"t":2},{"p":[412,118,-249],"s":[98,2,75],"l":1,"r":[-0.35,0,0],"t":5},{"p":[412,118,-174],"s":[98,2,77],"l":1,"r":[0.35,0,0],"t":5},{"p":[412,116,-175],"s":[98,2,77],"l":1,"r":[0.35,0,0],"c":4605510,"t":2},{"p":[412,132,-212],"s":[106,2,5],"t":5},{"p":[411,104,-212],"s":[90,4,138],"c":8215901,"t":10},{"p":[411,108,-212],"s":[90,4,117],"c":8215901,"t":10},{"p":[411,112,-212],"s":[90,4,94],"c":8215901,"t":10},{"p":[411,116,-212],"s":[90,4,73],"c":8215901,"t":10},{"p":[411,124,-212],"s":[90,4,29],"c":8215901,"t":10},{"p":[411,120,-212],"s":[90,4,51],"c":8215901,"t":10},{"p":[411,128,-212],"s":[90,1,11],"c":8215901,"t":10},{"p":[366,66,-237],"s":[2,20,2],"l":1,"c":11513775,"t":2},{"p":[366,66,-249],"s":[2,20,2],"l":1,"c":11513775,"t":2},{"p":[366,84,-243],"s":[2,2,10],"l":1,"c":11513775,"t":2},{"p":[381,66,-141],"s":[4,57,4],"c":11513775,"t":2,"bo":1},{"p":[381,66,-51],"s":[4,57,4],"c":11513775,"t":2,"bo":1},{"p":[381,66,-96],"s":[5,73,4],"c":11513775,"t":2,"bo":1},{"p":[381,119,-96],"s":[4,4,86],"c":11513775,"t":2,"bo":1},{"p":[427,119,-96],"s":[88,4,94],"l":1,"c":11513775,"t":2},{"p":[427,138,-96],"s":[108,6,6],"c":11513775,"t":2,"bo":1},{"p":[427,131,-121],"s":[102,2,52],"l":1,"r":[-0.35,0,0],"c":6052956,"t":2},{"p":[427,131,-70],"s":[102,2,52],"l":1,"r":[0.35,0,0],"c":6052956,"t":2},{"p":[427,133,-69],"s":[102,2,52],"l":1,"r":[0.35,0,0],"t":5},{"p":[427,133,-122],"s":[102,2,52],"l":1,"r":[-0.35,0,0],"t":5},{"p":[427,144,-96],"s":[108,2,6],"t":5},{"p":[425,123,-96],"s":[90,5,91],"c":6973550,"t":10},{"p":[425,128,-96],"s":[90,4,69],"c":6973550,"t":10},{"p":[425,132,-96],"s":[90,4,47],"c":6973550,"t":10},{"p":[425,136,-96],"s":[90,4,25],"c":6973550,"t":10},{"p":[369,66,-49],"s":[4,51,4],"c":7895160,"t":2,"bo":1},{"p":[369,66,35],"s":[4,51,4],"c":7895160,"t":2,"bo":1},{"p":[369,66,-7],"s":[5,65,4],"c":7895160,"t":2,"bo":1},{"p":[369,113,-7],"s":[4,4,80],"c":7895160,"t":2,"bo":1},{"p":[376,113,-49],"s":[10,4,4],"c":7895160,"t":2,"bo":1},{"p":[333,66,-71],"s":[4,58,4],"c":11513775,"t":2,"bo":1},{"p":[388,66,38],"s":[4,65,4],"c":11513775,"t":2},{"p":[334,66,38],"s":[4,83,5],"c":11513775,"t":2,"bo":1},{"p":[334,95,38],"s":[104,4,4],"c":11513775,"t":2},{"p":[334,127,38],"s":[104,4,4],"c":11513775,"t":2,"bo":1},{"p":[280,127,49],"s":[4,4,18],"l":1,"c":11513775,"t":2,"bo":1},{"p":[280,95,49],"s":[4,4,18],"c":11513775,"t":2},{"p":[277,66,47],"s":[4,81,4],"c":7895160,"t":2,"bo":1},{"p":[139,66,47],"s":[4,81,4],"c":7895160,"t":2,"bo":1},{"p":[107,66,-12],"s":[92,19,145],"c":6250335,"t":11},{"p":[64,85,28],"s":[2,38,59],"pe":1,"c":6254184,"t":10,"bo":1},{"p":[64,85,-43],"s":[2,38,53],"pe":1,"c":6254184,"t":10,"bo":1},{"p":[150,85,-27],"s":[2,38,77],"pe":1,"c":6254184,"t":10,"bo":1},{"p":[150,85,34],"s":[2,38,19],"pe":1,"c":6254184,"t":10,"bo":1},{"p":[208,66,47],"s":[4,104,5],"c":7895160,"t":2,"bo":1},{"p":[208,112,47],"s":[134,4,4],"l":1,"c":7895160,"t":2},{"p":[208,143,47],"s":[134,4,4],"c":7895160,"t":2,"bo":1},{"p":[252,66,81],"s":[85,17,73],"c":6250335},{"p":[277,143,87],"s":[4,4,76],"l":1,"c":7895160,"t":2},{"p":[413,130,-7],"s":[107,5,5],"c":7895160,"t":2,"bo":1},{"p":[413,124,-29],"s":[99,2,51],"l":1,"r":[-0.35,0,0],"c":5066061,"t":2},{"p":[413,124,16],"s":[99,2,54],"l":1,"r":[0.35,0,0],"c":5066061,"t":2},{"p":[413,126,17],"s":[99,2,54],"l":1,"r":[0.35,0,0],"t":5},{"p":[413,126,-30],"s":[99,2,51],"l":1,"r":[-0.35,0,0],"t":5},{"p":[413,135,-7],"s":[107,2,5],"t":5},{"p":[413,117,-6],"s":[90,3,88],"c":8215901,"t":10},{"p":[413,120,-6],"s":[90,3,71],"c":8215901,"t":10},{"p":[413,123,-6],"s":[90,3,58],"c":8215901,"t":10},{"p":[413,126,-6],"s":[90,3,37],"c":8215901,"t":10},{"p":[413,129,-6],"s":[90,3,22],"c":8215901,"t":10},{"p":[334,149,80],"s":[5,5,106],"c":11513775,"t":2,"bo":1},{"p":[364,140,80],"s":[61,2,97],"l":1,"r":[0,0,-0.35],"c":7039851,"t":2},{"p":[303,140,80],"s":[61,2,97],"l":1,"r":[0,0,0.35],"c":7039851,"t":2},{"p":[334,154,80],"s":[5,2,106],"t":5},{"p":[304,143,80],"s":[63,2,97],"l":1,"r":[0,0,0.35],"t":5},{"p":[364,142,80],"s":[63,2,97],"l":1,"r":[0,0,-0.35],"t":5},{"p":[334,130,80],"s":[110,5,86],"c":6254184,"t":10},{"p":[334,135,80],"s":[89,4,86],"c":6254184,"t":10},{"p":[334,139,80],"s":[67,4,86],"c":6254184,"t":10},{"p":[334,143,80],"s":[45,4,86],"c":6254184,"t":10},{"p":[334,147,80],"s":[23,4,86],"c":6254184,"t":10},{"p":[208,169,90],"s":[6,6,104],"c":7895160,"t":2,"bo":1},{"p":[246,158,90],"s":[81,2,97],"l":1,"r":[0,0,-0.35],"c":4605510,"t":2},{"p":[170,159,90],"s":[81,2,97],"l":1,"r":[0,0,0.35],"c":4605510,"t":2},{"p":[169,161,90],"s":[81,2,97],"l":1,"r":[0,0,0.35],"t":5},{"p":[247,160,90],"s":[81,2,97],"l":1,"r":[0,0,-0.35],"t":5},{"p":[208,175,90],"s":[6,2,104],"t":5},{"p":[208,147,90],"s":[140,3,88],"c":8215901,"t":10},{"p":[208,150,90],"s":[124,4,88],"c":8215901,"t":10},{"p":[208,154,90],"s":[102,4,88],"c":8215901,"t":10},{"p":[208,158,90],"s":[81,4,88],"c":8215901,"t":10},{"p":[208,162,90],"s":[58,4,88],"c":8215901,"t":10},{"p":[208,166,90],"s":[36,4,88],"c":8215901,"t":10},{"p":[208,170,90],"s":[15,3,88],"c":8215901,"t":10},{"p":[-72,87,-45],"s":[4,4,48],"c":7500402,"t":2},{"p":[-101,110,5],"s":[62,4,44],"c":7500402,"t":2,"bo":1},{"p":[368,84,-22],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[368,84,-34],"s":[2,22,2],"c":11513775,"t":2,"bo":1},{"p":[368,104,-28],"s":[2,2,10],"c":11513775,"t":2,"bo":1},{"p":[179,84,47],"s":[2,21,4],"l":1,"c":11513775,"t":2},{"p":[167,84,47],"s":[2,21,4],"l":1,"c":11513775,"t":2},{"p":[173,103,47],"s":[10,2,4],"l":1,"c":11513775,"t":2},{"p":[107,146,-9],"s":[101,5,5],"c":7895160,"t":2,"bo":1},{"p":[107,134,26],"s":[93,2,74],"l":1,"r":[0.35,0,0],"c":4868682,"t":2},{"p":[150,66,-64],"s":[4,58,4],"c":7895160,"t":2},{"p":[151,66,-9],"s":[3,81,4],"c":7895160,"t":2,"bo":1},{"p":[150,66,44],"s":[4,58,4],"c":7895160,"t":2,"bo":1},{"p":[107,85,50],"s":[84,38,19],"c":6254184,"t":10,"bo":1},{"p":[107,85,-44],"s":[84,38,51],"c":6254184,"t":10,"bo":1},{"p":[64,66,-2],"s":[5,54,2],"pe":1,"c":7895160,"t":2,"bo":1},{"p":[64,66,-16],"s":[5,54,2],"pe":1,"c":7895160,"t":2,"bo":1},{"p":[64,105,-9],"s":[5,2,12],"l":1,"c":7895160,"t":2},{"p":[150,66,11],"s":[4,54,2],"pe":1,"c":7895160,"t":2,"bo":1},{"p":[150,66,25],"s":[4,54,2],"pe":1,"c":7895160,"t":2,"bo":1},{"p":[150,105,18],"s":[4,2,12],"l":1,"c":7895160,"t":2},{"p":[150,106,18],"s":[2,15,13],"pe":1,"c":6254184,"t":10,"bo":1},{"p":[64,107,-9],"s":[2,16,15],"pe":1,"c":6254184,"t":10},{"p":[63,123,-9],"s":[2,24,4],"c":7895160,"t":2},{"p":[64,85,-68],"s":[5,39,4],"c":7895160,"t":2,"bo":1},{"p":[64,85,54],"s":[5,39,4],"c":7895160,"t":2,"bo":1},{"p":[64,120,-9],"s":[5,4,114],"c":7895160,"t":2,"bo":1},{"p":[64,120,50],"s":[5,4,4],"c":7895160,"t":2,"bo":1},{"p":[107,135,-41],"s":[93,2,70],"l":1,"r":[-0.35,0,0],"c":4868682,"t":2},{"p":[150,120,-10],"s":[4,4,104],"c":7895160,"t":2,"bo":1},{"p":[107,115,10],"s":[85,1,71],"c":6250335,"t":2},{"p":[107,124,-9],"s":[88,4,122],"c":6254184,"t":10,"bo":1},{"p":[107,136,27],"s":[93,2,74],"l":1,"r":[0.35,0,0],"t":5},{"p":[107,151,-9],"s":[101,2,5],"l":1,"t":5},{"p":[107,137,-42],"s":[93,2,70],"l":1,"r":[-0.35,0,0],"t":5},{"p":[107,128,-9],"s":[88,4,104],"c":6254184,"t":10},{"p":[107,132,-9],"s":[88,4,82],"c":6254184,"t":10},{"p":[107,136,-9],"s":[88,4,60],"c":6254184,"t":10},{"p":[107,140,-9],"s":[88,4,38],"c":6254184,"t":10},{"p":[107,144,-9],"s":[88,3,16],"c":6254184,"t":10},{"p":[50,83,-9],"s":[22,2,88],"c":7895160,"t":2},{"p":[41,66,-51],"s":[2,20,2],"c":7895160,"t":2},{"p":[41,66,33],"s":[2,20,2],"c":7895160,"t":2},{"p":[92,66,40],"s":[2,39,2],"c":7895160,"t":2,"bo":1},{"p":[80,66,40],"s":[2,39,2],"c":7895160,"t":2,"bo":1},{"p":[121,66,-18],"s":[2,39,2],"c":7895160,"t":2,"bo":1},{"p":[133,66,-18],"s":[2,39,2],"c":7895160,"t":2,"bo":1},{"p":[127,105,-18],"s":[14,2,2],"c":7895160,"t":2,"bo":1},{"p":[86,105,40],"s":[14,2,2],"c":7895160,"t":2,"bo":1},{"p":[10,128,-471],"s":[97,2,59],"l":1,"r":[-0.35,0,0],"c":5395026,"t":2},{"p":[10,130,-472],"s":[97,2,59],"l":1,"r":[-0.35,0,0],"t":5},{"p":[10,51,-444],"s":[92,67,107],"c":6254184,"t":10},{"p":[10,118,-444],"s":[92,2,107],"c":6254184,"t":10},{"p":[10,123,-444],"s":[92,5,75],"c":6254184,"t":10},{"p":[10,128,-444],"s":[92,5,49],"c":6254184,"t":10},{"p":[10,133,-444],"s":[92,5,22],"c":6254184,"t":10},{"p":[55,114,-444],"s":[4,4,107],"c":11513775,"t":2},{"p":[71,51,-393],"s":[4,63,4],"c":11513775,"t":2},{"p":[207,51,-393],"s":[4,64,4],"c":11513775,"t":2},{"p":[116,51,-393],"s":[4,77,5],"c":11513775,"t":2},{"p":[71,51,-445],"s":[4,63,4],"c":11513775,"t":2},{"p":[71,51,-495],"s":[4,62,4],"c":11513775,"t":2},{"p":[139,111,-393],"s":[132,4,4],"c":11513775,"t":2},{"p":[71,110,-444],"s":[4,4,98],"l":1,"c":11513775,"t":2},{"p":[139,134,-443],"s":[7,7,121],"c":11513775,"t":2},{"p":[101,121,-443],"s":[79,3,113],"l":1,"r":[0,0,0.35],"c":4605510,"t":2},{"p":[100,124,-443],"s":[79,2,113],"l":1,"r":[0,0,0.35],"t":5},{"p":[139,141,-443],"s":[7,2,121],"l":1,"t":5},{"p":[178,124,-443],"s":[78,3,113],"l":1,"r":[0,0,-0.35],"t":5},{"p":[139,66,-444],"s":[136,49,104],"c":9342330,"t":10},{"p":[139,115,-444],"s":[107,5,104],"c":9342330,"t":10},{"p":[139,120,-444],"s":[83,5,104],"c":9342330,"t":10},{"p":[139,125,-444],"s":[55,5,104],"c":9342330,"t":10},{"p":[139,130,-444],"s":[28,4,104],"c":9342330,"t":10},{"p":[161,51,-393],"s":[4,77,5],"c":11513775,"t":2},{"p":[214,113,-385],"s":[48,2,70],"l":1,"r":[0,0,0.52],"c":6908265,"t":2},{"p":[213,115,-385],"s":[48,2,70],"l":1,"r":[0,0,0.52],"t":5},{"p":[233,125,-386],"s":[5,5,71],"c":11513775,"t":2},{"p":[233,130,-386],"s":[5,2,71],"t":5},{"p":[55,65,13],"s":[12,12,12],"i":1},{"p":[55,65,-64],"s":[12,12,12],"i":1},{"p":[-65,65,-64],"s":[12,12,12],"i":1},{"p":[-65,65,-52],"s":[12,12,12],"i":1},{"p":[-72,110,-45],"s":[4,4,48],"c":7500402,"t":2,"bo":1},{"p":[-130,87,-44],"s":[4,4,46],"c":7500402,"t":2},{"p":[-130,110,-44],"s":[4,4,46],"c":7500402,"t":2,"bo":1},{"p":[28,65,-95],"s":[12,12,12],"i":1},{"p":[-88,65,36],"s":[12,12,12],"i":1},{"p":[28,65,50],"s":[12,12,12],"i":1},{"p":[28,77,50],"s":[12,12,12],"i":1},{"p":[146,85,35],"s":[6,8,6],"i":2},{"p":[60,85,-36],"s":[6,8,6],"i":2},{"p":[60,85,-28],"s":[6,8,6],"i":2},{"p":[-17,65,-178],"s":[12,12,12],"i":1},{"p":[-56,65,-128],"s":[12,12,12],"i":1},{"p":[-164,52,-158],"s":[12,12,12],"i":1},{"p":[-152,52,-158],"s":[12,12,12],"i":1},{"p":[-315,52,-86],"s":[12,12,12],"i":1},{"p":[-315,52,-74],"s":[12,12,12],"i":1},{"p":[-315,52,18],"s":[12,12,12],"i":1},{"p":[-315,52,6],"s":[12,12,12],"i":1},{"p":[-315,64,18],"s":[12,12,12],"i":1},{"p":[-231,52,-93],"s":[12,12,12],"i":1},{"p":[-281,52,-49],"s":[12,12,12],"i":1},{"p":[-269,52,-49],"s":[12,12,12],"i":1},{"p":[-128,52,-266],"s":[12,12,12],"i":1},{"p":[-116,52,-304],"s":[12,12,12],"i":1},{"p":[-116,64,-304],"s":[12,12,12],"i":1},{"p":[-162,65,-28],"s":[12,12,12],"i":1},{"p":[-19,65,-28],"s":[12,12,12],"i":1},{"p":[216,83,40],"s":[12,12,12],"i":1},{"p":[157,83,-56],"s":[12,12,12],"i":1},{"p":[300,83,-50],"s":[12,12,12],"i":1},{"p":[300,83,-62],"s":[12,12,12],"i":1},{"p":[361,83,31],"s":[12,12,12],"i":1},{"p":[360,65,-198],"s":[12,12,12],"i":1},{"p":[45,65,-66],"s":[6,8,6],"i":2},{"p":[-55,65,-66],"s":[6,8,6],"i":2},{"p":[-68,65,22],"s":[6,8,6],"i":2},{"p":[-68,65,14],"s":[6,8,6],"i":2},{"p":[-163,65,54],"s":[6,8,6],"i":2},{"p":[-165,65,-38],"s":[6,8,6],"i":2},{"p":[-269,52,-59],"s":[6,8,6],"i":2},{"p":[-317,52,-64],"s":[6,8,6],"i":2},{"p":[-317,52,-56],"s":[6,8,6],"i":2},{"p":[-317,52,-173],"s":[6,8,6],"i":2},{"p":[-305,52,20],"s":[6,8,6],"i":2},{"p":[-184,52,-204],"s":[6,8,6],"i":2},{"p":[-184,52,-196],"s":[6,8,6],"i":2},{"p":[75,71,-311],"s":[31,3,7],"c":8220776},{"p":[94,66,-292],"s":[6,7,44],"c":10983566,"t":11},{"p":[56,66,-292],"s":[6,7,44],"c":10983566,"t":11},{"p":[75,66,-273],"s":[32,7,6],"c":10983566,"t":11},{"p":[75,66,-311],"s":[32,7,6],"c":10983566,"t":11},{"p":[75,71,-273],"s":[31,3,7],"c":8220776},{"p":[56,71,-292],"s":[7,3,45],"c":8220776,"t":11},{"p":[94,71,-292],"s":[7,3,45],"c":8220776},{"p":[75,66,-292],"s":[32,1,33],"c":10983566},{"p":[75,66,-292],"s":[9,23,9],"c":10983566,"t":11},{"p":[75,77,-292],"s":[20,3,20],"c":8220776,"t":11},{"p":[75,86,-292],"s":[14,3,14],"c":8220776,"t":11},{"p":[75,74,-311],"s":[31,1,7],"l":1,"t":5},{"p":[75,74,-273],"s":[31,1,7],"l":1,"t":5},{"p":[94,74,-292],"s":[7,1,45],"l":1,"t":5},{"p":[56,74,-292],"s":[7,1,45],"l":1,"t":5},{"p":[75,80,-292],"s":[20,1,20],"l":1,"t":5},{"p":[75,89,-292],"s":[14,1,14],"l":1,"t":5},{"p":[75,67,-292],"s":[32,2,33],"c":9165268,"o":0.7000000000000001,"t":5},{"p":[63,62,-565],"s":[173,63,128],"c":8217957,"t":10},{"p":[351,83,34],"s":[6,8,6],"i":2},{"p":[296,83,-25],"s":[6,8,6],"i":2},{"p":[296,83,-17],"s":[6,8,6],"i":2},{"p":[375,65,-139],"s":[6,8,6],"i":2},{"p":[325,65,-202],"s":[6,8,6],"i":2},{"p":[325,65,-210],"s":[6,8,6],"i":2},{"p":[206,65,-227],"s":[6,8,6],"i":2},{"p":[206,65,-220],"s":[6,8,6],"i":2},{"p":[-222,52,-295],"s":[6,8,6],"i":2},{"p":[-17,65,-190],"s":[12,12,12],"i":1},{"p":[157,65,-201],"s":[12,12,12],"i":1},{"p":[157,65,-213],"s":[12,12,12],"i":1},{"p":[-1,65,-362],"s":[12,12,12],"i":1},{"p":[11,65,-362],"s":[12,12,12],"i":1},{"p":[23,65,-362],"s":[12,12,12],"i":1},{"p":[-1,77,-363],"s":[12,12,12],"i":1},{"p":[77,65,-362],"s":[12,12,12],"i":1},{"p":[89,65,-362],"s":[12,12,12],"i":1},{"p":[135,65,-362],"s":[12,12,12],"i":1},{"p":[135,77,-363],"s":[12,12,12],"i":1},{"p":[104,65,-301],"s":[12,12,12],"i":1},{"p":[65,65,-218],"s":[12,12,12],"i":1},{"p":[-11,66,-365],"s":[6,8,6],"i":2},{"p":[145,65,-365],"s":[6,8,6],"i":2},{"p":[152,65,-365],"s":[6,8,6],"i":2},{"p":[102,65,-291],"s":[6,8,6],"i":2},{"p":[147,65,-198],"s":[6,8,6],"i":2},{"p":[55,65,-215],"s":[6,8,6],"i":2},{"p":[-67,65,-9],"s":[1,18,4],"l":1,"r":[0,0,0.17],"c":7895160,"t":2},{"p":[-31,65,-28],"s":[12,12,12],"i":1},{"p":[-31,65,-16],"s":[12,12,12],"i":1},{"p":[39,66,-35],"s":[1,19,5],"pe":1,"v":1,"c":7895160,"t":2},{"p":[39,66,-35],"s":[1,19,3],"i":3,"t":2,"d":2},{"p":[-161,87,-309],"s":[4,8,10],"c":9013641,"t":2,"bo":1},{"p":[381,91,-96],"s":[4,4,86],"c":11513775,"t":2},{"p":[202,82,-11],"s":[110,2,165],"l":1,"t":5},{"p":[177,121,-443],"s":[79,3,113],"l":1,"r":[0,0,-0.35],"c":4605510,"t":2},{"p":[383,65,26],"s":[12,70,6],"c":11293523},{"p":[63,121,-502],"s":[174,4,4],"c":6381921,"t":2},{"p":[-22,96,-502],"s":[4,34,4],"c":6381921,"t":2},{"p":[63,156,-568],"s":[6,6,145],"c":6381921,"t":2},{"p":[18,140,-568],"s":[97,3,138],"l":1,"r":[0,0,0.35],"c":6381921,"t":2},{"p":[108,140,-568],"s":[102,3,138],"l":1,"r":[0,0,-0.35],"c":6381921,"t":2},{"p":[63,162,-568],"s":[6,2,145],"t":5},{"p":[109,143,-568],"s":[102,2,138],"l":1,"r":[0,0,-0.35],"t":5},{"p":[17,143,-568],"s":[97,2,138],"l":1,"r":[0,0,0.35],"t":5},{"p":[93,96,-502],"s":[4,50,4],"c":6381921,"t":2},{"p":[63,125,-565],"s":[173,4,128],"c":8217957,"t":10},{"p":[63,133,-565],"s":[131,4,128],"c":8217957,"t":10},{"p":[63,129,-565],"s":[153,4,128],"c":8217957,"t":10},{"p":[63,137,-565],"s":[109,4,128],"c":8217957,"t":10},{"p":[63,141,-565],"s":[86,4,128],"c":8217957,"t":10},{"p":[63,145,-565],"s":[65,4,128],"c":8217957,"t":10},{"p":[63,149,-565],"s":[43,4,128],"c":8217957,"t":10},{"p":[63,153,-565],"s":[22,3,128],"c":8217957,"t":10},{"p":[-108,107,-447],"s":[97,2,59],"l":1,"r":[0.35,0,0],"c":5395026,"t":2},{"p":[-108,108,-446],"s":[97,2,59],"l":1,"r":[0.35,0,0],"t":5},{"p":[-108,116,-475],"s":[100,5,5],"c":7895160,"t":2},{"p":[-108,121,-475],"s":[100,2,5],"t":5},{"p":[10,114,-392],"s":[94,4,4],"c":11513775,"t":2},{"p":[55,51,-392],"s":[4,63,4],"c":11513775,"t":2},{"p":[-35,51,-392],"s":[4,63,4],"c":11513775,"t":2},{"p":[11,51,-392],"s":[4,63,4],"c":11513775,"t":2},{"p":[30,96,-502],"s":[4,52,4],"c":6381921,"t":2},{"p":[63,109,-502],"s":[174,4,4],"c":6381921,"t":2},{"p":[10,120,-444],"s":[92,3,102],"c":6254184,"t":10},{"p":[55,51,-444],"s":[4,86,4],"c":11513775,"t":2},{"p":[296,66,-292],"s":[9,19,34],"c":7891810,"t":11},{"p":[298,101,-292],"s":[3,9,12],"c":6051153,"t":11,"bo":1},{"p":[298,85,-301],"s":[4,22,6],"c":6051153,"t":11,"bo":1},{"p":[298,85,-283],"s":[4,23,6],"c":6051153,"t":11,"bo":1},{"p":[300,85,-292],"s":[1,22,23],"c":5590860,"t":11},{"p":[293,85,-297],"s":[1,3,1],"l":1,"c":9997922,"t":5},{"p":[294,85,-301],"s":[1,2,1],"l":1,"r":[0,-0.35,0],"c":9997922,"t":5},{"p":[293,85,-306],"s":[1,3,1],"l":1,"r":[0,0.35,0],"c":9997922,"t":5},{"p":[294,85,-286],"s":[1,2,1],"l":1,"r":[0,-0.17,0],"c":9997922,"t":5},{"p":[293,85,-283],"s":[1,2,1],"l":1,"r":[0,1.05,0],"c":"#988e62","t":5},{"p":[294,85,-278],"s":[1,3,1],"l":1,"r":[0,0.35,0],"c":"#988e62","t":5},{"p":[-224,53,-74],"s":[216,0,229],"i":4,"l":1,"en":1.8,"t":5},{"p":[-277,51,-77],"s":[104,2,202],"v":1,"t":5},{"p":[-139,51,-111],"s":[172,2,130],"v":1,"t":5},{"p":[-211,51,-183],"s":[12,2,14],"v":1,"t":5},{"p":[-201,51,-179],"s":[8,2,6],"v":1,"t":5},{"p":[-183,51,-182],"s":[8,2,12],"v":1,"t":5},{"p":[22,66,-48],"s":[210,0,258],"i":4,"l":1,"en":1.8,"t":5},{"p":[-1,64,0],"s":[140,2,142],"v":1,"t":5},{"p":[-100,64,50],"s":[58,2,42],"v":1,"t":5},{"p":[-149,53,8],"s":[40,13,126],"v":1,"t":5},{"p":[-54,51,-143],"s":[58,15,42],"v":1,"t":5},{"p":[5,64,-123],"s":[60,2,104],"v":1,"t":5},{"p":[-124,51,-285],"s":[203,2,50],"v":1,"t":5},{"p":[343,64,-262],"s":[77,2,72],"v":1,"t":5},{"p":[343,64,-122],"s":[82,2,217],"v":1,"t":5},{"p":[327,64,-11],"s":[140,20,129],"v":1,"t":5},{"p":[202,82,-11],"s":[110,2,165],"v":1,"t":5},{"p":[213,64,-112],"s":[39,20,37],"v":1,"t":5},{"p":[213,64,-207],"s":[40,2,63],"v":1,"t":5},{"p":[-131,66,50],"s":[119,0,210],"i":4,"l":1,"en":1.8,"t":5},{"p":[74,66,-271],"s":[214,0,223],"i":4,"l":1,"en":1.8,"t":5},{"p":[80,51,-272],"s":[226,15,194],"v":1,"t":5},{"p":[80,51,-272],"s":[226,15,194],"l":1,"t":5},{"p":[-185,51,-254],"s":[8,2,12],"v":1,"t":5},{"p":[-195,51,-257],"s":[12,2,6],"v":1,"t":5},{"p":[-216,51,-254],"s":[19,2,12],"v":1,"t":5},{"p":[-195,53,-304],"s":[201,0,97],"i":4,"l":1,"en":1.8,"t":5},{"p":[-65,53,-289],"s":[64,13,195],"i":9,"t":5},{"p":[-149,53,-78],"s":[145,13,46],"i":9,"t":5,"d":1},{"p":[-101,53,-140],"s":[36,13,182],"i":9,"t":5},{"p":[216,66,-157],"s":[197,18,53],"i":9,"t":5,"d":1},{"p":[357,66,-103],"s":[244,18,55],"i":9,"t":5,"d":1},{"p":[344,66,-246],"s":[82,0,234],"i":4,"l":1,"en":1.8,"t":5},{"p":[220,66,-208],"s":[88,0,52],"i":4,"l":1,"en":1.8,"t":5},{"p":[342,84,36],"s":[170,0,223],"i":4,"l":1,"en":1.8,"t":5},{"p":[208,84,-10],"s":[131,0,240],"i":4,"l":1,"en":1.8,"t":5},{"p":[-72,52,-212],"s":[98,50,108],"c":8548950,"t":10,"bo":1},{"p":[65,77,-218],"s":[12,1,12],"l":1,"t":5},{"p":[157,77,-207],"s":[12,1,24],"l":1,"t":5},{"p":[83,77,-363],"s":[24,1,14],"l":1,"t":5},{"p":[17,77,-363],"s":[24,1,14],"l":1,"t":5},{"p":[-1,89,-363],"s":[12,1,12],"l":1,"t":5},{"p":[135,89,-363],"s":[12,1,12],"l":1,"t":5},{"p":[104,77,-301],"s":[12,1,12],"l":1,"t":5},{"p":[-17,77,-184],"s":[12,1,24],"l":1,"t":5},{"p":[28,77,-95],"s":[12,1,12],"l":1,"t":5},{"p":[55,77,-64],"s":[12,1,12],"l":1,"t":5},{"p":[-31,77,-22],"s":[12,1,24],"l":1,"t":5},{"p":[-19,77,-28],"s":[12,1,12],"l":1,"t":5},{"p":[-65,77,-58],"s":[12,1,24],"l":1,"t":5},{"p":[28,89,50],"s":[12,1,12],"l":1,"t":5},{"p":[-88,77,36],"s":[12,1,12],"l":1,"t":5},{"p":[-162,77,-28],"s":[12,1,12],"l":1,"t":5},{"p":[-158,64,-158],"s":[24,1,12],"l":1,"t":5},{"p":[-275,64,-49],"s":[24,1,12],"l":1,"t":5},{"p":[-315,64,6],"s":[12,1,12],"l":1,"t":5},{"p":[-315,64,-80],"s":[12,1,24],"l":1,"t":5},{"p":[-315,76,18],"s":[12,1,12],"l":1,"t":5},{"p":[-231,64,-93],"s":[12,1,12],"l":1,"t":5},{"p":[-128,64,-266],"s":[12,1,12],"l":1,"t":5},{"p":[-116,76,-304],"s":[12,1,12],"l":1,"t":5},{"p":[216,95,40],"s":[12,1,12],"l":1,"t":5},{"p":[157,95,-56],"s":[12,1,12],"l":1,"t":5},{"p":[361,95,31],"s":[12,1,12],"l":1,"t":5},{"p":[300,95,-50],"s":[12,1,12],"l":1,"t":5},{"p":[360,77,-198],"s":[12,1,12],"l":1,"t":5},{"p":[-56,77,-128],"s":[12,1,12],"l":1,"t":5},{"p":[-282,105,25],"s":[88,4,4],"c":8224125,"t":2,"bo":1},{"p":[-282,53,25],"s":[5,57,5],"c":9013641,"t":2,"bo":1},{"p":[-236,53,25],"s":[4,56,4],"c":8553090,"t":2,"bo":1},{"p":[-328,53,25],"s":[4,56,4],"c":9013641,"t":2,"bo":1},{"p":[-234,91,14],"s":[2,4,64],"c":7500402,"t":2},{"p":[76,114,-188],"s":[84,6,43],"c":8878432,"t":10},{"p":[76,114,-94],"s":[84,6,43],"c":8878432,"t":10},{"p":[76,120,-101],"s":[84,5,29],"c":8878432,"t":10},{"p":[76,125,-108],"s":[84,3,16],"c":8878432,"t":10},{"p":[76,128,-112],"s":[84,3,7],"c":8878432,"t":10},{"p":[76,120,-181],"s":[84,5,29],"c":8878432,"t":10},{"p":[76,125,-175],"s":[84,3,16],"c":8878432,"t":10},{"p":[76,128,-170],"s":[84,3,7],"c":8878432,"t":10},{"p":[-270,51,-177],"s":[3,20,10],"i":21,"l":1,"r":[0,-1.57,0]},{"p":[-258,51,24],"s":[3,20,10],"i":21,"l":1,"r":[0,1.57,0]},{"p":[-225,51,-42],"s":[3,20,10],"i":21,"l":1,"r":[-3.14,0,-3.14]},{"p":[-160,64,-3],"s":[3,20,10],"i":21,"l":1},{"p":[-133,65,71],"s":[3,20,10],"i":21,"l":1,"r":[0,1.57,0]},{"p":[34,63,-141],"s":[3,20,10],"i":21,"l":1,"r":[-3.14,0,-3.14]},{"p":[-25,64,-96],"s":[3,20,10],"i":21,"l":1},{"p":[-9,65,56],"s":[3,20,10],"i":21,"l":1,"r":[0,1.57,0]},{"p":[56,85,-2],"s":[3,20,10],"i":21,"l":1,"r":[0,1.57,0]},{"p":[157,85,11],"s":[3,20,10],"i":21,"l":1,"r":[0,-1.57,0]},{"p":[173,83,46],"s":[3,20,10],"i":21,"l":1,"r":[0,1.57,0]},{"p":[86,85,40],"s":[3,20,10],"i":21,"l":1,"r":[0,1.57,0]},{"p":[179,82,-65],"s":[3,20,10],"i":21,"l":1,"r":[0,1.57,0]},{"p":[233,82,-38],"s":[3,20,10],"i":21,"l":1},{"p":[368,84,-28],"s":[3,20,10],"i":21,"l":1},{"p":[96,64,-212],"s":[3,20,10],"i":21,"l":1,"r":[0,1.57,0]},{"p":[-105,52,-266],"s":[3,20,10],"i":21,"l":1,"r":[0,1.57,0]},{"p":[-142,51,-310],"s":[3,20,10],"i":21,"l":1,"r":[0,-1.57,0]},{"p":[-180,51,-301],"s":[3,20,10],"i":21,"l":1,"r":[0,-1.57,0]},{"p":[-225,51,-277],"s":[3,20,10],"i":21,"l":1},{"p":[366,64,-243],"s":[3,20,10],"i":21,"l":1},{"p":[350,64,-296],"s":[3,20,10],"i":21,"l":1,"r":[0,1.57,0]},{"p":[321,64,-172],"s":[3,20,10],"i":21,"l":1,"r":[3.14,0,3.14]},{"p":[-72,104,-212],"s":[99,8,108],"c":8548950,"t":10},{"p":[-72,112,-212],"s":[65,6,108],"c":8548950,"t":10},{"p":[-72,118,-212],"s":[35,6,108],"c":8548950,"t":10},{"p":[127,85,-18],"s":[3,20,10],"i":21,"l":1,"r":[0,-1.57,0]},{"p":[-259,85,23],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-305,85,23],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-235,70,4],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[-226,84,-44],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[-226,84,-81],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[-271,83,-176],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[-308,83,-176],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[-228,96,-164],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[-145,96,-164],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[-197,84,-103],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-102,97,-123],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-130,97,-96],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[-132,92,4],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[-159,99,14],"s":[1,17,17],"i":22,"l":1},{"p":[-22,83,-185],"s":[1,17,17],"i":22,"l":1},{"p":[-24,98,-97],"s":[1,17,17],"i":22,"l":1},{"p":[-224,84,-278],"s":[1,17,17],"i":22,"l":1},{"p":[-187,96,-260],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-76,87,-309],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[-49,83,-267],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[140,88,-194],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[56,92,-213],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[33,92,-188],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[33,92,-93],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[-73,76,70],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[-70,92,5],"s":[1,17,17],"i":22,"l":1},{"p":[42,97,55],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[242,121,45],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[227,100,-90],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[232,92,-211],"s":[1,17,17],"i":22,"l":1,"r":[-3.14,0,-3.14]},{"p":[200,88,-161],"s":[1,17,17],"i":22,"l":1},{"p":[308,105,36],"s":[1,17,17],"i":22,"l":1,"r":[0,1.57,0]},{"p":[322,98,-272],"s":[1,17,17],"i":22,"l":1,"r":[0,-1.57,0]},{"p":[367,92,13],"s":[1,17,17],"i":22,"l":1,"r":[3.14,0,3.14]},{"p":[294,116,-25],"s":[1,17,17],"i":22,"l":1},{"p":[335,100,-92],"s":[1,17,17],"i":22,"l":1},{"p":[322,92,-212],"s":[1,17,17],"i":22,"l":1},{"p":[379,99,-118],"s":[1,17,17],"i":22,"l":1,"r":[3.14,0,3.14]},{"p":[365,78,-179],"s":[1,17,17],"i":22,"l":1,"r":[3.14,0,3.14]},{"p":[175,99,-281],"s":[7,5,9],"c":6247502,"t":11,"bo":1},{"p":[175,103,-312],"s":[6,10,17],"c":10983566,"t":11,"bo":1},{"p":[166,65,-337],"s":[7,3,4],"l":1,"c":4275000,"t":5},{"p":[165,65,-348],"s":[4,3,7],"l":1,"c":4275000,"t":5},{"p":[175,107,-246],"s":[6,5,12],"l":1,"c":10983566,"t":11},{"p":[175,107,-265],"s":[6,3,14],"l":1,"c":10983566,"t":11},{"p":[175,120,-244],"s":[9,5,4],"c":6248017,"t":11,"bo":1},{"p":[165,65,-237],"s":[7,3,4],"l":1,"c":4275000,"t":5},{"p":[183,65,-300],"s":[4,3,7],"l":1,"c":4275000,"t":5},{"p":[167,65,-280],"s":[5,2,4],"l":1,"c":4275000,"t":5},{"p":[48,64,-271],"s":[4,3,7],"l":1,"c":4275000,"t":5},{"p":[102,64,-277],"s":[4,3,7],"l":1,"c":4275000,"t":5},{"p":[229,64,-224],"s":[4,3,7],"l":1,"c":4275000,"t":5},{"p":[267,129,-347],"s":[22,3,10],"c":8220776,"t":11,"bo":1},{"p":[214,105,-236],"s":[4,5,9],"c":10983566,"t":11,"bo":1},{"p":[287,115,-236],"s":[23,5,12],"c":5918536,"t":11,"bo":1},{"p":[237,115,-236],"s":[30,4,9],"c":7563360,"t":11,"bo":1},{"p":[64,64,-364],"s":[6,3,3],"l":1,"c":4275000,"t":5},{"p":[-20,64,-328],"s":[4,3,7],"l":1,"c":4275000,"t":5},{"p":[175,120,-355],"s":[9,5,6],"c":8220776,"t":11,"bo":1},{"p":[176,77,-363],"s":[5,31,22],"c":10983566,"t":11,"bo":1},{"p":[130,77,-371],"s":[90,31,4],"c":10983566,"t":11,"bo":1},{"p":[68,77,-371],"s":[34,24,4],"c":10983566,"t":11,"bo":1},{"p":[12,77,-371],"s":[78,27,4],"c":10983566,"t":11,"bo":1},{"p":[-28,77,-345],"s":[5,29,58],"c":10983566,"t":11,"bo":1},{"p":[-44,77,-315],"s":[27,29,4],"c":10983566,"t":11,"bo":1},{"p":[-28,106,-327],"s":[5,3,14],"l":1,"c":10983566,"t":11},{"p":[-28,106,-363],"s":[5,2,22],"l":1,"c":10983566,"t":11},{"p":[-36,106,-315],"s":[15,3,4],"l":1,"c":10983566,"t":11},{"p":[69,101,-371],"s":[16,3,4],"l":1,"c":10983566,"t":11},{"p":[177,65,-359],"s":[9,12,24],"c":6575952,"t":11},{"p":[64,65,-372],"s":[220,12,8],"c":6379602,"t":11},{"p":[-43,51,-341],"s":[37,26,58],"c":6576209,"t":11},{"p":[-29,77,-317],"s":[9,37,10],"c":6247759,"t":11,"bo":1},{"p":[303,110,-335],"s":[6,4,23],"c":10983566,"t":11,"bo":1},{"p":[291,74,-313],"s":[7,3,4],"l":1,"c":4275000,"t":5},{"p":[294,65,-246],"s":[4,3,7],"l":1,"c":4275000,"t":5},{"p":[303,110,-270],"s":[6,4,24],"c":6708310,"t":11,"bo":1},{"p":[182,65,-263],"s":[4,3,7],"l":1,"c":4275000,"t":5},{"p":[294,65,-335],"s":[4,3,7],"l":1,"c":4275000,"t":5},{"p":[270,65,-339],"s":[8,3,4],"l":1,"c":4275000,"t":5},{"p":[303,123,-340],"s":[9,6,4],"c":8220776,"t":11,"bo":1},{"p":[227,95,-236],"s":[2,5,9],"c":10983566,"t":11,"bo":1},{"p":[303,95,-249],"s":[6,5,2],"c":10983566,"t":11,"bo":1},{"p":[303,101,-263],"s":[6,4,2],"c":10983566,"t":11,"bo":1},{"p":[97,104,-219],"s":[2,2,15],"l":1,"c":7895160,"t":2},{"p":[97,95,-219],"s":[1,8,13],"l":1,"c":7895160,"t":2},{"p":[97,103,-224],"s":[1,1,1],"l":1,"c":7895160,"t":5},{"p":[97,103,-216],"s":[1,1,1],"l":1,"c":7895160,"t":5},{"p":[112,64,-218],"s":[4,3,7],"l":1,"c":4275000,"t":5},{"p":[-96,98,-272],"s":[2,2,18],"l":1,"c":7895160,"t":2},{"p":[-96,89,-274],"s":[1,8,13],"l":1,"c":7895160,"t":2},{"p":[-96,97,-278],"s":[1,1,1],"l":1,"c":7895160,"t":5},{"p":[-96,97,-270],"s":[1,1,1],"l":1,"c":7895160,"t":5},{"p":[-8,107,52],"s":[2,2,17],"l":1,"c":7895160,"t":2},{"p":[-8,100,49],"s":[1,6,9],"l":1,"c":7895160,"t":2},{"p":[-8,106,46],"s":[1,1,1],"l":1,"c":7895160,"t":5},{"p":[-8,106,52],"s":[1,1,1],"l":1,"c":7895160,"t":5},{"p":[-213,50,-197],"s":[4,3,7],"l":1,"c":3092271,"t":5},{"p":[-185,50,-237],"s":[4,3,7],"l":1,"c":3092271,"t":5},{"p":[-199,81,-260],"s":[33,3,3],"c":8684676,"t":2,"bo":1},{"p":[-181,53,-260],"s":[3,31,3],"c":8684676,"t":2,"bo":1},{"p":[-217,53,-260],"s":[3,31,3],"c":8684676,"t":2,"bo":1},{"p":[130,108,-371],"s":[90,1,4],"l":1,"t":5},{"p":[12,104,-371],"s":[78,1,4],"l":1,"t":5},{"p":[69,104,-371],"s":[16,1,4],"l":1,"t":5},{"p":[175,125,-355],"s":[9,1,6],"l":1,"t":5},{"p":[-28,106,-343],"s":[5,1,18],"l":1,"t":5},{"p":[-28,108,-363],"s":[5,1,22],"l":1,"t":5},{"p":[-28,109,-327],"s":[5,1,14],"l":1,"t":5},{"p":[-38,109,-315],"s":[11,1,4],"l":1,"t":5},{"p":[-50,106,-315],"s":[13,1,4],"l":1,"t":5},{"p":[176,108,-361],"s":[5,1,25],"l":1,"t":5},{"p":[175,125,-329],"s":[9,1,26],"l":1,"t":5},{"p":[175,133,-347],"s":[9,1,10],"l":1,"t":5},{"p":[175,113,-312],"s":[6,1,17],"l":1,"t":5},{"p":[175,110,-265],"s":[6,1,14],"l":1,"t":5},{"p":[175,112,-245],"s":[6,1,14],"l":1,"t":5},{"p":[303,114,-267],"s":[6,1,18],"l":1,"t":5},{"p":[303,128,-236],"s":[9,1,12],"l":1,"t":5},{"p":[199,124,-236],"s":[39,1,12],"l":1,"t":5},{"p":[175,132,-236],"s":[9,1,12],"l":1,"t":5},{"p":[303,134,-347],"s":[9,1,10],"l":1,"t":5},{"p":[292,129,-347],"s":[13,1,10],"l":1,"t":5},{"p":[211,129,-347],"s":[63,1,10],"l":1,"t":5},{"p":[300,110,-292],"s":[7,1,12],"l":1,"t":5},{"p":[300,107,-301],"s":[8,1,6],"l":1,"t":5},{"p":[157,85,11],"s":[10,20,1],"pe":1,"v":1,"c":7895160,"t":5},{"p":[56,85,-2],"s":[10,20,1],"pe":1,"v":1,"c":7895160,"t":5},{"p":[303,114,-333],"s":[6,1,19],"l":1,"t":5},{"p":[303,129,-340],"s":[9,1,4],"l":1,"t":5},{"p":[300,95,-62],"s":[12,1,12],"l":1,"t":5},{"p":[296,90,-25],"s":[6,1,6],"l":1,"t":5},{"p":[296,90,-17],"s":[6,1,6],"l":1,"t":5},{"p":[351,90,34],"s":[6,1,6],"l":1,"t":5},{"p":[375,72,-139],"s":[6,1,6],"l":1,"t":5},{"p":[325,72,-210],"s":[6,1,6],"l":1,"t":5},{"p":[325,72,-202],"s":[6,1,6],"l":1,"t":5},{"p":[102,72,-291],"s":[6,1,6],"l":1,"t":5},{"p":[147,72,-198],"s":[6,1,6],"l":1,"t":5},{"p":[152,72,-365],"s":[6,1,6],"l":1,"t":5},{"p":[145,72,-365],"s":[6,1,6],"l":1,"t":5},{"p":[45,72,-66],"s":[6,1,6],"l":1,"t":5},{"p":[-55,72,-66],"s":[6,1,6],"l":1,"t":5},{"p":[-68,72,14],"s":[6,1,6],"l":1,"t":5},{"p":[-68,72,22],"s":[6,1,6],"l":1,"t":5},{"p":[-163,72,54],"s":[6,1,6],"l":1,"t":5},{"p":[-165,72,-38],"s":[6,1,6],"l":1,"t":5},{"p":[-317,59,-173],"s":[6,1,6],"l":1,"t":5},{"p":[-317,59,-56],"s":[6,1,6],"l":1,"t":5},{"p":[-317,59,-64],"s":[6,1,6],"l":1,"t":5},{"p":[-305,59,20],"s":[6,1,6],"l":1,"t":5},{"p":[-269,59,-59],"s":[6,1,6],"l":1,"t":5},{"p":[-222,59,-295],"s":[6,1,6],"l":1,"t":5},{"p":[206,72,-227],"s":[6,1,6],"l":1,"t":5},{"p":[206,72,-220],"s":[6,1,6],"l":1,"t":5},{"p":[-205,51,-258],"s":[3,2,4],"l":1,"t":5},{"p":[-189,51,-180],"s":[4,2,8],"l":1,"t":5},{"p":[-189,51,-180],"s":[4,2,8],"v":1,"t":5},{"p":[61,89,-2],"s":[1,2,1],"pe":1,"c":7895160,"t":5},{"p":[61,99,-2],"s":[1,2,1],"pe":1,"c":7895160,"t":5},{"p":[-8,109,52],"s":[2,1,17],"l":1,"c":"#ffffff","t":5},{"p":[-96,100,-272],"s":[2,1,18],"l":1,"c":"#ffffff","t":5},{"p":[97,106,-219],"s":[2,1,15],"l":1,"c":"#ffffff","t":5},{"p":[-234,95,14],"s":[3,25,64],"v":1,"c":7500402,"t":2},{"p":[55,72,-215],"s":[6,1,6],"l":1,"t":5},{"p":[75,90,-292],"s":[3,16,3],"c":10983566,"t":11},{"p":[75,99,-292],"s":[2,3,12],"c":10983566,"t":11},{"p":[75,102,-292],"s":[2,1,12],"l":1,"t":5},{"p":[75,106,-292],"s":[3,1,3],"l":1,"t":5},{"p":[-276,53,-16],"s":[24,36,24],"i":23,"l":1,"tm":0},{"p":[245,67,-293],"s":[24,36,24],"i":23,"l":1,"tm":"1"},{"p":[-8,100,50],"s":[2,16,13],"v":1,"c":7895160,"t":2,"bo":1},{"p":[238,66,-292],"s":[114,50,95],"i":14,"l":1},{"p":[-273,53,-22],"s":[91,50,86],"i":14,"l":1},{"p":[74,66,-292],"s":[91,50,86],"i":14,"l":1},{"p":[192,84,-9],"s":[73,50,103],"i":14,"l":1},{"p":[-199,83,-212],"s":[36,8,96],"c":8355711,"t":11,"bo":1},{"p":[-329,87,65],"s":[62,1,13],"i":30,"r":[1.57,0,1.57],"st":"Map By  CrispyCrust","sc":"#ffffff","bv":1,"sf":70},{"p":[175,86,-259],"s":[6,21,35],"c":10983566,"t":11,"bo":1},{"p":[175,71,-273],"s":[6,15,7],"c":10983566,"t":11,"bo":1},{"p":[175,71,-247],"s":[6,15,10],"c":10983566,"t":11,"bo":1},{"p":[351,93,-302],"s":[28,28,58],"c":6973550,"t":10,"bo":1},{"p":[365,51,-302],"s":[4,45,58],"c":6973550,"t":10,"bo":1},{"p":[350,51,-297],"s":[30,48,2],"c":6973550,"t":10,"bo":1},{"p":[172,70,-253],"s":[1,17,4],"pe":1,"c":3616550,"t":5},{"p":[172,70,-257],"s":[1,19,4],"pe":1,"c":"#483b2d","t":5},{"p":[172,69,-261],"s":[1,18,4],"pe":1,"c":"#574837","t":5},{"p":[172,69,-265],"s":[1,19,4],"pe":1,"c":"#483b2d","t":5},{"p":[172,70,-269],"s":[1,17,4],"pe":1,"c":3616550,"t":5},{"p":[163,65,-248],"s":[4,2,14],"l":1,"r":[0,-0.61,0],"c":"#5a4938","t":5},{"p":[165,65,-327],"s":[4,2,14],"l":1,"r":[3.14,-0.52,3.14],"c":"#5a4938","t":5},{"p":[293,88,-306],"s":[1,1,1],"l":1,"r":[0,0.35,0],"c":"#000000","e":"#e8b024","t":5,"ab":1},{"p":[294,87,-301],"s":[1,1,1],"l":1,"r":[0,-0.35,0],"c":"#000000","e":"#e8b024","t":5},{"p":[293,88,-297],"s":[1,1,1],"l":1,"c":"#000000","e":"#e8b024","t":5},{"p":[294,88,-278],"s":[1,1,1],"l":1,"r":[0,0.35,0],"c":"#000000","e":"#e8b024","t":5,"ab":1},{"p":[294,87,-286],"s":[1,1,1],"l":1,"r":[0,-0.17,0],"c":"#000000","e":"#e8b024","t":5,"ab":1},{"p":[296,85,-292],"s":[3,3,6],"l":1,"c":"#c3a524","t":5},{"p":[296,85,-292],"s":[4,2,4],"l":1,"c":"#c3a524","t":5},{"p":[296,88,-289],"s":[2,3,3],"l":1,"c":"#c3a524","t":5},{"p":[296,88,-287],"s":[2,1,1],"l":1,"c":"#ff9800","t":5},{"p":[296,89,-289],"s":[3,1,1],"l":1,"c":"#000000","t":5},{"p":[296,88,-295],"s":[2,1,1],"l":1,"c":"#c3a524","t":5},{"p":[299,96,-280],"s":[32,1,9],"i":30,"r":[1.57,0,1.57],"st":"M","bv":1,"sf":120},{"p":[273,76,-267],"s":[1,2,1],"l":1,"r":[0,1.05,0],"c":"#988e62","t":5},{"p":[273,75,-314],"s":[1,2,1],"l":1,"r":[0,1.05,0],"c":"#988e62","t":5},{"p":[289,75,-309],"s":[1,3,1],"l":1,"r":[0,0.61,0],"c":"#988e62","t":5},{"p":[274,75,-272],"s":[1,3,1],"l":1,"r":[0,0.61,0],"c":"#988e62","t":5},{"p":[244,67,-331],"s":[2,5,2],"l":1,"c":"#000000","t":5},{"p":[244,67,-334],"s":[2,5,2],"l":1,"c":"#000000","t":5},{"p":[241,71,-331],"s":[8,2,2],"l":1,"c":"#000000","t":5},{"p":[241,71,-334],"s":[8,2,2],"l":1,"c":"#000000","t":5},{"p":[238,71,-332],"s":[3,9,5],"l":1,"c":"#000000","t":5},{"p":[239,80,-332],"s":[3,3,3],"l":1,"c":"#000000","t":5},{"p":[238,71,-332],"s":[2,8,7],"l":1,"c":"#000000","t":5},{"p":[274,78,-272],"s":[1,1,1],"l":1,"r":[0,0.61,0],"c":"#000000","e":"#e8b024","t":5},{"p":[273,78,-267],"s":[1,1,1],"l":1,"r":[0,1.05,0],"c":"#000000","e":"#e8b024","t":5},{"p":[289,78,-309],"s":[1,1,1],"l":1,"r":[0,0.61,0],"c":"#000000","e":"#e8b024","t":5,"ab":1},{"p":[273,77,-314],"s":[1,1,1],"l":1,"r":[0,1.05,0],"c":"#000000","e":"#e8b024","t":5,"ab":1},{"p":[240,71,-327],"s":[1,1,5],"l":1,"c":"#283e09","t":5},{"p":[240,71,-324],"s":[1,1,1],"l":1,"r":[0.5,-0.17,-0.31],"c":"#3e0808","t":5},{"p":[240,71,-324],"s":[1,1,1],"l":1,"r":[0.8,0.66,-0.39],"c":"#3e0808","t":5},{"p":[240,71,-324],"s":[1,1,1],"l":1,"r":[0.8,0.66,-0.39],"c":"#3e0808","t":5},{"p":[240,71,-324],"s":[2,1,1],"l":1,"c":"#3e0808","t":5},{"p":[299,75,-273],"s":[1,3,1],"l":1,"r":[0,0.35,0],"c":"#988e62","t":5},{"p":[299,78,-273],"s":[1,1,1],"l":1,"r":[0,0.35,0],"c":"#000000","e":"#e8b024","t":5,"ab":1},{"p":[298,75,-268],"s":[1,2,1],"l":1,"r":[0,-0.26,0],"c":"#988e62","t":5},{"p":[298,77,-268],"s":[1,1,1],"l":1,"r":[0,-0.17,0],"c":"#000000","e":"#e8b024","t":5,"ab":1},{"p":[290,75,-277],"s":[1,3,1],"l":1,"r":[0,-0.26,0],"c":"#988e62","t":5},{"p":[290,78,-277],"s":[1,1,1],"l":1,"r":[0,-0.26,0],"c":"#000000","e":"#e8b024","t":5,"ab":1},{"p":[-97,93,-274],"s":[11,0,6],"i":11,"l":1,"r":[1.57,0,-1.57],"sad":1},{"p":[-95,93,-274],"s":[11,0,6],"i":11,"l":1,"r":[1.57,0,1.57],"sad":1},{"p":[98,99,-219],"s":[12,0,7],"i":11,"l":1,"r":[1.57,0,1.57],"sad":1},{"p":[96,99,-219],"s":[12,0,7],"i":11,"l":1,"r":[1.57,0,-1.57],"sad":1},{"p":[12,123,-378],"s":[63,0,29],"i":11,"l":1,"r":[1.57,0,0],"sad":1},{"p":[12,107,-381],"s":[67,32,4],"c":"#554235","t":5},{"p":[-17,89,-382],"s":[4,52,4],"l":1,"c":"#554235","t":5},{"p":[41,89,-382],"s":[4,52,4],"l":1,"c":"#554235","t":5},{"p":[245,122,-60],"s":[3,32,3],"l":1,"c":"#554235","t":5},{"p":[245,122,-8],"s":[3,32,3],"l":1,"c":"#554235","t":5},{"p":[243,124,-34],"s":[1,28,58],"c":"#554235","t":5},{"p":[242,138,-33],"s":[55,0,25],"i":11,"l":1,"r":[1.57,0,-1.57],"sad":1}]};
    
    /***/ }),
    
    /***/ "./maps/undergrowth.json":
    /*!*******************************!*\
      !*** ./maps/undergrowth.json ***!
      \*******************************/
    /*! exports provided: name, ambInd, skyDome, skyDomeCol0, skyDomeCol1, skyDomeCol2, shadowR, ambient, light, sky, fog, fogD, camPos, spawns, objects, default */
    /***/ (function(module) {
    
    module.exports = {"name":"Undergrowth","ambInd":"3","skyDome":true,"skyDomeCol0":"#3983a2","skyDomeCol1":"#87ceeb","skyDomeCol2":"#dce8ed","shadowR":1297.054320662896,"ambient":"#97a0a8","light":"#f2f8fc","sky":"#dce8ed","fog":9280160,"fogD":2000,"camPos":[0,38,-387],"spawns":[[345,2,-169,0,1,0],[100,2,-229,0,2,0],[56,13,-449,0,1,0],[332,2,-543,0,0,0],[332,2,-189,0,0,0],[280,13,-177,0,2,0],[-18,2,-104,0,1,0],[182,2,26,0,3,0]],"objects":[{"p":[3,0,-211],"s":[224,2,190],"c":"#9d9d9d","t":1},{"p":[190,0,-58],"s":[134,2,200],"c":"#9d9d9d","t":1},{"p":[210,-16,-226],"s":[162,29,120],"c":"#9d9d9d","t":1},{"p":[233,2,-141],"s":[44,11,50],"i":9,"c":"#9d9d9d","t":1,"d":3},{"p":[218,-11,-321],"s":[62,24,70],"c":"#9d9d9d","t":1},{"p":[107,11,-334],"s":[44,2,57],"c":"#9d9d9d","t":1},{"p":[-5,11,-385],"s":[180,2,158],"c":"#9d9d9d","t":1},{"p":[295,0,-32],"s":[76,2,50],"c":"#434343","e":"#18180a"},{"p":[407,0,-90],"s":[148,2,176],"c":"#434343","e":"#18180a"},{"p":[-5,19,-440],"s":[74,2,77],"c":"#9d9d9d","t":1},{"p":[256,0,-400],"s":[126,2,128],"c":"#9d9d9d","t":1},{"p":[222,2,-378],"s":[46,11,44],"i":9,"c":"#9d9d9d","t":1,"d":1},{"p":[379,0,-481],"s":[120,2,230],"c":"#9d9d9d","t":1},{"p":[61,0,-87],"s":[124,2,58],"c":"#9d9d9d","t":1},{"p":[23,0,-42],"s":[48,2,32],"c":"#9d9d9d","t":1},{"p":[400,0,-350],"s":[46,2,32],"c":"#9d9d9d","t":1},{"p":[335,0,-268],"s":[145,2,44],"c":"#9d9d9d","t":1},{"p":[378,0,-312],"s":[90,2,44],"c":"#9d9d9d","t":1},{"p":[-49,-4,-288],"s":[48,17,36],"c":"#9d9d9d","t":1},{"p":[310,2,-263],"s":[38,11,46],"i":9,"c":"#9d9d9d","t":1,"d":2},{"p":[294,0,17],"s":[78,38,50],"c":"#ffffff","e":"#18180a"},{"p":[114,0,-40],"s":[34,46,36],"c":"#595959","e":"#11110c","bo":1},{"p":[408,8,-4],"s":[147,50,3],"c":"#ffffff","e":"#18180a","bo":1},{"p":[471,0,-323],"s":[96,54,154],"c":"#ffffff","e":"#18180a"},{"p":[406,0,-268],"s":[35,54,44],"c":"#ffffff","e":"#18180a"},{"p":[297,0,-534],"s":[44,41,162],"c":"#ffffff","e":"#18180a"},{"p":[371,0,-605],"s":[104,41,32],"c":"#ffffff","e":"#18180a"},{"p":[-38,38,-49],"s":[76,4,28],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[23,0,-24],"s":[48,23,4]},{"p":[121,0,-201],"s":[17,34,88],"c":"#ffffff","e":"#18180a"},{"p":[170,0,-144],"s":[82,34,44],"c":"#ffffff","e":"#18180a"},{"p":[-111,0,-448],"s":[62,67,156],"c":"#ffffff","e":"#18180a"},{"p":[-46,0,-502],"s":[80,49,48],"c":"#ffffff","e":"#18180a"},{"p":[40,0,-494],"s":[92,67,64],"c":"#ffffff","e":"#18180a"},{"p":[32,13,-432],"s":[4,10,68],"e":"#18180a"},{"p":[-5,13,-400],"s":[70,10,4],"e":"#18180a"},{"p":[-42,13,-410],"s":[4,10,24],"e":"#18180a"},{"p":[-61,19,-451],"s":[38,2,58],"c":"#9d9d9d","t":1},{"p":[-62,13,-410],"s":[36,8,24],"i":9,"c":"#9d9d9d","t":1,"d":3},{"p":[187,13,-287],"s":[4,19,12],"e":"#18180a"},{"p":[187,13,-319],"s":[4,15,4],"e":"#18180a"},{"p":[187,13,-350],"s":[4,19,12],"e":"#18180a"},{"p":[187,13,-343],"s":[4,7,2],"e":"#18180a"},{"p":[187,13,-279],"s":[4,7,4],"e":"#18180a"},{"p":[187,13,-233],"s":[4,19,23],"e":"#18180a"},{"p":[187,13,-251],"s":[4,11,13],"e":"#18180a"},{"p":[355,0,-350],"s":[44,54,32],"c":"#ffffff","e":"#18180a"},{"p":[289,0,-343],"s":[88,54,114],"c":"#ffffff","e":"#18180a"},{"p":[386,6,-67],"s":[10,50,10],"c":"#707070","e":"#18180a","t":11},{"p":[386,6,-118],"s":[10,21,10],"c":"#707070","e":"#18180a","t":11},{"p":[208,0,37],"s":[6,39,7],"l":1,"r":[0.17,0,0],"c":"#a7a7a7","e":"#18180a"},{"p":[230,0,37],"s":[6,39,7],"l":1,"r":[0.17,0,0],"c":"#a7a7a7","e":"#18180a"},{"p":[248,0,40],"s":[8,45,8],"c":"#6e6e6e","e":"#18180a","t":5,"bo":1},{"p":[190,0,40],"s":[8,45,8],"c":"#6e6e6e","e":"#18180a","t":5,"bo":1},{"p":[191,39,40],"s":[112,4,7],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[191,30,40],"s":[112,4,7],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[191,34,40],"s":[114,5,4],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[149,0,37],"s":[6,39,7],"l":1,"r":[0.17,0,0],"c":"#a7a7a7","e":"#18180a"},{"p":[171,0,37],"s":[6,39,7],"l":1,"r":[0.17,0,0],"c":"#a7a7a7","e":"#18180a"},{"p":[133,0,40],"s":[8,45,8],"c":"#6e6e6e","e":"#18180a","t":5,"bo":1},{"p":[191,0,40],"s":[112,32,4],"c":"#ffffff","e":"#18180a"},{"p":[133,2,12],"s":[21,1,71],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[134,2,-39],"s":[15,1,31],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[188,2,-50],"s":[49,1,41],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[211,2,28],"s":[29,1,20],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[241,2,28],"s":[31,1,40],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[150,2,-3],"s":[13,1,12],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[92,2,-61],"s":[90,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[143,3,34],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#85aa6c"},{"p":[130,3,28],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.05,0],"c":"#85aa6c"},{"p":[165,3,35],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.35,0],"c":"#85aa6c"},{"p":[136,3,-47],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.53,0],"c":"#85aa6c"},{"p":[110,0,-6],"s":[28,39,36],"c":"#595959","e":"#11110c","bo":1},{"p":[110,0,27],"s":[38,49,36],"c":"#595959","e":"#11110c","bo":1},{"p":[114,0,-23],"s":[38,31,25],"c":"#595959","e":"#11110c","bo":1},{"p":[110,39,-6],"s":[28,2,36],"c":"#8e8e8e","t":8,"bo":1},{"p":[114,31,-23],"s":[38,2,25],"c":"#8e8e8e","t":8,"bo":1},{"p":[114,46,-40],"s":[34,2,36],"c":"#8e8e8e","t":8,"bo":1},{"p":[110,49,27],"s":[38,2,36],"c":"#8e8e8e","t":8,"bo":1},{"p":[88,0,-45],"s":[28,38,36],"c":"#595959","e":"#11110c","bo":1},{"p":[66,0,-40],"s":[38,42,36],"c":"#595959","e":"#11110c","bo":1},{"p":[46,0,-14],"s":[38,36,36],"c":"#595959","e":"#11110c","bo":1},{"p":[8,0,-9],"s":[38,31,36],"c":"#595959","e":"#11110c","bo":1},{"p":[-4,0,-19],"s":[30,54,32],"c":"#595959","e":"#11110c","bo":1},{"p":[88,38,-45],"s":[28,2,36],"c":"#8e8e8e","t":8,"bo":1},{"p":[66,42,-40],"s":[38,2,36],"c":"#8e8e8e","t":8,"bo":1},{"p":[46,36,-14],"s":[38,2,36],"c":"#8e8e8e","t":8,"bo":1},{"p":[8,31,-9],"s":[38,2,36],"c":"#8e8e8e","t":8,"bo":1},{"p":[-4,54,-19],"s":[30,2,32],"c":"#8e8e8e","t":8,"bo":1},{"p":[78,2,-70],"s":[45,1,5],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[39,2,-44],"s":[16,1,40],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[15,2,-38],"s":[32,1,26],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[193,0,-48],"s":[26,53,26],"c":"#ffffff","e":"#18180a"},{"p":[193,2,-48],"s":[28,7,28],"c":"#a7a7a7","e":"#18180a"},{"p":[205,0,-36],"s":[6,53,6],"c":"#6e6e6e","e":"#18180a","t":5},{"p":[205,0,-60],"s":[6,53,6],"c":"#6e6e6e","e":"#18180a","t":5},{"p":[181,0,-60],"s":[6,53,6],"c":"#6e6e6e","e":"#18180a","t":5},{"p":[181,0,-36],"s":[6,53,6],"c":"#6e6e6e","e":"#18180a","t":5},{"p":[193,53,-48],"s":[32,4,32],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[193,61,-48],"s":[32,4,32],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[193,57,-48],"s":[30,4,30],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[170,2,21],"s":[53,1,36],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[194,2,-24],"s":[31,1,11],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[216,2,-51],"s":[7,1,25],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[190,2,-74],"s":[37,1,7],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[200,2,-69],"s":[12,12,12],"i":8},{"p":[188,2,-69],"s":[12,12,12],"i":8,"r":[0,1.57,0]},{"p":[194,8,-69],"s":[24,7,12],"l":1,"c":"#3964a2","t":5,"ab":1},{"p":[269,0,43],"s":[35,53,41],"c":"#595959","e":"#11110c","bo":1},{"p":[257,0,26],"s":[21,29,21],"c":"#595959","e":"#11110c","bo":1},{"p":[247,2,3],"s":[18,1,10],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[257,29,26],"s":[21,2,21],"c":"#8e8e8e","t":8,"bo":1},{"p":[269,53,43],"s":[35,2,41],"c":"#8e8e8e","t":8,"bo":1},{"p":[242,3,34],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.22,3.14],"c":"#85aa6c"},{"p":[251,3,11],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.04,3.14],"c":"#85aa6c"},{"p":[199,3,-30],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.39,3.14],"c":"#85aa6c"},{"p":[209,3,-66],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.36,0],"c":"#85aa6c"},{"p":[171,3,-62],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.88,0],"c":"#85aa6c"},{"p":[70,3,-61],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.23,0],"c":"#85aa6c"},{"p":[43,3,-36],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.39,3.14],"c":"#85aa6c"},{"p":[14,3,-30],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.88,0],"c":"#85aa6c"},{"p":[148,0,75],"s":[65,109,54],"i":15,"l":1,"c":"#4c663e"},{"p":[212,-9,75],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.57,0],"c":"#4c663e"},{"p":[258,-30,101],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.35,0],"c":"#4c663e"},{"p":[156,-36,116],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.35,0],"c":"#4c663e"},{"p":[257,0,-14],"s":[5,30,5],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[257,0,-50],"s":[5,30,5],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[257,30,-32],"s":[5,5,43],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[257,0,-56],"s":[8,56,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[257,0,-8],"s":[8,56,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[258,0,-163],"s":[8,38,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[258,0,-109],"s":[8,38,8],"c":"#a7a7a7","e":"#18180a"},{"p":[272,38,-112],"s":[36,4,110],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[291,46,-110],"s":[74,4,114],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[293,42,-111],"s":[74,4,108],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[255,2,-103],"s":[21,1,92],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[242,2,-83],"s":[5,1,29],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[261,2,-50],"s":[25,1,14],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[278,2,-53],"s":[9,1,6],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[258,2,-11],"s":[15,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[273,2,-11],"s":[15,1,6],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[185,2,-115],"s":[65,1,23],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[134,2,-115],"s":[37,1,12],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[196,2,-101],"s":[29,1,5],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[89,2,-130],"s":[53,1,47],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[96,2,-103],"s":[20,1,7],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[294,38,17],"s":[80,4,56],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[294,46,17],"s":[80,4,56],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[294,42,17],"s":[76,4,50],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[345,61,-32],"s":[180,5,50],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[257,35,-32],"s":[3,21,43],"c":"#ffffff","e":"#18180a"},{"p":[291,56,-32],"s":[76,5,56],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[291,66,-32],"s":[76,5,56],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[293,50,-8],"s":[77,7,6],"c":"#ffffff","e":"#18180a"},{"p":[293,50,-56],"s":[77,7,6],"c":"#ffffff","e":"#18180a"},{"p":[264,3,-51],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.4,0],"c":"#85aa6c"},{"p":[251,3,-64],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.18,0],"c":"#85aa6c"},{"p":[208,3,-112],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#85aa6c"},{"p":[263,40,-32],"s":[9,5,50],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[295,40,-51],"s":[55,5,12],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[327,40,-32],"s":[9,5,50],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[333,2,-50],"s":[5,28,5],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[333,30,-32],"s":[5,5,41],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[333,2,-14],"s":[5,28,5],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[333,35,-32],"s":[3,25,55],"c":"#ffffff","e":"#18180a"},{"p":[295,40,-13],"s":[55,5,12],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[333,8,-56],"s":[7,38,8],"c":"#a7a7a7","e":"#18180a"},{"p":[333,0,-8],"s":[7,45,8],"c":"#a7a7a7","e":"#18180a"},{"p":[251,2,-88],"s":[1,19,4],"l":1,"r":[0,0,-0.17],"c":"#bbbbbb","t":2},{"p":[251,2,-96],"s":[1,19,4],"l":1,"r":[0,0,-0.17],"c":"#bbbbbb","t":2},{"p":[293,30,-9],"s":[77,5,2],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[293,30,-55],"s":[77,5,2],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[258,0,-109],"s":[7,12,101],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[258,0,10],"s":[7,12,28],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[371,0,-212],"s":[161,2,68],"c":"#9d9d9d","t":1},{"p":[333,8,-75],"s":[5,48,31],"c":"#ffffff","e":"#18180a"},{"p":[429,42,-91],"s":[16,6,173],"c":"#a7a7a7","e":"#18180a"},{"p":[422,56,-94],"s":[30,5,178],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[383,61,-105],"s":[104,5,96],"c":"#e8e8e8","e":"#18180a","t":11,"bo":1},{"p":[342,42,-77],"s":[18,6,144],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[386,42,-12],"s":[70,6,16],"c":"#a7a7a7","e":"#18180a"},{"p":[403,42,-169],"s":[36,6,15],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[386,0,-67],"s":[12,6,12],"c":"#a7a7a7","e":"#18180a"},{"p":[386,56,-118],"s":[12,5,12],"c":"#e1e1e1","e":"#18180a"},{"p":[386,2,-118],"s":[12,4,12],"c":"#a7a7a7","e":"#18180a"},{"p":[333,8,-172],"s":[7,38,8],"c":"#a7a7a7","e":"#18180a"},{"p":[333,0,-180],"s":[8,53,6],"c":"#a7a7a7","e":"#18180a"},{"p":[383,66,-81],"s":[108,5,152],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[441,30,-214],"s":[7,4,49],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[441,34,-213],"s":[4,5,51],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[441,2,-215],"s":[4,29,48],"c":"#ffffff","e":"#18180a"},{"p":[441,0,-187],"s":[8,45,8],"c":"#6e6e6e","e":"#18180a","t":5,"bo":1},{"p":[441,0,-242],"s":[8,45,8],"c":"#6e6e6e","e":"#18180a","t":5,"bo":1},{"p":[437,-5,-204],"s":[7,39,6],"l":1,"r":[0,0,-0.17],"c":"#a7a7a7","e":"#18180a"},{"p":[437,-5,-225],"s":[7,39,6],"l":1,"r":[0,0,-0.17],"c":"#a7a7a7","e":"#18180a"},{"p":[340,8,-177],"s":[8,34,3],"c":"#a7a7a7","e":"#18180a"},{"p":[356,18,-189],"s":[48,1,12],"pe":1,"c":"#878787","t":2},{"p":[346,34,-189],"s":[28,1,12],"pe":1,"c":"#878787","t":2},{"p":[359,1,-194],"s":[1,35,1],"c":"#757575","t":5},{"p":[333,1,-194],"s":[1,35,1],"c":"#757575","t":5},{"p":[333,1,-184],"s":[1,35,1],"c":"#757575","t":5},{"p":[359,1,-184],"s":[1,35,1],"c":"#757575","t":5},{"p":[379,1,-194],"s":[1,19,1],"c":"#757575","t":5},{"p":[379,1,-184],"s":[1,19,1],"c":"#757575","t":5},{"p":[359,9,-194],"s":[2,1,2],"l":1,"c":"#757575","t":5},{"p":[333,9,-194],"s":[2,1,2],"l":1,"c":"#757575","t":5},{"p":[333,26,-194],"s":[2,1,2],"l":1,"c":"#757575","t":5},{"p":[359,26,-194],"s":[2,1,2],"l":1,"c":"#757575","t":5},{"p":[379,9,-194],"s":[2,1,2],"l":1,"c":"#757575","t":5},{"p":[379,9,-184],"s":[2,1,2],"l":1,"c":"#757575","t":5},{"p":[359,9,-184],"s":[2,1,2],"l":1,"c":"#757575","t":5},{"p":[333,9,-184],"s":[2,1,2],"l":1,"c":"#757575","t":5},{"p":[333,26,-184],"s":[2,1,2],"l":1,"c":"#757575","t":5},{"p":[359,26,-184],"s":[2,1,2],"l":1,"c":"#757575","t":5},{"p":[383,2,-189],"s":[15,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[352,2,-192],"s":[47,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[336,2,-215],"s":[15,1,25],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[353,2,-206],"s":[19,1,7],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[329,2,-236],"s":[20,1,17],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[389,3,-188],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.22,-3.14],"c":"#85aa6c"},{"p":[333,3,-187],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#85aa6c"},{"p":[322,0,-205],"s":[18,29,21],"c":"#595959","e":"#11110c"},{"p":[310,0,-224],"s":[38,57,32],"c":"#595959","e":"#11110c","bo":1},{"p":[305,0,-204],"s":[38,50,32],"c":"#595959","e":"#11110c","bo":1},{"p":[309,66,-183],"s":[40,2,36],"c":"#8e8e8e","e":"#11110c","t":8,"bo":1},{"p":[305,50,-204],"s":[38,2,32],"c":"#8e8e8e","e":"#11110c","t":8,"bo":1},{"p":[310,57,-224],"s":[38,2,32],"c":"#8e8e8e","e":"#11110c","t":8,"bo":1},{"p":[322,29,-205],"s":[18,2,21],"c":"#8e8e8e","e":"#11110c","t":8},{"p":[332,3,-219],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.4,0],"c":"#85aa6c"},{"p":[340,8,-3],"s":[8,34,7],"c":"#a7a7a7","e":"#18180a"},{"p":[432,8,-3],"s":[8,34,7],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[386,8,-5],"s":[8,34,3],"c":"#a7a7a7","e":"#18180a"},{"p":[386,8,-177],"s":[8,34,3],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[331,45,-10],"s":[4,11,4],"c":"#a7a7a7","e":"#18180a"},{"p":[331,45,-54],"s":[4,11,4],"c":"#a7a7a7","e":"#18180a"},{"p":[335,49,-32],"s":[1,7,55],"c":"#ffffff","e":"#18180a"},{"p":[333,8,-133],"s":[7,35,8],"c":"#a7a7a7","e":"#18180a"},{"p":[333,8,-94],"s":[7,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[419,41,-91],"s":[4,8,142],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[386,41,-22],"s":[62,8,4],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[353,41,-79],"s":[4,8,118],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[400,41,-160],"s":[34,8,4],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[347,56,-76],"s":[36,5,142],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[386,56,-152],"s":[42,5,18],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[386,56,-23],"s":[42,5,36],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[386,57,-67],"s":[12,4,12],"c":"#e1e1e1","e":"#18180a"},{"p":[188,11,-221],"s":[26,53,26],"c":"#ffffff","e":"#18180a"},{"p":[188,13,-221],"s":[28,7,28],"c":"#a7a7a7","e":"#18180a"},{"p":[200,11,-209],"s":[6,53,6],"c":"#6e6e6e","e":"#18180a","t":5},{"p":[200,11,-233],"s":[6,53,6],"c":"#6e6e6e","e":"#18180a","t":5},{"p":[176,11,-233],"s":[6,53,6],"c":"#6e6e6e","e":"#18180a","t":5},{"p":[176,11,-209],"s":[6,53,6],"c":"#6e6e6e","e":"#18180a","t":5},{"p":[188,64,-221],"s":[32,4,32],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[188,72,-221],"s":[32,4,32],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[188,68,-221],"s":[30,4,30],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[171,14,-215],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.88,0],"c":"#85aa6c"},{"p":[283,13,-193],"s":[16,1,28],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[277,13,-172],"s":[25,1,14],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[260,13,-169],"s":[9,1,8],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[270,13,-213],"s":[37,1,12],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[241,13,-220],"s":[21,1,19],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[204,13,-211],"s":[23,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[272,13,-202],"s":[6,1,10],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[180,13,-211],"s":[25,1,24],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[193,13,-231],"s":[45,1,16],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[166,13,-209],"s":[3,1,16],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[183,13,-197],"s":[13,1,4],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[185,13,-249],"s":[15,1,20],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[199,13,-242],"s":[13,1,6],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[186,13,-261],"s":[9,1,4],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[256,14,-214],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.18,0],"c":"#85aa6c"},{"p":[282,14,-212],"s":[7,6,8],"i":18,"l":1,"r":[0,0.69,0],"c":"#85aa6c"},{"p":[286,14,-170],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.71,0],"c":"#85aa6c"},{"p":[264,14,-169],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.38,-3.14],"c":"#85aa6c"},{"p":[186,-47,75],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.7,0],"c":"#4c663e"},{"p":[213,-40,126],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.7,0],"c":"#4c663e"},{"p":[99,-20,65],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.7,0],"c":"#4c663e"},{"p":[318,-13,75],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.35,0],"c":"#4c663e"},{"p":[266,13,-213],"s":[65,109,54],"i":15,"l":1,"c":"#4c663e"},{"p":[73,-2,-458],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,0.53,3.14],"c":"#4c663e"},{"p":[22,-23,-31],"s":[65,109,54],"i":15,"l":1,"r":[0,1.4,0],"c":"#4c663e"},{"p":[44,-31,85],"s":[65,109,54],"i":15,"l":1,"r":[0,0.35,0],"c":"#4c663e"},{"p":[-2,-42,85],"s":[65,109,54],"i":15,"l":1,"c":"#4c663e"},{"p":[22,0,-32],"s":[6,49,6],"v":1,"c":"#6e6e6e","e":"#18180a","t":5},{"p":[22,0,-32],"s":[7,49,7],"v":1,"c":"#6e6e6e","e":"#18180a","t":5,"bo":1},{"p":[208,0,-119],"s":[8,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[76,0,-119],"s":[8,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[76,0,-213],"s":[8,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[126,0,-171],"s":[8,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[134,0,-163],"s":[8,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[208,0,-163],"s":[8,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[143,0,-119],"s":[8,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[142,0,-119],"s":[127,12,6],"c":"#ffffff","e":"#18180a"},{"p":[142,25,-119],"s":[127,9,6],"c":"#ffffff","e":"#18180a"},{"p":[142,12,-119],"s":[127,2,7],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[142,23,-119],"s":[127,2,7],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[142,9,-122],"s":[127,15,1],"c":"#707070","e":"#18180a","t":11},{"p":[110,14,-119],"s":[3,9,3],"c":"#c5c5c5","e":"#18180a"},{"p":[135,14,-119],"s":[3,9,3],"c":"#c5c5c5","e":"#18180a"},{"p":[84,14,-119],"s":[3,9,3],"c":"#c5c5c5","e":"#18180a"},{"p":[96,14,-119],"s":[3,9,3],"c":"#c5c5c5","e":"#18180a"},{"p":[123,14,-119],"s":[3,9,3],"c":"#c5c5c5","e":"#18180a"},{"p":[151,14,-119],"s":[3,9,3],"c":"#c5c5c5","e":"#18180a"},{"p":[200,14,-119],"s":[3,9,3],"c":"#c5c5c5","e":"#18180a"},{"p":[176,14,-119],"s":[3,9,3],"c":"#c5c5c5","e":"#18180a"},{"p":[163,14,-119],"s":[3,9,3],"c":"#c5c5c5","e":"#18180a"},{"p":[188,14,-119],"s":[3,9,3],"c":"#c5c5c5","e":"#18180a"},{"p":[142,34,-141],"s":[140,4,52],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[142,38,-141],"s":[136,4,48],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[142,42,-141],"s":[140,4,52],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[7,2,-214],"s":[24,1,28],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[17,2,-237],"s":[34,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[6,2,-60],"s":[13,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[16,2,-56],"s":[7,1,10],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[3,2,-111],"s":[10,1,8],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-5,2,-118],"s":[26,1,6],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-25,2,-116],"s":[14,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-13,2,-123],"s":[10,1,4],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-69,2,-128],"s":[21,1,25],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-72,2,-159],"s":[17,1,37],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-62,2,-150],"s":[3,1,19],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-17,2,-212],"s":[24,1,17],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-76,2,-212],"s":[22,1,39],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-74,2,-185],"s":[10,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[61,2,-124],"s":[3,1,22],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[16,2,-175],"s":[12,12,12],"i":8},{"p":[28,2,-175],"s":[12,12,12],"i":8,"r":[0,1.57,0]},{"p":[22,8,-175],"s":[24,7,12],"l":1,"c":"#3964a2","t":5,"ab":1},{"p":[69,3,-153],"s":[1,18,5],"l":1,"r":[0,0,-0.17],"c":"#c8c8c8","t":2},{"p":[69,3,-145],"s":[1,18,5],"l":1,"r":[0,0,-0.17],"c":"#c8c8c8","t":2},{"p":[-49,54,-258],"s":[48,7,96],"c":"#ffffff","e":"#18180a"},{"p":[-4,0,-113],"s":[8,38,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-2,0,-93],"s":[2,38,4],"c":"#ffffff","e":"#18180a"},{"p":[-38,46,-74],"s":[76,4,86],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-39,42,-75],"s":[74,4,80],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[-38,50,-76],"s":[42,13,50],"c":"#ffffff","e":"#18180a"},{"p":[-38,63,-76],"s":[44,4,52],"c":"#a7a7a7","e":"#18180a"},{"p":[-38,67,-76],"s":[41,4,48],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[-38,71,-76],"s":[44,4,52],"c":"#a7a7a7","e":"#18180a"},{"p":[-16,0,-116],"s":[20,12,1],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[-19,50,-99],"s":[6,13,6],"c":"#a7a7a7","e":"#18180a"},{"p":[-57,50,-99],"s":[6,13,6],"c":"#a7a7a7","e":"#18180a"},{"p":[-19,50,-53],"s":[6,13,6],"c":"#a7a7a7","e":"#18180a"},{"p":[-57,50,-53],"s":[6,13,6],"c":"#a7a7a7","e":"#18180a"},{"p":[-30,-34,6],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.7,0],"c":"#4c663e"},{"p":[-2,-24,41],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.22,0],"c":"#4c663e"},{"p":[68,0,-274],"s":[122,61,64],"c":"#ffffff","e":"#18180a"},{"p":[-86,0,-154],"s":[28,37,36],"c":"#595959","e":"#11110c","bo":1},{"p":[-89,0,-130],"s":[28,53,38],"c":"#595959","e":"#11110c","bo":1},{"p":[-93,0,-178],"s":[28,46,38],"c":"#595959","e":"#11110c","bo":1},{"p":[-91,0,-203],"s":[28,41,27],"c":"#595959","e":"#11110c","bo":1},{"p":[-86,37,-154],"s":[28,2,36],"c":"#8e8e8e","t":8,"bo":1},{"p":[-93,46,-178],"s":[28,2,38],"c":"#8e8e8e","t":8,"bo":1},{"p":[-91,41,-203],"s":[28,2,27],"c":"#8e8e8e","t":8,"bo":1},{"p":[-89,53,-130],"s":[28,2,38],"c":"#8e8e8e","t":8,"bo":1},{"p":[4,3,-112],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.88,0],"c":"#85aa6c"},{"p":[4,3,-63],"s":[7,6,8],"i":18,"l":1,"r":[0,1.39,0],"c":"#85aa6c"},{"p":[-70,3,-121],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.71,0],"c":"#85aa6c"},{"p":[-71,3,-133],"s":[7,6,8],"i":18,"l":1,"r":[0,0.51,0],"c":"#85aa6c"},{"p":[-76,3,-176],"s":[7,6,8],"i":18,"l":1,"r":[0,1.21,0],"c":"#85aa6c"},{"p":[-72,3,-205],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.88,-3.14],"c":"#85aa6c"},{"p":[69,3,-126],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.04,3.14],"c":"#85aa6c"},{"p":[-148,-23,-143],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,-1.23,-3.14],"c":"#4c663e"},{"p":[-148,-35,-209],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,-0.71,-3.14],"c":"#4c663e"},{"p":[-148,-25,-83],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.04,0],"c":"#4c663e"},{"p":[-87,-25,-9],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.56,0],"c":"#4c663e"},{"p":[103,-36,128],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.52,0],"c":"#4c663e"},{"p":[19,52,-450],"s":[1,28,1],"l":1,"c":"#8e8e8e","t":2},{"p":[-50,50,-116],"s":[2,2,20],"c":"#c8c8c8","t":2,"bo":1},{"p":[-50,41,-115],"s":[1,13,2],"l":1,"r":[-0.7,0,0],"c":"#c8c8c8","t":2},{"p":[6,2,-53],"s":[12,12,12],"i":1},{"p":[6,2,-41],"s":[12,12,12],"i":1},{"p":[70,46,-138],"s":[21,2,2],"c":"#c8c8c8","t":2,"bo":1},{"p":[74,37,-138],"s":[2,13,1],"l":1,"r":[0,0,0.7],"c":"#c8c8c8","t":2},{"p":[61,23,-138],"s":[1,23,1],"l":1,"c":"#8e8e8e","t":2},{"p":[-124,-12,-42],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,-0.71,-3.14],"c":"#4c663e"},{"p":[-9,0,-258],"s":[32,61,96],"c":"#ffffff","e":"#18180a"},{"p":[68,0,-242],"s":[122,34,4],"c":"#ffffff","e":"#18180a"},{"p":[-22,0,-213],"s":[8,46,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-76,0,-213],"s":[8,46,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-49,46,-213],"s":[62,8,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-49,46,-303],"s":[62,8,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-76,0,-303],"s":[8,46,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-22,0,-303],"s":[8,46,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[4,0,-213],"s":[8,61,8],"c":"#a7a7a7","e":"#18180a"},{"p":[126,0,-208],"s":[8,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[101,42,-188],"s":[58,4,42],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[126,0,-245],"s":[8,61,8],"c":"#a7a7a7","e":"#18180a"},{"p":[126,13,-303],"s":[8,48,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-102,13,-303],"s":[8,48,8],"c":"#a7a7a7","e":"#18180a"},{"p":[-102,0,-213],"s":[8,61,8],"c":"#a7a7a7","e":"#18180a"},{"p":[69,34,-225],"s":[122,4,32],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[69,42,-225],"s":[122,4,32],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[68,38,-227],"s":[120,4,32],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[-49,61,-258],"s":[114,4,98],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-48,65,-258],"s":[112,4,94],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[-49,69,-258],"s":[114,4,98],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[69,61,-274],"s":[122,4,66],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[69,69,-274],"s":[122,4,66],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[68,65,-274],"s":[120,4,62],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[-9,0,-258],"s":[33,12,97],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[171,0,-163],"s":[8,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[101,38,-188],"s":[54,4,46],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[101,34,-188],"s":[58,4,42],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[76,0,-163],"s":[8,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[-49,47,-295],"s":[48,7,8],"c":"#ffffff","e":"#18180a"},{"p":[-69,47,-258],"s":[8,8,66],"c":"#ffffff","e":"#18180a"},{"p":[-49,47,-221],"s":[48,7,8],"c":"#ffffff","e":"#18180a"},{"p":[-29,47,-258],"s":[8,8,66],"c":"#ffffff","e":"#18180a"},{"p":[-49,52,-258],"s":[33,7,67],"c":"#8c8c8c","e":"#18180a","t":11},{"p":[-49,2,-241],"s":[48,11,58],"i":9,"c":"#9d9d9d","t":1,"d":3},{"p":[-77,36,-248],"s":[8,14,5],"l":1,"r":[0,0,-0.35],"c":"#a7a7a7","e":"#18180a"},{"p":[-77,36,-228],"s":[8,14,5],"l":1,"r":[0,0,-0.35],"c":"#a7a7a7","e":"#18180a"},{"p":[-77,36,-288],"s":[8,14,5],"l":1,"r":[0,0,-0.35],"c":"#a7a7a7","e":"#18180a"},{"p":[-77,36,-268],"s":[8,14,5],"l":1,"r":[0,0,-0.35],"c":"#a7a7a7","e":"#18180a"},{"p":[-21,36,-228],"s":[8,14,5],"l":1,"r":[0,0,0.35],"c":"#a7a7a7","e":"#18180a"},{"p":[-21,36,-288],"s":[8,14,5],"l":1,"r":[0,0,0.35],"c":"#a7a7a7","e":"#18180a"},{"p":[-21,36,-268],"s":[8,14,5],"l":1,"r":[0,0,0.35],"c":"#a7a7a7","e":"#18180a"},{"p":[-21,36,-248],"s":[8,14,5],"l":1,"r":[0,0,0.35],"c":"#a7a7a7","e":"#18180a"},{"p":[-76,0,-228],"s":[8,38,5],"c":"#a7a7a7","e":"#18180a"},{"p":[-76,0,-248],"s":[8,38,5],"c":"#a7a7a7","e":"#18180a"},{"p":[-76,0,-268],"s":[8,38,5],"c":"#a7a7a7","e":"#18180a"},{"p":[-76,0,-288],"s":[8,38,5],"c":"#a7a7a7","e":"#18180a"},{"p":[-22,0,-228],"s":[8,38,5],"c":"#a7a7a7","e":"#18180a"},{"p":[-22,0,-248],"s":[8,38,5],"c":"#a7a7a7","e":"#18180a"},{"p":[-22,0,-268],"s":[8,38,5],"c":"#a7a7a7","e":"#18180a"},{"p":[-22,0,-288],"s":[8,38,5],"c":"#a7a7a7","e":"#18180a"},{"p":[-22,36,-228],"s":[9,2,6],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[-22,36,-248],"s":[9,2,6],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[-22,36,-268],"s":[9,2,6],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[-22,36,-288],"s":[9,2,6],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[-73,36,-288],"s":[3,2,6],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[-73,36,-268],"s":[3,2,6],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[-73,36,-248],"s":[3,2,6],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[-73,36,-228],"s":[3,2,6],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[-49,51,-288],"s":[32,1,6],"c":"#a7a7a7","e":"#18180a"},{"p":[-49,51,-228],"s":[32,1,6],"c":"#a7a7a7","e":"#18180a"},{"p":[-36,51,-258],"s":[6,1,54],"c":"#a7a7a7","e":"#18180a"},{"p":[-62,51,-258],"s":[6,1,54],"c":"#a7a7a7","e":"#18180a"},{"p":[170,13,-163],"s":[33,1,24],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[194,13,-169],"s":[15,1,6],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[149,13,-163],"s":[9,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[134,13,-163],"s":[21,1,41],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[130,13,-200],"s":[21,1,33],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[126,13,-224],"s":[21,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[129,13,-245],"s":[21,1,27],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[165,13,-176],"s":[14,1,2],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[205,13,-167],"s":[7,1,5],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[129,13,-269],"s":[18,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[129,13,-290],"s":[21,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[129,13,-308],"s":[29,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[141,13,-247],"s":[3,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[135,13,-317],"s":[13,1,3],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[104,13,-313],"s":[21,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[86,13,-311],"s":[15,1,26],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[69,13,-313],"s":[19,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[36,13,-308],"s":[21,1,27],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[53,13,-310],"s":[13,1,8],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[15,13,-318],"s":[21,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-10,13,-310],"s":[11,1,22],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-24,13,-303],"s":[17,1,16],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-21,13,-313],"s":[11,1,4],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-27,13,-289],"s":[4,1,12],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-81,13,-311],"s":[27,1,11],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-74,13,-299],"s":[19,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-74,13,-290],"s":[12,1,5],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[13,3,-234],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.71,0],"c":"#85aa6c"},{"p":[-85,14,-311],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.41,0],"c":"#85aa6c"},{"p":[-15,14,-311],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.89,0],"c":"#85aa6c"},{"p":[131,14,-310],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.2,3.14],"c":"#85aa6c"},{"p":[134,14,-170],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.68,3.14],"c":"#85aa6c"},{"p":[133,14,-181],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.07,0],"c":"#85aa6c"},{"p":[179,14,-170],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.19,3.14],"c":"#85aa6c"},{"p":[133,14,-252],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.2,3.14],"c":"#85aa6c"},{"p":[246,32,-221],"s":[90,2,5],"c":"#939393","e":"#18180a","t":11},{"p":[187,32,-238],"s":[5,2,10],"c":"#939393","e":"#18180a","t":11},{"p":[187,32,-299],"s":[5,2,32],"c":"#939393","e":"#18180a","t":11},{"p":[187,32,-351],"s":[5,2,10],"c":"#939393","e":"#18180a","t":11},{"p":[188,13,-279],"s":[11,1,10],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[187,13,-299],"s":[17,1,30],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[187,13,-319],"s":[13,1,10],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[177,13,-295],"s":[3,1,14],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[188,13,-326],"s":[7,1,4],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[187,13,-347],"s":[12,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[173,13,-351],"s":[16,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[195,13,-351],"s":[4,1,10],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[61,42,-242],"s":[121,4,2],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[52,13,-303],"s":[8,48,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[15,12,-316],"s":[53,8,3],"c":"#ffffff","e":"#18180a"},{"p":[15,20,-316],"s":[54,2,4],"c":"#939393","e":"#18180a","t":11},{"p":[-10,12,-310],"s":[3,8,9],"c":"#ffffff","e":"#18180a"},{"p":[40,12,-310],"s":[3,8,9],"c":"#ffffff","e":"#18180a"},{"p":[-10,20,-310],"s":[4,2,8],"c":"#939393","e":"#18180a","t":11},{"p":[40,20,-310],"s":[4,2,8],"c":"#939393","e":"#18180a","t":11},{"p":[0,13,-312],"s":[9,1,22],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[15,12,-310],"s":[51,4,9],"c":"#ffffff","e":"#18180a"},{"p":[59,14,-310],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-1.03,-3.14],"c":"#85aa6c"},{"p":[89,12,-316],"s":[53,8,3],"c":"#ffffff","e":"#18180a"},{"p":[89,20,-316],"s":[54,2,4],"c":"#939393","e":"#18180a","t":11},{"p":[64,12,-310],"s":[3,8,9],"c":"#ffffff","e":"#18180a"},{"p":[114,12,-310],"s":[3,8,9],"c":"#ffffff","e":"#18180a"},{"p":[64,20,-310],"s":[4,2,8],"c":"#939393","e":"#18180a","t":11},{"p":[114,20,-310],"s":[4,2,8],"c":"#939393","e":"#18180a","t":11},{"p":[89,12,-310],"s":[51,4,9],"c":"#ffffff","e":"#18180a"},{"p":[117,13,-318],"s":[5,1,5],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[45,14,-310],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.06,0],"c":"#85aa6c"},{"p":[0,13,-303],"s":[4,33,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[30,13,-303],"s":[4,33,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[15,46,-303],"s":[37,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[74,13,-303],"s":[4,33,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[104,13,-303],"s":[4,33,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[89,46,-303],"s":[37,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[132,73,-289],"s":[17,2,2],"c":"#c8c8c8","t":2,"bo":1},{"p":[128,65,-289],"s":[2,12,1],"l":1,"r":[0,0,-0.7],"c":"#c8c8c8","t":2},{"p":[139,42,-289],"s":[1,31,1],"l":1,"c":"#8e8e8e","t":2},{"p":[133,12,-269],"s":[1,18,4],"l":1,"r":[0,0,0.18],"c":"#c8c8c8","t":2},{"p":[133,12,-261],"s":[1,18,4],"l":1,"r":[0,0,0.18],"c":"#c8c8c8","t":2},{"p":[-94,13,-366],"s":[8,45,8],"c":"#6e6e6e","e":"#18180a","t":5,"bo":1},{"p":[-94,52,-338],"s":[7,4,48],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-94,43,-339],"s":[7,4,50],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-94,47,-338],"s":[4,5,50],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[-91,13,-326],"s":[7,39,6],"l":1,"r":[0,0,0.17],"c":"#a7a7a7","e":"#18180a"},{"p":[-91,13,-348],"s":[7,39,6],"l":1,"r":[0,0,0.17],"c":"#a7a7a7","e":"#18180a"},{"p":[-94,13,-310],"s":[8,45,8],"c":"#6e6e6e","e":"#18180a","t":5,"bo":1},{"p":[-94,13,-339],"s":[4,32,52],"c":"#ffffff","e":"#18180a"},{"p":[-87,13,-326],"s":[11,1,19],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-86,13,-344],"s":[13,1,17],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-87,13,-358],"s":[11,1,11],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-84,13,-373],"s":[16,1,19],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-84,13,-394],"s":[20,1,23],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-79,13,-320],"s":[5,1,7],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-88,14,-356],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.68,3.14],"c":"#85aa6c"},{"p":[-133,-8,-326],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.04,0],"c":"#4c663e"},{"p":[-183,-20,-357],"s":[65,109,54],"i":15,"l":1,"r":[3.14,-0.88,3.14],"c":"#4c663e"},{"p":[-174,-9,-245],"s":[65,109,54],"i":15,"l":1,"r":[3.14,0.17,3.14],"c":"#4c663e"},{"p":[-174,-30,-295],"s":[65,109,54],"i":15,"l":1,"r":[3.14,0.87,3.14],"c":"#4c663e"},{"p":[-5,23,-400],"s":[69,2,5],"c":"#939393","e":"#18180a","t":11},{"p":[-42,23,-410],"s":[5,2,25],"c":"#939393","e":"#18180a","t":11},{"p":[32,23,-432],"s":[5,2,69],"c":"#939393","e":"#18180a","t":11},{"p":[-5,13,-431],"s":[79,7,67],"c":"#696969","e":"#18180a","t":11},{"p":[230,13,-216],"s":[6,8,6],"i":2},{"p":[-83,13,-373],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-86,14,-365],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.38,3.13],"c":"#85aa6c"},{"p":[-139,13,-373],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a"},{"p":[-83,13,-481],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a"},{"p":[-83,13,-523],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a"},{"p":[-83,13,-425],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-3,13,-465],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a"},{"p":[83,13,-465],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a"},{"p":[83,13,-523],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a"},{"p":[-3,13,-523],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a"},{"p":[-111,67,-448],"s":[64,4,158],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-111,0,-448],"s":[63,20,157],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[59,0,-492],"s":[49,20,61],"c":"#696969","e":"#18180a","t":11},{"p":[-111,71,-448],"s":[60,4,154],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[-111,75,-448],"s":[64,4,158],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-45,49,-496],"s":[80,4,62],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-45,53,-496],"s":[80,4,58],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[-45,57,-496],"s":[80,4,62],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[40,67,-494],"s":[94,4,66],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[40,75,-494],"s":[94,4,66],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[40,71,-494],"s":[90,4,62],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[40,13,-465],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a"},{"p":[-17,21,-472],"s":[9,4,9],"c":"#a7a7a7","e":"#18180a"},{"p":[-17,45,-472],"s":[9,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-70,21,-472],"s":[9,4,9],"c":"#a7a7a7","e":"#18180a"},{"p":[-70,45,-472],"s":[9,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-43,21,-472],"s":[9,4,9],"c":"#a7a7a7","e":"#18180a"},{"p":[-43,45,-472],"s":[9,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-68,-8,-546],"s":[65,109,54],"i":15,"l":1,"r":[0,0.71,0],"c":"#4c663e"},{"p":[-19,-18,-547],"s":[65,109,54],"i":15,"l":1,"r":[3.14,-1.23,3.14],"c":"#4c663e"},{"p":[19,79,-459],"s":[2,2,21],"c":"#c8c8c8","t":2,"bo":1},{"p":[19,71,-463],"s":[1,14,2],"l":1,"r":[0.87,0,0],"c":"#c8c8c8","t":2},{"p":[-50,29,-124],"s":[1,21,1],"l":1,"c":"#8e8e8e","t":2},{"p":[-75,46,-399],"s":[9,1,26],"pe":1,"c":"#c8c8c8","t":2},{"p":[-75,47,-387],"s":[1,40,1],"l":1,"c":"#8e8e8e","t":2},{"p":[-75,47,-411],"s":[1,39,1],"l":1,"c":"#8e8e8e","t":2},{"p":[-73,47,-393],"s":[5,1,5],"l":1,"c":"#5f3232","t":5},{"p":[-70,43,-393],"s":[1,5,5],"l":1,"c":"#5f3232","t":5},{"p":[-84,86,-411],"s":[22,2,2],"c":"#c8c8c8","t":2,"bo":1},{"p":[-94,79,-411],"s":[2,7,2],"c":"#c8c8c8","t":2},{"p":[-94,79,-387],"s":[2,7,2],"c":"#c8c8c8","t":2},{"p":[-84,86,-387],"s":[22,2,2],"c":"#c8c8c8","t":2,"bo":1},{"p":[-94,79,-387],"s":[2,16,1],"l":1,"r":[0,0,-1.05],"c":"#c8c8c8","t":2},{"p":[-94,79,-411],"s":[2,16,1],"l":1,"r":[0,0,-1.05],"c":"#c8c8c8","t":2},{"p":[7,21,-454],"s":[12,12,12],"i":1},{"p":[7,33,-454],"s":[12,12,12],"i":1},{"p":[-32,21,-410],"s":[12,12,12],"i":8},{"p":[-20,21,-410],"s":[12,12,12],"i":8,"r":[0,1.57,0]},{"p":[-26,27,-410],"s":[24,7,12],"l":1,"c":"#3964a2","t":5,"ab":1},{"p":[242,13,-296],"s":[6,8,6],"i":2},{"p":[75,13,-444],"s":[6,8,6],"i":2},{"p":[-65,21,-474],"s":[44,1,31],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-34,21,-474],"s":[18,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[8,21,-474],"s":[46,1,39],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-20,21,-474],"s":[10,1,30],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[24,21,-445],"s":[12,1,19],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[26,21,-430],"s":[9,1,11],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[26,21,-418],"s":[11,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[17,21,-406],"s":[27,1,11],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-2,21,-406],"s":[11,1,8],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-24,21,-411],"s":[33,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-19,21,-422],"s":[14,1,4],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[15,21,-415],"s":[11,1,7],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[6,21,-450],"s":[24,1,9],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-75,21,-448],"s":[12,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-64,21,-455],"s":[10,1,7],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-77,21,-432],"s":[6,1,11],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-35,13,-404],"s":[30,1,23],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-7,13,-404],"s":[26,1,29],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[23,13,-406],"s":[34,1,29],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[39,13,-431],"s":[12,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[42,13,-452],"s":[16,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[30,13,-390],"s":[14,1,3],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[56,13,-460],"s":[12,1,12],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[71,13,-452],"s":[18,1,33],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[79,13,-419],"s":[21,1,33],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[80,13,-392],"s":[11,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[74,13,-372],"s":[19,1,20],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[92,13,-446],"s":[28,39,36],"c":"#595959","e":"#11110c","bo":1},{"p":[96,13,-416],"s":[28,34,29],"c":"#595959","e":"#11110c","bo":1},{"p":[97,13,-379],"s":[36,44,46],"c":"#595959","e":"#11110c","bo":1},{"p":[124,13,-375],"s":[35,36,31],"c":"#595959","e":"#11110c","bo":1},{"p":[158,13,-373],"s":[40,41,31],"c":"#595959","e":"#11110c","bo":1},{"p":[143,13,-370],"s":[23,29,33],"c":"#595959","e":"#11110c","bo":1},{"p":[186,-9,-373],"s":[26,58,34],"c":"#595959","e":"#11110c","bo":1},{"p":[188,-9,-401],"s":[26,50,27],"c":"#595959","e":"#11110c","bo":1},{"p":[178,-9,-431],"s":[34,56,40],"c":"#595959","e":"#11110c","bo":1},{"p":[199,-9,-468],"s":[49,50,40],"c":"#595959","e":"#11110c","bo":1},{"p":[239,-9,-470],"s":[31,42,40],"c":"#595959","e":"#11110c","bo":1},{"p":[226,-9,-464],"s":[25,35,40],"c":"#595959","e":"#11110c","bo":1},{"p":[158,11,-323],"s":[58,2,74],"c":"#9d9d9d","t":1},{"p":[97,57,-379],"s":[36,2,46],"c":"#8e8e8e","t":8,"bo":1},{"p":[96,47,-416],"s":[28,2,29],"c":"#8e8e8e","t":8,"bo":1},{"p":[92,52,-446],"s":[28,2,36],"c":"#8e8e8e","t":8,"bo":1},{"p":[124,49,-375],"s":[35,2,31],"c":"#8e8e8e","t":8,"bo":1},{"p":[158,54,-373],"s":[40,2,31],"c":"#8e8e8e","t":8,"bo":1,"ab":1},{"p":[145,13,-356],"s":[40,1,14],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[99,13,-354],"s":[52,1,16],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[108,13,-345],"s":[25,1,2],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[143,42,-370],"s":[23,2,33],"c":"#8e8e8e","t":8,"bo":1},{"p":[186,49,-373],"s":[26,2,34],"c":"#8e8e8e","t":8,"bo":1},{"p":[-61,22,-474],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.85,3.14],"c":"#85aa6c"},{"p":[-75,22,-463],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.16,3.14],"c":"#85aa6c"},{"p":[-35,22,-473],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.15,3.14],"c":"#85aa6c"},{"p":[-26,22,-474],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.37,-3.14],"c":"#85aa6c"},{"p":[-9,22,-473],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.55,3.14],"c":"#85aa6c"},{"p":[17,22,-459],"s":[7,6,8],"i":18,"l":1,"r":[3.14,1.07,-3.14],"c":"#85aa6c"},{"p":[24,22,-408],"s":[7,6,8],"i":18,"l":1,"r":[0,1.02,0],"c":"#85aa6c"},{"p":[-8,22,-408],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.42,-3.14],"c":"#85aa6c"},{"p":[40,14,-456],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.37,-3.14],"c":"#85aa6c"},{"p":[74,14,-436],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.33,-3.14],"c":"#85aa6c"},{"p":[77,14,-406],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.37,-3.14],"c":"#85aa6c"},{"p":[127,14,-356],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.33,-3.14],"c":"#85aa6c"},{"p":[180,14,-352],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.37,-3.14],"c":"#85aa6c"},{"p":[266,13,-213],"s":[7,57,7],"v":1,"e":"#18180a"},{"p":[266,13,-213],"s":[8,57,8],"v":1,"e":"#18180a","bo":1},{"p":[72,13,-458],"s":[6,41,6],"v":1,"c":"#a7a7a7","e":"#18180a"},{"p":[72,13,-458],"s":[7,41,7],"v":1,"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[264,13,-228],"s":[25,1,10],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[285,13,-230],"s":[17,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[266,-9,-480],"s":[35,59,46],"c":"#595959","e":"#11110c","bo":1},{"p":[188,41,-401],"s":[26,2,27],"c":"#8e8e8e","t":8,"bo":1},{"p":[178,47,-431],"s":[34,2,40],"c":"#8e8e8e","t":8,"bo":1},{"p":[199,41,-468],"s":[49,2,40],"c":"#8e8e8e","t":8,"bo":1},{"p":[128,-22,-447],"s":[65,109,54],"i":15,"l":1,"r":[3.14,0,3.14],"c":"#4c663e"},{"p":[130,-27,-487],"s":[65,109,54],"i":15,"l":1,"r":[-3.13,1.4,3.13],"c":"#4c663e"},{"p":[181,-4,-498],"s":[65,109,54],"i":15,"l":1,"r":[0,0.34,0],"c":"#4c663e"},{"p":[223,-39,-513],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.41,0],"c":"#4c663e"},{"p":[262,-28,-574],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.36,0],"c":"#4c663e"},{"p":[169,-36,-547],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.23,0],"c":"#4c663e"},{"p":[135,-37,-522],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,1.41,-3.14],"c":"#4c663e"},{"p":[226,26,-464],"s":[25,2,40],"c":"#8e8e8e","t":8,"bo":1},{"p":[239,33,-470],"s":[31,2,40],"c":"#8e8e8e","t":8,"bo":1},{"p":[266,50,-480],"s":[35,2,46],"c":"#8e8e8e","t":8,"bo":1},{"p":[386,0,-180],"s":[8,56,6],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-43,0,-472],"s":[8,45,8],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[-17,0,-472],"s":[8,45,8],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[-70,0,-472],"s":[8,45,8],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[-38,59,-50],"s":[18,1,6],"i":30,"r":[1.57,0,0],"st":"Map By CrispyCrust","sb":"#ffffff","bv":1,"sf":74,"sa":1},{"p":[103,13,-354],"s":[4,37,4],"c":"#939393","t":2,"bo":1},{"p":[89,13,-354],"s":[4,37,4],"c":"#939393","t":2,"bo":1},{"p":[89,50,-331],"s":[4,2,50],"c":"#939393","t":2,"bo":1},{"p":[103,50,-331],"s":[4,2,50],"c":"#939393","t":2,"bo":1},{"p":[96,52,-319],"s":[17,1,15],"pe":1,"c":"#414f91","t":5,"bo":1},{"p":[87,43,-319],"s":[1,10,15],"pe":1,"c":"#414f91","t":5,"bo":1},{"p":[105,45,-319],"s":[1,8,15],"pe":1,"c":"#414f91","t":5,"bo":1},{"p":[89,41,-353],"s":[2,16,2],"l":1,"r":[0.87,0,0],"c":"#939393","t":2},{"p":[103,41,-353],"s":[2,16,2],"l":1,"r":[0.87,0,0],"c":"#939393","t":2},{"p":[240,28,-221],"s":[14,4,4],"e":"#18180a"},{"p":[217,13,-221],"s":[32,19,4],"e":"#18180a"},{"p":[270,13,-221],"s":[46,19,4],"e":"#18180a"},{"p":[333,47,-116],"s":[5,9,51],"c":"#ffffff","e":"#18180a"},{"p":[293,0,-111],"s":[76,38,110],"c":"#ffffff","e":"#18180a"},{"p":[309,0,-183],"s":[40,66,36],"c":"#595959","e":"#11110c","bo":1},{"p":[295,38,-55],"s":[70,4,4],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[334,8,-133],"s":[3,34,70],"c":"#ffffff","e":"#18180a"},{"p":[340,2,-111],"s":[1,23,5],"l":1,"r":[0,0,0.17],"c":"#a7a7a7","t":2},{"p":[363,0,-177],"s":[55,8,4],"c":"#696969","e":"#18180a","t":11},{"p":[411,0,-5],"s":[148,8,4],"c":"#696969","e":"#18180a","t":11},{"p":[333,0,-9],"s":[8,8,7],"c":"#696969","e":"#18180a","t":11},{"p":[358,0,-181],"s":[49,12,2],"c":"#696969","e":"#18180a","t":11},{"p":[414,35,-179],"s":[32,21,5],"c":"#ffffff","e":"#18180a","bo":1},{"p":[135,-15,-411],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.18,0],"c":"#4c663e"},{"p":[167,-14,-472],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.7,0],"c":"#4c663e"},{"p":[125,34,-391],"s":[2,8,3],"c":"#939393","t":2},{"p":[125,34,-429],"s":[2,8,2],"c":"#939393","t":2},{"p":[154,-38,-407],"s":[65,109,54],"i":15,"l":1,"r":[0,1.39,0],"c":"#4c663e"},{"p":[96,51,-354],"s":[10,1,2],"c":"#939393","t":2},{"p":[96,51,-308],"s":[10,1,2],"c":"#939393","t":2},{"p":[96,51,-330],"s":[10,1,2],"c":"#939393","t":2},{"p":[96,51,-318],"s":[10,1,2],"c":"#939393","t":2},{"p":[96,51,-342],"s":[10,1,2],"c":"#939393","t":2},{"p":[15,31,-303],"s":[5,1,9],"c":"#a7a7a7","e":"#18180a"},{"p":[15,34,-303],"s":[5,1,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[12,31,-303],"s":[1,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[18,31,-303],"s":[1,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[15,18,-308],"s":[5,15,1],"l":1,"c":"#2787ca","o":0.7000000000000001,"t":8,"ts":5,"td":1,"ab":1},{"p":[15,16,-310],"s":[47,2,10],"l":1,"c":"#2787ca","o":0.7000000000000001,"t":8,"ts":-0.1,"td":1,"ab":1},{"p":[89,16,-310],"s":[47,2,10],"l":1,"c":"#2787ca","o":0.7000000000000001,"t":8,"ts":-0.1,"td":1,"ab":1},{"p":[15,32,-303],"s":[5,2,8],"c":"#000000","e":"#18180a"},{"p":[89,31,-303],"s":[5,1,9],"c":"#a7a7a7","e":"#18180a"},{"p":[89,34,-303],"s":[5,1,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[86,31,-303],"s":[1,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[92,31,-303],"s":[1,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[89,18,-308],"s":[5,15,1],"l":1,"c":"#2787ca","o":0.7000000000000001,"t":8,"ts":5,"td":1,"ab":1},{"p":[89,32,-303],"s":[5,2,8],"c":"#000000","e":"#18180a"},{"p":[386,27,-116],"s":[10,4,6],"c":"#707070","e":"#18180a","t":11},{"p":[389,27,-121],"s":[4,2,4],"c":"#707070","e":"#18180a","t":11},{"p":[386,55,-118],"s":[10,4,10],"c":"#707070","e":"#18180a","t":11},{"p":[386,53,-115],"s":[10,2,4],"c":"#707070","e":"#18180a","t":11},{"p":[87,42,-339],"s":[1,11,22],"pe":1,"c":"#612424","t":5,"bo":1},{"p":[105,43,-339],"s":[1,10,22],"pe":1,"c":"#612424","t":5,"bo":1},{"p":[96,52,-339],"s":[17,1,22],"pe":1,"c":"#612424","t":5,"bo":1},{"p":[411,66,-170],"s":[52,5,26],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[373,66,-162],"s":[24,5,10],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[412,61,-167],"s":[46,5,28],"c":"#e8e8e8","e":"#18180a","t":11,"bo":1},{"p":[376,61,-159],"s":[26,5,12],"c":"#e8e8e8","e":"#18180a","t":11,"bo":1},{"p":[400,56,-169],"s":[14,5,16],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[371,8,-179],"s":[26,45,5],"c":"#ffffff","e":"#18180a"},{"p":[347,8,-179],"s":[22,42,5],"c":"#ffffff","e":"#18180a"},{"p":[332,47,-160],"s":[7,5,37],"c":"#ffffff","e":"#18180a"},{"p":[338,42,-163],"s":[8,6,28],"c":"#a7a7a7","e":"#18180a"},{"p":[373,42,-174],"s":[24,6,6],"c":"#a7a7a7","e":"#18180a"},{"p":[349,2,-159],"s":[4,2,6],"l":1,"r":[0,0.35,0],"c":"#8c8c8c","e":"#18180a"},{"p":[374,2,-159],"s":[7,3,5],"l":1,"r":[0,0.87,0],"c":"#8c8c8c","e":"#18180a"},{"p":[398,2,-74],"s":[4,2,5],"l":1,"r":[-3.14,0.17,-3.14],"c":"#ffffff","e":"#18180a"},{"p":[353,2,-133],"s":[5,3,6],"l":1,"r":[0,0.52,0],"c":"#707070","e":"#18180a","t":11},{"p":[360,56,-149],"s":[10,5,4],"c":"#8c8c8c","e":"#18180a","bo":1},{"p":[419,2,-514],"s":[15,14,4],"e":"#18180a"},{"p":[372,0,-589],"s":[110,10,53],"c":"#ffffff","e":"#18180a"},{"p":[312,16,-514],"s":[70,2,5],"c":"#939393","e":"#18180a","t":11},{"p":[414,16,-514],"s":[38,2,5],"c":"#939393","e":"#18180a","t":11},{"p":[248,0,-397],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[248,0,-289],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[330,0,-289],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[330,0,-329],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[338,0,-337],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[374,0,-337],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[330,0,-371],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[338,0,-363],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[330,0,-397],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[374,0,-363],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[426,0,-371],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[419,0,-350],"s":[8,54,32],"c":"#ffffff","e":"#18180a"},{"p":[418,0,-337],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[418,0,-363],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[426,0,-329],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[396,41,-350],"s":[38,13,32],"c":"#ffffff","e":"#18180a"},{"p":[426,0,-295],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[418,0,-287],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[392,0,-287],"s":[9,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[392,0,-249],"s":[9,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[516,0,-249],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[433,0,-249],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[478,0,-249],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[248,0,-342],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[426,0,-397],"s":[8,54,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[452,-9,-410],"s":[26,51,34],"c":"#595959","e":"#11110c","bo":1},{"p":[450,-9,-438],"s":[28,46,32],"c":"#595959","e":"#11110c","bo":1},{"p":[450,37,-438],"s":[28,2,32],"c":"#8e8e8e","t":8,"bo":1},{"p":[452,42,-410],"s":[26,2,34],"c":"#8e8e8e","t":8,"bo":1},{"p":[289,54,-343],"s":[90,4,116],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[289,58,-343],"s":[86,4,112],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[289,62,-343],"s":[90,4,116],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[378,54,-350],"s":[88,4,34],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[471,54,-323],"s":[98,4,156],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[405,54,-268],"s":[35,4,46],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[407,58,-268],"s":[35,4,42],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[471,58,-323],"s":[94,4,152],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[378,58,-350],"s":[92,4,30],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[378,62,-350],"s":[88,4,34],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[471,62,-323],"s":[98,4,156],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[405,62,-268],"s":[35,4,46],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[289,0,-343],"s":[89,12,115],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[355,0,-350],"s":[45,12,33],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[396,37,-337],"s":[36,4,6],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[377,37,-350],"s":[2,4,18],"c":"#a7a7a7","e":"#18180a"},{"p":[415,37,-350],"s":[2,4,18],"c":"#a7a7a7","e":"#18180a"},{"p":[406,0,-268],"s":[33,12,45],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[471,0,-323],"s":[97,12,155],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[389,0,-268],"s":[2,12,34],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[419,0,-350],"s":[9,12,32],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[396,2,-246],"s":[26,1,29],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[389,2,-279],"s":[19,1,37],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[419,2,-298],"s":[19,1,23],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[404,2,-293],"s":[11,1,5],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[424,2,-316],"s":[19,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[424,2,-349],"s":[30,1,53],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[407,2,-358],"s":[4,1,24],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[378,2,-284],"s":[3,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[393,2,-230],"s":[13,1,3],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[428,2,-393],"s":[23,1,35],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[420,2,-513],"s":[30,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[415,2,-383],"s":[3,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[433,2,-428],"s":[15,1,35],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[397,2,-514],"s":[16,1,11],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[330,2,-525],"s":[24,1,9],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[423,2,-438],"s":[5,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[372,0,-561],"s":[26,8,3],"c":"#ffffff","e":"#18180a"},{"p":[372,0,-558],"s":[26,6,3],"c":"#ffffff","e":"#18180a"},{"p":[372,0,-555],"s":[26,4,3],"c":"#ffffff","e":"#18180a"},{"p":[404,9,-563],"s":[38,2,2],"c":"#939393","e":"#18180a","t":11},{"p":[386,2,-563],"s":[2,7,2],"c":"#939393","e":"#18180a","t":11},{"p":[422,2,-563],"s":[2,7,2],"c":"#939393","e":"#18180a","t":11},{"p":[358,2,-563],"s":[2,7,2],"c":"#939393","e":"#18180a","t":11},{"p":[320,2,-563],"s":[2,7,2],"c":"#939393","e":"#18180a","t":11},{"p":[339,9,-563],"s":[40,2,2],"c":"#939393","e":"#18180a","t":11},{"p":[426,0,-456],"s":[8,41,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[426,0,-584],"s":[8,41,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[418,0,-592],"s":[8,41,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[324,0,-592],"s":[8,41,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[316,0,-584],"s":[8,41,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[316,0,-456],"s":[8,41,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[297,41,-527],"s":[46,4,150],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[371,41,-590],"s":[102,4,58],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[297,45,-527],"s":[42,4,146],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[371,45,-590],"s":[106,4,54],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[297,49,-535],"s":[46,4,166],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[371,49,-590],"s":[102,4,58],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[420,2,-528],"s":[13,1,17],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[420,2,-560],"s":[38,1,17],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[420,2,-544],"s":[9,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[395,2,-560],"s":[12,1,11],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[372,2,-556],"s":[34,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[367,2,-547],"s":[16,1,5],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[320,2,-561],"s":[22,1,17],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[348,2,-560],"s":[14,1,9],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[336,2,-560],"s":[10,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[320,2,-541],"s":[12,1,23],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[321,2,-513],"s":[25,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[342,2,-515],"s":[17,1,11],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[352,2,-514],"s":[3,1,7],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[409,2,-524],"s":[9,1,9],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[413,2,-549],"s":[5,1,5],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[274,2,-517],"s":[35,1,32],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[300,2,-517],"s":[17,1,20],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[285,13,-229],"s":[12,12,12],"i":1},{"p":[274,14,-227],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,1.4,-3.14],"c":"#85aa6c"},{"p":[206,14,-227],"s":[7,6,8],"i":18,"l":1,"r":[0,0.69,0],"c":"#85aa6c"},{"p":[193,14,-240],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.18,0],"c":"#85aa6c"},{"p":[193,14,-293],"s":[7,6,8],"i":18,"l":1,"r":[0,0.87,0],"c":"#85aa6c"},{"p":[193,14,-352],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.53,0],"c":"#85aa6c"},{"p":[226,2,-456],"s":[35,1,36],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[250,2,-452],"s":[13,1,19],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[200,2,-438],"s":[17,1,22],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[200,2,-406],"s":[11,1,26],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[198,2,-423],"s":[11,1,8],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[217,2,-436],"s":[17,1,4],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[263,2,-456],"s":[13,1,10],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[249,13,-299],"s":[21,1,39],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[245,13,-323],"s":[11,1,9],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[245,13,-338],"s":[8,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[237,13,-296],"s":[3,1,26],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[273,13,-284],"s":[27,1,5],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[75,13,-450],"s":[6,8,6],"i":2},{"p":[242,13,-302],"s":[6,8,6],"i":2},{"p":[242,14,-309],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#85aa6c"},{"p":[253,2,-398],"s":[29,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[286,2,-402],"s":[37,1,14],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[328,2,-384],"s":[21,1,47],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[311,2,-402],"s":[13,1,7],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[347,2,-372],"s":[17,1,17],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[370,2,-362],"s":[29,1,28],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[342,2,-389],"s":[7,1,17],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[289,2,-412],"s":[24,1,6],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[249,2,-407],"s":[13,1,3],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[368,2,-339],"s":[29,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[339,2,-332],"s":[29,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[334,2,-316],"s":[23,1,14],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[330,2,-295],"s":[19,1,28],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[363,2,-329],"s":[19,1,2],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[386,2,-365],"s":[3,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[349,2,-382],"s":[7,1,3],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[363,2,-377],"s":[15,1,2],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[417,3,-371],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.7,3.14],"c":"#85aa6c"},{"p":[417,3,-295],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.52,3.14],"c":"#85aa6c"},{"p":[417,3,-328],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.35,3.14],"c":"#85aa6c"},{"p":[348,3,-329],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.17,3.14],"c":"#85aa6c"},{"p":[339,3,-328],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.53,3.14],"c":"#85aa6c"},{"p":[430,3,-405],"s":[7,6,8],"i":18,"l":1,"r":[3.13,-1.4,3.13],"c":"#85aa6c"},{"p":[427,3,-446],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.04,0],"c":"#85aa6c"},{"p":[288,3,-508],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.71,3.14],"c":"#85aa6c"},{"p":[243,3,-446],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.54,3.14],"c":"#85aa6c"},{"p":[200,3,-443],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.19,3.14],"c":"#85aa6c"},{"p":[210,3,-444],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.86,-3.14],"c":"#85aa6c"},{"p":[198,3,-419],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.06,3.14],"c":"#85aa6c"},{"p":[297,3,-405],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.71,3.14],"c":"#85aa6c"},{"p":[287,2,-407],"s":[12,12,12],"i":1},{"p":[287,14,-407],"s":[12,12,12],"i":1},{"p":[338,3,-371],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.21,0],"c":"#85aa6c"},{"p":[368,3,-371],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.41,3.14],"c":"#85aa6c"},{"p":[355,3,-558],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.54,3.14],"c":"#85aa6c"},{"p":[390,3,-558],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.06,3.14],"c":"#85aa6c"},{"p":[418,3,-558],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.38,0],"c":"#85aa6c"},{"p":[418,3,-520],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.86,0],"c":"#85aa6c"},{"p":[322,3,-521],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.34,0],"c":"#85aa6c"},{"p":[323,3,-559],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.69,0],"c":"#85aa6c"},{"p":[334,10,-570],"s":[9,4,9],"l":1,"c":"#a7a7a7","e":"#18180a"},{"p":[334,37,-570],"s":[9,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[334,-11,-570],"s":[8,48,8],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[392,10,-570],"s":[9,4,9],"l":1,"c":"#a7a7a7","e":"#18180a"},{"p":[392,37,-570],"s":[9,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[392,-11,-570],"s":[8,48,8],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[352,10,-570],"s":[9,4,9],"l":1,"c":"#a7a7a7","e":"#18180a"},{"p":[352,37,-570],"s":[9,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[352,-11,-570],"s":[8,48,8],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[410,10,-570],"s":[9,4,9],"l":1,"c":"#a7a7a7","e":"#18180a"},{"p":[410,37,-570],"s":[9,4,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[410,-11,-570],"s":[8,48,8],"c":"#707070","e":"#18180a","t":11,"bo":1},{"p":[361,10,-590],"s":[4,22,4],"c":"#a7a7a7","e":"#18180a"},{"p":[383,10,-590],"s":[4,22,4],"c":"#a7a7a7","e":"#18180a"},{"p":[372,32,-590],"s":[27,4,5],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[371,2,-590],"s":[23,30,3],"c":"#b9b9b9","t":2},{"p":[325,-7,-643],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.36,0],"c":"#4c663e"},{"p":[431,-14,-643],"s":[65,109,54],"i":15,"l":1,"r":[3.14,-1.04,3.14],"c":"#4c663e"},{"p":[483,-14,-498],"s":[65,109,54],"i":15,"l":1,"r":[3.14,-1.04,3.14],"c":"#4c663e"},{"p":[501,-25,-489],"s":[65,109,54],"i":15,"l":1,"r":[3.14,1.05,-3.14],"c":"#4c663e"},{"p":[529,-30,-414],"s":[65,109,54],"i":15,"l":1,"r":[3.14,1.05,-3.14],"c":"#4c663e"},{"p":[482,-31,-599],"s":[65,109,54],"i":15,"l":1,"r":[3.14,0.36,-3.14],"c":"#4c663e"},{"p":[378,-20,-659],"s":[65,109,54],"i":15,"l":1,"r":[3.14,-0.86,3.14],"c":"#4c663e"},{"p":[270,-21,-643],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.41,0],"c":"#4c663e"},{"p":[356,-23,-384],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.06,0],"c":"#4c663e"},{"p":[333,2,-522],"s":[12,12,12],"i":1},{"p":[357,0,-383],"s":[5,35,5],"v":1,"c":"#a7a7a7","e":"#18180a"},{"p":[357,0,-383],"s":[6,35,6],"v":1,"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[413,33,-234],"s":[1,33,1],"l":1,"c":"#8e8e8e","t":2},{"p":[413,66,-243],"s":[2,2,21],"c":"#c8c8c8","t":2,"bo":1},{"p":[413,58,-247],"s":[1,14,2],"l":1,"r":[0.87,0,0],"c":"#c8c8c8","t":2},{"p":[272,66,-401],"s":[2,2,20],"c":"#c8c8c8","t":2,"bo":1},{"p":[272,57,-398],"s":[1,13,2],"l":1,"r":[-0.7,0,0],"c":"#c8c8c8","t":2},{"p":[272,39,-410],"s":[1,27,1],"l":1,"c":"#8e8e8e","t":2},{"p":[396,37,-363],"s":[36,4,6],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[411,37,-350],"s":[6,4,20],"c":"#a7a7a7","e":"#18180a"},{"p":[381,37,-350],"s":[6,4,20],"c":"#a7a7a7","e":"#18180a"},{"p":[395,40,-350],"s":[26,1,20],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[273,13,-281],"s":[3,15,1],"l":1,"r":[-0.17,0,0],"c":"#a7a7a7","t":2},{"p":[266,13,-281],"s":[3,15,1],"l":1,"r":[-0.17,0,0],"c":"#a7a7a7","t":2},{"p":[-42,2,-75],"s":[24,36,24],"i":23,"l":1,"tm":0},{"p":[372,2,-529],"s":[24,36,24],"i":23,"l":1,"tm":"1"},{"p":[-5,21,-432],"s":[68,50,57],"i":14,"l":1},{"p":[457,2,-67],"s":[47,35,119],"i":14,"l":1},{"p":[371,2,-539],"s":[100,35,44],"i":14,"l":1},{"p":[60,2,-203],"s":[103,35,71],"i":14,"l":1},{"p":[96,0,-144],"s":[47,34,44],"c":"#ffffff","e":"#18180a"},{"p":[51,2,-240],"s":[34,1,18],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[79,2,-240],"s":[22,1,23],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[77,2,-209],"s":[20,1,6],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[76,2,-216],"s":[15,1,8],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[75,2,-205],"s":[11,1,2],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[102,2,-240],"s":[24,1,45],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[106,2,-212],"s":[15,1,11],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[108,2,-196],"s":[9,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[104,2,-175],"s":[19,1,21],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[81,2,-163],"s":[27,1,19],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[88,2,-175],"s":[13,1,5],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[5,2,-199],"s":[12,1,2],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[22,2,-221],"s":[6,1,14],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[60,0,-240],"s":[105,12,1],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[113,0,-202],"s":[2,12,75],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[96,0,-166],"s":[32,12,1],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[105,2,-174],"s":[12,12,12],"i":1},{"p":[108,2,-183],"s":[6,8,6],"i":2},{"p":[108,2,-189],"s":[6,8,6],"i":2},{"p":[107,3,-234],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.86,3.14],"c":"#85aa6c"},{"p":[108,3,-223],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.36,-3.14],"c":"#85aa6c"},{"p":[108,3,-196],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.51,-3.14],"c":"#85aa6c"},{"p":[94,3,-171],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.21,3.14],"c":"#85aa6c"},{"p":[-55,-35,-570],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.52,0],"c":"#4c663e"},{"p":[495,-41,-439],"s":[65,109,54],"i":15,"l":1,"r":[3.14,-0.34,-3.14],"c":"#4c663e"},{"p":[66,2,-211],"s":[12,12,12],"i":1},{"p":[54,2,-211],"s":[12,12,12],"i":1},{"p":[398,2,-514],"s":[5,14,4],"e":"#18180a"},{"p":[406,2,-514],"s":[11,3,4],"e":"#18180a"},{"p":[406,14,-514],"s":[11,2,4],"e":"#18180a"},{"p":[406,5,-512],"s":[5,11,1],"pe":1,"c":"#acaaaa","t":2},{"p":[402,4,-512],"s":[3,11,1],"pe":1,"c":"#acaaaa","t":2},{"p":[410,4,-512],"s":[3,11,1],"pe":1,"c":"#acaaaa","t":2},{"p":[410,2,-521],"s":[5,3,4],"l":1,"r":[0,0.7,0],"e":"#18180a"},{"p":[142,0,-119],"s":[127,2,8],"v":1,"c":"#ffffff","e":"#18180a","bo":1},{"p":[7,34,-228],"s":[2,12,26],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[409,30,-179],"s":[40,5,6],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[392,0,-179],"s":[5,30,6],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[427,0,-179],"s":[5,30,6],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[433,0,-180],"s":[8,56,6],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[437,8,-152],"s":[1,50,34],"c":"#ffffff","e":"#18180a"},{"p":[439,0,-52],"s":[8,8,9],"c":"#696969","e":"#18180a","t":11},{"p":[436,0,-172],"s":[1,56,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[391,35,-179],"s":[14,18,5],"c":"#ffffff","e":"#18180a","bo":1},{"p":[344,42,-172],"s":[4,6,9],"c":"#a7a7a7","e":"#18180a"},{"p":[432,0,-177],"s":[7,8,4],"c":"#696969","e":"#18180a","t":11},{"p":[433,0,-176],"s":[8,56,1],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[214,-55,-321],"s":[619,35,929],"c":"#39301f","t":5},{"p":[439,8,-52],"s":[7,37,8],"c":"#a7a7a7","e":"#18180a"},{"p":[439,8,-92],"s":[7,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[439,8,-132],"s":[7,34,8],"c":"#a7a7a7","e":"#18180a"},{"p":[437,47,-68],"s":[1,11,134],"c":"#ffffff","e":"#18180a"},{"p":[441,39,-214],"s":[7,4,49],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[463,42,-71],"s":[52,4,130],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[478,8,-3],"s":[7,34,7],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[485,8,-10],"s":[7,34,7],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[478,8,-131],"s":[7,34,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[485,8,-124],"s":[7,34,7],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[439,0,-92],"s":[8,8,9],"c":"#696969","e":"#18180a","t":11},{"p":[460,0,-152],"s":[50,8,49],"c":"#696969","e":"#18180a","t":11},{"p":[459,8,-132],"s":[33,35,7],"c":"#ffffff","e":"#18180a","bo":1},{"p":[485,0,-67],"s":[8,8,125],"c":"#696969","e":"#18180a","t":11},{"p":[485,8,-67],"s":[6,34,125],"c":"#ffffff","e":"#18180a","bo":1},{"p":[465,-17,-188],"s":[65,109,54],"i":15,"l":1,"r":[0,0.87,0],"c":"#4c663e"},{"p":[504,-29,-216],"s":[65,109,54],"i":15,"l":1,"r":[0,-1.05,0],"c":"#4c663e"},{"p":[544,-13,-253],"s":[65,109,54],"i":15,"l":1,"r":[3.14,-0.7,3.14],"c":"#4c663e"},{"p":[528,-36,-167],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,0.53,-3.14],"c":"#4c663e"},{"p":[471,-37,-159],"s":[65,109,54],"i":15,"l":1,"r":[0,-0.18,0],"c":"#4c663e"},{"p":[528,-66,-203],"s":[65,109,54],"i":15,"l":1,"r":[-3.14,0.53,-3.14],"c":"#4c663e"},{"p":[278,0,-456],"s":[8,41,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[445,0,-534],"s":[44,41,162],"c":"#ffffff","e":"#18180a"},{"p":[445,41,-527],"s":[46,4,150],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[445,45,-527],"s":[42,4,146],"c":"#e8e8e8","e":"#18180a","t":11},{"p":[445,49,-536],"s":[46,4,168],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[316,0,-514],"s":[8,41,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[426,0,-514],"s":[8,41,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[317,2,-452],"s":[29,1,15],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[286,2,-456],"s":[33,1,16],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[289,2,-447],"s":[14,1,2],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[321,2,-443],"s":[17,1,3],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[433,2,-457],"s":[37,1,23],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[410,2,-469],"s":[9,1,25],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[406,2,-493],"s":[4,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[410,2,-494],"s":[4,1,25],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[394,2,-181],"s":[7,1,20],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[385,2,-175],"s":[11,1,6],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[399,2,-179],"s":[3,1,12],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[417,2,-246],"s":[16,1,19],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[433,2,-234],"s":[16,1,34],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[434,2,-212],"s":[10,1,10],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[434,2,-182],"s":[26,1,22],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[434,2,-200],"s":[16,1,14],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[420,2,-179],"s":[2,1,10],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[434,2,-169],"s":[12,1,4],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[221,13,-229],"s":[12,12,12],"i":1},{"p":[221,13,-213],"s":[12,12,12],"i":1},{"p":[209,13,-213],"s":[12,12,12],"i":1},{"p":[421,53,-483],"s":[21,2,2],"c":"#c8c8c8","t":2,"bo":1},{"p":[425,44,-483],"s":[2,13,1],"l":1,"r":[0,0,0.7],"c":"#c8c8c8","t":2},{"p":[412,30,-483],"s":[1,23,1],"l":1,"c":"#8e8e8e","t":2},{"p":[418,2,-515],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.89,0],"c":"#85aa6c"},{"p":[413,0,-485],"s":[3,8,45],"c":"#ffffff","e":"#18180a"},{"p":[413,8,-485],"s":[4,2,46],"c":"#939393","e":"#18180a","t":11},{"p":[419,0,-506],"s":[9,8,3],"c":"#ffffff","e":"#18180a"},{"p":[419,0,-464],"s":[9,8,3],"c":"#ffffff","e":"#18180a"},{"p":[419,8,-506],"s":[8,2,4],"c":"#939393","e":"#18180a","t":11},{"p":[419,8,-464],"s":[8,2,4],"c":"#939393","e":"#18180a","t":11},{"p":[419,0,-485],"s":[9,4,40],"c":"#ffffff","e":"#18180a"},{"p":[419,2,-455],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.06,0],"c":"#85aa6c"},{"p":[426,1,-500],"s":[8,33,4],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[426,1,-470],"s":[8,33,4],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[426,34,-485],"s":[9,4,37],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[426,19,-485],"s":[9,1,5],"c":"#a7a7a7","e":"#18180a"},{"p":[426,22,-485],"s":[9,1,5],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[426,19,-488],"s":[9,4,1],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[426,19,-482],"s":[9,4,1],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[421,6,-485],"s":[1,15,5],"l":1,"c":"#2787ca","o":0.7000000000000001,"t":8,"ts":5,"td":1,"ab":1},{"p":[419,4,-485],"s":[10,2,39],"l":1,"c":"#2787ca","o":0.7000000000000001,"t":8,"ts":-0.1,"td":1,"ab":1},{"p":[426,20,-485],"s":[8,2,5],"c":"#000000","e":"#18180a"},{"p":[329,0,-485],"s":[3,8,45],"c":"#ffffff","e":"#18180a"},{"p":[329,8,-485],"s":[4,2,46],"c":"#939393","e":"#18180a","t":11},{"p":[323,0,-464],"s":[9,8,3],"c":"#ffffff","e":"#18180a"},{"p":[323,0,-506],"s":[9,8,3],"c":"#ffffff","e":"#18180a"},{"p":[323,8,-464],"s":[8,2,4],"c":"#939393","e":"#18180a","t":11},{"p":[323,8,-506],"s":[8,2,4],"c":"#939393","e":"#18180a","t":11},{"p":[323,0,-485],"s":[9,4,40],"c":"#ffffff","e":"#18180a"},{"p":[316,1,-470],"s":[8,33,4],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[316,1,-500],"s":[8,33,4],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[316,34,-485],"s":[9,4,37],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[316,19,-485],"s":[9,1,5],"c":"#a7a7a7","e":"#18180a"},{"p":[316,22,-485],"s":[9,1,5],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[316,19,-482],"s":[9,4,1],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[316,19,-488],"s":[9,4,1],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[321,6,-485],"s":[1,15,5],"l":1,"c":"#2787ca","o":0.7000000000000001,"t":8,"ts":5,"td":1,"ab":1},{"p":[323,4,-485],"s":[10,2,39],"l":1,"c":"#2787ca","o":0.7000000000000001,"t":8,"ts":-0.1,"td":1,"ab":1},{"p":[316,20,-485],"s":[8,2,5],"c":"#000000","e":"#18180a"},{"p":[320,2,-473],"s":[33,1,27],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[320,2,-496],"s":[30,1,19],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[338,2,-476],"s":[3,1,14],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[324,3,-458],"s":[7,6,8],"i":18,"l":1,"r":[3.13,-1.41,3.13],"c":"#85aa6c"},{"p":[433,3,-188],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.7,-3.14],"c":"#85aa6c"},{"p":[432,3,-240],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,0.17,-3.14],"c":"#85aa6c"},{"p":[422,3,-241],"s":[7,6,8],"i":18,"l":1,"r":[-3.14,-0.53,-3.14],"c":"#85aa6c"},{"p":[240,13,-221],"s":[14,3,4],"e":"#18180a"},{"p":[241,16,-219],"s":[4,13,1],"pe":1,"c":"#b1b1b1","t":2},{"p":[245,16,-219],"s":[4,12,1],"pe":1,"c":"#b1b1b1","t":2},{"p":[236,15,-219],"s":[6,13,1],"pe":1,"c":"#b1b1b1","t":2},{"p":[340,2,-74],"s":[6,8,6],"i":2},{"p":[477,2,-37],"s":[6,8,6],"i":2},{"p":[333,0,-114],"s":[8,8,125],"c":"#696969","e":"#18180a","t":11},{"p":[340,2,-121],"s":[1,23,5],"l":1,"r":[0,0,0.17],"c":"#a7a7a7","t":2},{"p":[474,2,-120],"s":[12,12,12],"i":1},{"p":[474,2,-108],"s":[12,12,12],"i":1},{"p":[474,2,-28],"s":[12,12,12],"i":1},{"p":[474,14,-28],"s":[12,12,12],"i":1},{"p":[340,2,-80],"s":[6,8,6],"i":2},{"p":[-17,0,-115],"s":[18,38,2],"c":"#ffffff","e":"#18180a"},{"p":[-68,0,-116],"s":[20,12,1],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[-28,0,-115],"s":[4,26,4],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-42,26,-115],"s":[32,4,4],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-56,0,-115],"s":[4,26,4],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-1,0,-107],"s":[1,12,4],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[-2,0,-89],"s":[4,26,4],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-2,0,-61],"s":[4,26,4],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-2,26,-75],"s":[4,4,32],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-1,0,-46],"s":[1,12,30],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[-2,0,-47],"s":[2,38,24],"c":"#ffffff","e":"#18180a"},{"p":[-2,30,-75],"s":[2,8,32],"c":"#ffffff","e":"#18180a"},{"p":[-67,0,-115],"s":[18,38,2],"c":"#ffffff","e":"#18180a"},{"p":[-42,30,-115],"s":[32,8,2],"c":"#ffffff","e":"#18180a"},{"p":[-2,2,-88],"s":[9,1,10],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-37,0,-80],"s":[72,2,72],"c":"#434343","e":"#18180a"},{"p":[-55,2,-115],"s":[7,1,11],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-64,2,-113],"s":[11,1,3],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[2,2,-100],"s":[5,1,14],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-15,2,-113],"s":[6,1,4],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-3,2,-97],"s":[4,1,8],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-4,2,-61],"s":[7,1,13],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-38,0,-43],"s":[70,38,2],"c":"#ffffff","e":"#18180a"},{"p":[-74,0,-79],"s":[2,38,70],"c":"#ffffff","e":"#18180a"},{"p":[-72,0,-113],"s":[8,38,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-5,0,-45],"s":[6,38,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-72,0,-45],"s":[8,38,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-33,2,-116],"s":[2,1,8],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-38,34,-112],"s":[60,4,6],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-38,34,-46],"s":[60,4,6],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-71,34,-79],"s":[6,4,60],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-5,34,-79],"s":[6,4,60],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-38,38,-106],"s":[76,4,22],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-4,0,-39],"s":[8,38,8],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-11,38,-79],"s":[22,4,32],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-65,38,-79],"s":[22,4,32],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[-17,2,-47],"s":[3,14,1],"l":1,"r":[0.17,0,0],"c":"#989898","t":2},{"p":[-24,2,-47],"s":[3,14,1],"l":1,"r":[0.17,0,0],"c":"#989898","t":2},{"p":[-70,2,-52],"s":[6,8,6],"i":2},{"p":[-70,2,-58],"s":[6,8,6],"i":2},{"p":[369,2,-458],"s":[12,12,12],"i":8},{"p":[381,2,-458],"s":[12,12,12],"i":8,"r":[0,1.57,0]},{"p":[375,8,-458],"s":[24,7,12],"l":1,"c":"#3964a2","t":5,"ab":1},{"p":[29,51,-29],"s":[12,8,1],"l":1,"c":"#2f241a","e":"#18180a","t":5,"ab":1},{"p":[29,59,-29],"s":[14,6,1],"l":1,"c":"#2f241a","e":"#18180a","t":5,"ab":1},{"p":[29,52,-29],"s":[10,8,2],"l":1,"c":"#7d634b","e":"#18180a","t":5,"ab":1},{"p":[29,60,-29],"s":[12,4,2],"l":1,"c":"#7d634b","e":"#18180a","t":5,"ab":1},{"p":[333,2,-514],"s":[27,14,4],"e":"#18180a"},{"p":[328,2,-533],"s":[4,1,7],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[223,13,-221],"s":[15,1,34],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-89,0,-258],"s":[33,12,97],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[-1,0,-93],"s":[1,12,4],"c":"#696969","e":"#18180a","t":11,"bo":1},{"p":[-1,0,-100],"s":[1,5,10],"c":"#464646","e":"#18180a","t":11,"bo":1},{"p":[-2,0,-107],"s":[2,38,4],"c":"#ffffff","e":"#18180a"},{"p":[-2,15,-100],"s":[2,23,10],"c":"#ffffff","e":"#18180a"},{"p":[-2,0,-100],"s":[2,5,10],"c":"#bebebe","e":"#18180a"},{"p":[-1,5,-99],"s":[1,10,4],"pe":1,"c":"#afafaf","t":2},{"p":[-1,5,-103],"s":[1,11,4],"pe":1,"c":"#afafaf","t":2},{"p":[-1,5,-96],"s":[1,11,2],"pe":1,"c":"#afafaf","t":2},{"p":[187,13,-300],"s":[4,4,14],"e":"#18180a"},{"p":[187,13,-312],"s":[4,19,10],"e":"#18180a"},{"p":[187,28,-300],"s":[4,4,14],"e":"#18180a"},{"p":[185,16,-301],"s":[1,12,4],"pe":1,"c":"#b1b1b1","t":2},{"p":[185,17,-305],"s":[1,12,4],"pe":1,"c":"#b1b1b1","t":2},{"p":[-89,0,-258],"s":[32,61,96],"c":"#ffffff","e":"#18180a"},{"p":[383,2,-186],"s":[6,8,6],"i":2},{"p":[363,19,-186],"s":[6,8,6],"i":2},{"p":[185,17,-296],"s":[1,12,6],"pe":1,"c":"#b1b1b1","t":2},{"p":[391,48,-171],"s":[8,5,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[382,48,-173],"s":[4,1,3],"l":1,"c":"#a7a7a7","e":"#18180a"},{"p":[341,48,-143],"s":[8,5,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[339,48,-150],"s":[4,1,3],"l":1,"c":"#a7a7a7","e":"#18180a"},{"p":[348,48,-146],"s":[4,2,3],"l":1,"c":"#a7a7a7","e":"#18180a"},{"p":[324,50,-158],"s":[10,10,14],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[325,50,-147],"s":[12,13,9],"c":"#a7a7a7","e":"#18180a","bo":1},{"p":[332,52,-173],"s":[5,1,5],"l":1,"c":"#a7a7a7","e":"#18180a"},{"p":[139,38,-441],"s":[35,72,116],"v":1,"c":"#8e8e8e","t":8},{"p":[332,52,-157],"s":[2,1,2],"l":1,"c":"#a7a7a7","e":"#18180a"},{"p":[367,2,-144],"s":[4,2,5],"l":1,"r":[-3.14,0.17,-3.14],"c":"#ffffff","e":"#18180a"},{"p":[288,2,-51],"s":[4,2,5],"l":1,"r":[-3.14,0.17,-3.14],"c":"#ffffff","e":"#18180a"},{"p":[-67,13,-278],"s":[12,12,12],"i":1},{"p":[73,13,-371],"s":[12,12,12],"i":1},{"p":[382,2,-265],"s":[12,12,12],"i":1},{"p":[-16,13,-357],"s":[12,12,12],"i":1},{"p":[-4,13,-357],"s":[12,12,12],"i":1},{"p":[-10,25,-357],"s":[12,12,12],"i":1},{"p":[-11,13,-348],"s":[6,8,6],"i":2},{"p":[-16,13,-355],"s":[22,1,24],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[0,13,-356],"s":[10,1,19],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[-4,14,-347],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.06,0],"c":"#85aa6c"},{"p":[-17,14,-348],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.06,0],"c":"#85aa6c"},{"p":[-23,14,-364],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.41,0],"c":"#85aa6c"},{"p":[82,14,-351],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-0.33,-3.14],"c":"#85aa6c"},{"p":[11,14,-321],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.97,0],"c":"#85aa6c"},{"p":[187,24,-255],"s":[4,1,3],"l":1,"e":"#18180a"},{"p":[-69,14,-300],"s":[7,6,8],"i":18,"l":1,"r":[3.14,-1.03,3.14],"c":"#85aa6c"},{"p":[247,3,-405],"s":[7,6,8],"i":18,"l":1,"r":[3.14,0.86,-3.14],"c":"#85aa6c"},{"p":[393,3,-511],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.38,0],"c":"#85aa6c"},{"p":[124,2,-64],"s":[12,12,12],"i":1},{"p":[168,3,-36],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.53,0],"c":"#85aa6c"},{"p":[189,3,9],"s":[7,6,8],"i":18,"l":1,"r":[0,0.35,0],"c":"#85aa6c"},{"p":[124,14,-64],"s":[12,12,12],"i":1},{"p":[124,2,-71],"s":[18,1,7],"l":1,"c":"#8e8e8e","t":8,"ab":1},{"p":[89,3,-104],"s":[7,6,8],"i":18,"l":1,"r":[0,-1.23,0],"c":"#85aa6c"},{"p":[161,3,-109],"s":[7,6,8],"i":18,"l":1,"r":[0,-0.7,0],"c":"#85aa6c"},{"p":[-41,76,-469],"s":[58,0,24],"i":11,"l":1,"r":[1.57,0,0],"sad":1},{"p":[-66,61,-472],"s":[4,30,3],"l":1,"c":"#3e352b","e":"#18180a","t":5},{"p":[-41,63,-470],"s":[61,26,1],"l":1,"c":"#3e352b","e":"#18180a","t":5},{"p":[-15,61,-472],"s":[4,30,3],"l":1,"c":"#3e352b","e":"#18180a","t":5},{"p":[431,69,-527],"s":[54,0,21],"i":11,"l":1,"r":[1.57,0,-1.57],"sad":1},{"p":[434,52,-503],"s":[4,30,3],"l":1,"c":"#3e352b","e":"#18180a","t":5},{"p":[434,52,-550],"s":[4,30,3],"l":1,"c":"#3e352b","e":"#18180a","t":5},{"p":[432,57,-527],"s":[1,23,57],"l":1,"c":"#3e352b","e":"#18180a","t":5},{"p":[291,38,-284],"s":[58,0,23],"i":11,"l":1,"r":[1.57,0,0],"sad":1},{"p":[291,25,-285],"s":[62,26,1],"l":1,"c":"#3e352b","t":5}]};
    
    /***/ }),
    
    /***/ "./node_modules/axios/index.js":
    /*!*************************************!*\
      !*** ./node_modules/axios/index.js ***!
      \*************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/adapters/xhr.js":
    /*!************************************************!*\
      !*** ./node_modules/axios/lib/adapters/xhr.js ***!
      \************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
    var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
    var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
    var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
    var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
    var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");
    
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
    
        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }
    
        var request = new XMLHttpRequest();
    
        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password || '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }
    
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    
        // Set the request timeout in MS
        request.timeout = config.timeout;
    
        // Listen for ready state
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
    
          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }
    
          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };
    
          settle(resolve, reject, response);
    
          // Clean up request
          request = null;
        };
    
        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
    
          reject(createError('Request aborted', config, 'ECONNABORTED', request));
    
          // Clean up request
          request = null;
        };
    
        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));
    
          // Clean up request
          request = null;
        };
    
        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
            request));
    
          // Clean up request
          request = null;
        };
    
        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
    
          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies.read(config.xsrfCookieName) :
            undefined;
    
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
    
        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }
    
        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
    
        // Add responseType to request if needed
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config.responseType !== 'json') {
              throw e;
            }
          }
        }
    
        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }
    
        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }
    
        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
    
            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }
    
        if (requestData === undefined) {
          requestData = null;
        }
    
        // Send the request
        request.send(requestData);
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/axios.js":
    /*!*****************************************!*\
      !*** ./node_modules/axios/lib/axios.js ***!
      \*****************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
    var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
    var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
    var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
    var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");
    
    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
    
      // Copy axios.prototype to instance
      utils.extend(instance, Axios.prototype, context);
    
      // Copy context to instance
      utils.extend(instance, context);
    
      return instance;
    }
    
    // Create the default instance to be exported
    var axios = createInstance(defaults);
    
    // Expose Axios class to allow class inheritance
    axios.Axios = Axios;
    
    // Factory for creating new instances
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };
    
    // Expose Cancel & CancelToken
    axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
    axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
    axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
    
    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");
    
    module.exports = axios;
    
    // Allow use of default import syntax in TypeScript
    module.exports.default = axios;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/cancel/Cancel.js":
    /*!*************************************************!*\
      !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
      \*************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }
    
    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };
    
    Cancel.prototype.__CANCEL__ = true;
    
    module.exports = Cancel;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/cancel/CancelToken.js":
    /*!******************************************************!*\
      !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
    
    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }
    
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
    
      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }
    
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    
    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };
    
    module.exports = CancelToken;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/cancel/isCancel.js":
    /*!***************************************************!*\
      !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
      \***************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/Axios.js":
    /*!**********************************************!*\
      !*** ./node_modules/axios/lib/core/Axios.js ***!
      \**********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
    var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
    var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
    var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
    
    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    
    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
    
      config = mergeConfig(this.defaults, config);
    
      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }
    
      // Hook up interceptors middleware
      var chain = [dispatchRequest, undefined];
      var promise = Promise.resolve(config);
    
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
    
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });
    
      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }
    
      return promise;
    };
    
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };
    
    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url
        }));
      };
    });
    
    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(utils.merge(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });
    
    module.exports = Axios;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/InterceptorManager.js":
    /*!***********************************************************!*\
      !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    function InterceptorManager() {
      this.handlers = [];
    }
    
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
      });
      return this.handlers.length - 1;
    };
    
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    
    module.exports = InterceptorManager;
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/buildFullPath.js":
    /*!******************************************************!*\
      !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
    var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");
    
    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/createError.js":
    /*!****************************************************!*\
      !*** ./node_modules/axios/lib/core/createError.js ***!
      \****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");
    
    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/dispatchRequest.js":
    /*!********************************************************!*\
      !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
    var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
    var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
    
    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    
    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
    
      // Ensure headers exist
      config.headers = config.headers || {};
    
      // Transform request data
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );
    
      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
    
      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
    
      var adapter = config.adapter || defaults.adapter;
    
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
    
        // Transform response data
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );
    
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
    
          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
    
        return Promise.reject(reason);
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/enhanceError.js":
    /*!*****************************************************!*\
      !*** ./node_modules/axios/lib/core/enhanceError.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
    
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
    
      error.toJSON = function() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/mergeConfig.js":
    /*!****************************************************!*\
      !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
      \****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
    
    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    module.exports = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};
    
      var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
      var defaultToConfig2Keys = [
        'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',
        'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath'
      ];
    
      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        }
      });
    
      utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
        if (utils.isObject(config2[prop])) {
          config[prop] = utils.deepMerge(config1[prop], config2[prop]);
        } else if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (utils.isObject(config1[prop])) {
          config[prop] = utils.deepMerge(config1[prop]);
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });
    
      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });
    
      var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys);
    
      var otherKeys = Object
        .keys(config2)
        .filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });
    
      utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
        if (typeof config2[prop] !== 'undefined') {
          config[prop] = config2[prop];
        } else if (typeof config1[prop] !== 'undefined') {
          config[prop] = config1[prop];
        }
      });
    
      return config;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/settle.js":
    /*!***********************************************!*\
      !*** ./node_modules/axios/lib/core/settle.js ***!
      \***********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");
    
    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/core/transformData.js":
    /*!******************************************************!*\
      !*** ./node_modules/axios/lib/core/transformData.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    module.exports = function transformData(data, headers, fns) {
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });
    
      return data;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/defaults.js":
    /*!********************************************!*\
      !*** ./node_modules/axios/lib/defaults.js ***!
      \********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    /* WEBPACK VAR INJECTION */(function(process) {
    
    var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
    var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
    
    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };
    
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }
    
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
      }
      return adapter;
    }
    
    var defaults = {
      adapter: getDefaultAdapter(),
    
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');
        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }
        return data;
      }],
    
      transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (e) { /* Ignore */ }
        }
        return data;
      }],
    
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
    
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
    
      maxContentLength: -1,
    
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    
    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };
    
    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    
    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    
    module.exports = defaults;
    
    /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/bind.js":
    /*!************************************************!*\
      !*** ./node_modules/axios/lib/helpers/bind.js ***!
      \************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/buildURL.js":
    /*!****************************************************!*\
      !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
      \****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    function encode(val) {
      return encodeURIComponent(val).
        replace(/%40/gi, '@').
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }
    
    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    module.exports = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }
    
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
    
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }
    
          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }
    
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });
    
        serializedParams = parts.join('&');
      }
    
      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
    
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }
    
      return url;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/combineURLs.js":
    /*!*******************************************************!*\
      !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/cookies.js":
    /*!***************************************************!*\
      !*** ./node_modules/axios/lib/helpers/cookies.js ***!
      \***************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    module.exports = (
      utils.isStandardBrowserEnv() ?
    
      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));
    
              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }
    
              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }
    
              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }
    
              if (secure === true) {
                cookie.push('secure');
              }
    
              document.cookie = cookie.join('; ');
            },
    
            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },
    
            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :
    
      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
    /*!*********************************************************!*\
      !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
      \*********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    module.exports = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
    /*!***********************************************************!*\
      !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    module.exports = (
      utils.isStandardBrowserEnv() ?
    
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;
    
          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;
    
            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }
    
            urlParsingNode.setAttribute('href', href);
    
            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }
    
          originURL = resolveURL(window.location.href);
    
          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :
    
      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
    /*!***************************************************************!*\
      !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
      \***************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
    
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
    /*!********************************************************!*\
      !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
    
    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];
    
    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
    
      if (!headers) { return parsed; }
    
      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
    
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });
    
      return parsed;
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/helpers/spread.js":
    /*!**************************************************!*\
      !*** ./node_modules/axios/lib/helpers/spread.js ***!
      \**************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/axios/lib/utils.js":
    /*!*****************************************!*\
      !*** ./node_modules/axios/lib/utils.js ***!
      \*****************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
    
    /*global toString:true*/
    
    // utils is a library of generic helper functions non-specific to axios
    
    var toString = Object.prototype.toString;
    
    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }
    
    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }
    
    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }
    
    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }
    
    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }
    
    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }
    
    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }
    
    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }
    
    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }
    
    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }
    
    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }
    
    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }
    
    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }
    
    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    
    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }
    
    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }
    
    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }
    
    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }
    
      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }
    
      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    
    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = merge(result[key], val);
        } else {
          result[key] = val;
        }
      }
    
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    
    /**
     * Function equal to merge with the difference being that no reference
     * to original objects is kept.
     *
     * @see merge
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function deepMerge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (typeof result[key] === 'object' && typeof val === 'object') {
          result[key] = deepMerge(result[key], val);
        } else if (typeof val === 'object') {
          result[key] = deepMerge({}, val);
        } else {
          result[key] = val;
        }
      }
    
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    
    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    
    module.exports = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      deepMerge: deepMerge,
      extend: extend,
      trim: trim
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/base64-js/index.js":
    /*!*****************************************!*\
      !*** ./node_modules/base64-js/index.js ***!
      \*****************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    
    
    exports.byteLength = byteLength
    exports.toByteArray = toByteArray
    exports.fromByteArray = fromByteArray
    
    var lookup = []
    var revLookup = []
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
    
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i]
      revLookup[code.charCodeAt(i)] = i
    }
    
    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup['-'.charCodeAt(0)] = 62
    revLookup['_'.charCodeAt(0)] = 63
    
    function getLens (b64) {
      var len = b64.length
    
      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }
    
      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf('=')
      if (validLen === -1) validLen = len
    
      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4)
    
      return [validLen, placeHoldersLen]
    }
    
    // base64 is 4/3 + up to two characters of the original data
    function byteLength (b64) {
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }
    
    function _byteLength (b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }
    
    function toByteArray (b64) {
      var tmp
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
    
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
    
      var curByte = 0
    
      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen
    
      for (var i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)]
        arr[curByte++] = (tmp >> 16) & 0xFF
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }
    
      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4)
        arr[curByte++] = tmp & 0xFF
      }
    
      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2)
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }
    
      return arr
    }
    
    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }
    
    function encodeChunk (uint8, start, end) {
      var tmp
      var output = []
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF)
        output.push(tripletToBase64(tmp))
      }
      return output.join('')
    }
    
    function fromByteArray (uint8) {
      var tmp
      var len = uint8.length
      var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
      var parts = []
      var maxChunkLength = 16383 // must be multiple of 3
    
      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(
          uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
        ))
      }
    
      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1]
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        )
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1]
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        )
      }
    
      return parts.join('')
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/buffer/index.js":
    /*!**************************************!*\
      !*** ./node_modules/buffer/index.js ***!
      \**************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    "use strict";
    /* WEBPACK VAR INJECTION */(function(global) {/*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    /* eslint-disable no-proto */
    
    
    
    var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
    var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
    var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")
    
    exports.Buffer = Buffer
    exports.SlowBuffer = SlowBuffer
    exports.INSPECT_MAX_BYTES = 50
    
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.
    
     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
      ? global.TYPED_ARRAY_SUPPORT
      : typedArraySupport()
    
    /*
     * Export kMaxLength after typed array support is determined.
     */
    exports.kMaxLength = kMaxLength()
    
    function typedArraySupport () {
      try {
        var arr = new Uint8Array(1)
        arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
        return arr.foo() === 42 && // typed array instances can be augmented
            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
            arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
      } catch (e) {
        return false
      }
    }
    
    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }
    
    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length)
        that.__proto__ = Buffer.prototype
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length)
        }
        that.length = length
      }
    
      return that
    }
    
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */
    
    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }
    
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }
    
    Buffer.poolSize = 8192 // not used by this implementation
    
    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype
      return arr
    }
    
    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }
    
      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }
    
      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }
    
      return fromObject(that, value)
    }
    
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    }
    
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype
      Buffer.__proto__ = Uint8Array
      if (typeof Symbol !== 'undefined' && Symbol.species &&
          Buffer[Symbol.species] === Buffer) {
        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        Object.defineProperty(Buffer, Symbol.species, {
          value: null,
          configurable: true
        })
      }
    }
    
    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }
    
    function alloc (that, size, fill, encoding) {
      assertSize(size)
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }
    
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    }
    
    function allocUnsafe (that, size) {
      assertSize(size)
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0
        }
      }
      return that
    }
    
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    }
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    }
    
    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8'
      }
    
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }
    
      var length = byteLength(string, encoding) | 0
      that = createBuffer(that, length)
    
      var actual = that.write(string, encoding)
    
      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual)
      }
    
      return that
    }
    
    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0
      that = createBuffer(that, length)
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255
      }
      return that
    }
    
    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength // this throws if `array` is not a valid ArrayBuffer
    
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }
    
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }
    
      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array)
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset)
      } else {
        array = new Uint8Array(array, byteOffset, length)
      }
    
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array
        that.__proto__ = Buffer.prototype
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array)
      }
      return that
    }
    
    function fromObject (that, obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0
        that = createBuffer(that, len)
    
        if (that.length === 0) {
          return that
        }
    
        obj.copy(that, 0, 0, len)
        return that
      }
    
      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }
    
        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }
    
      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }
    
    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    
    function SlowBuffer (length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0
      }
      return Buffer.alloc(+length)
    }
    
    Buffer.isBuffer = function isBuffer (b) {
      return !!(b != null && b._isBuffer)
    }
    
    Buffer.compare = function compare (a, b) {
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }
    
      if (a === b) return 0
    
      var x = a.length
      var y = b.length
    
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i]
          y = b[i]
          break
        }
      }
    
      if (x < y) return -1
      if (y < x) return 1
      return 0
    }
    
    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    }
    
    Buffer.concat = function concat (list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
    
      if (list.length === 0) {
        return Buffer.alloc(0)
      }
    
      var i
      if (length === undefined) {
        length = 0
        for (i = 0; i < list.length; ++i) {
          length += list[i].length
        }
      }
    
      var buffer = Buffer.allocUnsafe(length)
      var pos = 0
      for (i = 0; i < list.length; ++i) {
        var buf = list[i]
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos)
        pos += buf.length
      }
      return buffer
    }
    
    function byteLength (string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string
      }
    
      var len = string.length
      if (len === 0) return 0
    
      // Use a for loop to avoid recursion
      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    Buffer.byteLength = byteLength
    
    function slowToString (encoding, start, end) {
      var loweredCase = false
    
      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
    
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }
    
      if (end === undefined || end > this.length) {
        end = this.length
      }
    
      if (end <= 0) {
        return ''
      }
    
      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0
      start >>>= 0
    
      if (end <= start) {
        return ''
      }
    
      if (!encoding) encoding = 'utf8'
    
      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)
    
          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)
    
          case 'ascii':
            return asciiSlice(this, start, end)
    
          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)
    
          case 'base64':
            return base64Slice(this, start, end)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase()
            loweredCase = true
        }
      }
    }
    
    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true
    
    function swap (b, n, m) {
      var i = b[n]
      b[n] = b[m]
      b[m] = i
    }
    
    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1)
      }
      return this
    }
    
    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3)
        swap(this, i + 1, i + 2)
      }
      return this
    }
    
    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7)
        swap(this, i + 1, i + 6)
        swap(this, i + 2, i + 5)
        swap(this, i + 3, i + 4)
      }
      return this
    }
    
    Buffer.prototype.toString = function toString () {
      var length = this.length | 0
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    }
    
    Buffer.prototype.equals = function equals (b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    }
    
    Buffer.prototype.inspect = function inspect () {
      var str = ''
      var max = exports.INSPECT_MAX_BYTES
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
        if (this.length > max) str += ' ... '
      }
      return '<Buffer ' + str + '>'
    }
    
    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!Buffer.isBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }
    
      if (start === undefined) {
        start = 0
      }
      if (end === undefined) {
        end = target ? target.length : 0
      }
      if (thisStart === undefined) {
        thisStart = 0
      }
      if (thisEnd === undefined) {
        thisEnd = this.length
      }
    
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }
    
      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }
    
      start >>>= 0
      end >>>= 0
      thisStart >>>= 0
      thisEnd >>>= 0
    
      if (this === target) return 0
    
      var x = thisEnd - thisStart
      var y = end - start
      var len = Math.min(x, y)
    
      var thisCopy = this.slice(thisStart, thisEnd)
      var targetCopy = target.slice(start, end)
    
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i]
          y = targetCopy[i]
          break
        }
      }
    
      if (x < y) return -1
      if (y < x) return 1
      return 0
    }
    
    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1
    
      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset
        byteOffset = 0
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000
      }
      byteOffset = +byteOffset  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1)
      }
    
      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0
        else return -1
      }
    
      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding)
      }
    
      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }
    
      throw new TypeError('val must be string, number or Buffer')
    }
    
    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1
      var arrLength = arr.length
      var valLength = val.length
    
      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase()
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2
          arrLength /= 2
          valLength /= 2
          byteOffset /= 2
        }
      }
    
      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }
    
      var i
      if (dir) {
        var foundIndex = -1
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex
            foundIndex = -1
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
        for (i = byteOffset; i >= 0; i--) {
          var found = true
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false
              break
            }
          }
          if (found) return i
        }
      }
    
      return -1
    }
    
    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    }
    
    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    }
    
    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    }
    
    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0
      var remaining = buf.length - offset
      if (!length) {
        length = remaining
      } else {
        length = Number(length)
        if (length > remaining) {
          length = remaining
        }
      }
    
      // must be an even number of digits
      var strLen = string.length
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
    
      if (length > strLen / 2) {
        length = strLen / 2
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16)
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed
      }
      return i
    }
    
    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }
    
    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }
    
    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }
    
    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8'
        length = this.length
        offset = 0
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset
        length = this.length
        offset = 0
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0
        if (isFinite(length)) {
          length = length | 0
          if (encoding === undefined) encoding = 'utf8'
        } else {
          encoding = length
          length = undefined
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }
    
      var remaining = this.length - offset
      if (length === undefined || length > remaining) length = remaining
    
      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }
    
      if (!encoding) encoding = 'utf8'
    
      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)
    
          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)
    
          case 'ascii':
            return asciiWrite(this, string, offset, length)
    
          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)
    
          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    
    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    }
    
    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf)
      } else {
        return base64.fromByteArray(buf.slice(start, end))
      }
    }
    
    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end)
      var res = []
    
      var i = start
      while (i < end) {
        var firstByte = buf[i]
        var codePoint = null
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1
    
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint
    
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte
              }
              break
            case 2:
              secondByte = buf[i + 1]
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 3:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 4:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              fourthByte = buf[i + 3]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint
                }
              }
          }
        }
    
        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD
          bytesPerSequence = 1
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000
          res.push(codePoint >>> 10 & 0x3FF | 0xD800)
          codePoint = 0xDC00 | codePoint & 0x3FF
        }
    
        res.push(codePoint)
        i += bytesPerSequence
      }
    
      return decodeCodePointsArray(res)
    }
    
    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000
    
    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }
    
      // Decode in chunks to avoid "call stack size exceeded".
      var res = ''
      var i = 0
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        )
      }
      return res
    }
    
    function asciiSlice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)
    
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F)
      }
      return ret
    }
    
    function latin1Slice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)
    
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i])
      }
      return ret
    }
    
    function hexSlice (buf, start, end) {
      var len = buf.length
    
      if (!start || start < 0) start = 0
      if (!end || end < 0 || end > len) end = len
    
      var out = ''
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i])
      }
      return out
    }
    
    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end)
      var res = ''
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
      }
      return res
    }
    
    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length
      start = ~~start
      end = end === undefined ? len : ~~end
    
      if (start < 0) {
        start += len
        if (start < 0) start = 0
      } else if (start > len) {
        start = len
      }
    
      if (end < 0) {
        end += len
        if (end < 0) end = 0
      } else if (end > len) {
        end = len
      }
    
      if (end < start) end = start
    
      var newBuf
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end)
        newBuf.__proto__ = Buffer.prototype
      } else {
        var sliceLen = end - start
        newBuf = new Buffer(sliceLen, undefined)
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start]
        }
      }
    
      return newBuf
    }
    
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }
    
    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length)
      }
    
      var val = this[offset + --byteLength]
      var mul = 1
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length)
      return this[offset]
    }
    
    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      return this[offset] | (this[offset + 1] << 8)
    }
    
    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      return (this[offset] << 8) | this[offset + 1]
    }
    
    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    }
    
    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    }
    
    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var i = byteLength
      var mul = 1
      var val = this[offset + --i]
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length)
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    }
    
    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset] | (this[offset + 1] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset + 1] | (this[offset] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    }
    
    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    }
    
    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, true, 23, 4)
    }
    
    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, false, 23, 4)
    }
    
    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, true, 52, 8)
    }
    
    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, false, 52, 8)
    }
    
    function checkInt (buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }
    
    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }
    
      var mul = 1
      var i = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }
    
      var i = byteLength - 1
      var mul = 1
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8
      }
    }
    
    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }
    
    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }
    
    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
      }
    }
    
    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24)
        this[offset + 2] = (value >>> 16)
        this[offset + 1] = (value >>> 8)
        this[offset] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }
    
    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }
    
    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      var i = 0
      var mul = 1
      var sub = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      var i = byteLength - 1
      var mul = 1
      var sub = 0
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
      if (value < 0) value = 0xff + value + 1
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }
    
    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }
    
    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
        this[offset + 2] = (value >>> 16)
        this[offset + 3] = (value >>> 24)
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }
    
    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (value < 0) value = 0xffffffff + value + 1
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }
    
    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }
    
    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4)
      return offset + 4
    }
    
    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    }
    
    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8)
      return offset + 8
    }
    
    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    }
    
    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0
      if (!end && end !== 0) end = this.length
      if (targetStart >= target.length) targetStart = target.length
      if (!targetStart) targetStart = 0
      if (end > 0 && end < start) end = start
    
      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0
    
      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')
    
      // Are we oob?
      if (end > this.length) end = this.length
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start
      }
    
      var len = end - start
      var i
    
      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start]
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start]
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        )
      }
    
      return len
    }
    
    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start
          start = 0
          end = this.length
        } else if (typeof end === 'string') {
          encoding = end
          end = this.length
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0)
          if (code < 256) {
            val = code
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255
      }
    
      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }
    
      if (end <= start) {
        return this
      }
    
      start = start >>> 0
      end = end === undefined ? this.length : end >>> 0
    
      if (!val) val = 0
    
      var i
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val
        }
      } else {
        var bytes = Buffer.isBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString())
        var len = bytes.length
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len]
        }
      }
    
      return this
    }
    
    // HELPER FUNCTIONS
    // ================
    
    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
    
    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '')
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '='
      }
      return str
    }
    
    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }
    
    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }
    
    function utf8ToBytes (string, units) {
      units = units || Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null
      var bytes = []
    
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)
    
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            }
    
            // valid lead
            leadSurrogate = codePoint
    
            continue
          }
    
          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            leadSurrogate = codePoint
            continue
          }
    
          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        }
    
        leadSurrogate = null
    
        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint)
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else {
          throw new Error('Invalid code point')
        }
      }
    
      return bytes
    }
    
    function asciiToBytes (str) {
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF)
      }
      return byteArray
    }
    
    function utf16leToBytes (str, units) {
      var c, hi, lo
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break
    
        c = str.charCodeAt(i)
        hi = c >> 8
        lo = c % 256
        byteArray.push(lo)
        byteArray.push(hi)
      }
    
      return byteArray
    }
    
    function base64ToBytes (str) {
      return base64.toByteArray(base64clean(str))
    }
    
    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i]
      }
      return i
    }
    
    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }
    
    /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))
    
    /***/ }),
    
    /***/ "./node_modules/event-lite/event-lite.js":
    /*!***********************************************!*\
      !*** ./node_modules/event-lite/event-lite.js ***!
      \***********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    /**
     * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
     *
     * @copyright Yusuke Kawasaki
     * @license MIT
     * @constructor
     * @see https://github.com/kawanet/event-lite
     * @see http://kawanet.github.io/event-lite/EventLite.html
     * @example
     * var EventLite = require("event-lite");
     *
     * function MyClass() {...}             // your class
     *
     * EventLite.mixin(MyClass.prototype);  // import event methods
     *
     * var obj = new MyClass();
     * obj.on("foo", function() {...});     // add event listener
     * obj.once("bar", function() {...});   // add one-time event listener
     * obj.emit("foo");                     // dispatch event
     * obj.emit("bar");                     // dispatch another event
     * obj.off("foo");                      // remove event listener
     */
    
    function EventLite() {
      if (!(this instanceof EventLite)) return new EventLite();
    }
    
    (function(EventLite) {
      // export the class for node.js
      if (true) module.exports = EventLite;
    
      // property name to hold listeners
      var LISTENERS = "listeners";
    
      // methods to export
      var methods = {
        on: on,
        once: once,
        off: off,
        emit: emit
      };
    
      // mixin to self
      mixin(EventLite.prototype);
    
      // export mixin function
      EventLite.mixin = mixin;
    
      /**
       * Import on(), once(), off() and emit() methods into target object.
       *
       * @function EventLite.mixin
       * @param target {Prototype}
       */
    
      function mixin(target) {
        for (var key in methods) {
          target[key] = methods[key];
        }
        return target;
      }
    
      /**
       * Add an event listener.
       *
       * @function EventLite.prototype.on
       * @param type {string}
       * @param func {Function}
       * @returns {EventLite} Self for method chaining
       */
    
      function on(type, func) {
        getListeners(this, type).push(func);
        return this;
      }
    
      /**
       * Add one-time event listener.
       *
       * @function EventLite.prototype.once
       * @param type {string}
       * @param func {Function}
       * @returns {EventLite} Self for method chaining
       */
    
      function once(type, func) {
        var that = this;
        wrap.originalListener = func;
        getListeners(that, type).push(wrap);
        return that;
    
        function wrap() {
          off.call(that, type, wrap);
          func.apply(this, arguments);
        }
      }
    
      /**
       * Remove an event listener.
       *
       * @function EventLite.prototype.off
       * @param [type] {string}
       * @param [func] {Function}
       * @returns {EventLite} Self for method chaining
       */
    
      function off(type, func) {
        var that = this;
        var listners;
        if (!arguments.length) {
          delete that[LISTENERS];
        } else if (!func) {
          listners = that[LISTENERS];
          if (listners) {
            delete listners[type];
            if (!Object.keys(listners).length) return off.call(that);
          }
        } else {
          listners = getListeners(that, type, true);
          if (listners) {
            listners = listners.filter(ne);
            if (!listners.length) return off.call(that, type);
            that[LISTENERS][type] = listners;
          }
        }
        return that;
    
        function ne(test) {
          return test !== func && test.originalListener !== func;
        }
      }
    
      /**
       * Dispatch (trigger) an event.
       *
       * @function EventLite.prototype.emit
       * @param type {string}
       * @param [value] {*}
       * @returns {boolean} True when a listener received the event
       */
    
      function emit(type, value) {
        var that = this;
        var listeners = getListeners(that, type, true);
        if (!listeners) return false;
        var arglen = arguments.length;
        if (arglen === 1) {
          listeners.forEach(zeroarg);
        } else if (arglen === 2) {
          listeners.forEach(onearg);
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          listeners.forEach(moreargs);
        }
        return !!listeners.length;
    
        function zeroarg(func) {
          func.call(that);
        }
    
        function onearg(func) {
          func.call(that, value);
        }
    
        function moreargs(func) {
          func.apply(that, args);
        }
      }
    
      /**
       * @ignore
       */
    
      function getListeners(that, type, readonly) {
        if (readonly && !that[LISTENERS]) return;
        var listeners = that[LISTENERS] || (that[LISTENERS] = {});
        return listeners[type] || (listeners[type] = []);
      }
    
    })(EventLite);
    
    
    /***/ }),
    
    /***/ "./node_modules/ieee754/index.js":
    /*!***************************************!*\
      !*** ./node_modules/ieee754/index.js ***!
      \***************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var nBits = -7
      var i = isLE ? (nBytes - 1) : 0
      var d = isLE ? -1 : 1
      var s = buffer[offset + i]
    
      i += d
    
      e = s & ((1 << (-nBits)) - 1)
      s >>= (-nBits)
      nBits += eLen
      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
    
      m = e & ((1 << (-nBits)) - 1)
      e >>= (-nBits)
      nBits += mLen
      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
    
      if (e === 0) {
        e = 1 - eBias
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen)
        e = e - eBias
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }
    
    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
      var i = isLE ? 0 : (nBytes - 1)
      var d = isLE ? 1 : -1
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
    
      value = Math.abs(value)
    
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0
        e = eMax
      } else {
        e = Math.floor(Math.log(value) / Math.LN2)
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--
          c *= 2
        }
        if (e + eBias >= 1) {
          value += rt / c
        } else {
          value += rt * Math.pow(2, 1 - eBias)
        }
        if (value * c >= 2) {
          e++
          c /= 2
        }
    
        if (e + eBias >= eMax) {
          m = 0
          e = eMax
        } else if (e + eBias >= 1) {
          m = ((value * c) - 1) * Math.pow(2, mLen)
          e = e + eBias
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
          e = 0
        }
      }
    
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    
      e = (e << mLen) | m
      eLen += mLen
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    
      buffer[offset + i - d] |= s * 128
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/int64-buffer/int64-buffer.js":
    /*!***************************************************!*\
      !*** ./node_modules/int64-buffer/int64-buffer.js ***!
      \***************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    /* WEBPACK VAR INJECTION */(function(Buffer) {// int64-buffer.js
    
    /*jshint -W018 */ // Confusing use of '!'.
    /*jshint -W030 */ // Expected an assignment or function call and instead saw an expression.
    /*jshint -W093 */ // Did you mean to return a conditional instead of an assignment?
    
    var Uint64BE, Int64BE, Uint64LE, Int64LE;
    
    !function(exports) {
      // constants
    
      var UNDEFINED = "undefined";
      var BUFFER = (UNDEFINED !== typeof Buffer) && Buffer;
      var UINT8ARRAY = (UNDEFINED !== typeof Uint8Array) && Uint8Array;
      var ARRAYBUFFER = (UNDEFINED !== typeof ArrayBuffer) && ArrayBuffer;
      var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
      var isArray = Array.isArray || _isArray;
      var BIT32 = 4294967296;
      var BIT24 = 16777216;
    
      // storage class
    
      var storage; // Array;
    
      // generate classes
    
      Uint64BE = factory("Uint64BE", true, true);
      Int64BE = factory("Int64BE", true, false);
      Uint64LE = factory("Uint64LE", false, true);
      Int64LE = factory("Int64LE", false, false);
    
      // class factory
    
      function factory(name, bigendian, unsigned) {
        var posH = bigendian ? 0 : 4;
        var posL = bigendian ? 4 : 0;
        var pos0 = bigendian ? 0 : 3;
        var pos1 = bigendian ? 1 : 2;
        var pos2 = bigendian ? 2 : 1;
        var pos3 = bigendian ? 3 : 0;
        var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
        var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
        var proto = Int64.prototype;
        var isName = "is" + name;
        var _isInt64 = "_" + isName;
    
        // properties
        proto.buffer = void 0;
        proto.offset = 0;
        proto[_isInt64] = true;
    
        // methods
        proto.toNumber = toNumber;
        proto.toString = toString;
        proto.toJSON = toNumber;
        proto.toArray = toArray;
    
        // add .toBuffer() method only when Buffer available
        if (BUFFER) proto.toBuffer = toBuffer;
    
        // add .toArrayBuffer() method only when Uint8Array available
        if (UINT8ARRAY) proto.toArrayBuffer = toArrayBuffer;
    
        // isUint64BE, isInt64BE
        Int64[isName] = isInt64;
    
        // CommonJS
        exports[name] = Int64;
    
        return Int64;
    
        // constructor
        function Int64(buffer, offset, value, raddix) {
          if (!(this instanceof Int64)) return new Int64(buffer, offset, value, raddix);
          return init(this, buffer, offset, value, raddix);
        }
    
        // isUint64BE, isInt64BE
        function isInt64(b) {
          return !!(b && b[_isInt64]);
        }
    
        // initializer
        function init(that, buffer, offset, value, raddix) {
          if (UINT8ARRAY && ARRAYBUFFER) {
            if (buffer instanceof ARRAYBUFFER) buffer = new UINT8ARRAY(buffer);
            if (value instanceof ARRAYBUFFER) value = new UINT8ARRAY(value);
          }
    
          // Int64BE() style
          if (!buffer && !offset && !value && !storage) {
            // shortcut to initialize with zero
            that.buffer = newArray(ZERO, 0);
            return;
          }
    
          // Int64BE(value, raddix) style
          if (!isValidBuffer(buffer, offset)) {
            var _storage = storage || Array;
            raddix = offset;
            value = buffer;
            offset = 0;
            buffer = new _storage(8);
          }
    
          that.buffer = buffer;
          that.offset = offset |= 0;
    
          // Int64BE(buffer, offset) style
          if (UNDEFINED === typeof value) return;
    
          // Int64BE(buffer, offset, value, raddix) style
          if ("string" === typeof value) {
            fromString(buffer, offset, value, raddix || 10);
          } else if (isValidBuffer(value, raddix)) {
            fromArray(buffer, offset, value, raddix);
          } else if ("number" === typeof raddix) {
            writeInt32(buffer, offset + posH, value); // high
            writeInt32(buffer, offset + posL, raddix); // low
          } else if (value > 0) {
            fromPositive(buffer, offset, value); // positive
          } else if (value < 0) {
            fromNegative(buffer, offset, value); // negative
          } else {
            fromArray(buffer, offset, ZERO, 0); // zero, NaN and others
          }
        }
    
        function fromString(buffer, offset, str, raddix) {
          var pos = 0;
          var len = str.length;
          var high = 0;
          var low = 0;
          if (str[0] === "-") pos++;
          var sign = pos;
          while (pos < len) {
            var chr = parseInt(str[pos++], raddix);
            if (!(chr >= 0)) break; // NaN
            low = low * raddix + chr;
            high = high * raddix + Math.floor(low / BIT32);
            low %= BIT32;
          }
          if (sign) {
            high = ~high;
            if (low) {
              low = BIT32 - low;
            } else {
              high++;
            }
          }
          writeInt32(buffer, offset + posH, high);
          writeInt32(buffer, offset + posL, low);
        }
    
        function toNumber() {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          if (!unsigned) high |= 0; // a trick to get signed
          return high ? (high * BIT32 + low) : low;
        }
    
        function toString(radix) {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          var str = "";
          var sign = !unsigned && (high & 0x80000000);
          if (sign) {
            high = ~high;
            low = BIT32 - low;
          }
          radix = radix || 10;
          while (1) {
            var mod = (high % radix) * BIT32 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod / radix);
            str = (mod % radix).toString(radix) + str;
            if (!high && !low) break;
          }
          if (sign) {
            str = "-" + str;
          }
          return str;
        }
    
        function writeInt32(buffer, offset, value) {
          buffer[offset + pos3] = value & 255;
          value = value >> 8;
          buffer[offset + pos2] = value & 255;
          value = value >> 8;
          buffer[offset + pos1] = value & 255;
          value = value >> 8;
          buffer[offset + pos0] = value & 255;
        }
    
        function readInt32(buffer, offset) {
          return (buffer[offset + pos0] * BIT24) +
            (buffer[offset + pos1] << 16) +
            (buffer[offset + pos2] << 8) +
            buffer[offset + pos3];
        }
      }
    
      function toArray(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = null; // Array
        if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer)) return buffer;
        return newArray(buffer, offset);
      }
    
      function toBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = BUFFER;
        if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer)) return buffer;
        var dest = new BUFFER(8);
        fromArray(dest, 0, buffer, offset);
        return dest;
      }
    
      function toArrayBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        var arrbuf = buffer.buffer;
        storage = UINT8ARRAY;
        if (raw !== false && offset === 0 && (arrbuf instanceof ARRAYBUFFER) && arrbuf.byteLength === 8) return arrbuf;
        var dest = new UINT8ARRAY(8);
        fromArray(dest, 0, buffer, offset);
        return dest.buffer;
      }
    
      function isValidBuffer(buffer, offset) {
        var len = buffer && buffer.length;
        offset |= 0;
        return len && (offset + 8 <= len) && ("string" !== typeof buffer[offset]);
      }
    
      function fromArray(destbuf, destoff, srcbuf, srcoff) {
        destoff |= 0;
        srcoff |= 0;
        for (var i = 0; i < 8; i++) {
          destbuf[destoff++] = srcbuf[srcoff++] & 255;
        }
      }
    
      function newArray(buffer, offset) {
        return Array.prototype.slice.call(buffer, offset, offset + 8);
      }
    
      function fromPositiveBE(buffer, offset, value) {
        var pos = offset + 8;
        while (pos > offset) {
          buffer[--pos] = value & 255;
          value /= 256;
        }
      }
    
      function fromNegativeBE(buffer, offset, value) {
        var pos = offset + 8;
        value++;
        while (pos > offset) {
          buffer[--pos] = ((-value) & 255) ^ 255;
          value /= 256;
        }
      }
    
      function fromPositiveLE(buffer, offset, value) {
        var end = offset + 8;
        while (offset < end) {
          buffer[offset++] = value & 255;
          value /= 256;
        }
      }
    
      function fromNegativeLE(buffer, offset, value) {
        var end = offset + 8;
        value++;
        while (offset < end) {
          buffer[offset++] = ((-value) & 255) ^ 255;
          value /= 256;
        }
      }
    
      // https://github.com/retrofox/is-array
      function _isArray(val) {
        return !!val && "[object Array]" == Object.prototype.toString.call(val);
      }
    
    }( true && typeof exports.nodeName !== 'string' ? exports : (this || {}));
    
    /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))
    
    /***/ }),
    
    /***/ "./node_modules/isarray/index.js":
    /*!***************************************!*\
      !*** ./node_modules/isarray/index.js ***!
      \***************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    var toString = {}.toString;
    
    module.exports = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/browser.js":
    /*!**************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/browser.js ***!
      \**************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // browser.js
    
    exports.encode = __webpack_require__(/*! ./encode */ "./node_modules/msgpack-lite/lib/encode.js").encode;
    exports.decode = __webpack_require__(/*! ./decode */ "./node_modules/msgpack-lite/lib/decode.js").decode;
    
    exports.Encoder = __webpack_require__(/*! ./encoder */ "./node_modules/msgpack-lite/lib/encoder.js").Encoder;
    exports.Decoder = __webpack_require__(/*! ./decoder */ "./node_modules/msgpack-lite/lib/decoder.js").Decoder;
    
    exports.createCodec = __webpack_require__(/*! ./ext */ "./node_modules/msgpack-lite/lib/ext.js").createCodec;
    exports.codec = __webpack_require__(/*! ./codec */ "./node_modules/msgpack-lite/lib/codec.js").codec;
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/buffer-global.js":
    /*!********************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/buffer-global.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    /* WEBPACK VAR INJECTION */(function(Buffer) {/* globals Buffer */
    
    module.exports =
      c(("undefined" !== typeof Buffer) && Buffer) ||
      c(this.Buffer) ||
      c(("undefined" !== typeof window) && window.Buffer) ||
      this.Buffer;
    
    function c(B) {
      return B && B.isBuffer && B;
    }
    /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "./node_modules/buffer/index.js").Buffer))
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/buffer-lite.js":
    /*!******************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/buffer-lite.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    // buffer-lite.js
    
    var MAXBUFLEN = 8192;
    
    exports.copy = copy;
    exports.toString = toString;
    exports.write = write;
    
    /**
     * Buffer.prototype.write()
     *
     * @param string {String}
     * @param [offset] {Number}
     * @returns {Number}
     */
    
    function write(string, offset) {
      var buffer = this;
      var index = offset || (offset |= 0);
      var length = string.length;
      var chr = 0;
      var i = 0;
      while (i < length) {
        chr = string.charCodeAt(i++);
    
        if (chr < 128) {
          buffer[index++] = chr;
        } else if (chr < 0x800) {
          // 2 bytes
          buffer[index++] = 0xC0 | (chr >>> 6);
          buffer[index++] = 0x80 | (chr & 0x3F);
        } else if (chr < 0xD800 || chr > 0xDFFF) {
          // 3 bytes
          buffer[index++] = 0xE0 | (chr  >>> 12);
          buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);
          buffer[index++] = 0x80 | (chr          & 0x3F);
        } else {
          // 4 bytes - surrogate pair
          chr = (((chr - 0xD800) << 10) | (string.charCodeAt(i++) - 0xDC00)) + 0x10000;
          buffer[index++] = 0xF0 | (chr >>> 18);
          buffer[index++] = 0x80 | ((chr >>> 12) & 0x3F);
          buffer[index++] = 0x80 | ((chr >>> 6)  & 0x3F);
          buffer[index++] = 0x80 | (chr          & 0x3F);
        }
      }
      return index - offset;
    }
    
    /**
     * Buffer.prototype.toString()
     *
     * @param [encoding] {String} ignored
     * @param [start] {Number}
     * @param [end] {Number}
     * @returns {String}
     */
    
    function toString(encoding, start, end) {
      var buffer = this;
      var index = start|0;
      if (!end) end = buffer.length;
      var string = '';
      var chr = 0;
    
      while (index < end) {
        chr = buffer[index++];
        if (chr < 128) {
          string += String.fromCharCode(chr);
          continue;
        }
    
        if ((chr & 0xE0) === 0xC0) {
          // 2 bytes
          chr = (chr & 0x1F) << 6 |
                (buffer[index++] & 0x3F);
    
        } else if ((chr & 0xF0) === 0xE0) {
          // 3 bytes
          chr = (chr & 0x0F)             << 12 |
                (buffer[index++] & 0x3F) << 6  |
                (buffer[index++] & 0x3F);
    
        } else if ((chr & 0xF8) === 0xF0) {
          // 4 bytes
          chr = (chr & 0x07)             << 18 |
                (buffer[index++] & 0x3F) << 12 |
                (buffer[index++] & 0x3F) << 6  |
                (buffer[index++] & 0x3F);
        }
    
        if (chr >= 0x010000) {
          // A surrogate pair
          chr -= 0x010000;
    
          string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
        } else {
          string += String.fromCharCode(chr);
        }
      }
    
      return string;
    }
    
    /**
     * Buffer.prototype.copy()
     *
     * @param target {Buffer}
     * @param [targetStart] {Number}
     * @param [start] {Number}
     * @param [end] {Number}
     * @returns {number}
     */
    
    function copy(target, targetStart, start, end) {
      var i;
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (!targetStart) targetStart = 0;
      var len = end - start;
    
      if (target === this && start < targetStart && targetStart < end) {
        // descending
        for (i = len - 1; i >= 0; i--) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        // ascending
        for (i = 0; i < len; i++) {
          target[i + targetStart] = this[i + start];
        }
      }
    
      return len;
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/bufferish-array.js":
    /*!**********************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/bufferish-array.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // bufferish-array.js
    
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    
    var exports = module.exports = alloc(0);
    
    exports.alloc = alloc;
    exports.concat = Bufferish.concat;
    exports.from = from;
    
    /**
     * @param size {Number}
     * @returns {Buffer|Uint8Array|Array}
     */
    
    function alloc(size) {
      return new Array(size);
    }
    
    /**
     * @param value {Array|ArrayBuffer|Buffer|String}
     * @returns {Array}
     */
    
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        // TypedArray to Uint8Array
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        // ArrayBuffer to Uint8Array
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        // String to Array
        return Bufferish.from.call(exports, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
    
      // Array-like to Array
      return Array.prototype.slice.call(value);
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/bufferish-buffer.js":
    /*!***********************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/bufferish-buffer.js ***!
      \***********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // bufferish-buffer.js
    
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    var Buffer = Bufferish.global;
    
    var exports = module.exports = Bufferish.hasBuffer ? alloc(0) : [];
    
    exports.alloc = Bufferish.hasBuffer && Buffer.alloc || alloc;
    exports.concat = Bufferish.concat;
    exports.from = from;
    
    /**
     * @param size {Number}
     * @returns {Buffer|Uint8Array|Array}
     */
    
    function alloc(size) {
      return new Buffer(size);
    }
    
    /**
     * @param value {Array|ArrayBuffer|Buffer|String}
     * @returns {Buffer}
     */
    
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        // TypedArray to Uint8Array
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        // ArrayBuffer to Uint8Array
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        // String to Buffer
        return Bufferish.from.call(exports, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
    
      // Array-like to Buffer
      if (Buffer.from && Buffer.from.length !== 1) {
        return Buffer.from(value); // node v6+
      } else {
        return new Buffer(value); // node v4
      }
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/bufferish-proto.js":
    /*!**********************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/bufferish-proto.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // bufferish-proto.js
    
    /* jshint eqnull:true */
    
    var BufferLite = __webpack_require__(/*! ./buffer-lite */ "./node_modules/msgpack-lite/lib/buffer-lite.js");
    
    exports.copy = copy;
    exports.slice = slice;
    exports.toString = toString;
    exports.write = gen("write");
    
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    var Buffer = Bufferish.global;
    
    var isBufferShim = Bufferish.hasBuffer && ("TYPED_ARRAY_SUPPORT" in Buffer);
    var brokenTypedArray = isBufferShim && !Buffer.TYPED_ARRAY_SUPPORT;
    
    /**
     * @param target {Buffer|Uint8Array|Array}
     * @param [targetStart] {Number}
     * @param [start] {Number}
     * @param [end] {Number}
     * @returns {Buffer|Uint8Array|Array}
     */
    
    function copy(target, targetStart, start, end) {
      var thisIsBuffer = Bufferish.isBuffer(this);
      var targetIsBuffer = Bufferish.isBuffer(target);
      if (thisIsBuffer && targetIsBuffer) {
        // Buffer to Buffer
        return this.copy(target, targetStart, start, end);
      } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer &&
        Bufferish.isView(this) && Bufferish.isView(target)) {
        // Uint8Array to Uint8Array (except for minor some browsers)
        var buffer = (start || end != null) ? slice.call(this, start, end) : this;
        target.set(buffer, targetStart);
        return buffer.length;
      } else {
        // other cases
        return BufferLite.copy.call(this, target, targetStart, start, end);
      }
    }
    
    /**
     * @param [start] {Number}
     * @param [end] {Number}
     * @returns {Buffer|Uint8Array|Array}
     */
    
    function slice(start, end) {
      // for Buffer, Uint8Array (except for minor some browsers) and Array
      var f = this.slice || (!brokenTypedArray && this.subarray);
      if (f) return f.call(this, start, end);
    
      // Uint8Array (for minor some browsers)
      var target = Bufferish.alloc.call(this, end - start);
      copy.call(this, target, 0, start, end);
      return target;
    }
    
    /**
     * Buffer.prototype.toString()
     *
     * @param [encoding] {String} ignored
     * @param [start] {Number}
     * @param [end] {Number}
     * @returns {String}
     */
    
    function toString(encoding, start, end) {
      var f = (!isBufferShim && Bufferish.isBuffer(this)) ? this.toString : BufferLite.toString;
      return f.apply(this, arguments);
    }
    
    /**
     * @private
     */
    
    function gen(method) {
      return wrap;
    
      function wrap() {
        var f = this[method] || BufferLite[method];
        return f.apply(this, arguments);
      }
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/bufferish-uint8array.js":
    /*!***************************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/bufferish-uint8array.js ***!
      \***************************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // bufferish-uint8array.js
    
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    
    var exports = module.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];
    
    exports.alloc = alloc;
    exports.concat = Bufferish.concat;
    exports.from = from;
    
    /**
     * @param size {Number}
     * @returns {Buffer|Uint8Array|Array}
     */
    
    function alloc(size) {
      return new Uint8Array(size);
    }
    
    /**
     * @param value {Array|ArrayBuffer|Buffer|String}
     * @returns {Uint8Array}
     */
    
    function from(value) {
      if (Bufferish.isView(value)) {
        // TypedArray to ArrayBuffer
        var byteOffset = value.byteOffset;
        var byteLength = value.byteLength;
        value = value.buffer;
        if (value.byteLength !== byteLength) {
          if (value.slice) {
            value = value.slice(byteOffset, byteOffset + byteLength);
          } else {
            // Android 4.1 does not have ArrayBuffer.prototype.slice
            value = new Uint8Array(value);
            if (value.byteLength !== byteLength) {
              // TypedArray to ArrayBuffer to Uint8Array to Array
              value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength);
            }
          }
        }
      } else if (typeof value === "string") {
        // String to Uint8Array
        return Bufferish.from.call(exports, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
    
      return new Uint8Array(value);
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/bufferish.js":
    /*!****************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/bufferish.js ***!
      \****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // bufferish.js
    
    var Buffer = exports.global = __webpack_require__(/*! ./buffer-global */ "./node_modules/msgpack-lite/lib/buffer-global.js");
    var hasBuffer = exports.hasBuffer = Buffer && !!Buffer.isBuffer;
    var hasArrayBuffer = exports.hasArrayBuffer = ("undefined" !== typeof ArrayBuffer);
    
    var isArray = exports.isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
    exports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
    var isBuffer = exports.isBuffer = hasBuffer ? Buffer.isBuffer : _false;
    var isView = exports.isView = hasArrayBuffer ? (ArrayBuffer.isView || _is("ArrayBuffer", "buffer")) : _false;
    
    exports.alloc = alloc;
    exports.concat = concat;
    exports.from = from;
    
    var BufferArray = exports.Array = __webpack_require__(/*! ./bufferish-array */ "./node_modules/msgpack-lite/lib/bufferish-array.js");
    var BufferBuffer = exports.Buffer = __webpack_require__(/*! ./bufferish-buffer */ "./node_modules/msgpack-lite/lib/bufferish-buffer.js");
    var BufferUint8Array = exports.Uint8Array = __webpack_require__(/*! ./bufferish-uint8array */ "./node_modules/msgpack-lite/lib/bufferish-uint8array.js");
    var BufferProto = exports.prototype = __webpack_require__(/*! ./bufferish-proto */ "./node_modules/msgpack-lite/lib/bufferish-proto.js");
    
    /**
     * @param value {Array|ArrayBuffer|Buffer|String}
     * @returns {Buffer|Uint8Array|Array}
     */
    
    function from(value) {
      if (typeof value === "string") {
        return fromString.call(this, value);
      } else {
        return auto(this).from(value);
      }
    }
    
    /**
     * @param size {Number}
     * @returns {Buffer|Uint8Array|Array}
     */
    
    function alloc(size) {
      return auto(this).alloc(size);
    }
    
    /**
     * @param list {Array} array of (Buffer|Uint8Array|Array)s
     * @param [length]
     * @returns {Buffer|Uint8Array|Array}
     */
    
    function concat(list, length) {
      if (!length) {
        length = 0;
        Array.prototype.forEach.call(list, dryrun);
      }
      var ref = (this !== exports) && this || list[0];
      var result = alloc.call(ref, length);
      var offset = 0;
      Array.prototype.forEach.call(list, append);
      return result;
    
      function dryrun(buffer) {
        length += buffer.length;
      }
    
      function append(buffer) {
        offset += BufferProto.copy.call(buffer, result, offset);
      }
    }
    
    var _isArrayBuffer = _is("ArrayBuffer");
    
    function isArrayBuffer(value) {
      return (value instanceof ArrayBuffer) || _isArrayBuffer(value);
    }
    
    /**
     * @private
     */
    
    function fromString(value) {
      var expected = value.length * 3;
      var that = alloc.call(this, expected);
      var actual = BufferProto.write.call(that, value);
      if (expected !== actual) {
        that = BufferProto.slice.call(that, 0, actual);
      }
      return that;
    }
    
    function auto(that) {
      return isBuffer(that) ? BufferBuffer
        : isView(that) ? BufferUint8Array
        : isArray(that) ? BufferArray
        : hasBuffer ? BufferBuffer
        : hasArrayBuffer ? BufferUint8Array
        : BufferArray;
    }
    
    function _false() {
      return false;
    }
    
    function _is(name, key) {
      /* jshint eqnull:true */
      name = "[object " + name + "]";
      return function(value) {
        return (value != null) && {}.toString.call(key ? value[key] : value) === name;
      };
    }
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/codec-base.js":
    /*!*****************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/codec-base.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // codec-base.js
    
    var IS_ARRAY = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
    
    exports.createCodec = createCodec;
    exports.install = install;
    exports.filter = filter;
    
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    
    function Codec(options) {
      if (!(this instanceof Codec)) return new Codec(options);
      this.options = options;
      this.init();
    }
    
    Codec.prototype.init = function() {
      var options = this.options;
    
      if (options && options.uint8array) {
        this.bufferish = Bufferish.Uint8Array;
      }
    
      return this;
    };
    
    function install(props) {
      for (var key in props) {
        Codec.prototype[key] = add(Codec.prototype[key], props[key]);
      }
    }
    
    function add(a, b) {
      return (a && b) ? ab : (a || b);
    
      function ab() {
        a.apply(this, arguments);
        return b.apply(this, arguments);
      }
    }
    
    function join(filters) {
      filters = filters.slice();
    
      return function(value) {
        return filters.reduce(iterator, value);
      };
    
      function iterator(value, filter) {
        return filter(value);
      }
    }
    
    function filter(filter) {
      return IS_ARRAY(filter) ? join(filter) : filter;
    }
    
    // @public
    // msgpack.createCodec()
    
    function createCodec(options) {
      return new Codec(options);
    }
    
    // default shared codec
    
    exports.preset = createCodec({preset: true});
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/codec.js":
    /*!************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/codec.js ***!
      \************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // codec.js
    
    // load both interfaces
    __webpack_require__(/*! ./read-core */ "./node_modules/msgpack-lite/lib/read-core.js");
    __webpack_require__(/*! ./write-core */ "./node_modules/msgpack-lite/lib/write-core.js");
    
    // @public
    // msgpack.codec.preset
    
    exports.codec = {
      preset: __webpack_require__(/*! ./codec-base */ "./node_modules/msgpack-lite/lib/codec-base.js").preset
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/decode-buffer.js":
    /*!********************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/decode-buffer.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // decode-buffer.js
    
    exports.DecodeBuffer = DecodeBuffer;
    
    var preset = __webpack_require__(/*! ./read-core */ "./node_modules/msgpack-lite/lib/read-core.js").preset;
    
    var FlexDecoder = __webpack_require__(/*! ./flex-buffer */ "./node_modules/msgpack-lite/lib/flex-buffer.js").FlexDecoder;
    
    FlexDecoder.mixin(DecodeBuffer.prototype);
    
    function DecodeBuffer(options) {
      if (!(this instanceof DecodeBuffer)) return new DecodeBuffer(options);
    
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec = this.codec = options.codec;
          if (codec.bufferish) this.bufferish = codec.bufferish;
        }
      }
    }
    
    DecodeBuffer.prototype.codec = preset;
    
    DecodeBuffer.prototype.fetch = function() {
      return this.codec.decode(this);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/decode.js":
    /*!*************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/decode.js ***!
      \*************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // decode.js
    
    exports.decode = decode;
    
    var DecodeBuffer = __webpack_require__(/*! ./decode-buffer */ "./node_modules/msgpack-lite/lib/decode-buffer.js").DecodeBuffer;
    
    function decode(input, options) {
      var decoder = new DecodeBuffer(options);
      decoder.write(input);
      return decoder.read();
    }
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/decoder.js":
    /*!**************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/decoder.js ***!
      \**************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // decoder.js
    
    exports.Decoder = Decoder;
    
    var EventLite = __webpack_require__(/*! event-lite */ "./node_modules/event-lite/event-lite.js");
    var DecodeBuffer = __webpack_require__(/*! ./decode-buffer */ "./node_modules/msgpack-lite/lib/decode-buffer.js").DecodeBuffer;
    
    function Decoder(options) {
      if (!(this instanceof Decoder)) return new Decoder(options);
      DecodeBuffer.call(this, options);
    }
    
    Decoder.prototype = new DecodeBuffer();
    
    EventLite.mixin(Decoder.prototype);
    
    Decoder.prototype.decode = function(chunk) {
      if (arguments.length) this.write(chunk);
      this.flush();
    };
    
    Decoder.prototype.push = function(chunk) {
      this.emit("data", chunk);
    };
    
    Decoder.prototype.end = function(chunk) {
      this.decode(chunk);
      this.emit("end");
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/encode-buffer.js":
    /*!********************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/encode-buffer.js ***!
      \********************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // encode-buffer.js
    
    exports.EncodeBuffer = EncodeBuffer;
    
    var preset = __webpack_require__(/*! ./write-core */ "./node_modules/msgpack-lite/lib/write-core.js").preset;
    
    var FlexEncoder = __webpack_require__(/*! ./flex-buffer */ "./node_modules/msgpack-lite/lib/flex-buffer.js").FlexEncoder;
    
    FlexEncoder.mixin(EncodeBuffer.prototype);
    
    function EncodeBuffer(options) {
      if (!(this instanceof EncodeBuffer)) return new EncodeBuffer(options);
    
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec = this.codec = options.codec;
          if (codec.bufferish) this.bufferish = codec.bufferish;
        }
      }
    }
    
    EncodeBuffer.prototype.codec = preset;
    
    EncodeBuffer.prototype.write = function(input) {
      this.codec.encode(this, input);
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/encode.js":
    /*!*************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/encode.js ***!
      \*************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // encode.js
    
    exports.encode = encode;
    
    var EncodeBuffer = __webpack_require__(/*! ./encode-buffer */ "./node_modules/msgpack-lite/lib/encode-buffer.js").EncodeBuffer;
    
    function encode(input, options) {
      var encoder = new EncodeBuffer(options);
      encoder.write(input);
      return encoder.read();
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/encoder.js":
    /*!**************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/encoder.js ***!
      \**************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // encoder.js
    
    exports.Encoder = Encoder;
    
    var EventLite = __webpack_require__(/*! event-lite */ "./node_modules/event-lite/event-lite.js");
    var EncodeBuffer = __webpack_require__(/*! ./encode-buffer */ "./node_modules/msgpack-lite/lib/encode-buffer.js").EncodeBuffer;
    
    function Encoder(options) {
      if (!(this instanceof Encoder)) return new Encoder(options);
      EncodeBuffer.call(this, options);
    }
    
    Encoder.prototype = new EncodeBuffer();
    
    EventLite.mixin(Encoder.prototype);
    
    Encoder.prototype.encode = function(chunk) {
      this.write(chunk);
      this.emit("data", this.read());
    };
    
    Encoder.prototype.end = function(chunk) {
      if (arguments.length) this.encode(chunk);
      this.flush();
      this.emit("end");
    };
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/ext-buffer.js":
    /*!*****************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/ext-buffer.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // ext-buffer.js
    
    exports.ExtBuffer = ExtBuffer;
    
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    
    function ExtBuffer(buffer, type) {
      if (!(this instanceof ExtBuffer)) return new ExtBuffer(buffer, type);
      this.buffer = Bufferish.from(buffer);
      this.type = type;
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/ext-packer.js":
    /*!*****************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/ext-packer.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // ext-packer.js
    
    exports.setExtPackers = setExtPackers;
    
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    var Buffer = Bufferish.global;
    var packTypedArray = Bufferish.Uint8Array.from;
    var _encode;
    
    var ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};
    
    function setExtPackers(codec) {
      codec.addExtPacker(0x0E, Error, [packError, encode]);
      codec.addExtPacker(0x01, EvalError, [packError, encode]);
      codec.addExtPacker(0x02, RangeError, [packError, encode]);
      codec.addExtPacker(0x03, ReferenceError, [packError, encode]);
      codec.addExtPacker(0x04, SyntaxError, [packError, encode]);
      codec.addExtPacker(0x05, TypeError, [packError, encode]);
      codec.addExtPacker(0x06, URIError, [packError, encode]);
    
      codec.addExtPacker(0x0A, RegExp, [packRegExp, encode]);
      codec.addExtPacker(0x0B, Boolean, [packValueOf, encode]);
      codec.addExtPacker(0x0C, String, [packValueOf, encode]);
      codec.addExtPacker(0x0D, Date, [Number, encode]);
      codec.addExtPacker(0x0F, Number, [packValueOf, encode]);
    
      if ("undefined" !== typeof Uint8Array) {
        codec.addExtPacker(0x11, Int8Array, packTypedArray);
        codec.addExtPacker(0x12, Uint8Array, packTypedArray);
        codec.addExtPacker(0x13, Int16Array, packTypedArray);
        codec.addExtPacker(0x14, Uint16Array, packTypedArray);
        codec.addExtPacker(0x15, Int32Array, packTypedArray);
        codec.addExtPacker(0x16, Uint32Array, packTypedArray);
        codec.addExtPacker(0x17, Float32Array, packTypedArray);
    
        // PhantomJS/1.9.7 doesn't have Float64Array
        if ("undefined" !== typeof Float64Array) {
          codec.addExtPacker(0x18, Float64Array, packTypedArray);
        }
    
        // IE10 doesn't have Uint8ClampedArray
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec.addExtPacker(0x19, Uint8ClampedArray, packTypedArray);
        }
    
        codec.addExtPacker(0x1A, ArrayBuffer, packTypedArray);
        codec.addExtPacker(0x1D, DataView, packTypedArray);
      }
    
      if (Bufferish.hasBuffer) {
        codec.addExtPacker(0x1B, Buffer, Bufferish.from);
      }
    }
    
    function encode(input) {
      if (!_encode) _encode = __webpack_require__(/*! ./encode */ "./node_modules/msgpack-lite/lib/encode.js").encode; // lazy load
      return _encode(input);
    }
    
    function packValueOf(value) {
      return (value).valueOf();
    }
    
    function packRegExp(value) {
      value = RegExp.prototype.toString.call(value).split("/");
      value.shift();
      var out = [value.pop()];
      out.unshift(value.join("/"));
      return out;
    }
    
    function packError(value) {
      var out = {};
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/ext-unpacker.js":
    /*!*******************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/ext-unpacker.js ***!
      \*******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // ext-unpacker.js
    
    exports.setExtUnpackers = setExtUnpackers;
    
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    var Buffer = Bufferish.global;
    var _decode;
    
    var ERROR_COLUMNS = {name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1};
    
    function setExtUnpackers(codec) {
      codec.addExtUnpacker(0x0E, [decode, unpackError(Error)]);
      codec.addExtUnpacker(0x01, [decode, unpackError(EvalError)]);
      codec.addExtUnpacker(0x02, [decode, unpackError(RangeError)]);
      codec.addExtUnpacker(0x03, [decode, unpackError(ReferenceError)]);
      codec.addExtUnpacker(0x04, [decode, unpackError(SyntaxError)]);
      codec.addExtUnpacker(0x05, [decode, unpackError(TypeError)]);
      codec.addExtUnpacker(0x06, [decode, unpackError(URIError)]);
    
      codec.addExtUnpacker(0x0A, [decode, unpackRegExp]);
      codec.addExtUnpacker(0x0B, [decode, unpackClass(Boolean)]);
      codec.addExtUnpacker(0x0C, [decode, unpackClass(String)]);
      codec.addExtUnpacker(0x0D, [decode, unpackClass(Date)]);
      codec.addExtUnpacker(0x0F, [decode, unpackClass(Number)]);
    
      if ("undefined" !== typeof Uint8Array) {
        codec.addExtUnpacker(0x11, unpackClass(Int8Array));
        codec.addExtUnpacker(0x12, unpackClass(Uint8Array));
        codec.addExtUnpacker(0x13, [unpackArrayBuffer, unpackClass(Int16Array)]);
        codec.addExtUnpacker(0x14, [unpackArrayBuffer, unpackClass(Uint16Array)]);
        codec.addExtUnpacker(0x15, [unpackArrayBuffer, unpackClass(Int32Array)]);
        codec.addExtUnpacker(0x16, [unpackArrayBuffer, unpackClass(Uint32Array)]);
        codec.addExtUnpacker(0x17, [unpackArrayBuffer, unpackClass(Float32Array)]);
    
        // PhantomJS/1.9.7 doesn't have Float64Array
        if ("undefined" !== typeof Float64Array) {
          codec.addExtUnpacker(0x18, [unpackArrayBuffer, unpackClass(Float64Array)]);
        }
    
        // IE10 doesn't have Uint8ClampedArray
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec.addExtUnpacker(0x19, unpackClass(Uint8ClampedArray));
        }
    
        codec.addExtUnpacker(0x1A, unpackArrayBuffer);
        codec.addExtUnpacker(0x1D, [unpackArrayBuffer, unpackClass(DataView)]);
      }
    
      if (Bufferish.hasBuffer) {
        codec.addExtUnpacker(0x1B, unpackClass(Buffer));
      }
    }
    
    function decode(input) {
      if (!_decode) _decode = __webpack_require__(/*! ./decode */ "./node_modules/msgpack-lite/lib/decode.js").decode; // lazy load
      return _decode(input);
    }
    
    function unpackRegExp(value) {
      return RegExp.apply(null, value);
    }
    
    function unpackError(Class) {
      return function(value) {
        var out = new Class();
        for (var key in ERROR_COLUMNS) {
          out[key] = value[key];
        }
        return out;
      };
    }
    
    function unpackClass(Class) {
      return function(value) {
        return new Class(value);
      };
    }
    
    function unpackArrayBuffer(value) {
      return (new Uint8Array(value)).buffer;
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/ext.js":
    /*!**********************************************!*\
      !*** ./node_modules/msgpack-lite/lib/ext.js ***!
      \**********************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // ext.js
    
    // load both interfaces
    __webpack_require__(/*! ./read-core */ "./node_modules/msgpack-lite/lib/read-core.js");
    __webpack_require__(/*! ./write-core */ "./node_modules/msgpack-lite/lib/write-core.js");
    
    exports.createCodec = __webpack_require__(/*! ./codec-base */ "./node_modules/msgpack-lite/lib/codec-base.js").createCodec;
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/flex-buffer.js":
    /*!******************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/flex-buffer.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // flex-buffer.js
    
    exports.FlexDecoder = FlexDecoder;
    exports.FlexEncoder = FlexEncoder;
    
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    
    var MIN_BUFFER_SIZE = 2048;
    var MAX_BUFFER_SIZE = 65536;
    var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
    
    function FlexDecoder() {
      if (!(this instanceof FlexDecoder)) return new FlexDecoder();
    }
    
    function FlexEncoder() {
      if (!(this instanceof FlexEncoder)) return new FlexEncoder();
    }
    
    FlexDecoder.mixin = mixinFactory(getDecoderMethods());
    FlexDecoder.mixin(FlexDecoder.prototype);
    
    FlexEncoder.mixin = mixinFactory(getEncoderMethods());
    FlexEncoder.mixin(FlexEncoder.prototype);
    
    function getDecoderMethods() {
      return {
        bufferish: Bufferish,
        write: write,
        fetch: fetch,
        flush: flush,
        push: push,
        pull: pull,
        read: read,
        reserve: reserve,
        offset: 0
      };
    
      function write(chunk) {
        var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
        this.buffer = prev ? (chunk ? this.bufferish.concat([prev, chunk]) : prev) : chunk;
        this.offset = 0;
      }
    
      function flush() {
        while (this.offset < this.buffer.length) {
          var start = this.offset;
          var value;
          try {
            value = this.fetch();
          } catch (e) {
            if (e && e.message != BUFFER_SHORTAGE) throw e;
            // rollback
            this.offset = start;
            break;
          }
          this.push(value);
        }
      }
    
      function reserve(length) {
        var start = this.offset;
        var end = start + length;
        if (end > this.buffer.length) throw new Error(BUFFER_SHORTAGE);
        this.offset = end;
        return start;
      }
    }
    
    function getEncoderMethods() {
      return {
        bufferish: Bufferish,
        write: write,
        fetch: fetch,
        flush: flush,
        push: push,
        pull: pull,
        read: read,
        reserve: reserve,
        send: send,
        maxBufferSize: MAX_BUFFER_SIZE,
        minBufferSize: MIN_BUFFER_SIZE,
        offset: 0,
        start: 0
      };
    
      function fetch() {
        var start = this.start;
        if (start < this.offset) {
          var end = this.start = this.offset;
          return Bufferish.prototype.slice.call(this.buffer, start, end);
        }
      }
    
      function flush() {
        while (this.start < this.offset) {
          var value = this.fetch();
          if (value) this.push(value);
        }
      }
    
      function pull() {
        var buffers = this.buffers || (this.buffers = []);
        var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
        buffers.length = 0; // buffer exhausted
        return chunk;
      }
    
      function reserve(length) {
        var req = length | 0;
    
        if (this.buffer) {
          var size = this.buffer.length;
          var start = this.offset | 0;
          var end = start + req;
    
          // is it long enough?
          if (end < size) {
            this.offset = end;
            return start;
          }
    
          // flush current buffer
          this.flush();
    
          // resize it to 2x current length
          length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
        }
    
        // minimum buffer size
        length = Math.max(length, this.minBufferSize);
    
        // allocate new buffer
        this.buffer = this.bufferish.alloc(length);
        this.start = 0;
        this.offset = req;
        return 0;
      }
    
      function send(buffer) {
        var length = buffer.length;
        if (length > this.minBufferSize) {
          this.flush();
          this.push(buffer);
        } else {
          var offset = this.reserve(length);
          Bufferish.prototype.copy.call(buffer, this.buffer, offset);
        }
      }
    }
    
    // common methods
    
    function write() {
      throw new Error("method not implemented: write()");
    }
    
    function fetch() {
      throw new Error("method not implemented: fetch()");
    }
    
    function read() {
      var length = this.buffers && this.buffers.length;
    
      // fetch the first result
      if (!length) return this.fetch();
    
      // flush current buffer
      this.flush();
    
      // read from the results
      return this.pull();
    }
    
    function push(chunk) {
      var buffers = this.buffers || (this.buffers = []);
      buffers.push(chunk);
    }
    
    function pull() {
      var buffers = this.buffers || (this.buffers = []);
      return buffers.shift();
    }
    
    function mixinFactory(source) {
      return mixin;
    
      function mixin(target) {
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/read-core.js":
    /*!****************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/read-core.js ***!
      \****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // read-core.js
    
    var ExtBuffer = __webpack_require__(/*! ./ext-buffer */ "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;
    var ExtUnpacker = __webpack_require__(/*! ./ext-unpacker */ "./node_modules/msgpack-lite/lib/ext-unpacker.js");
    var readUint8 = __webpack_require__(/*! ./read-format */ "./node_modules/msgpack-lite/lib/read-format.js").readUint8;
    var ReadToken = __webpack_require__(/*! ./read-token */ "./node_modules/msgpack-lite/lib/read-token.js");
    var CodecBase = __webpack_require__(/*! ./codec-base */ "./node_modules/msgpack-lite/lib/codec-base.js");
    
    CodecBase.install({
      addExtUnpacker: addExtUnpacker,
      getExtUnpacker: getExtUnpacker,
      init: init
    });
    
    exports.preset = init.call(CodecBase.preset);
    
    function getDecoder(options) {
      var readToken = ReadToken.getReadToken(options);
      return decode;
    
      function decode(decoder) {
        var type = readUint8(decoder);
        var func = readToken[type];
        if (!func) throw new Error("Invalid type: " + (type ? ("0x" + type.toString(16)) : type));
        return func(decoder);
      }
    }
    
    function init() {
      var options = this.options;
      this.decode = getDecoder(options);
    
      if (options && options.preset) {
        ExtUnpacker.setExtUnpackers(this);
      }
    
      return this;
    }
    
    function addExtUnpacker(etype, unpacker) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      unpackers[etype] = CodecBase.filter(unpacker);
    }
    
    function getExtUnpacker(type) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      return unpackers[type] || extUnpacker;
    
      function extUnpacker(buffer) {
        return new ExtBuffer(buffer, type);
      }
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/read-format.js":
    /*!******************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/read-format.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // read-format.js
    
    var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");
    var Int64Buffer = __webpack_require__(/*! int64-buffer */ "./node_modules/int64-buffer/int64-buffer.js");
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    
    exports.getReadFormat = getReadFormat;
    exports.readUint8 = uint8;
    
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    var BufferProto = __webpack_require__(/*! ./bufferish-proto */ "./node_modules/msgpack-lite/lib/bufferish-proto.js");
    
    var HAS_MAP = ("undefined" !== typeof Map);
    var NO_ASSERT = true;
    
    function getReadFormat(options) {
      var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
      var int64 = options && options.int64;
      var usemap = HAS_MAP && options && options.usemap;
    
      var readFormat = {
        map: (usemap ? map_to_map : map_to_obj),
        array: array,
        str: str,
        bin: (binarraybuffer ? bin_arraybuffer : bin_buffer),
        ext: ext,
        uint8: uint8,
        uint16: uint16,
        uint32: uint32,
        uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
        int8: int8,
        int16: int16,
        int32: int32,
        int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
        float32: read(4, readFloatBE),
        float64: read(8, readDoubleBE)
      };
    
      return readFormat;
    }
    
    function map_to_obj(decoder, len) {
      var value = {};
      var i;
      var k = new Array(len);
      var v = new Array(len);
    
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value[k[i]] = v[i];
      }
      return value;
    }
    
    function map_to_map(decoder, len) {
      var value = new Map();
      var i;
      var k = new Array(len);
      var v = new Array(len);
    
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value.set(k[i], v[i]);
      }
      return value;
    }
    
    function array(decoder, len) {
      var value = new Array(len);
      var decode = decoder.codec.decode;
      for (var i = 0; i < len; i++) {
        value[i] = decode(decoder);
      }
      return value;
    }
    
    function str(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
    }
    
    function bin_buffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.from(buf);
    }
    
    function bin_arraybuffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.Uint8Array.from(buf).buffer;
    }
    
    function ext(decoder, len) {
      var start = decoder.reserve(len+1);
      var type = decoder.buffer[start++];
      var end = start + len;
      var unpack = decoder.codec.getExtUnpacker(type);
      if (!unpack) throw new Error("Invalid ext type: " + (type ? ("0x" + type.toString(16)) : type));
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return unpack(buf);
    }
    
    function uint8(decoder) {
      var start = decoder.reserve(1);
      return decoder.buffer[start];
    }
    
    function int8(decoder) {
      var start = decoder.reserve(1);
      var value = decoder.buffer[start];
      return (value & 0x80) ? value - 0x100 : value;
    }
    
    function uint16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      return (buffer[start++] << 8) | buffer[start];
    }
    
    function int16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      var value = (buffer[start++] << 8) | buffer[start];
      return (value & 0x8000) ? value - 0x10000 : value;
    }
    
    function uint32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return (buffer[start++] * 16777216) + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];
    }
    
    function int32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return (buffer[start++] << 24) | (buffer[start++] << 16) | (buffer[start++] << 8) | buffer[start];
    }
    
    function read(len, method) {
      return function(decoder) {
        var start = decoder.reserve(len);
        return method.call(decoder.buffer, start, NO_ASSERT);
      };
    }
    
    function readUInt64BE(start) {
      return new Uint64BE(this, start).toNumber();
    }
    
    function readInt64BE(start) {
      return new Int64BE(this, start).toNumber();
    }
    
    function readUInt64BE_int64(start) {
      return new Uint64BE(this, start);
    }
    
    function readInt64BE_int64(start) {
      return new Int64BE(this, start);
    }
    
    function readFloatBE(start) {
      return ieee754.read(this, start, false, 23, 4);
    }
    
    function readDoubleBE(start) {
      return ieee754.read(this, start, false, 52, 8);
    }
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/read-token.js":
    /*!*****************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/read-token.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // read-token.js
    
    var ReadFormat = __webpack_require__(/*! ./read-format */ "./node_modules/msgpack-lite/lib/read-format.js");
    
    exports.getReadToken = getReadToken;
    
    function getReadToken(options) {
      var format = ReadFormat.getReadFormat(options);
    
      if (options && options.useraw) {
        return init_useraw(format);
      } else {
        return init_token(format);
      }
    }
    
    function init_token(format) {
      var i;
      var token = new Array(256);
    
      // positive fixint -- 0x00 - 0x7f
      for (i = 0x00; i <= 0x7f; i++) {
        token[i] = constant(i);
      }
    
      // fixmap -- 0x80 - 0x8f
      for (i = 0x80; i <= 0x8f; i++) {
        token[i] = fix(i - 0x80, format.map);
      }
    
      // fixarray -- 0x90 - 0x9f
      for (i = 0x90; i <= 0x9f; i++) {
        token[i] = fix(i - 0x90, format.array);
      }
    
      // fixstr -- 0xa0 - 0xbf
      for (i = 0xa0; i <= 0xbf; i++) {
        token[i] = fix(i - 0xa0, format.str);
      }
    
      // nil -- 0xc0
      token[0xc0] = constant(null);
    
      // (never used) -- 0xc1
      token[0xc1] = null;
    
      // false -- 0xc2
      // true -- 0xc3
      token[0xc2] = constant(false);
      token[0xc3] = constant(true);
    
      // bin 8 -- 0xc4
      // bin 16 -- 0xc5
      // bin 32 -- 0xc6
      token[0xc4] = flex(format.uint8, format.bin);
      token[0xc5] = flex(format.uint16, format.bin);
      token[0xc6] = flex(format.uint32, format.bin);
    
      // ext 8 -- 0xc7
      // ext 16 -- 0xc8
      // ext 32 -- 0xc9
      token[0xc7] = flex(format.uint8, format.ext);
      token[0xc8] = flex(format.uint16, format.ext);
      token[0xc9] = flex(format.uint32, format.ext);
    
      // float 32 -- 0xca
      // float 64 -- 0xcb
      token[0xca] = format.float32;
      token[0xcb] = format.float64;
    
      // uint 8 -- 0xcc
      // uint 16 -- 0xcd
      // uint 32 -- 0xce
      // uint 64 -- 0xcf
      token[0xcc] = format.uint8;
      token[0xcd] = format.uint16;
      token[0xce] = format.uint32;
      token[0xcf] = format.uint64;
    
      // int 8 -- 0xd0
      // int 16 -- 0xd1
      // int 32 -- 0xd2
      // int 64 -- 0xd3
      token[0xd0] = format.int8;
      token[0xd1] = format.int16;
      token[0xd2] = format.int32;
      token[0xd3] = format.int64;
    
      // fixext 1 -- 0xd4
      // fixext 2 -- 0xd5
      // fixext 4 -- 0xd6
      // fixext 8 -- 0xd7
      // fixext 16 -- 0xd8
      token[0xd4] = fix(1, format.ext);
      token[0xd5] = fix(2, format.ext);
      token[0xd6] = fix(4, format.ext);
      token[0xd7] = fix(8, format.ext);
      token[0xd8] = fix(16, format.ext);
    
      // str 8 -- 0xd9
      // str 16 -- 0xda
      // str 32 -- 0xdb
      token[0xd9] = flex(format.uint8, format.str);
      token[0xda] = flex(format.uint16, format.str);
      token[0xdb] = flex(format.uint32, format.str);
    
      // array 16 -- 0xdc
      // array 32 -- 0xdd
      token[0xdc] = flex(format.uint16, format.array);
      token[0xdd] = flex(format.uint32, format.array);
    
      // map 16 -- 0xde
      // map 32 -- 0xdf
      token[0xde] = flex(format.uint16, format.map);
      token[0xdf] = flex(format.uint32, format.map);
    
      // negative fixint -- 0xe0 - 0xff
      for (i = 0xe0; i <= 0xff; i++) {
        token[i] = constant(i - 0x100);
      }
    
      return token;
    }
    
    function init_useraw(format) {
      var i;
      var token = init_token(format).slice();
    
      // raw 8 -- 0xd9
      // raw 16 -- 0xda
      // raw 32 -- 0xdb
      token[0xd9] = token[0xc4];
      token[0xda] = token[0xc5];
      token[0xdb] = token[0xc6];
    
      // fixraw -- 0xa0 - 0xbf
      for (i = 0xa0; i <= 0xbf; i++) {
        token[i] = fix(i - 0xa0, format.bin);
      }
    
      return token;
    }
    
    function constant(value) {
      return function() {
        return value;
      };
    }
    
    function flex(lenFunc, decodeFunc) {
      return function(decoder) {
        var len = lenFunc(decoder);
        return decodeFunc(decoder, len);
      };
    }
    
    function fix(len, method) {
      return function(decoder) {
        return method(decoder, len);
      };
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/write-core.js":
    /*!*****************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/write-core.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // write-core.js
    
    var ExtBuffer = __webpack_require__(/*! ./ext-buffer */ "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;
    var ExtPacker = __webpack_require__(/*! ./ext-packer */ "./node_modules/msgpack-lite/lib/ext-packer.js");
    var WriteType = __webpack_require__(/*! ./write-type */ "./node_modules/msgpack-lite/lib/write-type.js");
    var CodecBase = __webpack_require__(/*! ./codec-base */ "./node_modules/msgpack-lite/lib/codec-base.js");
    
    CodecBase.install({
      addExtPacker: addExtPacker,
      getExtPacker: getExtPacker,
      init: init
    });
    
    exports.preset = init.call(CodecBase.preset);
    
    function getEncoder(options) {
      var writeType = WriteType.getWriteType(options);
      return encode;
    
      function encode(encoder, value) {
        var func = writeType[typeof value];
        if (!func) throw new Error("Unsupported type \"" + (typeof value) + "\": " + value);
        func(encoder, value);
      }
    }
    
    function init() {
      var options = this.options;
      this.encode = getEncoder(options);
    
      if (options && options.preset) {
        ExtPacker.setExtPackers(this);
      }
    
      return this;
    }
    
    function addExtPacker(etype, Class, packer) {
      packer = CodecBase.filter(packer);
      var name = Class.name;
      if (name && name !== "Object") {
        var packers = this.extPackers || (this.extPackers = {});
        packers[name] = extPacker;
      } else {
        // fallback for IE
        var list = this.extEncoderList || (this.extEncoderList = []);
        list.unshift([Class, extPacker]);
      }
    
      function extPacker(value) {
        if (packer) value = packer(value);
        return new ExtBuffer(value, etype);
      }
    }
    
    function getExtPacker(value) {
      var packers = this.extPackers || (this.extPackers = {});
      var c = value.constructor;
      var e = c && c.name && packers[c.name];
      if (e) return e;
    
      // fallback for IE
      var list = this.extEncoderList || (this.extEncoderList = []);
      var len = list.length;
      for (var i = 0; i < len; i++) {
        var pair = list[i];
        if (c === pair[0]) return pair[1];
      }
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/write-token.js":
    /*!******************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/write-token.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // write-token.js
    
    var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");
    var Int64Buffer = __webpack_require__(/*! int64-buffer */ "./node_modules/int64-buffer/int64-buffer.js");
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    
    var uint8 = __webpack_require__(/*! ./write-uint8 */ "./node_modules/msgpack-lite/lib/write-uint8.js").uint8;
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    var Buffer = Bufferish.global;
    var IS_BUFFER_SHIM = Bufferish.hasBuffer && ("TYPED_ARRAY_SUPPORT" in Buffer);
    var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer.TYPED_ARRAY_SUPPORT;
    var Buffer_prototype = Bufferish.hasBuffer && Buffer.prototype || {};
    
    exports.getWriteToken = getWriteToken;
    
    function getWriteToken(options) {
      if (options && options.uint8array) {
        return init_uint8array();
      } else if (NO_TYPED_ARRAY || (Bufferish.hasBuffer && options && options.safe)) {
        return init_safe();
      } else {
        return init_token();
      }
    }
    
    function init_uint8array() {
      var token = init_token();
    
      // float 32 -- 0xca
      // float 64 -- 0xcb
      token[0xca] = writeN(0xca, 4, writeFloatBE);
      token[0xcb] = writeN(0xcb, 8, writeDoubleBE);
    
      return token;
    }
    
    // Node.js and browsers with TypedArray
    
    function init_token() {
      // (immediate values)
      // positive fixint -- 0x00 - 0x7f
      // nil -- 0xc0
      // false -- 0xc2
      // true -- 0xc3
      // negative fixint -- 0xe0 - 0xff
      var token = uint8.slice();
    
      // bin 8 -- 0xc4
      // bin 16 -- 0xc5
      // bin 32 -- 0xc6
      token[0xc4] = write1(0xc4);
      token[0xc5] = write2(0xc5);
      token[0xc6] = write4(0xc6);
    
      // ext 8 -- 0xc7
      // ext 16 -- 0xc8
      // ext 32 -- 0xc9
      token[0xc7] = write1(0xc7);
      token[0xc8] = write2(0xc8);
      token[0xc9] = write4(0xc9);
    
      // float 32 -- 0xca
      // float 64 -- 0xcb
      token[0xca] = writeN(0xca, 4, (Buffer_prototype.writeFloatBE || writeFloatBE), true);
      token[0xcb] = writeN(0xcb, 8, (Buffer_prototype.writeDoubleBE || writeDoubleBE), true);
    
      // uint 8 -- 0xcc
      // uint 16 -- 0xcd
      // uint 32 -- 0xce
      // uint 64 -- 0xcf
      token[0xcc] = write1(0xcc);
      token[0xcd] = write2(0xcd);
      token[0xce] = write4(0xce);
      token[0xcf] = writeN(0xcf, 8, writeUInt64BE);
    
      // int 8 -- 0xd0
      // int 16 -- 0xd1
      // int 32 -- 0xd2
      // int 64 -- 0xd3
      token[0xd0] = write1(0xd0);
      token[0xd1] = write2(0xd1);
      token[0xd2] = write4(0xd2);
      token[0xd3] = writeN(0xd3, 8, writeInt64BE);
    
      // str 8 -- 0xd9
      // str 16 -- 0xda
      // str 32 -- 0xdb
      token[0xd9] = write1(0xd9);
      token[0xda] = write2(0xda);
      token[0xdb] = write4(0xdb);
    
      // array 16 -- 0xdc
      // array 32 -- 0xdd
      token[0xdc] = write2(0xdc);
      token[0xdd] = write4(0xdd);
    
      // map 16 -- 0xde
      // map 32 -- 0xdf
      token[0xde] = write2(0xde);
      token[0xdf] = write4(0xdf);
    
      return token;
    }
    
    // safe mode: for old browsers and who needs asserts
    
    function init_safe() {
      // (immediate values)
      // positive fixint -- 0x00 - 0x7f
      // nil -- 0xc0
      // false -- 0xc2
      // true -- 0xc3
      // negative fixint -- 0xe0 - 0xff
      var token = uint8.slice();
    
      // bin 8 -- 0xc4
      // bin 16 -- 0xc5
      // bin 32 -- 0xc6
      token[0xc4] = writeN(0xc4, 1, Buffer.prototype.writeUInt8);
      token[0xc5] = writeN(0xc5, 2, Buffer.prototype.writeUInt16BE);
      token[0xc6] = writeN(0xc6, 4, Buffer.prototype.writeUInt32BE);
    
      // ext 8 -- 0xc7
      // ext 16 -- 0xc8
      // ext 32 -- 0xc9
      token[0xc7] = writeN(0xc7, 1, Buffer.prototype.writeUInt8);
      token[0xc8] = writeN(0xc8, 2, Buffer.prototype.writeUInt16BE);
      token[0xc9] = writeN(0xc9, 4, Buffer.prototype.writeUInt32BE);
    
      // float 32 -- 0xca
      // float 64 -- 0xcb
      token[0xca] = writeN(0xca, 4, Buffer.prototype.writeFloatBE);
      token[0xcb] = writeN(0xcb, 8, Buffer.prototype.writeDoubleBE);
    
      // uint 8 -- 0xcc
      // uint 16 -- 0xcd
      // uint 32 -- 0xce
      // uint 64 -- 0xcf
      token[0xcc] = writeN(0xcc, 1, Buffer.prototype.writeUInt8);
      token[0xcd] = writeN(0xcd, 2, Buffer.prototype.writeUInt16BE);
      token[0xce] = writeN(0xce, 4, Buffer.prototype.writeUInt32BE);
      token[0xcf] = writeN(0xcf, 8, writeUInt64BE);
    
      // int 8 -- 0xd0
      // int 16 -- 0xd1
      // int 32 -- 0xd2
      // int 64 -- 0xd3
      token[0xd0] = writeN(0xd0, 1, Buffer.prototype.writeInt8);
      token[0xd1] = writeN(0xd1, 2, Buffer.prototype.writeInt16BE);
      token[0xd2] = writeN(0xd2, 4, Buffer.prototype.writeInt32BE);
      token[0xd3] = writeN(0xd3, 8, writeInt64BE);
    
      // str 8 -- 0xd9
      // str 16 -- 0xda
      // str 32 -- 0xdb
      token[0xd9] = writeN(0xd9, 1, Buffer.prototype.writeUInt8);
      token[0xda] = writeN(0xda, 2, Buffer.prototype.writeUInt16BE);
      token[0xdb] = writeN(0xdb, 4, Buffer.prototype.writeUInt32BE);
    
      // array 16 -- 0xdc
      // array 32 -- 0xdd
      token[0xdc] = writeN(0xdc, 2, Buffer.prototype.writeUInt16BE);
      token[0xdd] = writeN(0xdd, 4, Buffer.prototype.writeUInt32BE);
    
      // map 16 -- 0xde
      // map 32 -- 0xdf
      token[0xde] = writeN(0xde, 2, Buffer.prototype.writeUInt16BE);
      token[0xdf] = writeN(0xdf, 4, Buffer.prototype.writeUInt32BE);
    
      return token;
    }
    
    function write1(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(2);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset] = value;
      };
    }
    
    function write2(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(3);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    
    function write4(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(5);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 24;
        buffer[offset++] = value >>> 16;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    
    function writeN(type, len, method, noAssert) {
      return function(encoder, value) {
        var offset = encoder.reserve(len + 1);
        encoder.buffer[offset++] = type;
        method.call(encoder.buffer, value, offset, noAssert);
      };
    }
    
    function writeUInt64BE(value, offset) {
      new Uint64BE(this, offset, value);
    }
    
    function writeInt64BE(value, offset) {
      new Int64BE(this, offset, value);
    }
    
    function writeFloatBE(value, offset) {
      ieee754.write(this, value, offset, false, 23, 4);
    }
    
    function writeDoubleBE(value, offset) {
      ieee754.write(this, value, offset, false, 52, 8);
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/write-type.js":
    /*!*****************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/write-type.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    // write-type.js
    
    var IS_ARRAY = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js");
    var Int64Buffer = __webpack_require__(/*! int64-buffer */ "./node_modules/int64-buffer/int64-buffer.js");
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    
    var Bufferish = __webpack_require__(/*! ./bufferish */ "./node_modules/msgpack-lite/lib/bufferish.js");
    var BufferProto = __webpack_require__(/*! ./bufferish-proto */ "./node_modules/msgpack-lite/lib/bufferish-proto.js");
    var WriteToken = __webpack_require__(/*! ./write-token */ "./node_modules/msgpack-lite/lib/write-token.js");
    var uint8 = __webpack_require__(/*! ./write-uint8 */ "./node_modules/msgpack-lite/lib/write-uint8.js").uint8;
    var ExtBuffer = __webpack_require__(/*! ./ext-buffer */ "./node_modules/msgpack-lite/lib/ext-buffer.js").ExtBuffer;
    
    var HAS_UINT8ARRAY = ("undefined" !== typeof Uint8Array);
    var HAS_MAP = ("undefined" !== typeof Map);
    
    var extmap = [];
    extmap[1] = 0xd4;
    extmap[2] = 0xd5;
    extmap[4] = 0xd6;
    extmap[8] = 0xd7;
    extmap[16] = 0xd8;
    
    exports.getWriteType = getWriteType;
    
    function getWriteType(options) {
      var token = WriteToken.getWriteToken(options);
      var useraw = options && options.useraw;
      var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
      var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
      var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
      var usemap = HAS_MAP && options && options.usemap;
      var map = usemap ? map_to_map : obj_to_map;
    
      var writeType = {
        "boolean": bool,
        "function": nil,
        "number": number,
        "object": (useraw ? object_raw : object),
        "string": _string(useraw ? raw_head_size : str_head_size),
        "symbol": nil,
        "undefined": nil
      };
    
      return writeType;
    
      // false -- 0xc2
      // true -- 0xc3
      function bool(encoder, value) {
        var type = value ? 0xc3 : 0xc2;
        token[type](encoder, value);
      }
    
      function number(encoder, value) {
        var ivalue = value | 0;
        var type;
        if (value !== ivalue) {
          // float 64 -- 0xcb
          type = 0xcb;
          token[type](encoder, value);
          return;
        } else if (-0x20 <= ivalue && ivalue <= 0x7F) {
          // positive fixint -- 0x00 - 0x7f
          // negative fixint -- 0xe0 - 0xff
          type = ivalue & 0xFF;
        } else if (0 <= ivalue) {
          // uint 8 -- 0xcc
          // uint 16 -- 0xcd
          // uint 32 -- 0xce
          type = (ivalue <= 0xFF) ? 0xcc : (ivalue <= 0xFFFF) ? 0xcd : 0xce;
        } else {
          // int 8 -- 0xd0
          // int 16 -- 0xd1
          // int 32 -- 0xd2
          type = (-0x80 <= ivalue) ? 0xd0 : (-0x8000 <= ivalue) ? 0xd1 : 0xd2;
        }
        token[type](encoder, ivalue);
      }
    
      // uint 64 -- 0xcf
      function uint64(encoder, value) {
        var type = 0xcf;
        token[type](encoder, value.toArray());
      }
    
      // int 64 -- 0xd3
      function int64(encoder, value) {
        var type = 0xd3;
        token[type](encoder, value.toArray());
      }
    
      // str 8 -- 0xd9
      // str 16 -- 0xda
      // str 32 -- 0xdb
      // fixstr -- 0xa0 - 0xbf
      function str_head_size(length) {
        return (length < 32) ? 1 : (length <= 0xFF) ? 2 : (length <= 0xFFFF) ? 3 : 5;
      }
    
      // raw 16 -- 0xda
      // raw 32 -- 0xdb
      // fixraw -- 0xa0 - 0xbf
      function raw_head_size(length) {
        return (length < 32) ? 1 : (length <= 0xFFFF) ? 3 : 5;
      }
    
      function _string(head_size) {
        return string;
    
        function string(encoder, value) {
          // prepare buffer
          var length = value.length;
          var maxsize = 5 + length * 3;
          encoder.offset = encoder.reserve(maxsize);
          var buffer = encoder.buffer;
    
          // expected header size
          var expected = head_size(length);
    
          // expected start point
          var start = encoder.offset + expected;
    
          // write string
          length = BufferProto.write.call(buffer, value, start);
    
          // actual header size
          var actual = head_size(length);
    
          // move content when needed
          if (expected !== actual) {
            var targetStart = start + actual - expected;
            var end = start + length;
            BufferProto.copy.call(buffer, buffer, targetStart, start, end);
          }
    
          // write header
          var type = (actual === 1) ? (0xa0 + length) : (actual <= 3) ? (0xd7 + actual) : 0xdb;
          token[type](encoder, length);
    
          // move cursor
          encoder.offset += length;
        }
      }
    
      function object(encoder, value) {
        // null
        if (value === null) return nil(encoder, value);
    
        // Buffer
        if (isBuffer(value)) return bin(encoder, value);
    
        // Array
        if (IS_ARRAY(value)) return array(encoder, value);
    
        // int64-buffer objects
        if (Uint64BE.isUint64BE(value)) return uint64(encoder, value);
        if (Int64BE.isInt64BE(value)) return int64(encoder, value);
    
        // ext formats
        var packer = encoder.codec.getExtPacker(value);
        if (packer) value = packer(value);
        if (value instanceof ExtBuffer) return ext(encoder, value);
    
        // plain old Objects or Map
        map(encoder, value);
      }
    
      function object_raw(encoder, value) {
        // Buffer
        if (isBuffer(value)) return raw(encoder, value);
    
        // others
        object(encoder, value);
      }
    
      // nil -- 0xc0
      function nil(encoder, value) {
        var type = 0xc0;
        token[type](encoder, value);
      }
    
      // fixarray -- 0x90 - 0x9f
      // array 16 -- 0xdc
      // array 32 -- 0xdd
      function array(encoder, value) {
        var length = value.length;
        var type = (length < 16) ? (0x90 + length) : (length <= 0xFFFF) ? 0xdc : 0xdd;
        token[type](encoder, length);
    
        var encode = encoder.codec.encode;
        for (var i = 0; i < length; i++) {
          encode(encoder, value[i]);
        }
      }
    
      // bin 8 -- 0xc4
      // bin 16 -- 0xc5
      // bin 32 -- 0xc6
      function bin_buffer(encoder, value) {
        var length = value.length;
        var type = (length < 0xFF) ? 0xc4 : (length <= 0xFFFF) ? 0xc5 : 0xc6;
        token[type](encoder, length);
        encoder.send(value);
      }
    
      function bin_arraybuffer(encoder, value) {
        bin_buffer(encoder, new Uint8Array(value));
      }
    
      // fixext 1 -- 0xd4
      // fixext 2 -- 0xd5
      // fixext 4 -- 0xd6
      // fixext 8 -- 0xd7
      // fixext 16 -- 0xd8
      // ext 8 -- 0xc7
      // ext 16 -- 0xc8
      // ext 32 -- 0xc9
      function ext(encoder, value) {
        var buffer = value.buffer;
        var length = buffer.length;
        var type = extmap[length] || ((length < 0xFF) ? 0xc7 : (length <= 0xFFFF) ? 0xc8 : 0xc9);
        token[type](encoder, length);
        uint8[value.type](encoder);
        encoder.send(buffer);
      }
    
      // fixmap -- 0x80 - 0x8f
      // map 16 -- 0xde
      // map 32 -- 0xdf
      function obj_to_map(encoder, value) {
        var keys = Object.keys(value);
        var length = keys.length;
        var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;
        token[type](encoder, length);
    
        var encode = encoder.codec.encode;
        keys.forEach(function(key) {
          encode(encoder, key);
          encode(encoder, value[key]);
        });
      }
    
      // fixmap -- 0x80 - 0x8f
      // map 16 -- 0xde
      // map 32 -- 0xdf
      function map_to_map(encoder, value) {
        if (!(value instanceof Map)) return obj_to_map(encoder, value);
    
        var length = value.size;
        var type = (length < 16) ? (0x80 + length) : (length <= 0xFFFF) ? 0xde : 0xdf;
        token[type](encoder, length);
    
        var encode = encoder.codec.encode;
        value.forEach(function(val, key, m) {
          encode(encoder, key);
          encode(encoder, val);
        });
      }
    
      // raw 16 -- 0xda
      // raw 32 -- 0xdb
      // fixraw -- 0xa0 - 0xbf
      function raw(encoder, value) {
        var length = value.length;
        var type = (length < 32) ? (0xa0 + length) : (length <= 0xFFFF) ? 0xda : 0xdb;
        token[type](encoder, length);
        encoder.send(value);
      }
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/msgpack-lite/lib/write-uint8.js":
    /*!******************************************************!*\
      !*** ./node_modules/msgpack-lite/lib/write-uint8.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    // write-unit8.js
    
    var constant = exports.uint8 = new Array(256);
    
    for (var i = 0x00; i <= 0xFF; i++) {
      constant[i] = write0(i);
    }
    
    function write0(type) {
      return function(encoder) {
        var offset = encoder.reserve(1);
        encoder.buffer[offset] = type;
      };
    }
    
    
    /***/ }),
    
    /***/ "./node_modules/node-libs-browser/mock/empty.js":
    /*!******************************************************!*\
      !*** ./node_modules/node-libs-browser/mock/empty.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
    
    /***/ }),
    
    /***/ "./node_modules/process/browser.js":
    /*!*****************************************!*\
      !*** ./node_modules/process/browser.js ***!
      \*****************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    // shim for using process in browser
    var process = module.exports = {};
    
    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.
    
    var cachedSetTimeout;
    var cachedClearTimeout;
    
    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    } ())
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    
    
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    
    
    
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    
    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }
    
    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
    
        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    
    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };
    
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};
    
    function noop() {}
    
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    
    process.listeners = function (name) { return [] }
    
    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };
    
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };
    
    
    /***/ }),
    
    /***/ "./node_modules/simplex-noise/simplex-noise.js":
    /*!*****************************************************!*\
      !*** ./node_modules/simplex-noise/simplex-noise.js ***!
      \*****************************************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    var __WEBPACK_AMD_DEFINE_RESULT__;/*
     * A fast javascript implementation of simplex noise by Jonas Wagner
    
    Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.
    Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).
    With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
    Better rank ordering method by Stefan Gustavson in 2012.
    
    
     Copyright (c) 2018 Jonas Wagner
    
     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:
    
     The above copyright notice and this permission notice shall be included in all
     copies or substantial portions of the Software.
    
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     SOFTWARE.
     */
    (function() {
      'use strict';
    
      var F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
      var G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
      var F3 = 1.0 / 3.0;
      var G3 = 1.0 / 6.0;
      var F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
      var G4 = (5.0 - Math.sqrt(5.0)) / 20.0;
    
      function SimplexNoise(randomOrSeed) {
        var random;
        if (typeof randomOrSeed == 'function') {
          random = randomOrSeed;
        }
        else if (randomOrSeed) {
          random = alea(randomOrSeed);
        } else {
          random = Math.random;
        }
        this.p = buildPermutationTable(random);
        this.perm = new Uint8Array(512);
        this.permMod12 = new Uint8Array(512);
        for (var i = 0; i < 512; i++) {
          this.perm[i] = this.p[i & 255];
          this.permMod12[i] = this.perm[i] % 12;
        }
    
      }
      SimplexNoise.prototype = {
        grad3: new Float32Array([1, 1, 0,
          -1, 1, 0,
          1, -1, 0,
    
          -1, -1, 0,
          1, 0, 1,
          -1, 0, 1,
    
          1, 0, -1,
          -1, 0, -1,
          0, 1, 1,
    
          0, -1, 1,
          0, 1, -1,
          0, -1, -1]),
        grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,
          0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,
          1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,
          -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,
          1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,
          -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,
          1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,
          -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),
        noise2D: function(xin, yin) {
          var permMod12 = this.permMod12;
          var perm = this.perm;
          var grad3 = this.grad3;
          var n0 = 0; // Noise contributions from the three corners
          var n1 = 0;
          var n2 = 0;
          // Skew the input space to determine which simplex cell we're in
          var s = (xin + yin) * F2; // Hairy factor for 2D
          var i = Math.floor(xin + s);
          var j = Math.floor(yin + s);
          var t = (i + j) * G2;
          var X0 = i - t; // Unskew the cell origin back to (x,y) space
          var Y0 = j - t;
          var x0 = xin - X0; // The x,y distances from the cell origin
          var y0 = yin - Y0;
          // For the 2D case, the simplex shape is an equilateral triangle.
          // Determine which simplex we are in.
          var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
          if (x0 > y0) {
            i1 = 1;
            j1 = 0;
          } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
          else {
            i1 = 0;
            j1 = 1;
          } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
          // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
          // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
          // c = (3-sqrt(3))/6
          var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
          var y1 = y0 - j1 + G2;
          var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
          var y2 = y0 - 1.0 + 2.0 * G2;
          // Work out the hashed gradient indices of the three simplex corners
          var ii = i & 255;
          var jj = j & 255;
          // Calculate the contribution from the three corners
          var t0 = 0.5 - x0 * x0 - y0 * y0;
          if (t0 >= 0) {
            var gi0 = permMod12[ii + perm[jj]] * 3;
            t0 *= t0;
            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
          }
          var t1 = 0.5 - x1 * x1 - y1 * y1;
          if (t1 >= 0) {
            var gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
            t1 *= t1;
            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
          }
          var t2 = 0.5 - x2 * x2 - y2 * y2;
          if (t2 >= 0) {
            var gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
            t2 *= t2;
            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
          }
          // Add contributions from each corner to get the final noise value.
          // The result is scaled to return values in the interval [-1,1].
          return 70.0 * (n0 + n1 + n2);
        },
        // 3D simplex noise
        noise3D: function(xin, yin, zin) {
          var permMod12 = this.permMod12;
          var perm = this.perm;
          var grad3 = this.grad3;
          var n0, n1, n2, n3; // Noise contributions from the four corners
          // Skew the input space to determine which simplex cell we're in
          var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
          var i = Math.floor(xin + s);
          var j = Math.floor(yin + s);
          var k = Math.floor(zin + s);
          var t = (i + j + k) * G3;
          var X0 = i - t; // Unskew the cell origin back to (x,y,z) space
          var Y0 = j - t;
          var Z0 = k - t;
          var x0 = xin - X0; // The x,y,z distances from the cell origin
          var y0 = yin - Y0;
          var z0 = zin - Z0;
          // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
          // Determine which simplex we are in.
          var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
          var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
          if (x0 >= y0) {
            if (y0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            } // X Y Z order
            else if (x0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            } // X Z Y order
            else {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            } // Z X Y order
          }
          else { // x0<y0
            if (y0 < z0) {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } // Z Y X order
            else if (x0 < z0) {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } // Y Z X order
            else {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            } // Y X Z order
          }
          // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
          // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
          // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
          // c = 1/6.
          var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
          var y1 = y0 - j1 + G3;
          var z1 = z0 - k1 + G3;
          var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
          var y2 = y0 - j2 + 2.0 * G3;
          var z2 = z0 - k2 + 2.0 * G3;
          var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
          var y3 = y0 - 1.0 + 3.0 * G3;
          var z3 = z0 - 1.0 + 3.0 * G3;
          // Work out the hashed gradient indices of the four simplex corners
          var ii = i & 255;
          var jj = j & 255;
          var kk = k & 255;
          // Calculate the contribution from the four corners
          var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
          if (t0 < 0) n0 = 0.0;
          else {
            var gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
            t0 *= t0;
            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
          }
          var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
          if (t1 < 0) n1 = 0.0;
          else {
            var gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
            t1 *= t1;
            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
          }
          var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
          if (t2 < 0) n2 = 0.0;
          else {
            var gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
            t2 *= t2;
            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
          }
          var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
          if (t3 < 0) n3 = 0.0;
          else {
            var gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
            t3 *= t3;
            n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
          }
          // Add contributions from each corner to get the final noise value.
          // The result is scaled to stay just inside [-1,1]
          return 32.0 * (n0 + n1 + n2 + n3);
        },
        // 4D simplex noise, better simplex rank ordering method 2012-03-09
        noise4D: function(x, y, z, w) {
          var perm = this.perm;
          var grad4 = this.grad4;
    
          var n0, n1, n2, n3, n4; // Noise contributions from the five corners
          // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
          var s = (x + y + z + w) * F4; // Factor for 4D skewing
          var i = Math.floor(x + s);
          var j = Math.floor(y + s);
          var k = Math.floor(z + s);
          var l = Math.floor(w + s);
          var t = (i + j + k + l) * G4; // Factor for 4D unskewing
          var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
          var Y0 = j - t;
          var Z0 = k - t;
          var W0 = l - t;
          var x0 = x - X0; // The x,y,z,w distances from the cell origin
          var y0 = y - Y0;
          var z0 = z - Z0;
          var w0 = w - W0;
          // For the 4D case, the simplex is a 4D shape I won't even try to describe.
          // To find out which of the 24 possible simplices we're in, we need to
          // determine the magnitude ordering of x0, y0, z0 and w0.
          // Six pair-wise comparisons are performed between each possible pair
          // of the four coordinates, and the results are used to rank the numbers.
          var rankx = 0;
          var ranky = 0;
          var rankz = 0;
          var rankw = 0;
          if (x0 > y0) rankx++;
          else ranky++;
          if (x0 > z0) rankx++;
          else rankz++;
          if (x0 > w0) rankx++;
          else rankw++;
          if (y0 > z0) ranky++;
          else rankz++;
          if (y0 > w0) ranky++;
          else rankw++;
          if (z0 > w0) rankz++;
          else rankw++;
          var i1, j1, k1, l1; // The integer offsets for the second simplex corner
          var i2, j2, k2, l2; // The integer offsets for the third simplex corner
          var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
          // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
          // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
          // impossible. Only the 24 indices which have non-zero entries make any sense.
          // We use a thresholding to set the coordinates in turn from the largest magnitude.
          // Rank 3 denotes the largest coordinate.
          i1 = rankx >= 3 ? 1 : 0;
          j1 = ranky >= 3 ? 1 : 0;
          k1 = rankz >= 3 ? 1 : 0;
          l1 = rankw >= 3 ? 1 : 0;
          // Rank 2 denotes the second largest coordinate.
          i2 = rankx >= 2 ? 1 : 0;
          j2 = ranky >= 2 ? 1 : 0;
          k2 = rankz >= 2 ? 1 : 0;
          l2 = rankw >= 2 ? 1 : 0;
          // Rank 1 denotes the second smallest coordinate.
          i3 = rankx >= 1 ? 1 : 0;
          j3 = ranky >= 1 ? 1 : 0;
          k3 = rankz >= 1 ? 1 : 0;
          l3 = rankw >= 1 ? 1 : 0;
          // The fifth corner has all coordinate offsets = 1, so no need to compute that.
          var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
          var y1 = y0 - j1 + G4;
          var z1 = z0 - k1 + G4;
          var w1 = w0 - l1 + G4;
          var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
          var y2 = y0 - j2 + 2.0 * G4;
          var z2 = z0 - k2 + 2.0 * G4;
          var w2 = w0 - l2 + 2.0 * G4;
          var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
          var y3 = y0 - j3 + 3.0 * G4;
          var z3 = z0 - k3 + 3.0 * G4;
          var w3 = w0 - l3 + 3.0 * G4;
          var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
          var y4 = y0 - 1.0 + 4.0 * G4;
          var z4 = z0 - 1.0 + 4.0 * G4;
          var w4 = w0 - 1.0 + 4.0 * G4;
          // Work out the hashed gradient indices of the five simplex corners
          var ii = i & 255;
          var jj = j & 255;
          var kk = k & 255;
          var ll = l & 255;
          // Calculate the contribution from the five corners
          var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
          if (t0 < 0) n0 = 0.0;
          else {
            var gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;
            t0 *= t0;
            n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);
          }
          var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
          if (t1 < 0) n1 = 0.0;
          else {
            var gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;
            t1 *= t1;
            n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);
          }
          var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
          if (t2 < 0) n2 = 0.0;
          else {
            var gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;
            t2 *= t2;
            n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);
          }
          var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
          if (t3 < 0) n3 = 0.0;
          else {
            var gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;
            t3 *= t3;
            n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);
          }
          var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
          if (t4 < 0) n4 = 0.0;
          else {
            var gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;
            t4 *= t4;
            n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);
          }
          // Sum up and scale the result to cover the range [-1,1]
          return 27.0 * (n0 + n1 + n2 + n3 + n4);
        }
      };
    
      function buildPermutationTable(random) {
        var i;
        var p = new Uint8Array(256);
        for (i = 0; i < 256; i++) {
          p[i] = i;
        }
        for (i = 0; i < 255; i++) {
          var r = i + ~~(random() * (256 - i));
          var aux = p[i];
          p[i] = p[r];
          p[r] = aux;
        }
        return p;
      }
      SimplexNoise._buildPermutationTable = buildPermutationTable;
    
      function alea() {
        // Johannes Baagøe <baagoe@baagoe.com>, 2010
        var s0 = 0;
        var s1 = 0;
        var s2 = 0;
        var c = 1;
    
        var mash = masher();
        s0 = mash(' ');
        s1 = mash(' ');
        s2 = mash(' ');
    
        for (var i = 0; i < arguments.length; i++) {
          s0 -= mash(arguments[i]);
          if (s0 < 0) {
            s0 += 1;
          }
          s1 -= mash(arguments[i]);
          if (s1 < 0) {
            s1 += 1;
          }
          s2 -= mash(arguments[i]);
          if (s2 < 0) {
            s2 += 1;
          }
        }
        mash = null;
        return function() {
          var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
          s0 = s1;
          s1 = s2;
          return s2 = t - (c = t | 0);
        };
      }
      function masher() {
        var n = 0xefc8249d;
        return function(data) {
          data = data.toString();
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 0x100000000; // 2^32
          }
          return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
        };
      }
    
      // amd
      if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {return SimplexNoise;}).call(exports, __webpack_require__, exports, module),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      // common js
      if (true) exports.SimplexNoise = SimplexNoise;
      // browser
      else {}
      // nodejs
      if (true) {
        module.exports = SimplexNoise;
      }
    
    })();
    
    
    /***/ }),
    
    /***/ "./node_modules/three/build/three.module.js":
    /*!**************************************************!*\
      !*** ./node_modules/three/build/three.module.js ***!
      \**************************************************/
    /*! exports provided: ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, ClosedSplineCurve3, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, CubeGeometry, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DirectionalLightShadow, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EdgesHelper, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, Face3, Face4, FaceColors, FileLoader, FlatShading, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontFaceDirectionCCW, FrontFaceDirectionCW, FrontSide, Frustum, GammaEncoding, Geometry, GeometryUtils, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, JSONLoader, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, LightShadow, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, Math, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColors, NoToneMapping, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, ParametricBufferGeometry, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBIntegerFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SphericalReflectionMapping, Spline, SplineCurve, SplineCurve3, SpotLight, SpotLightHelper, SpotLightShadow, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextBufferGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uncharted2ToneMapping, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VideoTexture, WebGLCubeRenderTarget, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, sRGBEncoding */
    /***/ (function(module, __webpack_exports__, __webpack_require__) {
    
    "use strict";
    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function() { return ACESFilmicToneMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysStencilFunc", function() { return AlwaysStencilFunc; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return AmbientLight; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLightProbe", function() { return AmbientLightProbe; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function() { return AnimationClip; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationLoader", function() { return AnimationLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() { return AnimationMixer; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() { return AnimationObjectGroup; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() { return AnimationUtils; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return ArcCurve; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() { return ArrayCamera; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() { return ArrowHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() { return AudioAnalyser; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return AudioContext; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioListener", function() { return AudioListener; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioLoader", function() { return AudioLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxesHelper", function() { return AxesHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisHelper", function() { return AxisHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() { return BinaryTextureLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bone", function() { return Bone; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() { return BooleanKeyframeTrack; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() { return BoundingBoxHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box2", function() { return Box2; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3", function() { return Box3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3Helper", function() { return Box3Helper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() { return BoxBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return BoxGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxHelper", function() { return BoxHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return BufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return BufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() { return BufferGeometryLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return Cache; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return CameraHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() { return CanvasRenderer; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return CanvasTexture; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return CatmullRomCurve3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() { return CircleBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return CircleGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return Clock; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClosedSplineCurve3", function() { return ClosedSplineCurve3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() { return ColorKeyframeTrack; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() { return CompressedTexture; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() { return CompressedTextureLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() { return ConeBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return ConeGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function() { return CubeCamera; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() { return BoxGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return CubeTexture; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return CubeTextureLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return CubicBezierCurve; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return CubicBezierCurve3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() { return CubicInterpolant; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CurvePath", function() { return CurvePath; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() { return CylinderBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return CylinderGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cylindrical", function() { return Cylindrical; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return DataTexture; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture2DArray", function() { return DataTexture2DArray; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture3D", function() { return DataTexture3D; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() { return DataTextureLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementStencilOp", function() { return DecrementStencilOp; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementWrapStencilOp", function() { return DecrementWrapStencilOp; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() { return DefaultLoadingManager; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTexture", function() { return DepthTexture; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return DirectionalLight; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() { return DirectionalLightHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightShadow", function() { return DirectionalLightShadow; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() { return DiscreteInterpolant; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() { return DodecahedronBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return DodecahedronGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() { return DynamicBufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicCopyUsage", function() { return DynamicCopyUsage; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDrawUsage", function() { return DynamicDrawUsage; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicReadUsage", function() { return DynamicReadUsage; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return EdgesGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() { return EdgesHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return EllipseCurve; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualStencilFunc", function() { return EqualStencilFunc; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() { return ExtrudeBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return ExtrudeGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face3", function() { return Face3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face4", function() { return Face4; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return FaceColors; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return FileLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return FlatShading; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() { return Float32Attribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return Float32BufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() { return Float64Attribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() { return Float64BufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fog", function() { return Fog; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FogExp2", function() { return FogExp2; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Font", function() { return Font; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontLoader", function() { return FontLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCCW", function() { return FrontFaceDirectionCCW; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCW", function() { return FrontFaceDirectionCW; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return Frustum; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return GammaEncoding; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryUtils", function() { return GeometryUtils; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualStencilFunc", function() { return GreaterEqualStencilFunc; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterStencilFunc", function() { return GreaterStencilFunc; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridHelper", function() { return GridHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() { return HemisphereLight; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() { return HemisphereLightHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightProbe", function() { return HemisphereLightProbe; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() { return IcosahedronBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return IcosahedronGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return ImageLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function() { return ImageUtils; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() { return ImmediateRenderObject; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementStencilOp", function() { return IncrementStencilOp; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementWrapStencilOp", function() { return IncrementWrapStencilOp; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() { return InstancedBufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() { return InstancedBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() { return InstancedInterleavedBuffer; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedMesh", function() { return InstancedMesh; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() { return Int16Attribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return Int16BufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() { return Int32Attribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return Int32BufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() { return Int8Attribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return Int8BufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() { return InterleavedBuffer; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() { return InterleavedBufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function() { return Interpolant; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InvertStencilOp", function() { return InvertStencilOp; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return JSONLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeepStencilOp", function() { return KeepStencilOp; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() { return KeyframeTrack; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOD", function() { return LOD; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() { return LatheBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return LatheGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LensFlare", function() { return LensFlare; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualStencilFunc", function() { return LessEqualStencilFunc; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessStencilFunc", function() { return LessStencilFunc; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Light", function() { return Light; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightProbe", function() { return LightProbe; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightShadow", function() { return LightShadow; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line3", function() { return Line3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return LineBasicMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return LineCurve; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return LineCurve3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return LineDashedMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function() { return LineLoop; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinePieces", function() { return LinePieces; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return LineSegments; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineStrip", function() { return LineStrip; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return LinearEncoding; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() { return LinearInterpolant; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapLinearFilter", function() { return LinearMipmapLinearFilter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapNearestFilter", function() { return LinearMipmapNearestFilter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoaderUtils", function() { return LoaderUtils; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function() { return LoadingManager; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return LogLuvEncoding; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return Material; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() { return MaterialLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math", function() { return MathUtils; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MathUtils", function() { return MathUtils; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return Mesh; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return MeshBasicMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return MeshDepthMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() { return MeshDistanceMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() { return MeshFaceMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return MeshLambertMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshMatcapMaterial", function() { return MeshMatcapMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return MeshNormalMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return MeshPhongMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return MeshPhysicalMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return MeshStandardMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return MeshToonMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() { return MultiMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapLinearFilter", function() { return NearestMipmapLinearFilter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapNearestFilter", function() { return NearestMipmapNearestFilter; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverStencilFunc", function() { return NeverStencilFunc; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return NoColors; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualStencilFunc", function() { return NotEqualStencilFunc; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() { return NumberKeyframeTrack; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() { return ObjectLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return ObjectSpaceNormalMap; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() { return OctahedronBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return OctahedronGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return OrthographicCamera; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PMREMGenerator", function() { return PMREMGenerator; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() { return ParametricBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() { return ParametricGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() { return ParticleBasicMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() { return ParticleSystem; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() { return ParticleSystemMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return PerspectiveCamera; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() { return PlaneBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return PlaneGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneHelper", function() { return PlaneHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloud", function() { return PointCloud; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() { return PointCloudMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return PointLight; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() { return PointLightHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return Points; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return PointsMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() { return PolarGridHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() { return PolyhedronBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return PolyhedronGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() { return PositionalAudio; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() { return PropertyBinding; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() { return PropertyMixer; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return QuadraticBezierCurve; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return QuadraticBezierCurve3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() { return QuaternionKeyframeTrack; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() { return QuaternionLinearInterpolant; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAIntegerFormat", function() { return RGBAIntegerFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return RGBA_ASTC_10x10_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return RGBA_ASTC_10x5_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return RGBA_ASTC_10x6_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return RGBA_ASTC_10x8_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return RGBA_ASTC_12x10_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return RGBA_ASTC_12x12_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return RGBA_ASTC_4x4_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return RGBA_ASTC_5x4_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return RGBA_ASTC_5x5_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return RGBA_ASTC_6x5_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return RGBA_ASTC_6x6_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return RGBA_ASTC_8x5_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return RGBA_ASTC_8x6_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return RGBA_ASTC_8x8_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ETC2_EAC_Format", function() { return RGBA_ETC2_EAC_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return RGBDEncoding; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return RGBEEncoding; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return RGBEFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBIntegerFormat", function() { return RGBIntegerFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return RGBM16Encoding; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return RGBM7Encoding; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC2_Format", function() { return RGB_ETC2_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGFormat", function() { return RGFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGIntegerFormat", function() { return RGIntegerFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return RawShaderMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return Raycaster; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() { return RectAreaLight; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function() { return RedFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedIntegerFormat", function() { return RedIntegerFormat; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaceStencilOp", function() { return ReplaceStencilOp; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() { return RingBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return RingGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x10_Format", function() { return SRGB8_ALPHA8_ASTC_10x10_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x5_Format", function() { return SRGB8_ALPHA8_ASTC_10x5_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x6_Format", function() { return SRGB8_ALPHA8_ASTC_10x6_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x8_Format", function() { return SRGB8_ALPHA8_ASTC_10x8_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x10_Format", function() { return SRGB8_ALPHA8_ASTC_12x10_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x12_Format", function() { return SRGB8_ALPHA8_ASTC_12x12_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_4x4_Format", function() { return SRGB8_ALPHA8_ASTC_4x4_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x4_Format", function() { return SRGB8_ALPHA8_ASTC_5x4_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x5_Format", function() { return SRGB8_ALPHA8_ASTC_5x5_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x5_Format", function() { return SRGB8_ALPHA8_ASTC_6x5_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x6_Format", function() { return SRGB8_ALPHA8_ASTC_6x6_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x5_Format", function() { return SRGB8_ALPHA8_ASTC_8x5_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x6_Format", function() { return SRGB8_ALPHA8_ASTC_8x6_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x8_Format", function() { return SRGB8_ALPHA8_ASTC_8x8_Format; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return Scene; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneUtils", function() { return SceneUtils; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() { return ShaderChunk; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function() { return ShaderLib; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return ShaderMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return ShadowMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() { return ShapeBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return ShapeGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapePath", function() { return ShapePath; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() { return ShapeUtils; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function() { return Skeleton; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() { return SkeletonHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() { return SkinnedMesh; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return SmoothShading; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() { return SphereBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return SphereGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spherical", function() { return Spherical; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalHarmonics3", function() { return SphericalHarmonics3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalReflectionMapping", function() { return SphericalReflectionMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spline", function() { return Spline; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return SplineCurve; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve3", function() { return SplineCurve3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function() { return SpotLight; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() { return SpotLightHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightShadow", function() { return SpotLightShadow; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return SpriteMaterial; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticCopyUsage", function() { return StaticCopyUsage; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticDrawUsage", function() { return StaticDrawUsage; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticReadUsage", function() { return StaticReadUsage; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StereoCamera", function() { return StereoCamera; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamCopyUsage", function() { return StreamCopyUsage; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamDrawUsage", function() { return StreamDrawUsage; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamReadUsage", function() { return StreamReadUsage; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() { return StringKeyframeTrack; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function() { return TOUCH; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return TangentSpaceNormalMap; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() { return TetrahedronBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return TetrahedronGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextBufferGeometry", function() { return TextBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextGeometry", function() { return TextGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return TextureLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() { return TorusBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return TorusGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() { return TorusKnotBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return TorusKnotGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return Triangle; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() { return TubeBufferGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return TubeGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() { return Uint16Attribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return Uint16BufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() { return Uint32Attribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return Uint32BufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() { return Uint8Attribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return Uint8BufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() { return Uint8ClampedAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return Uint8ClampedBufferAttribute; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uncharted2ToneMapping", function() { return Uncharted2ToneMapping; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uniform", function() { return Uniform; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function() { return UniformsLib; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() { return UniformsUtils; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSMShadowMap", function() { return VSMShadowMap; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return Vector2; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return Vector4; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() { return VectorKeyframeTrack; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vertex", function() { return Vertex; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return VertexColors; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return VideoTexture; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeRenderTarget", function() { return WebGLCubeRenderTarget; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMultisampleRenderTarget", function() { return WebGLMultisampleRenderTarget; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return WebGLRenderTarget; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() { return WebGLRenderTargetCube; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return WebGLRenderer; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUtils", function() { return WebGLUtils; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return WireframeGeometry; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() { return WireframeHelper; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHRLoader", function() { return XHRLoader; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroStencilOp", function() { return ZeroStencilOp; });
    /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return sRGBEncoding; });
    // Polyfills
    
    if ( Number.EPSILON === undefined ) {
    
        Number.EPSILON = Math.pow( 2, - 52 );
    
    }
    
    if ( Number.isInteger === undefined ) {
    
        // Missing in IE
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
    
        Number.isInteger = function ( value ) {
    
            return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;
    
        };
    
    }
    
    //
    
    if ( Math.sign === undefined ) {
    
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
    
        Math.sign = function ( x ) {
    
            return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;
    
        };
    
    }
    
    if ( 'name' in Function.prototype === false ) {
    
        // Missing in IE
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
    
        Object.defineProperty( Function.prototype, 'name', {
    
            get: function () {
    
                return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];
    
            }
    
        } );
    
    }
    
    if ( Object.assign === undefined ) {
    
        // Missing in IE
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
    
        Object.assign = function ( target ) {
    
            if ( target === undefined || target === null ) {
    
                throw new TypeError( 'Cannot convert undefined or null to object' );
    
            }
    
            var output = Object( target );
    
            for ( var index = 1; index < arguments.length; index ++ ) {
    
                var source = arguments[ index ];
    
                if ( source !== undefined && source !== null ) {
    
                    for ( var nextKey in source ) {
    
                        if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {
    
                            output[ nextKey ] = source[ nextKey ];
    
                        }
    
                    }
    
                }
    
            }
    
            return output;
    
        };
    
    }
    
    var REVISION = '114';
    var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
    var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var CullFaceFrontBack = 3;
    var FrontFaceDirectionCW = 0;
    var FrontFaceDirectionCCW = 1;
    var BasicShadowMap = 0;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var VSMShadowMap = 3;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var SmoothShading = 2;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var Uncharted2ToneMapping = 3;
    var CineonToneMapping = 4;
    var ACESFilmicToneMapping = 5;
    
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var SphericalReflectionMapping = 305;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var RepeatWrapping = 1000;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var NearestFilter = 1003;
    var NearestMipmapNearestFilter = 1004;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipmapLinearFilter = 1005;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipmapNearestFilter = 1007;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipmapLinearFilter = 1008;
    var LinearMipMapLinearFilter = 1008;
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RedFormat = 1028;
    var RedIntegerFormat = 1029;
    var RGFormat = 1030;
    var RGIntegerFormat = 1031;
    var RGBIntegerFormat = 1032;
    var RGBAIntegerFormat = 1033;
    
    var RGB_S3TC_DXT1_Format = 33776;
    var RGBA_S3TC_DXT1_Format = 33777;
    var RGBA_S3TC_DXT3_Format = 33778;
    var RGBA_S3TC_DXT5_Format = 33779;
    var RGB_PVRTC_4BPPV1_Format = 35840;
    var RGB_PVRTC_2BPPV1_Format = 35841;
    var RGBA_PVRTC_4BPPV1_Format = 35842;
    var RGBA_PVRTC_2BPPV1_Format = 35843;
    var RGB_ETC1_Format = 36196;
    var RGB_ETC2_Format = 37492;
    var RGBA_ETC2_EAC_Format = 37496;
    var RGBA_ASTC_4x4_Format = 37808;
    var RGBA_ASTC_5x4_Format = 37809;
    var RGBA_ASTC_5x5_Format = 37810;
    var RGBA_ASTC_6x5_Format = 37811;
    var RGBA_ASTC_6x6_Format = 37812;
    var RGBA_ASTC_8x5_Format = 37813;
    var RGBA_ASTC_8x6_Format = 37814;
    var RGBA_ASTC_8x8_Format = 37815;
    var RGBA_ASTC_10x5_Format = 37816;
    var RGBA_ASTC_10x6_Format = 37817;
    var RGBA_ASTC_10x8_Format = 37818;
    var RGBA_ASTC_10x10_Format = 37819;
    var RGBA_ASTC_12x10_Format = 37820;
    var RGBA_ASTC_12x12_Format = 37821;
    var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
    var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
    var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
    var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
    var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
    var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
    var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
    var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
    var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
    var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
    var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
    var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
    var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
    var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var TrianglesDrawMode = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3000;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;
    var TangentSpaceNormalMap = 0;
    var ObjectSpaceNormalMap = 1;
    
    var ZeroStencilOp = 0;
    var KeepStencilOp = 7680;
    var ReplaceStencilOp = 7681;
    var IncrementStencilOp = 7682;
    var DecrementStencilOp = 7683;
    var IncrementWrapStencilOp = 34055;
    var DecrementWrapStencilOp = 34056;
    var InvertStencilOp = 5386;
    
    var NeverStencilFunc = 512;
    var LessStencilFunc = 513;
    var EqualStencilFunc = 514;
    var LessEqualStencilFunc = 515;
    var GreaterStencilFunc = 516;
    var NotEqualStencilFunc = 517;
    var GreaterEqualStencilFunc = 518;
    var AlwaysStencilFunc = 519;
    
    var StaticDrawUsage = 35044;
    var DynamicDrawUsage = 35048;
    var StreamDrawUsage = 35040;
    var StaticReadUsage = 35045;
    var DynamicReadUsage = 35049;
    var StreamReadUsage = 35041;
    var StaticCopyUsage = 35046;
    var DynamicCopyUsage = 35050;
    var StreamCopyUsage = 35042;
    
    /**
     * https://github.com/mrdoob/eventdispatcher.js/
     */
    
    function EventDispatcher() {}
    
    Object.assign( EventDispatcher.prototype, {
    
        addEventListener: function ( type, listener ) {
    
            if ( this._listeners === undefined ) this._listeners = {};
    
            var listeners = this._listeners;
    
            if ( listeners[ type ] === undefined ) {
    
                listeners[ type ] = [];
    
            }
    
            if ( listeners[ type ].indexOf( listener ) === - 1 ) {
    
                listeners[ type ].push( listener );
    
            }
    
        },
    
        hasEventListener: function ( type, listener ) {
    
            if ( this._listeners === undefined ) return false;
    
            var listeners = this._listeners;
    
            return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;
    
        },
    
        removeEventListener: function ( type, listener ) {
    
            if ( this._listeners === undefined ) return;
    
            var listeners = this._listeners;
            var listenerArray = listeners[ type ];
    
            if ( listenerArray !== undefined ) {
    
                var index = listenerArray.indexOf( listener );
    
                if ( index !== - 1 ) {
    
                    listenerArray.splice( index, 1 );
    
                }
    
            }
    
        },
    
        dispatchEvent: function ( event ) {
    
            if ( this._listeners === undefined ) return;
    
            var listeners = this._listeners;
            var listenerArray = listeners[ event.type ];
    
            if ( listenerArray !== undefined ) {
    
                event.target = this;
    
                var array = listenerArray.slice( 0 );
    
                for ( var i = 0, l = array.length; i < l; i ++ ) {
    
                    array[ i ].call( this, event );
    
                }
    
            }
    
        }
    
    } );
    
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author thezwap
     */
    
    var _lut = [];
    
    for ( var i = 0; i < 256; i ++ ) {
    
        _lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );
    
    }
    
    var MathUtils = {
    
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
    
        generateUUID: function () {
    
            // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
    
            var d0 = Math.random() * 0xffffffff | 0;
            var d1 = Math.random() * 0xffffffff | 0;
            var d2 = Math.random() * 0xffffffff | 0;
            var d3 = Math.random() * 0xffffffff | 0;
            var uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
                _lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
                _lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
                _lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];
    
            // .toUpperCase() here flattens concatenated strings to save heap memory space.
            return uuid.toUpperCase();
    
        },
    
        clamp: function ( value, min, max ) {
    
            return Math.max( min, Math.min( max, value ) );
    
        },
    
        // compute euclidian modulo of m % n
        // https://en.wikipedia.org/wiki/Modulo_operation
    
        euclideanModulo: function ( n, m ) {
    
            return ( ( n % m ) + m ) % m;
    
        },
    
        // Linear mapping from range <a1, a2> to range <b1, b2>
    
        mapLinear: function ( x, a1, a2, b1, b2 ) {
    
            return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
    
        },
    
        // https://en.wikipedia.org/wiki/Linear_interpolation
    
        lerp: function ( x, y, t ) {
    
            return ( 1 - t ) * x + t * y;
    
        },
    
        // http://en.wikipedia.org/wiki/Smoothstep
    
        smoothstep: function ( x, min, max ) {
    
            if ( x <= min ) return 0;
            if ( x >= max ) return 1;
    
            x = ( x - min ) / ( max - min );
    
            return x * x * ( 3 - 2 * x );
    
        },
    
        smootherstep: function ( x, min, max ) {
    
            if ( x <= min ) return 0;
            if ( x >= max ) return 1;
    
            x = ( x - min ) / ( max - min );
    
            return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
    
        },
    
        // Random integer from <low, high> interval
    
        randInt: function ( low, high ) {
    
            return low + Math.floor( Math.random() * ( high - low + 1 ) );
    
        },
    
        // Random float from <low, high> interval
    
        randFloat: function ( low, high ) {
    
            return low + Math.random() * ( high - low );
    
        },
    
        // Random float from <-range/2, range/2> interval
    
        randFloatSpread: function ( range ) {
    
            return range * ( 0.5 - Math.random() );
    
        },
    
        degToRad: function ( degrees ) {
    
            return degrees * MathUtils.DEG2RAD;
    
        },
    
        radToDeg: function ( radians ) {
    
            return radians * MathUtils.RAD2DEG;
    
        },
    
        isPowerOfTwo: function ( value ) {
    
            return ( value & ( value - 1 ) ) === 0 && value !== 0;
    
        },
    
        ceilPowerOfTwo: function ( value ) {
    
            return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );
    
        },
    
        floorPowerOfTwo: function ( value ) {
    
            return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );
    
        },
    
        setQuaternionFromProperEuler: function ( q, a, b, c, order ) {
    
            // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
    
            // rotations are applied to the axes in the order specified by 'order'
            // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
            // angles are in radians
    
            var cos = Math.cos;
            var sin = Math.sin;
    
            var c2 = cos( b / 2 );
            var s2 = sin( b / 2 );
    
            var c13 = cos( ( a + c ) / 2 );
            var s13 = sin( ( a + c ) / 2 );
    
            var c1_3 = cos( ( a - c ) / 2 );
            var s1_3 = sin( ( a - c ) / 2 );
    
            var c3_1 = cos( ( c - a ) / 2 );
            var s3_1 = sin( ( c - a ) / 2 );
    
            if ( order === 'XYX' ) {
    
                q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
    
            } else if ( order === 'YZY' ) {
    
                q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
    
            } else if ( order === 'ZXZ' ) {
    
                q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
    
            } else if ( order === 'XZX' ) {
    
                q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
    
            } else if ( order === 'YXY' ) {
    
                q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
    
            } else if ( order === 'ZYZ' ) {
    
                q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
    
            } else {
    
                console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );
    
            }
    
        }
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author philogb / http://blog.thejit.org/
     * @author egraether / http://egraether.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */
    
    function Vector2( x, y ) {
    
        this.x = x || 0;
        this.y = y || 0;
    
    }
    
    Object.defineProperties( Vector2.prototype, {
    
        "width": {
    
            get: function () {
    
                return this.x;
    
            },
    
            set: function ( value ) {
    
                this.x = value;
    
            }
    
        },
    
        "height": {
    
            get: function () {
    
                return this.y;
    
            },
    
            set: function ( value ) {
    
                this.y = value;
    
            }
    
        }
    
    } );
    
    Object.assign( Vector2.prototype, {
    
        isVector2: true,
    
        set: function ( x, y ) {
    
            this.x = x;
            this.y = y;
    
            return this;
    
        },
    
        setScalar: function ( scalar ) {
    
            this.x = scalar;
            this.y = scalar;
    
            return this;
    
        },
    
        setX: function ( x ) {
    
            this.x = x;
    
            return this;
    
        },
    
        setY: function ( y ) {
    
            this.y = y;
    
            return this;
    
        },
    
        setComponent: function ( index, value ) {
    
            switch ( index ) {
    
                case 0: this.x = value; break;
                case 1: this.y = value; break;
                default: throw new Error( 'index is out of range: ' + index );
    
            }
    
            return this;
    
        },
    
        getComponent: function ( index ) {
    
            switch ( index ) {
    
                case 0: return this.x;
                case 1: return this.y;
                default: throw new Error( 'index is out of range: ' + index );
    
            }
    
        },
    
        clone: function () {
    
            return new this.constructor( this.x, this.y );
    
        },
    
        copy: function ( v ) {
    
            this.x = v.x;
            this.y = v.y;
    
            return this;
    
        },
    
        add: function ( v, w ) {
    
            if ( w !== undefined ) {
    
                console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
                return this.addVectors( v, w );
    
            }
    
            this.x += v.x;
            this.y += v.y;
    
            return this;
    
        },
    
        addScalar: function ( s ) {
    
            this.x += s;
            this.y += s;
    
            return this;
    
        },
    
        addVectors: function ( a, b ) {
    
            this.x = a.x + b.x;
            this.y = a.y + b.y;
    
            return this;
    
        },
    
        addScaledVector: function ( v, s ) {
    
            this.x += v.x * s;
            this.y += v.y * s;
    
            return this;
    
        },
    
        sub: function ( v, w ) {
    
            if ( w !== undefined ) {
    
                console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
                return this.subVectors( v, w );
    
            }
    
            this.x -= v.x;
            this.y -= v.y;
    
            return this;
    
        },
    
        subScalar: function ( s ) {
    
            this.x -= s;
            this.y -= s;
    
            return this;
    
        },
    
        subVectors: function ( a, b ) {
    
            this.x = a.x - b.x;
            this.y = a.y - b.y;
    
            return this;
    
        },
    
        multiply: function ( v ) {
    
            this.x *= v.x;
            this.y *= v.y;
    
            return this;
    
        },
    
        multiplyScalar: function ( scalar ) {
    
            this.x *= scalar;
            this.y *= scalar;
    
            return this;
    
        },
    
        divide: function ( v ) {
    
            this.x /= v.x;
            this.y /= v.y;
    
            return this;
    
        },
    
        divideScalar: function ( scalar ) {
    
            return this.multiplyScalar( 1 / scalar );
    
        },
    
        applyMatrix3: function ( m ) {
    
            var x = this.x, y = this.y;
            var e = m.elements;
    
            this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
            this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];
    
            return this;
    
        },
    
        min: function ( v ) {
    
            this.x = Math.min( this.x, v.x );
            this.y = Math.min( this.y, v.y );
    
            return this;
    
        },
    
        max: function ( v ) {
    
            this.x = Math.max( this.x, v.x );
            this.y = Math.max( this.y, v.y );
    
            return this;
    
        },
    
        clamp: function ( min, max ) {
    
            // assumes min < max, componentwise
    
            this.x = Math.max( min.x, Math.min( max.x, this.x ) );
            this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    
            return this;
    
        },
    
        clampScalar: function ( minVal, maxVal ) {
    
            this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
            this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
    
            return this;
    
        },
    
        clampLength: function ( min, max ) {
    
            var length = this.length();
    
            return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
    
        },
    
        floor: function () {
    
            this.x = Math.floor( this.x );
            this.y = Math.floor( this.y );
    
            return this;
    
        },
    
        ceil: function () {
    
            this.x = Math.ceil( this.x );
            this.y = Math.ceil( this.y );
    
            return this;
    
        },
    
        round: function () {
    
            this.x = Math.round( this.x );
            this.y = Math.round( this.y );
    
            return this;
    
        },
    
        roundToZero: function () {
    
            this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
            this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    
            return this;
    
        },
    
        negate: function () {
    
            this.x = - this.x;
            this.y = - this.y;
    
            return this;
    
        },
    
        dot: function ( v ) {
    
            return this.x * v.x + this.y * v.y;
    
        },
    
        cross: function ( v ) {
    
            return this.x * v.y - this.y * v.x;
    
        },
    
        lengthSq: function () {
    
            return this.x * this.x + this.y * this.y;
    
        },
    
        length: function () {
    
            return Math.sqrt( this.x * this.x + this.y * this.y );
    
        },
    
        manhattanLength: function () {
    
            return Math.abs( this.x ) + Math.abs( this.y );
    
        },
    
        normalize: function () {
    
            return this.divideScalar( this.length() || 1 );
    
        },
    
        angle: function () {
    
            // computes the angle in radians with respect to the positive x-axis
    
            var angle = Math.atan2( - this.y, - this.x ) + Math.PI;
    
            return angle;
    
        },
    
        distanceTo: function ( v ) {
    
            return Math.sqrt( this.distanceToSquared( v ) );
    
        },
    
        distanceToSquared: function ( v ) {
    
            var dx = this.x - v.x, dy = this.y - v.y;
            return dx * dx + dy * dy;
    
        },
    
        manhattanDistanceTo: function ( v ) {
    
            return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );
    
        },
    
        setLength: function ( length ) {
    
            return this.normalize().multiplyScalar( length );
    
        },
    
        lerp: function ( v, alpha ) {
    
            this.x += ( v.x - this.x ) * alpha;
            this.y += ( v.y - this.y ) * alpha;
    
            return this;
    
        },
    
        lerpVectors: function ( v1, v2, alpha ) {
    
            return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
    
        },
    
        equals: function ( v ) {
    
            return ( ( v.x === this.x ) && ( v.y === this.y ) );
    
        },
    
        fromArray: function ( array, offset ) {
    
            if ( offset === undefined ) offset = 0;
    
            this.x = array[ offset ];
            this.y = array[ offset + 1 ];
    
            return this;
    
        },
    
        toArray: function ( array, offset ) {
    
            if ( array === undefined ) array = [];
            if ( offset === undefined ) offset = 0;
    
            array[ offset ] = this.x;
            array[ offset + 1 ] = this.y;
    
            return array;
    
        },
    
        fromBufferAttribute: function ( attribute, index, offset ) {
    
            if ( offset !== undefined ) {
    
                console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );
    
            }
    
            this.x = attribute.getX( index );
            this.y = attribute.getY( index );
    
            return this;
    
        },
    
        rotateAround: function ( center, angle ) {
    
            var c = Math.cos( angle ), s = Math.sin( angle );
    
            var x = this.x - center.x;
            var y = this.y - center.y;
    
            this.x = x * c - y * s + center.x;
            this.y = x * s + y * c + center.y;
    
            return this;
    
        }
    
    } );
    
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     * @author tschw
     */
    
    function Matrix3() {
    
        this.elements = [
    
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
    
        ];
    
        if ( arguments.length > 0 ) {
    
            console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
    
        }
    
    }
    
    Object.assign( Matrix3.prototype, {
    
        isMatrix3: true,
    
        set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
    
            var te = this.elements;
    
            te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
            te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
            te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;
    
            return this;
    
        },
    
        identity: function () {
    
            this.set(
    
                1, 0, 0,
                0, 1, 0,
                0, 0, 1
    
            );
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().fromArray( this.elements );
    
        },
    
        copy: function ( m ) {
    
            var te = this.elements;
            var me = m.elements;
    
            te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
            te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
            te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];
    
            return this;
    
        },
    
        extractBasis: function ( xAxis, yAxis, zAxis ) {
    
            xAxis.setFromMatrix3Column( this, 0 );
            yAxis.setFromMatrix3Column( this, 1 );
            zAxis.setFromMatrix3Column( this, 2 );
    
            return this;
    
        },
    
        setFromMatrix4: function ( m ) {
    
            var me = m.elements;
    
            this.set(
    
                me[ 0 ], me[ 4 ], me[ 8 ],
                me[ 1 ], me[ 5 ], me[ 9 ],
                me[ 2 ], me[ 6 ], me[ 10 ]
    
            );
    
            return this;
    
        },
    
        multiply: function ( m ) {
    
            return this.multiplyMatrices( this, m );
    
        },
    
        premultiply: function ( m ) {
    
            return this.multiplyMatrices( m, this );
    
        },
    
        multiplyMatrices: function ( a, b ) {
    
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
    
            var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
            var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
            var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];
    
            var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
            var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
            var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];
    
            te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
            te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
            te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;
    
            te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
            te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
            te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;
    
            te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
            te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
            te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;
    
            return this;
    
        },
    
        multiplyScalar: function ( s ) {
    
            var te = this.elements;
    
            te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
            te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
            te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
    
            return this;
    
        },
    
        determinant: function () {
    
            var te = this.elements;
    
            var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
                d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
                g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
    
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    
        },
    
        getInverse: function ( matrix, throwOnDegenerate ) {
    
            if ( matrix && matrix.isMatrix4 ) {
    
                console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );
    
            }
    
            var me = matrix.elements,
                te = this.elements,
    
                n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
                n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
                n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],
    
                t11 = n33 * n22 - n32 * n23,
                t12 = n32 * n13 - n33 * n12,
                t13 = n23 * n12 - n22 * n13,
    
                det = n11 * t11 + n21 * t12 + n31 * t13;
    
            if ( det === 0 ) {
    
                var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
    
                if ( throwOnDegenerate === true ) {
    
                    throw new Error( msg );
    
                } else {
    
                    console.warn( msg );
    
                }
    
                return this.identity();
    
            }
    
            var detInv = 1 / det;
    
            te[ 0 ] = t11 * detInv;
            te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
            te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;
    
            te[ 3 ] = t12 * detInv;
            te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
            te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;
    
            te[ 6 ] = t13 * detInv;
            te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
            te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
    
            return this;
    
        },
    
        transpose: function () {
    
            var tmp, m = this.elements;
    
            tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
            tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
            tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
    
            return this;
    
        },
    
        getNormalMatrix: function ( matrix4 ) {
    
            return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
    
        },
    
        transposeIntoArray: function ( r ) {
    
            var m = this.elements;
    
            r[ 0 ] = m[ 0 ];
            r[ 1 ] = m[ 3 ];
            r[ 2 ] = m[ 6 ];
            r[ 3 ] = m[ 1 ];
            r[ 4 ] = m[ 4 ];
            r[ 5 ] = m[ 7 ];
            r[ 6 ] = m[ 2 ];
            r[ 7 ] = m[ 5 ];
            r[ 8 ] = m[ 8 ];
    
            return this;
    
        },
    
        setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {
    
            var c = Math.cos( rotation );
            var s = Math.sin( rotation );
    
            this.set(
                sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
                - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
                0, 0, 1
            );
    
        },
    
        scale: function ( sx, sy ) {
    
            var te = this.elements;
    
            te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
            te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;
    
            return this;
    
        },
    
        rotate: function ( theta ) {
    
            var c = Math.cos( theta );
            var s = Math.sin( theta );
    
            var te = this.elements;
    
            var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
            var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];
    
            te[ 0 ] = c * a11 + s * a21;
            te[ 3 ] = c * a12 + s * a22;
            te[ 6 ] = c * a13 + s * a23;
    
            te[ 1 ] = - s * a11 + c * a21;
            te[ 4 ] = - s * a12 + c * a22;
            te[ 7 ] = - s * a13 + c * a23;
    
            return this;
    
        },
    
        translate: function ( tx, ty ) {
    
            var te = this.elements;
    
            te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
            te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];
    
            return this;
    
        },
    
        equals: function ( matrix ) {
    
            var te = this.elements;
            var me = matrix.elements;
    
            for ( var i = 0; i < 9; i ++ ) {
    
                if ( te[ i ] !== me[ i ] ) return false;
    
            }
    
            return true;
    
        },
    
        fromArray: function ( array, offset ) {
    
            if ( offset === undefined ) offset = 0;
    
            for ( var i = 0; i < 9; i ++ ) {
    
                this.elements[ i ] = array[ i + offset ];
    
            }
    
            return this;
    
        },
    
        toArray: function ( array, offset ) {
    
            if ( array === undefined ) array = [];
            if ( offset === undefined ) offset = 0;
    
            var te = this.elements;
    
            array[ offset ] = te[ 0 ];
            array[ offset + 1 ] = te[ 1 ];
            array[ offset + 2 ] = te[ 2 ];
    
            array[ offset + 3 ] = te[ 3 ];
            array[ offset + 4 ] = te[ 4 ];
            array[ offset + 5 ] = te[ 5 ];
    
            array[ offset + 6 ] = te[ 6 ];
            array[ offset + 7 ] = te[ 7 ];
            array[ offset + 8 ] = te[ 8 ];
    
            return array;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     */
    
    var _canvas;
    
    var ImageUtils = {
    
        getDataURL: function ( image ) {
    
            var canvas;
    
            if ( typeof HTMLCanvasElement == 'undefined' ) {
    
                return image.src;
    
            } else if ( image instanceof HTMLCanvasElement ) {
    
                canvas = image;
    
            } else {
    
                if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    
                _canvas.width = image.width;
                _canvas.height = image.height;
    
                var context = _canvas.getContext( '2d' );
    
                if ( image instanceof ImageData ) {
    
                    context.putImageData( image, 0, 0 );
    
                } else {
    
                    context.drawImage( image, 0, 0, image.width, image.height );
    
                }
    
                canvas = _canvas;
    
            }
    
            if ( canvas.width > 2048 || canvas.height > 2048 ) {
    
                return canvas.toDataURL( 'image/jpeg', 0.6 );
    
            } else {
    
                return canvas.toDataURL( 'image/png' );
    
            }
    
        }
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     */
    
    var textureId = 0;
    
    function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
    
        Object.defineProperty( this, 'id', { value: textureId ++ } );
    
        this.uuid = MathUtils.generateUUID();
    
        this.name = '';
    
        this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
        this.mipmaps = [];
    
        this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
    
        this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
        this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
    
        this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
        this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
    
        this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
    
        this.format = format !== undefined ? format : RGBAFormat;
        this.internalFormat = null;
        this.type = type !== undefined ? type : UnsignedByteType;
    
        this.offset = new Vector2( 0, 0 );
        this.repeat = new Vector2( 1, 1 );
        this.center = new Vector2( 0, 0 );
        this.rotation = 0;
    
        this.matrixAutoUpdate = true;
        this.matrix = new Matrix3();
    
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
    
        // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
        //
        // Also changing the encoding after already used by a Material will not automatically make the Material
        // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
        this.encoding = encoding !== undefined ? encoding : LinearEncoding;
    
        this.version = 0;
        this.onUpdate = null;
    
    }
    
    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = UVMapping;
    
    Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
    
        constructor: Texture,
    
        isTexture: true,
    
        updateMatrix: function () {
    
            this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( source ) {
    
            this.name = source.name;
    
            this.image = source.image;
            this.mipmaps = source.mipmaps.slice( 0 );
    
            this.mapping = source.mapping;
    
            this.wrapS = source.wrapS;
            this.wrapT = source.wrapT;
    
            this.magFilter = source.magFilter;
            this.minFilter = source.minFilter;
    
            this.anisotropy = source.anisotropy;
    
            this.format = source.format;
            this.internalFormat = source.internalFormat;
            this.type = source.type;
    
            this.offset.copy( source.offset );
            this.repeat.copy( source.repeat );
            this.center.copy( source.center );
            this.rotation = source.rotation;
    
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrix.copy( source.matrix );
    
            this.generateMipmaps = source.generateMipmaps;
            this.premultiplyAlpha = source.premultiplyAlpha;
            this.flipY = source.flipY;
            this.unpackAlignment = source.unpackAlignment;
            this.encoding = source.encoding;
    
            return this;
    
        },
    
        toJSON: function ( meta ) {
    
            var isRootObject = ( meta === undefined || typeof meta === 'string' );
    
            if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {
    
                return meta.textures[ this.uuid ];
    
            }
    
            var output = {
    
                metadata: {
                    version: 4.5,
                    type: 'Texture',
                    generator: 'Texture.toJSON'
                },
    
                uuid: this.uuid,
                name: this.name,
    
                mapping: this.mapping,
    
                repeat: [ this.repeat.x, this.repeat.y ],
                offset: [ this.offset.x, this.offset.y ],
                center: [ this.center.x, this.center.y ],
                rotation: this.rotation,
    
                wrap: [ this.wrapS, this.wrapT ],
    
                format: this.format,
                type: this.type,
                encoding: this.encoding,
    
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
    
                flipY: this.flipY,
    
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
    
            };
    
            if ( this.image !== undefined ) {
    
                // TODO: Move to THREE.Image
    
                var image = this.image;
    
                if ( image.uuid === undefined ) {
    
                    image.uuid = MathUtils.generateUUID(); // UGH
    
                }
    
                if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {
    
                    var url;
    
                    if ( Array.isArray( image ) ) {
    
                        // process array of images e.g. CubeTexture
    
                        url = [];
    
                        for ( var i = 0, l = image.length; i < l; i ++ ) {
    
                            url.push( ImageUtils.getDataURL( image[ i ] ) );
    
                        }
    
                    } else {
    
                        // process single image
    
                        url = ImageUtils.getDataURL( image );
    
                    }
    
                    meta.images[ image.uuid ] = {
                        uuid: image.uuid,
                        url: url
                    };
    
                }
    
                output.image = image.uuid;
    
            }
    
            if ( ! isRootObject ) {
    
                meta.textures[ this.uuid ] = output;
    
            }
    
            return output;
    
        },
    
        dispose: function () {
    
            this.dispatchEvent( { type: 'dispose' } );
    
        },
    
        transformUv: function ( uv ) {
    
            if ( this.mapping !== UVMapping ) return uv;
    
            uv.applyMatrix3( this.matrix );
    
            if ( uv.x < 0 || uv.x > 1 ) {
    
                switch ( this.wrapS ) {
    
                    case RepeatWrapping:
    
                        uv.x = uv.x - Math.floor( uv.x );
                        break;
    
                    case ClampToEdgeWrapping:
    
                        uv.x = uv.x < 0 ? 0 : 1;
                        break;
    
                    case MirroredRepeatWrapping:
    
                        if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
    
                            uv.x = Math.ceil( uv.x ) - uv.x;
    
                        } else {
    
                            uv.x = uv.x - Math.floor( uv.x );
    
                        }
                        break;
    
                }
    
            }
    
            if ( uv.y < 0 || uv.y > 1 ) {
    
                switch ( this.wrapT ) {
    
                    case RepeatWrapping:
    
                        uv.y = uv.y - Math.floor( uv.y );
                        break;
    
                    case ClampToEdgeWrapping:
    
                        uv.y = uv.y < 0 ? 0 : 1;
                        break;
    
                    case MirroredRepeatWrapping:
    
                        if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
    
                            uv.y = Math.ceil( uv.y ) - uv.y;
    
                        } else {
    
                            uv.y = uv.y - Math.floor( uv.y );
    
                        }
                        break;
    
                }
    
            }
    
            if ( this.flipY ) {
    
                uv.y = 1 - uv.y;
    
            }
    
            return uv;
    
        }
    
    } );
    
    Object.defineProperty( Texture.prototype, "needsUpdate", {
    
        set: function ( value ) {
    
            if ( value === true ) this.version ++;
    
        }
    
    } );
    
    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */
    
    function Vector4( x, y, z, w ) {
    
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = ( w !== undefined ) ? w : 1;
    
    }
    
    Object.defineProperties( Vector4.prototype, {
    
        "width": {
    
            get: function () {
    
                return this.z;
    
            },
    
            set: function ( value ) {
    
                this.z = value;
    
            }
    
        },
    
        "height": {
    
            get: function () {
    
                return this.w;
    
            },
    
            set: function ( value ) {
    
                this.w = value;
    
            }
    
        }
    
    } );
    
    Object.assign( Vector4.prototype, {
    
        isVector4: true,
    
        set: function ( x, y, z, w ) {
    
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
    
            return this;
    
        },
    
        setScalar: function ( scalar ) {
    
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
            this.w = scalar;
    
            return this;
    
        },
    
        setX: function ( x ) {
    
            this.x = x;
    
            return this;
    
        },
    
        setY: function ( y ) {
    
            this.y = y;
    
            return this;
    
        },
    
        setZ: function ( z ) {
    
            this.z = z;
    
            return this;
    
        },
    
        setW: function ( w ) {
    
            this.w = w;
    
            return this;
    
        },
    
        setComponent: function ( index, value ) {
    
            switch ( index ) {
    
                case 0: this.x = value; break;
                case 1: this.y = value; break;
                case 2: this.z = value; break;
                case 3: this.w = value; break;
                default: throw new Error( 'index is out of range: ' + index );
    
            }
    
            return this;
    
        },
    
        getComponent: function ( index ) {
    
            switch ( index ) {
    
                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                case 3: return this.w;
                default: throw new Error( 'index is out of range: ' + index );
    
            }
    
        },
    
        clone: function () {
    
            return new this.constructor( this.x, this.y, this.z, this.w );
    
        },
    
        copy: function ( v ) {
    
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = ( v.w !== undefined ) ? v.w : 1;
    
            return this;
    
        },
    
        add: function ( v, w ) {
    
            if ( w !== undefined ) {
    
                console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
                return this.addVectors( v, w );
    
            }
    
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;
    
            return this;
    
        },
    
        addScalar: function ( s ) {
    
            this.x += s;
            this.y += s;
            this.z += s;
            this.w += s;
    
            return this;
    
        },
    
        addVectors: function ( a, b ) {
    
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
    
            return this;
    
        },
    
        addScaledVector: function ( v, s ) {
    
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
            this.w += v.w * s;
    
            return this;
    
        },
    
        sub: function ( v, w ) {
    
            if ( w !== undefined ) {
    
                console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
                return this.subVectors( v, w );
    
            }
    
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;
    
            return this;
    
        },
    
        subScalar: function ( s ) {
    
            this.x -= s;
            this.y -= s;
            this.z -= s;
            this.w -= s;
    
            return this;
    
        },
    
        subVectors: function ( a, b ) {
    
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
    
            return this;
    
        },
    
        multiplyScalar: function ( scalar ) {
    
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
            this.w *= scalar;
    
            return this;
    
        },
    
        applyMatrix4: function ( m ) {
    
            var x = this.x, y = this.y, z = this.z, w = this.w;
            var e = m.elements;
    
            this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
            this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
            this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
            this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
    
            return this;
    
        },
    
        divideScalar: function ( scalar ) {
    
            return this.multiplyScalar( 1 / scalar );
    
        },
    
        setAxisAngleFromQuaternion: function ( q ) {
    
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
    
            // q is assumed to be normalized
    
            this.w = 2 * Math.acos( q.w );
    
            var s = Math.sqrt( 1 - q.w * q.w );
    
            if ( s < 0.0001 ) {
    
                this.x = 1;
                this.y = 0;
                this.z = 0;
    
            } else {
    
                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
    
            }
    
            return this;
    
        },
    
        setAxisAngleFromRotationMatrix: function ( m ) {
    
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
    
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    
            var angle, x, y, z,		// variables for result
                epsilon = 0.01,		// margin to allow for rounding errors
                epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
    
                te = m.elements,
    
                m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
                m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
                m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
    
            if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
                 ( Math.abs( m13 - m31 ) < epsilon ) &&
                 ( Math.abs( m23 - m32 ) < epsilon ) ) {
    
                // singularity found
                // first check for identity matrix which must have +1 for all terms
                // in leading diagonal and zero in other terms
    
                if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
                     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
                     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
                     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
    
                    // this singularity is identity matrix so angle = 0
    
                    this.set( 1, 0, 0, 0 );
    
                    return this; // zero angle, arbitrary axis
    
                }
    
                // otherwise this singularity is angle = 180
    
                angle = Math.PI;
    
                var xx = ( m11 + 1 ) / 2;
                var yy = ( m22 + 1 ) / 2;
                var zz = ( m33 + 1 ) / 2;
                var xy = ( m12 + m21 ) / 4;
                var xz = ( m13 + m31 ) / 4;
                var yz = ( m23 + m32 ) / 4;
    
                if ( ( xx > yy ) && ( xx > zz ) ) {
    
                    // m11 is the largest diagonal term
    
                    if ( xx < epsilon ) {
    
                        x = 0;
                        y = 0.707106781;
                        z = 0.707106781;
    
                    } else {
    
                        x = Math.sqrt( xx );
                        y = xy / x;
                        z = xz / x;
    
                    }
    
                } else if ( yy > zz ) {
    
                    // m22 is the largest diagonal term
    
                    if ( yy < epsilon ) {
    
                        x = 0.707106781;
                        y = 0;
                        z = 0.707106781;
    
                    } else {
    
                        y = Math.sqrt( yy );
                        x = xy / y;
                        z = yz / y;
    
                    }
    
                } else {
    
                    // m33 is the largest diagonal term so base result on this
    
                    if ( zz < epsilon ) {
    
                        x = 0.707106781;
                        y = 0.707106781;
                        z = 0;
    
                    } else {
    
                        z = Math.sqrt( zz );
                        x = xz / z;
                        y = yz / z;
    
                    }
    
                }
    
                this.set( x, y, z, angle );
    
                return this; // return 180 deg rotation
    
            }
    
            // as we have reached here there are no singularities so we can handle normally
    
            var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
                               ( m13 - m31 ) * ( m13 - m31 ) +
                               ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
    
            if ( Math.abs( s ) < 0.001 ) s = 1;
    
            // prevent divide by zero, should not happen if matrix is orthogonal and should be
            // caught by singularity test above, but I've left it in just in case
    
            this.x = ( m32 - m23 ) / s;
            this.y = ( m13 - m31 ) / s;
            this.z = ( m21 - m12 ) / s;
            this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
    
            return this;
    
        },
    
        min: function ( v ) {
    
            this.x = Math.min( this.x, v.x );
            this.y = Math.min( this.y, v.y );
            this.z = Math.min( this.z, v.z );
            this.w = Math.min( this.w, v.w );
    
            return this;
    
        },
    
        max: function ( v ) {
    
            this.x = Math.max( this.x, v.x );
            this.y = Math.max( this.y, v.y );
            this.z = Math.max( this.z, v.z );
            this.w = Math.max( this.w, v.w );
    
            return this;
    
        },
    
        clamp: function ( min, max ) {
    
            // assumes min < max, componentwise
    
            this.x = Math.max( min.x, Math.min( max.x, this.x ) );
            this.y = Math.max( min.y, Math.min( max.y, this.y ) );
            this.z = Math.max( min.z, Math.min( max.z, this.z ) );
            this.w = Math.max( min.w, Math.min( max.w, this.w ) );
    
            return this;
    
        },
    
        clampScalar: function ( minVal, maxVal ) {
    
            this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
            this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
            this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
            this.w = Math.max( minVal, Math.min( maxVal, this.w ) );
    
            return this;
    
        },
    
        clampLength: function ( min, max ) {
    
            var length = this.length();
    
            return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
    
        },
    
        floor: function () {
    
            this.x = Math.floor( this.x );
            this.y = Math.floor( this.y );
            this.z = Math.floor( this.z );
            this.w = Math.floor( this.w );
    
            return this;
    
        },
    
        ceil: function () {
    
            this.x = Math.ceil( this.x );
            this.y = Math.ceil( this.y );
            this.z = Math.ceil( this.z );
            this.w = Math.ceil( this.w );
    
            return this;
    
        },
    
        round: function () {
    
            this.x = Math.round( this.x );
            this.y = Math.round( this.y );
            this.z = Math.round( this.z );
            this.w = Math.round( this.w );
    
            return this;
    
        },
    
        roundToZero: function () {
    
            this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
            this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
            this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
            this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
    
            return this;
    
        },
    
        negate: function () {
    
            this.x = - this.x;
            this.y = - this.y;
            this.z = - this.z;
            this.w = - this.w;
    
            return this;
    
        },
    
        dot: function ( v ) {
    
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    
        },
    
        lengthSq: function () {
    
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    
        },
    
        length: function () {
    
            return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
    
        },
    
        manhattanLength: function () {
    
            return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
    
        },
    
        normalize: function () {
    
            return this.divideScalar( this.length() || 1 );
    
        },
    
        setLength: function ( length ) {
    
            return this.normalize().multiplyScalar( length );
    
        },
    
        lerp: function ( v, alpha ) {
    
            this.x += ( v.x - this.x ) * alpha;
            this.y += ( v.y - this.y ) * alpha;
            this.z += ( v.z - this.z ) * alpha;
            this.w += ( v.w - this.w ) * alpha;
    
            return this;
    
        },
    
        lerpVectors: function ( v1, v2, alpha ) {
    
            return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
    
        },
    
        equals: function ( v ) {
    
            return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
    
        },
    
        fromArray: function ( array, offset ) {
    
            if ( offset === undefined ) offset = 0;
    
            this.x = array[ offset ];
            this.y = array[ offset + 1 ];
            this.z = array[ offset + 2 ];
            this.w = array[ offset + 3 ];
    
            return this;
    
        },
    
        toArray: function ( array, offset ) {
    
            if ( array === undefined ) array = [];
            if ( offset === undefined ) offset = 0;
    
            array[ offset ] = this.x;
            array[ offset + 1 ] = this.y;
            array[ offset + 2 ] = this.z;
            array[ offset + 3 ] = this.w;
    
            return array;
    
        },
    
        fromBufferAttribute: function ( attribute, index, offset ) {
    
            if ( offset !== undefined ) {
    
                console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );
    
            }
    
            this.x = attribute.getX( index );
            this.y = attribute.getY( index );
            this.z = attribute.getZ( index );
            this.w = attribute.getW( index );
    
            return this;
    
        }
    
    } );
    
    /**
     * @author szimek / https://github.com/szimek/
     * @author alteredq / http://alteredqualia.com/
     * @author Marius Kintel / https://github.com/kintel
     */
    
    /*
     In options, we can specify:
     * Texture parameters for an auto-generated target texture
     * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
    */
    function WebGLRenderTarget( width, height, options ) {
    
        this.width = width;
        this.height = height;
    
        this.scissor = new Vector4( 0, 0, width, height );
        this.scissorTest = false;
    
        this.viewport = new Vector4( 0, 0, width, height );
    
        options = options || {};
    
        this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
    
        this.texture.image = {};
        this.texture.image.width = width;
        this.texture.image.height = height;
    
        this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
        this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
    
        this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
        this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
    
    }
    
    WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
    
        constructor: WebGLRenderTarget,
    
        isWebGLRenderTarget: true,
    
        setSize: function ( width, height ) {
    
            if ( this.width !== width || this.height !== height ) {
    
                this.width = width;
                this.height = height;
    
                this.texture.image.width = width;
                this.texture.image.height = height;
    
                this.dispose();
    
            }
    
            this.viewport.set( 0, 0, width, height );
            this.scissor.set( 0, 0, width, height );
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( source ) {
    
            this.width = source.width;
            this.height = source.height;
    
            this.viewport.copy( source.viewport );
    
            this.texture = source.texture.clone();
    
            this.depthBuffer = source.depthBuffer;
            this.stencilBuffer = source.stencilBuffer;
            this.depthTexture = source.depthTexture;
    
            return this;
    
        },
    
        dispose: function () {
    
            this.dispatchEvent( { type: 'dispose' } );
    
        }
    
    } );
    
    /**
     * @author Mugen87 / https://github.com/Mugen87
     * @author Matt DesLauriers / @mattdesl
     */
    
    function WebGLMultisampleRenderTarget( width, height, options ) {
    
        WebGLRenderTarget.call( this, width, height, options );
    
        this.samples = 4;
    
    }
    
    WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {
    
        constructor: WebGLMultisampleRenderTarget,
    
        isWebGLMultisampleRenderTarget: true,
    
        copy: function ( source ) {
    
            WebGLRenderTarget.prototype.copy.call( this, source );
    
            this.samples = source.samples;
    
            return this;
    
        }
    
    } );
    
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */
    
    function Quaternion( x, y, z, w ) {
    
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._w = ( w !== undefined ) ? w : 1;
    
    }
    
    Object.assign( Quaternion, {
    
        slerp: function ( qa, qb, qm, t ) {
    
            return qm.copy( qa ).slerp( qb, t );
    
        },
    
        slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
    
            // fuzz-free, array-based Quaternion SLERP operation
    
            var x0 = src0[ srcOffset0 + 0 ],
                y0 = src0[ srcOffset0 + 1 ],
                z0 = src0[ srcOffset0 + 2 ],
                w0 = src0[ srcOffset0 + 3 ],
    
                x1 = src1[ srcOffset1 + 0 ],
                y1 = src1[ srcOffset1 + 1 ],
                z1 = src1[ srcOffset1 + 2 ],
                w1 = src1[ srcOffset1 + 3 ];
    
            if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
    
                var s = 1 - t,
    
                    cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
    
                    dir = ( cos >= 0 ? 1 : - 1 ),
                    sqrSin = 1 - cos * cos;
    
                // Skip the Slerp for tiny steps to avoid numeric problems:
                if ( sqrSin > Number.EPSILON ) {
    
                    var sin = Math.sqrt( sqrSin ),
                        len = Math.atan2( sin, cos * dir );
    
                    s = Math.sin( s * len ) / sin;
                    t = Math.sin( t * len ) / sin;
    
                }
    
                var tDir = t * dir;
    
                x0 = x0 * s + x1 * tDir;
                y0 = y0 * s + y1 * tDir;
                z0 = z0 * s + z1 * tDir;
                w0 = w0 * s + w1 * tDir;
    
                // Normalize in case we just did a lerp:
                if ( s === 1 - t ) {
    
                    var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
    
                    x0 *= f;
                    y0 *= f;
                    z0 *= f;
                    w0 *= f;
    
                }
    
            }
    
            dst[ dstOffset ] = x0;
            dst[ dstOffset + 1 ] = y0;
            dst[ dstOffset + 2 ] = z0;
            dst[ dstOffset + 3 ] = w0;
    
        }
    
    } );
    
    Object.defineProperties( Quaternion.prototype, {
    
        x: {
    
            get: function () {
    
                return this._x;
    
            },
    
            set: function ( value ) {
    
                this._x = value;
                this._onChangeCallback();
    
            }
    
        },
    
        y: {
    
            get: function () {
    
                return this._y;
    
            },
    
            set: function ( value ) {
    
                this._y = value;
                this._onChangeCallback();
    
            }
    
        },
    
        z: {
    
            get: function () {
    
                return this._z;
    
            },
    
            set: function ( value ) {
    
                this._z = value;
                this._onChangeCallback();
    
            }
    
        },
    
        w: {
    
            get: function () {
    
                return this._w;
    
            },
    
            set: function ( value ) {
    
                this._w = value;
                this._onChangeCallback();
    
            }
    
        }
    
    } );
    
    Object.assign( Quaternion.prototype, {
    
        isQuaternion: true,
    
        set: function ( x, y, z, w ) {
    
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor( this._x, this._y, this._z, this._w );
    
        },
    
        copy: function ( quaternion ) {
    
            this._x = quaternion.x;
            this._y = quaternion.y;
            this._z = quaternion.z;
            this._w = quaternion.w;
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        setFromEuler: function ( euler, update ) {
    
            if ( ! ( euler && euler.isEuler ) ) {
    
                throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );
    
            }
    
            var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
    
            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
    
            var cos = Math.cos;
            var sin = Math.sin;
    
            var c1 = cos( x / 2 );
            var c2 = cos( y / 2 );
            var c3 = cos( z / 2 );
    
            var s1 = sin( x / 2 );
            var s2 = sin( y / 2 );
            var s3 = sin( z / 2 );
    
            if ( order === 'XYZ' ) {
    
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
    
            } else if ( order === 'YXZ' ) {
    
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
    
            } else if ( order === 'ZXY' ) {
    
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
    
            } else if ( order === 'ZYX' ) {
    
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
    
            } else if ( order === 'YZX' ) {
    
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
    
            } else if ( order === 'XZY' ) {
    
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
    
            }
    
            if ( update !== false ) this._onChangeCallback();
    
            return this;
    
        },
    
        setFromAxisAngle: function ( axis, angle ) {
    
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
    
            // assumes axis is normalized
    
            var halfAngle = angle / 2, s = Math.sin( halfAngle );
    
            this._x = axis.x * s;
            this._y = axis.y * s;
            this._z = axis.z * s;
            this._w = Math.cos( halfAngle );
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        setFromRotationMatrix: function ( m ) {
    
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    
            var te = m.elements,
    
                m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
                m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
                m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
    
                trace = m11 + m22 + m33,
                s;
    
            if ( trace > 0 ) {
    
                s = 0.5 / Math.sqrt( trace + 1.0 );
    
                this._w = 0.25 / s;
                this._x = ( m32 - m23 ) * s;
                this._y = ( m13 - m31 ) * s;
                this._z = ( m21 - m12 ) * s;
    
            } else if ( m11 > m22 && m11 > m33 ) {
    
                s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
    
                this._w = ( m32 - m23 ) / s;
                this._x = 0.25 * s;
                this._y = ( m12 + m21 ) / s;
                this._z = ( m13 + m31 ) / s;
    
            } else if ( m22 > m33 ) {
    
                s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
    
                this._w = ( m13 - m31 ) / s;
                this._x = ( m12 + m21 ) / s;
                this._y = 0.25 * s;
                this._z = ( m23 + m32 ) / s;
    
            } else {
    
                s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
    
                this._w = ( m21 - m12 ) / s;
                this._x = ( m13 + m31 ) / s;
                this._y = ( m23 + m32 ) / s;
                this._z = 0.25 * s;
    
            }
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        setFromUnitVectors: function ( vFrom, vTo ) {
    
            // assumes direction vectors vFrom and vTo are normalized
    
            var EPS = 0.000001;
    
            var r = vFrom.dot( vTo ) + 1;
    
            if ( r < EPS ) {
    
                r = 0;
    
                if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
    
                    this._x = - vFrom.y;
                    this._y = vFrom.x;
                    this._z = 0;
                    this._w = r;
    
                } else {
    
                    this._x = 0;
                    this._y = - vFrom.z;
                    this._z = vFrom.y;
                    this._w = r;
    
                }
    
            } else {
    
                // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
    
                this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
                this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
                this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
                this._w = r;
    
            }
    
            return this.normalize();
    
        },
    
        angleTo: function ( q ) {
    
            return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );
    
        },
    
        rotateTowards: function ( q, step ) {
    
            var angle = this.angleTo( q );
    
            if ( angle === 0 ) return this;
    
            var t = Math.min( 1, step / angle );
    
            this.slerp( q, t );
    
            return this;
    
        },
    
        inverse: function () {
    
            // quaternion is assumed to have unit length
    
            return this.conjugate();
    
        },
    
        conjugate: function () {
    
            this._x *= - 1;
            this._y *= - 1;
            this._z *= - 1;
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        dot: function ( v ) {
    
            return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    
        },
    
        lengthSq: function () {
    
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    
        },
    
        length: function () {
    
            return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
    
        },
    
        normalize: function () {
    
            var l = this.length();
    
            if ( l === 0 ) {
    
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
    
            } else {
    
                l = 1 / l;
    
                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
    
            }
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        multiply: function ( q, p ) {
    
            if ( p !== undefined ) {
    
                console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
                return this.multiplyQuaternions( q, p );
    
            }
    
            return this.multiplyQuaternions( this, q );
    
        },
    
        premultiply: function ( q ) {
    
            return this.multiplyQuaternions( q, this );
    
        },
    
        multiplyQuaternions: function ( a, b ) {
    
            // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
    
            var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
            var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    
            this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        slerp: function ( qb, t ) {
    
            if ( t === 0 ) return this;
            if ( t === 1 ) return this.copy( qb );
    
            var x = this._x, y = this._y, z = this._z, w = this._w;
    
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
    
            var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    
            if ( cosHalfTheta < 0 ) {
    
                this._w = - qb._w;
                this._x = - qb._x;
                this._y = - qb._y;
                this._z = - qb._z;
    
                cosHalfTheta = - cosHalfTheta;
    
            } else {
    
                this.copy( qb );
    
            }
    
            if ( cosHalfTheta >= 1.0 ) {
    
                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;
    
                return this;
    
            }
    
            var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
    
            if ( sqrSinHalfTheta <= Number.EPSILON ) {
    
                var s = 1 - t;
                this._w = s * w + t * this._w;
                this._x = s * x + t * this._x;
                this._y = s * y + t * this._y;
                this._z = s * z + t * this._z;
    
                this.normalize();
                this._onChangeCallback();
    
                return this;
    
            }
    
            var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
            var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
            var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
                ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
    
            this._w = ( w * ratioA + this._w * ratioB );
            this._x = ( x * ratioA + this._x * ratioB );
            this._y = ( y * ratioA + this._y * ratioB );
            this._z = ( z * ratioA + this._z * ratioB );
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        equals: function ( quaternion ) {
    
            return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
    
        },
    
        fromArray: function ( array, offset ) {
    
            if ( offset === undefined ) offset = 0;
    
            this._x = array[ offset ];
            this._y = array[ offset + 1 ];
            this._z = array[ offset + 2 ];
            this._w = array[ offset + 3 ];
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        toArray: function ( array, offset ) {
    
            if ( array === undefined ) array = [];
            if ( offset === undefined ) offset = 0;
    
            array[ offset ] = this._x;
            array[ offset + 1 ] = this._y;
            array[ offset + 2 ] = this._z;
            array[ offset + 3 ] = this._w;
    
            return array;
    
        },
    
        _onChange: function ( callback ) {
    
            this._onChangeCallback = callback;
    
            return this;
    
        },
    
        _onChangeCallback: function () {}
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author kile / http://kile.stravaganza.org/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */
    
    var _vector = new Vector3();
    var _quaternion = new Quaternion();
    
    function Vector3( x, y, z ) {
    
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
    
    }
    
    Object.assign( Vector3.prototype, {
    
        isVector3: true,
    
        set: function ( x, y, z ) {
    
            this.x = x;
            this.y = y;
            this.z = z;
    
            return this;
    
        },
    
        setScalar: function ( scalar ) {
    
            this.x = scalar;
            this.y = scalar;
            this.z = scalar;
    
            return this;
    
        },
    
        setX: function ( x ) {
    
            this.x = x;
    
            return this;
    
        },
    
        setY: function ( y ) {
    
            this.y = y;
    
            return this;
    
        },
    
        setZ: function ( z ) {
    
            this.z = z;
    
            return this;
    
        },
    
        setComponent: function ( index, value ) {
    
            switch ( index ) {
    
                case 0: this.x = value; break;
                case 1: this.y = value; break;
                case 2: this.z = value; break;
                default: throw new Error( 'index is out of range: ' + index );
    
            }
    
            return this;
    
        },
    
        getComponent: function ( index ) {
    
            switch ( index ) {
    
                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                default: throw new Error( 'index is out of range: ' + index );
    
            }
    
        },
    
        clone: function () {
    
            return new this.constructor( this.x, this.y, this.z );
    
        },
    
        copy: function ( v ) {
    
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
    
            return this;
    
        },
    
        add: function ( v, w ) {
    
            if ( w !== undefined ) {
    
                console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
                return this.addVectors( v, w );
    
            }
    
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
    
            return this;
    
        },
    
        addScalar: function ( s ) {
    
            this.x += s;
            this.y += s;
            this.z += s;
    
            return this;
    
        },
    
        addVectors: function ( a, b ) {
    
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
    
            return this;
    
        },
    
        addScaledVector: function ( v, s ) {
    
            this.x += v.x * s;
            this.y += v.y * s;
            this.z += v.z * s;
    
            return this;
    
        },
    
        sub: function ( v, w ) {
    
            if ( w !== undefined ) {
    
                console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
                return this.subVectors( v, w );
    
            }
    
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
    
            return this;
    
        },
    
        subScalar: function ( s ) {
    
            this.x -= s;
            this.y -= s;
            this.z -= s;
    
            return this;
    
        },
    
        subVectors: function ( a, b ) {
    
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
    
            return this;
    
        },
    
        multiply: function ( v, w ) {
    
            if ( w !== undefined ) {
    
                console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
                return this.multiplyVectors( v, w );
    
            }
    
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
    
            return this;
    
        },
    
        multiplyScalar: function ( scalar ) {
    
            this.x *= scalar;
            this.y *= scalar;
            this.z *= scalar;
    
            return this;
    
        },
    
        multiplyVectors: function ( a, b ) {
    
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
    
            return this;
    
        },
    
        applyEuler: function ( euler ) {
    
            if ( ! ( euler && euler.isEuler ) ) {
    
                console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
    
            }
    
            return this.applyQuaternion( _quaternion.setFromEuler( euler ) );
    
        },
    
        applyAxisAngle: function ( axis, angle ) {
    
            return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );
    
        },
    
        applyMatrix3: function ( m ) {
    
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
    
            this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
            this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
            this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
    
            return this;
    
        },
    
        applyNormalMatrix: function ( m ) {
    
            return this.applyMatrix3( m ).normalize();
    
        },
    
        applyMatrix4: function ( m ) {
    
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
    
            var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );
    
            this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
            this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
            this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;
    
            return this;
    
        },
    
        applyQuaternion: function ( q ) {
    
            var x = this.x, y = this.y, z = this.z;
            var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    
            // calculate quat * vector
    
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = - qx * x - qy * y - qz * z;
    
            // calculate result * inverse quat
    
            this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
            this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
            this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
    
            return this;
    
        },
    
        project: function ( camera ) {
    
            return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );
    
        },
    
        unproject: function ( camera ) {
    
            return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );
    
        },
    
        transformDirection: function ( m ) {
    
            // input: THREE.Matrix4 affine matrix
            // vector interpreted as a direction
    
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
    
            this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
            this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
            this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
    
            return this.normalize();
    
        },
    
        divide: function ( v ) {
    
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
    
            return this;
    
        },
    
        divideScalar: function ( scalar ) {
    
            return this.multiplyScalar( 1 / scalar );
    
        },
    
        min: function ( v ) {
    
            this.x = Math.min( this.x, v.x );
            this.y = Math.min( this.y, v.y );
            this.z = Math.min( this.z, v.z );
    
            return this;
    
        },
    
        max: function ( v ) {
    
            this.x = Math.max( this.x, v.x );
            this.y = Math.max( this.y, v.y );
            this.z = Math.max( this.z, v.z );
    
            return this;
    
        },
    
        clamp: function ( min, max ) {
    
            // assumes min < max, componentwise
    
            this.x = Math.max( min.x, Math.min( max.x, this.x ) );
            this.y = Math.max( min.y, Math.min( max.y, this.y ) );
            this.z = Math.max( min.z, Math.min( max.z, this.z ) );
    
            return this;
    
        },
    
        clampScalar: function ( minVal, maxVal ) {
    
            this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
            this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
            this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
    
            return this;
    
        },
    
        clampLength: function ( min, max ) {
    
            var length = this.length();
    
            return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
    
        },
    
        floor: function () {
    
            this.x = Math.floor( this.x );
            this.y = Math.floor( this.y );
            this.z = Math.floor( this.z );
    
            return this;
    
        },
    
        ceil: function () {
    
            this.x = Math.ceil( this.x );
            this.y = Math.ceil( this.y );
            this.z = Math.ceil( this.z );
    
            return this;
    
        },
    
        round: function () {
    
            this.x = Math.round( this.x );
            this.y = Math.round( this.y );
            this.z = Math.round( this.z );
    
            return this;
    
        },
    
        roundToZero: function () {
    
            this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
            this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
            this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
    
            return this;
    
        },
    
        negate: function () {
    
            this.x = - this.x;
            this.y = - this.y;
            this.z = - this.z;
    
            return this;
    
        },
    
        dot: function ( v ) {
    
            return this.x * v.x + this.y * v.y + this.z * v.z;
    
        },
    
        // TODO lengthSquared?
    
        lengthSq: function () {
    
            return this.x * this.x + this.y * this.y + this.z * this.z;
    
        },
    
        length: function () {
    
            return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
    
        },
    
        manhattanLength: function () {
    
            return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
    
        },
    
        normalize: function () {
    
            return this.divideScalar( this.length() || 1 );
    
        },
    
        setLength: function ( length ) {
    
            return this.normalize().multiplyScalar( length );
    
        },
    
        lerp: function ( v, alpha ) {
    
            this.x += ( v.x - this.x ) * alpha;
            this.y += ( v.y - this.y ) * alpha;
            this.z += ( v.z - this.z ) * alpha;
    
            return this;
    
        },
    
        lerpVectors: function ( v1, v2, alpha ) {
    
            return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
    
        },
    
        cross: function ( v, w ) {
    
            if ( w !== undefined ) {
    
                console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
                return this.crossVectors( v, w );
    
            }
    
            return this.crossVectors( this, v );
    
        },
    
        crossVectors: function ( a, b ) {
    
            var ax = a.x, ay = a.y, az = a.z;
            var bx = b.x, by = b.y, bz = b.z;
    
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
    
            return this;
    
        },
    
        projectOnVector: function ( v ) {
    
            var denominator = v.lengthSq();
    
            if ( denominator === 0 ) return this.set( 0, 0, 0 );
    
            var scalar = v.dot( this ) / denominator;
    
            return this.copy( v ).multiplyScalar( scalar );
    
        },
    
        projectOnPlane: function ( planeNormal ) {
    
            _vector.copy( this ).projectOnVector( planeNormal );
    
            return this.sub( _vector );
    
        },
    
        reflect: function ( normal ) {
    
            // reflect incident vector off plane orthogonal to normal
            // normal is assumed to have unit length
    
            return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
    
        },
    
        angleTo: function ( v ) {
    
            var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );
    
            if ( denominator === 0 ) return Math.PI / 2;
    
            var theta = this.dot( v ) / denominator;
    
            // clamp, to handle numerical problems
    
            return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );
    
        },
    
        distanceTo: function ( v ) {
    
            return Math.sqrt( this.distanceToSquared( v ) );
    
        },
    
        distanceToSquared: function ( v ) {
    
            var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    
            return dx * dx + dy * dy + dz * dz;
    
        },
    
        manhattanDistanceTo: function ( v ) {
    
            return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );
    
        },
    
        setFromSpherical: function ( s ) {
    
            return this.setFromSphericalCoords( s.radius, s.phi, s.theta );
    
        },
    
        setFromSphericalCoords: function ( radius, phi, theta ) {
    
            var sinPhiRadius = Math.sin( phi ) * radius;
    
            this.x = sinPhiRadius * Math.sin( theta );
            this.y = Math.cos( phi ) * radius;
            this.z = sinPhiRadius * Math.cos( theta );
    
            return this;
    
        },
    
        setFromCylindrical: function ( c ) {
    
            return this.setFromCylindricalCoords( c.radius, c.theta, c.y );
    
        },
    
        setFromCylindricalCoords: function ( radius, theta, y ) {
    
            this.x = radius * Math.sin( theta );
            this.y = y;
            this.z = radius * Math.cos( theta );
    
            return this;
    
        },
    
        setFromMatrixPosition: function ( m ) {
    
            var e = m.elements;
    
            this.x = e[ 12 ];
            this.y = e[ 13 ];
            this.z = e[ 14 ];
    
            return this;
    
        },
    
        setFromMatrixScale: function ( m ) {
    
            var sx = this.setFromMatrixColumn( m, 0 ).length();
            var sy = this.setFromMatrixColumn( m, 1 ).length();
            var sz = this.setFromMatrixColumn( m, 2 ).length();
    
            this.x = sx;
            this.y = sy;
            this.z = sz;
    
            return this;
    
        },
    
        setFromMatrixColumn: function ( m, index ) {
    
            return this.fromArray( m.elements, index * 4 );
    
        },
    
        setFromMatrix3Column: function ( m, index ) {
    
            return this.fromArray( m.elements, index * 3 );
    
        },
    
        equals: function ( v ) {
    
            return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
    
        },
    
        fromArray: function ( array, offset ) {
    
            if ( offset === undefined ) offset = 0;
    
            this.x = array[ offset ];
            this.y = array[ offset + 1 ];
            this.z = array[ offset + 2 ];
    
            return this;
    
        },
    
        toArray: function ( array, offset ) {
    
            if ( array === undefined ) array = [];
            if ( offset === undefined ) offset = 0;
    
            array[ offset ] = this.x;
            array[ offset + 1 ] = this.y;
            array[ offset + 2 ] = this.z;
    
            return array;
    
        },
    
        fromBufferAttribute: function ( attribute, index, offset ) {
    
            if ( offset !== undefined ) {
    
                console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );
    
            }
    
            this.x = attribute.getX( index );
            this.y = attribute.getY( index );
            this.z = attribute.getZ( index );
    
            return this;
    
        }
    
    } );
    
    var _v1 = new Vector3();
    var _m1 = new Matrix4();
    var _zero = new Vector3( 0, 0, 0 );
    var _one = new Vector3( 1, 1, 1 );
    var _x = new Vector3();
    var _y = new Vector3();
    var _z = new Vector3();
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author jordi_ros / http://plattsoft.com
     * @author D1plo1d / http://github.com/D1plo1d
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author timknip / http://www.floorplanner.com/
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */
    
    function Matrix4() {
    
        this.elements = [
    
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
    
        ];
    
        if ( arguments.length > 0 ) {
    
            console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
    
        }
    
    }
    
    Object.assign( Matrix4.prototype, {
    
        isMatrix4: true,
    
        set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
    
            var te = this.elements;
    
            te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
            te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
            te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
            te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
    
            return this;
    
        },
    
        identity: function () {
    
            this.set(
    
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
    
            );
    
            return this;
    
        },
    
        clone: function () {
    
            return new Matrix4().fromArray( this.elements );
    
        },
    
        copy: function ( m ) {
    
            var te = this.elements;
            var me = m.elements;
    
            te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
            te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
            te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
            te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];
    
            return this;
    
        },
    
        copyPosition: function ( m ) {
    
            var te = this.elements, me = m.elements;
    
            te[ 12 ] = me[ 12 ];
            te[ 13 ] = me[ 13 ];
            te[ 14 ] = me[ 14 ];
    
            return this;
    
        },
    
        extractBasis: function ( xAxis, yAxis, zAxis ) {
    
            xAxis.setFromMatrixColumn( this, 0 );
            yAxis.setFromMatrixColumn( this, 1 );
            zAxis.setFromMatrixColumn( this, 2 );
    
            return this;
    
        },
    
        makeBasis: function ( xAxis, yAxis, zAxis ) {
    
            this.set(
                xAxis.x, yAxis.x, zAxis.x, 0,
                xAxis.y, yAxis.y, zAxis.y, 0,
                xAxis.z, yAxis.z, zAxis.z, 0,
                0, 0, 0, 1
            );
    
            return this;
    
        },
    
        extractRotation: function ( m ) {
    
            // this method does not support reflection matrices
    
            var te = this.elements;
            var me = m.elements;
    
            var scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
            var scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
            var scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();
    
            te[ 0 ] = me[ 0 ] * scaleX;
            te[ 1 ] = me[ 1 ] * scaleX;
            te[ 2 ] = me[ 2 ] * scaleX;
            te[ 3 ] = 0;
    
            te[ 4 ] = me[ 4 ] * scaleY;
            te[ 5 ] = me[ 5 ] * scaleY;
            te[ 6 ] = me[ 6 ] * scaleY;
            te[ 7 ] = 0;
    
            te[ 8 ] = me[ 8 ] * scaleZ;
            te[ 9 ] = me[ 9 ] * scaleZ;
            te[ 10 ] = me[ 10 ] * scaleZ;
            te[ 11 ] = 0;
    
            te[ 12 ] = 0;
            te[ 13 ] = 0;
            te[ 14 ] = 0;
            te[ 15 ] = 1;
    
            return this;
    
        },
    
        makeRotationFromEuler: function ( euler ) {
    
            if ( ! ( euler && euler.isEuler ) ) {
    
                console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
    
            }
    
            var te = this.elements;
    
            var x = euler.x, y = euler.y, z = euler.z;
            var a = Math.cos( x ), b = Math.sin( x );
            var c = Math.cos( y ), d = Math.sin( y );
            var e = Math.cos( z ), f = Math.sin( z );
    
            if ( euler.order === 'XYZ' ) {
    
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
    
                te[ 0 ] = c * e;
                te[ 4 ] = - c * f;
                te[ 8 ] = d;
    
                te[ 1 ] = af + be * d;
                te[ 5 ] = ae - bf * d;
                te[ 9 ] = - b * c;
    
                te[ 2 ] = bf - ae * d;
                te[ 6 ] = be + af * d;
                te[ 10 ] = a * c;
    
            } else if ( euler.order === 'YXZ' ) {
    
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
    
                te[ 0 ] = ce + df * b;
                te[ 4 ] = de * b - cf;
                te[ 8 ] = a * d;
    
                te[ 1 ] = a * f;
                te[ 5 ] = a * e;
                te[ 9 ] = - b;
    
                te[ 2 ] = cf * b - de;
                te[ 6 ] = df + ce * b;
                te[ 10 ] = a * c;
    
            } else if ( euler.order === 'ZXY' ) {
    
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
    
                te[ 0 ] = ce - df * b;
                te[ 4 ] = - a * f;
                te[ 8 ] = de + cf * b;
    
                te[ 1 ] = cf + de * b;
                te[ 5 ] = a * e;
                te[ 9 ] = df - ce * b;
    
                te[ 2 ] = - a * d;
                te[ 6 ] = b;
                te[ 10 ] = a * c;
    
            } else if ( euler.order === 'ZYX' ) {
    
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
    
                te[ 0 ] = c * e;
                te[ 4 ] = be * d - af;
                te[ 8 ] = ae * d + bf;
    
                te[ 1 ] = c * f;
                te[ 5 ] = bf * d + ae;
                te[ 9 ] = af * d - be;
    
                te[ 2 ] = - d;
                te[ 6 ] = b * c;
                te[ 10 ] = a * c;
    
            } else if ( euler.order === 'YZX' ) {
    
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
    
                te[ 0 ] = c * e;
                te[ 4 ] = bd - ac * f;
                te[ 8 ] = bc * f + ad;
    
                te[ 1 ] = f;
                te[ 5 ] = a * e;
                te[ 9 ] = - b * e;
    
                te[ 2 ] = - d * e;
                te[ 6 ] = ad * f + bc;
                te[ 10 ] = ac - bd * f;
    
            } else if ( euler.order === 'XZY' ) {
    
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
    
                te[ 0 ] = c * e;
                te[ 4 ] = - f;
                te[ 8 ] = d * e;
    
                te[ 1 ] = ac * f + bd;
                te[ 5 ] = a * e;
                te[ 9 ] = ad * f - bc;
    
                te[ 2 ] = bc * f - ad;
                te[ 6 ] = b * e;
                te[ 10 ] = bd * f + ac;
    
            }
    
            // bottom row
            te[ 3 ] = 0;
            te[ 7 ] = 0;
            te[ 11 ] = 0;
    
            // last column
            te[ 12 ] = 0;
            te[ 13 ] = 0;
            te[ 14 ] = 0;
            te[ 15 ] = 1;
    
            return this;
    
        },
    
        makeRotationFromQuaternion: function ( q ) {
    
            return this.compose( _zero, q, _one );
    
        },
    
        lookAt: function ( eye, target, up ) {
    
            var te = this.elements;
    
            _z.subVectors( eye, target );
    
            if ( _z.lengthSq() === 0 ) {
    
                // eye and target are in the same position
    
                _z.z = 1;
    
            }
    
            _z.normalize();
            _x.crossVectors( up, _z );
    
            if ( _x.lengthSq() === 0 ) {
    
                // up and z are parallel
    
                if ( Math.abs( up.z ) === 1 ) {
    
                    _z.x += 0.0001;
    
                } else {
    
                    _z.z += 0.0001;
    
                }
    
                _z.normalize();
                _x.crossVectors( up, _z );
    
            }
    
            _x.normalize();
            _y.crossVectors( _z, _x );
    
            te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
            te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
            te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;
    
            return this;
    
        },
    
        multiply: function ( m, n ) {
    
            if ( n !== undefined ) {
    
                console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
                return this.multiplyMatrices( m, n );
    
            }
    
            return this.multiplyMatrices( this, m );
    
        },
    
        premultiply: function ( m ) {
    
            return this.multiplyMatrices( m, this );
    
        },
    
        multiplyMatrices: function ( a, b ) {
    
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
    
            var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
            var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
            var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
            var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
    
            var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
            var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
            var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
            var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
    
            te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    
            te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    
            te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    
            te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    
            return this;
    
        },
    
        multiplyScalar: function ( s ) {
    
            var te = this.elements;
    
            te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
            te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
            te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
            te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
    
            return this;
    
        },
    
        determinant: function () {
    
            var te = this.elements;
    
            var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
            var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
            var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
            var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
    
            //TODO: make this more efficient
            //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
    
            return (
                n41 * (
                    + n14 * n23 * n32
                     - n13 * n24 * n32
                     - n14 * n22 * n33
                     + n12 * n24 * n33
                     + n13 * n22 * n34
                     - n12 * n23 * n34
                ) +
                n42 * (
                    + n11 * n23 * n34
                     - n11 * n24 * n33
                     + n14 * n21 * n33
                     - n13 * n21 * n34
                     + n13 * n24 * n31
                     - n14 * n23 * n31
                ) +
                n43 * (
                    + n11 * n24 * n32
                     - n11 * n22 * n34
                     - n14 * n21 * n32
                     + n12 * n21 * n34
                     + n14 * n22 * n31
                     - n12 * n24 * n31
                ) +
                n44 * (
                    - n13 * n22 * n31
                     - n11 * n23 * n32
                     + n11 * n22 * n33
                     + n13 * n21 * n32
                     - n12 * n21 * n33
                     + n12 * n23 * n31
                )
    
            );
    
        },
    
        transpose: function () {
    
            var te = this.elements;
            var tmp;
    
            tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
            tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
            tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
    
            tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
            tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
            tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
    
            return this;
    
        },
    
        setPosition: function ( x, y, z ) {
    
            var te = this.elements;
    
            if ( x.isVector3 ) {
    
                te[ 12 ] = x.x;
                te[ 13 ] = x.y;
                te[ 14 ] = x.z;
    
            } else {
    
                te[ 12 ] = x;
                te[ 13 ] = y;
                te[ 14 ] = z;
    
            }
    
            return this;
    
        },
    
        getInverse: function ( m, throwOnDegenerate ) {
    
            // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
            var te = this.elements,
                me = m.elements,
    
                n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
                n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
                n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
                n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],
    
                t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
                t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
                t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
                t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    
            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    
            if ( det === 0 ) {
    
                var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
    
                if ( throwOnDegenerate === true ) {
    
                    throw new Error( msg );
    
                } else {
    
                    console.warn( msg );
    
                }
    
                return this.identity();
    
            }
    
            var detInv = 1 / det;
    
            te[ 0 ] = t11 * detInv;
            te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
            te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
            te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;
    
            te[ 4 ] = t12 * detInv;
            te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
            te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
            te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;
    
            te[ 8 ] = t13 * detInv;
            te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
            te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
            te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;
    
            te[ 12 ] = t14 * detInv;
            te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
            te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
            te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;
    
            return this;
    
        },
    
        scale: function ( v ) {
    
            var te = this.elements;
            var x = v.x, y = v.y, z = v.z;
    
            te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
            te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
            te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
            te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
    
            return this;
    
        },
    
        getMaxScaleOnAxis: function () {
    
            var te = this.elements;
    
            var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
            var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
            var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
    
            return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
    
        },
    
        makeTranslation: function ( x, y, z ) {
    
            this.set(
    
                1, 0, 0, x,
                0, 1, 0, y,
                0, 0, 1, z,
                0, 0, 0, 1
    
            );
    
            return this;
    
        },
    
        makeRotationX: function ( theta ) {
    
            var c = Math.cos( theta ), s = Math.sin( theta );
    
            this.set(
    
                1, 0, 0, 0,
                0, c, - s, 0,
                0, s, c, 0,
                0, 0, 0, 1
    
            );
    
            return this;
    
        },
    
        makeRotationY: function ( theta ) {
    
            var c = Math.cos( theta ), s = Math.sin( theta );
    
            this.set(
    
                 c, 0, s, 0,
                 0, 1, 0, 0,
                - s, 0, c, 0,
                 0, 0, 0, 1
    
            );
    
            return this;
    
        },
    
        makeRotationZ: function ( theta ) {
    
            var c = Math.cos( theta ), s = Math.sin( theta );
    
            this.set(
    
                c, - s, 0, 0,
                s, c, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
    
            );
    
            return this;
    
        },
    
        makeRotationAxis: function ( axis, angle ) {
    
            // Based on http://www.gamedev.net/reference/articles/article1199.asp
    
            var c = Math.cos( angle );
            var s = Math.sin( angle );
            var t = 1 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;
    
            this.set(
    
                tx * x + c, tx * y - s * z, tx * z + s * y, 0,
                tx * y + s * z, ty * y + c, ty * z - s * x, 0,
                tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
                0, 0, 0, 1
    
            );
    
             return this;
    
        },
    
        makeScale: function ( x, y, z ) {
    
            this.set(
    
                x, 0, 0, 0,
                0, y, 0, 0,
                0, 0, z, 0,
                0, 0, 0, 1
    
            );
    
            return this;
    
        },
    
        makeShear: function ( x, y, z ) {
    
            this.set(
    
                1, y, z, 0,
                x, 1, z, 0,
                x, y, 1, 0,
                0, 0, 0, 1
    
            );
    
            return this;
    
        },
    
        compose: function ( position, quaternion, scale ) {
    
            var te = this.elements;
    
            var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
            var x2 = x + x,	y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2;
            var yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;
    
            var sx = scale.x, sy = scale.y, sz = scale.z;
    
            te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
            te[ 1 ] = ( xy + wz ) * sx;
            te[ 2 ] = ( xz - wy ) * sx;
            te[ 3 ] = 0;
    
            te[ 4 ] = ( xy - wz ) * sy;
            te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
            te[ 6 ] = ( yz + wx ) * sy;
            te[ 7 ] = 0;
    
            te[ 8 ] = ( xz + wy ) * sz;
            te[ 9 ] = ( yz - wx ) * sz;
            te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
            te[ 11 ] = 0;
    
            te[ 12 ] = position.x;
            te[ 13 ] = position.y;
            te[ 14 ] = position.z;
            te[ 15 ] = 1;
    
            return this;
    
        },
    
        decompose: function ( position, quaternion, scale ) {
    
            var te = this.elements;
    
            var sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
            var sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
            var sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
    
            // if determine is negative, we need to invert one scale
            var det = this.determinant();
            if ( det < 0 ) sx = - sx;
    
            position.x = te[ 12 ];
            position.y = te[ 13 ];
            position.z = te[ 14 ];
    
            // scale the rotation part
            _m1.copy( this );
    
            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;
    
            _m1.elements[ 0 ] *= invSX;
            _m1.elements[ 1 ] *= invSX;
            _m1.elements[ 2 ] *= invSX;
    
            _m1.elements[ 4 ] *= invSY;
            _m1.elements[ 5 ] *= invSY;
            _m1.elements[ 6 ] *= invSY;
    
            _m1.elements[ 8 ] *= invSZ;
            _m1.elements[ 9 ] *= invSZ;
            _m1.elements[ 10 ] *= invSZ;
    
            quaternion.setFromRotationMatrix( _m1 );
    
            scale.x = sx;
            scale.y = sy;
            scale.z = sz;
    
            return this;
    
        },
    
        makePerspective: function ( left, right, top, bottom, near, far ) {
    
            if ( far === undefined ) {
    
                console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );
    
            }
    
            var te = this.elements;
            var x = 2 * near / ( right - left );
            var y = 2 * near / ( top - bottom );
    
            var a = ( right + left ) / ( right - left );
            var b = ( top + bottom ) / ( top - bottom );
            var c = - ( far + near ) / ( far - near );
            var d = - 2 * far * near / ( far - near );
    
            te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
            te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
            te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
            te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
    
            return this;
    
        },
    
        makeOrthographic: function ( left, right, top, bottom, near, far ) {
    
            var te = this.elements;
            var w = 1.0 / ( right - left );
            var h = 1.0 / ( top - bottom );
            var p = 1.0 / ( far - near );
    
            var x = ( right + left ) * w;
            var y = ( top + bottom ) * h;
            var z = ( far + near ) * p;
    
            te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
            te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
            te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
            te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
    
            return this;
    
        },
    
        equals: function ( matrix ) {
    
            var te = this.elements;
            var me = matrix.elements;
    
            for ( var i = 0; i < 16; i ++ ) {
    
                if ( te[ i ] !== me[ i ] ) return false;
    
            }
    
            return true;
    
        },
    
        fromArray: function ( array, offset ) {
    
            if ( offset === undefined ) offset = 0;
    
            for ( var i = 0; i < 16; i ++ ) {
    
                this.elements[ i ] = array[ i + offset ];
    
            }
    
            return this;
    
        },
    
        toArray: function ( array, offset ) {
    
            if ( array === undefined ) array = [];
            if ( offset === undefined ) offset = 0;
    
            var te = this.elements;
    
            array[ offset ] = te[ 0 ];
            array[ offset + 1 ] = te[ 1 ];
            array[ offset + 2 ] = te[ 2 ];
            array[ offset + 3 ] = te[ 3 ];
    
            array[ offset + 4 ] = te[ 4 ];
            array[ offset + 5 ] = te[ 5 ];
            array[ offset + 6 ] = te[ 6 ];
            array[ offset + 7 ] = te[ 7 ];
    
            array[ offset + 8 ] = te[ 8 ];
            array[ offset + 9 ] = te[ 9 ];
            array[ offset + 10 ] = te[ 10 ];
            array[ offset + 11 ] = te[ 11 ];
    
            array[ offset + 12 ] = te[ 12 ];
            array[ offset + 13 ] = te[ 13 ];
            array[ offset + 14 ] = te[ 14 ];
            array[ offset + 15 ] = te[ 15 ];
    
            return array;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */
    
    var _matrix = new Matrix4();
    var _quaternion$1 = new Quaternion();
    
    function Euler( x, y, z, order ) {
    
        this._x = x || 0;
        this._y = y || 0;
        this._z = z || 0;
        this._order = order || Euler.DefaultOrder;
    
    }
    
    Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
    
    Euler.DefaultOrder = 'XYZ';
    
    Object.defineProperties( Euler.prototype, {
    
        x: {
    
            get: function () {
    
                return this._x;
    
            },
    
            set: function ( value ) {
    
                this._x = value;
                this._onChangeCallback();
    
            }
    
        },
    
        y: {
    
            get: function () {
    
                return this._y;
    
            },
    
            set: function ( value ) {
    
                this._y = value;
                this._onChangeCallback();
    
            }
    
        },
    
        z: {
    
            get: function () {
    
                return this._z;
    
            },
    
            set: function ( value ) {
    
                this._z = value;
                this._onChangeCallback();
    
            }
    
        },
    
        order: {
    
            get: function () {
    
                return this._order;
    
            },
    
            set: function ( value ) {
    
                this._order = value;
                this._onChangeCallback();
    
            }
    
        }
    
    } );
    
    Object.assign( Euler.prototype, {
    
        isEuler: true,
    
        set: function ( x, y, z, order ) {
    
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order || this._order;
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor( this._x, this._y, this._z, this._order );
    
        },
    
        copy: function ( euler ) {
    
            this._x = euler._x;
            this._y = euler._y;
            this._z = euler._z;
            this._order = euler._order;
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        setFromRotationMatrix: function ( m, order, update ) {
    
            var clamp = MathUtils.clamp;
    
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    
            var te = m.elements;
            var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
            var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
            var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
    
            order = order || this._order;
    
            if ( order === 'XYZ' ) {
    
                this._y = Math.asin( clamp( m13, - 1, 1 ) );
    
                if ( Math.abs( m13 ) < 0.9999999 ) {
    
                    this._x = Math.atan2( - m23, m33 );
                    this._z = Math.atan2( - m12, m11 );
    
                } else {
    
                    this._x = Math.atan2( m32, m22 );
                    this._z = 0;
    
                }
    
            } else if ( order === 'YXZ' ) {
    
                this._x = Math.asin( - clamp( m23, - 1, 1 ) );
    
                if ( Math.abs( m23 ) < 0.9999999 ) {
    
                    this._y = Math.atan2( m13, m33 );
                    this._z = Math.atan2( m21, m22 );
    
                } else {
    
                    this._y = Math.atan2( - m31, m11 );
                    this._z = 0;
    
                }
    
            } else if ( order === 'ZXY' ) {
    
                this._x = Math.asin( clamp( m32, - 1, 1 ) );
    
                if ( Math.abs( m32 ) < 0.9999999 ) {
    
                    this._y = Math.atan2( - m31, m33 );
                    this._z = Math.atan2( - m12, m22 );
    
                } else {
    
                    this._y = 0;
                    this._z = Math.atan2( m21, m11 );
    
                }
    
            } else if ( order === 'ZYX' ) {
    
                this._y = Math.asin( - clamp( m31, - 1, 1 ) );
    
                if ( Math.abs( m31 ) < 0.9999999 ) {
    
                    this._x = Math.atan2( m32, m33 );
                    this._z = Math.atan2( m21, m11 );
    
                } else {
    
                    this._x = 0;
                    this._z = Math.atan2( - m12, m22 );
    
                }
    
            } else if ( order === 'YZX' ) {
    
                this._z = Math.asin( clamp( m21, - 1, 1 ) );
    
                if ( Math.abs( m21 ) < 0.9999999 ) {
    
                    this._x = Math.atan2( - m23, m22 );
                    this._y = Math.atan2( - m31, m11 );
    
                } else {
    
                    this._x = 0;
                    this._y = Math.atan2( m13, m33 );
    
                }
    
            } else if ( order === 'XZY' ) {
    
                this._z = Math.asin( - clamp( m12, - 1, 1 ) );
    
                if ( Math.abs( m12 ) < 0.9999999 ) {
    
                    this._x = Math.atan2( m32, m22 );
                    this._y = Math.atan2( m13, m11 );
    
                } else {
    
                    this._x = Math.atan2( - m23, m33 );
                    this._y = 0;
    
                }
    
            } else {
    
                console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );
    
            }
    
            this._order = order;
    
            if ( update !== false ) this._onChangeCallback();
    
            return this;
    
        },
    
        setFromQuaternion: function ( q, order, update ) {
    
            _matrix.makeRotationFromQuaternion( q );
    
            return this.setFromRotationMatrix( _matrix, order, update );
    
        },
    
        setFromVector3: function ( v, order ) {
    
            return this.set( v.x, v.y, v.z, order || this._order );
    
        },
    
        reorder: function ( newOrder ) {
    
            // WARNING: this discards revolution information -bhouston
    
            _quaternion$1.setFromEuler( this );
    
            return this.setFromQuaternion( _quaternion$1, newOrder );
    
        },
    
        equals: function ( euler ) {
    
            return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
    
        },
    
        fromArray: function ( array ) {
    
            this._x = array[ 0 ];
            this._y = array[ 1 ];
            this._z = array[ 2 ];
            if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
    
            this._onChangeCallback();
    
            return this;
    
        },
    
        toArray: function ( array, offset ) {
    
            if ( array === undefined ) array = [];
            if ( offset === undefined ) offset = 0;
    
            array[ offset ] = this._x;
            array[ offset + 1 ] = this._y;
            array[ offset + 2 ] = this._z;
            array[ offset + 3 ] = this._order;
    
            return array;
    
        },
    
        toVector3: function ( optionalResult ) {
    
            if ( optionalResult ) {
    
                return optionalResult.set( this._x, this._y, this._z );
    
            } else {
    
                return new Vector3( this._x, this._y, this._z );
    
            }
    
        },
    
        _onChange: function ( callback ) {
    
            this._onChangeCallback = callback;
    
            return this;
    
        },
    
        _onChangeCallback: function () {}
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function Layers() {
    
        this.mask = 1 | 0;
    
    }
    
    Object.assign( Layers.prototype, {
    
        set: function ( channel ) {
    
            this.mask = 1 << channel | 0;
    
        },
    
        enable: function ( channel ) {
    
            this.mask |= 1 << channel | 0;
    
        },
    
        enableAll: function () {
    
            this.mask = 0xffffffff | 0;
    
        },
    
        toggle: function ( channel ) {
    
            this.mask ^= 1 << channel | 0;
    
        },
    
        disable: function ( channel ) {
    
            this.mask &= ~ ( 1 << channel | 0 );
    
        },
    
        disableAll: function () {
    
            this.mask = 0;
    
        },
    
        test: function ( layers ) {
    
            return ( this.mask & layers.mask ) !== 0;
    
        }
    
    } );
    
    var _object3DId = 0;
    
    var _v1$1 = new Vector3();
    var _q1 = new Quaternion();
    var _m1$1 = new Matrix4();
    var _target = new Vector3();
    
    var _position = new Vector3();
    var _scale = new Vector3();
    var _quaternion$2 = new Quaternion();
    
    var _xAxis = new Vector3( 1, 0, 0 );
    var _yAxis = new Vector3( 0, 1, 0 );
    var _zAxis = new Vector3( 0, 0, 1 );
    
    var _addedEvent = { type: 'added' };
    var _removedEvent = { type: 'removed' };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author elephantatwork / www.elephantatwork.ch
     */
    
    function Object3D() {
    
        Object.defineProperty( this, 'id', { value: _object3DId ++ } );
    
        this.uuid = MathUtils.generateUUID();
    
        this.name = '';
        this.type = 'Object3D';
    
        this.parent = null;
        this.children = [];
    
        this.up = Object3D.DefaultUp.clone();
    
        var position = new Vector3();
        var rotation = new Euler();
        var quaternion = new Quaternion();
        var scale = new Vector3( 1, 1, 1 );
    
        function onRotationChange() {
    
            quaternion.setFromEuler( rotation, false );
    
        }
    
        function onQuaternionChange() {
    
            rotation.setFromQuaternion( quaternion, undefined, false );
    
        }
    
        rotation._onChange( onRotationChange );
        quaternion._onChange( onQuaternionChange );
    
        Object.defineProperties( this, {
            position: {
                configurable: true,
                enumerable: true,
                value: position
            },
            rotation: {
                configurable: true,
                enumerable: true,
                value: rotation
            },
            quaternion: {
                configurable: true,
                enumerable: true,
                value: quaternion
            },
            scale: {
                configurable: true,
                enumerable: true,
                value: scale
            },
            modelViewMatrix: {
                value: new Matrix4()
            },
            normalMatrix: {
                value: new Matrix3()
            }
        } );
    
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
    
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
    
        this.layers = new Layers();
        this.visible = true;
    
        this.castShadow = false;
        this.receiveShadow = false;
    
        this.frustumCulled = true;
        this.renderOrder = 0;
    
        this.userData = {};
    
    }
    
    Object3D.DefaultUp = new Vector3( 0, 1, 0 );
    Object3D.DefaultMatrixAutoUpdate = true;
    
    Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
    
        constructor: Object3D,
    
        isObject3D: true,
    
        onBeforeRender: function () {},
        onAfterRender: function () {},
    
        applyMatrix4: function ( matrix ) {
    
            if ( this.matrixAutoUpdate ) this.updateMatrix();
    
            this.matrix.premultiply( matrix );
    
            this.matrix.decompose( this.position, this.quaternion, this.scale );
    
        },
    
        applyQuaternion: function ( q ) {
    
            this.quaternion.premultiply( q );
    
            return this;
    
        },
    
        setRotationFromAxisAngle: function ( axis, angle ) {
    
            // assumes axis is normalized
    
            this.quaternion.setFromAxisAngle( axis, angle );
    
        },
    
        setRotationFromEuler: function ( euler ) {
    
            this.quaternion.setFromEuler( euler, true );
    
        },
    
        setRotationFromMatrix: function ( m ) {
    
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
    
            this.quaternion.setFromRotationMatrix( m );
    
        },
    
        setRotationFromQuaternion: function ( q ) {
    
            // assumes q is normalized
    
            this.quaternion.copy( q );
    
        },
    
        rotateOnAxis: function ( axis, angle ) {
    
            // rotate object on axis in object space
            // axis is assumed to be normalized
    
            _q1.setFromAxisAngle( axis, angle );
    
            this.quaternion.multiply( _q1 );
    
            return this;
    
        },
    
        rotateOnWorldAxis: function ( axis, angle ) {
    
            // rotate object on axis in world space
            // axis is assumed to be normalized
            // method assumes no rotated parent
    
            _q1.setFromAxisAngle( axis, angle );
    
            this.quaternion.premultiply( _q1 );
    
            return this;
    
        },
    
        rotateX: function ( angle ) {
    
            return this.rotateOnAxis( _xAxis, angle );
    
        },
    
        rotateY: function ( angle ) {
    
            return this.rotateOnAxis( _yAxis, angle );
    
        },
    
        rotateZ: function ( angle ) {
    
            return this.rotateOnAxis( _zAxis, angle );
    
        },
    
        translateOnAxis: function ( axis, distance ) {
    
            // translate object by distance along axis in object space
            // axis is assumed to be normalized
    
            _v1$1.copy( axis ).applyQuaternion( this.quaternion );
    
            this.position.add( _v1$1.multiplyScalar( distance ) );
    
            return this;
    
        },
    
        translateX: function ( distance ) {
    
            return this.translateOnAxis( _xAxis, distance );
    
        },
    
        translateY: function ( distance ) {
    
            return this.translateOnAxis( _yAxis, distance );
    
        },
    
        translateZ: function ( distance ) {
    
            return this.translateOnAxis( _zAxis, distance );
    
        },
    
        localToWorld: function ( vector ) {
    
            return vector.applyMatrix4( this.matrixWorld );
    
        },
    
        worldToLocal: function ( vector ) {
    
            return vector.applyMatrix4( _m1$1.getInverse( this.matrixWorld ) );
    
        },
    
        lookAt: function ( x, y, z ) {
    
            // This method does not support objects having non-uniformly-scaled parent(s)
    
            if ( x.isVector3 ) {
    
                _target.copy( x );
    
            } else {
    
                _target.set( x, y, z );
    
            }
    
            var parent = this.parent;
    
            this.updateWorldMatrix( true, false );
    
            _position.setFromMatrixPosition( this.matrixWorld );
    
            if ( this.isCamera || this.isLight ) {
    
                _m1$1.lookAt( _position, _target, this.up );
    
            } else {
    
                _m1$1.lookAt( _target, _position, this.up );
    
            }
    
            this.quaternion.setFromRotationMatrix( _m1$1 );
    
            if ( parent ) {
    
                _m1$1.extractRotation( parent.matrixWorld );
                _q1.setFromRotationMatrix( _m1$1 );
                this.quaternion.premultiply( _q1.inverse() );
    
            }
    
        },
    
        add: function ( object ) {
    
            if ( arguments.length > 1 ) {
    
                for ( var i = 0; i < arguments.length; i ++ ) {
    
                    this.add( arguments[ i ] );
    
                }
    
                return this;
    
            }
    
            if ( object === this ) {
    
                console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
                return this;
    
            }
    
            if ( ( object && object.isObject3D ) ) {
    
                if ( object.parent !== null ) {
    
                    object.parent.remove( object );
    
                }
    
                object.parent = this;
                this.children.push( object );
    
                object.dispatchEvent( _addedEvent );
    
            } else {
    
                console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
    
            }
    
            return this;
    
        },
    
        remove: function ( object ) {
    
            if ( arguments.length > 1 ) {
    
                for ( var i = 0; i < arguments.length; i ++ ) {
    
                    this.remove( arguments[ i ] );
    
                }
    
                return this;
    
            }
    
            var index = this.children.indexOf( object );
    
            if ( index !== - 1 ) {
    
                object.parent = null;
                this.children.splice( index, 1 );
    
                object.dispatchEvent( _removedEvent );
    
            }
    
            return this;
    
        },
    
        attach: function ( object ) {
    
            // adds object as a child of this, while maintaining the object's world transform
    
            this.updateWorldMatrix( true, false );
    
            _m1$1.getInverse( this.matrixWorld );
    
            if ( object.parent !== null ) {
    
                object.parent.updateWorldMatrix( true, false );
    
                _m1$1.multiply( object.parent.matrixWorld );
    
            }
    
            object.applyMatrix4( _m1$1 );
    
            object.updateWorldMatrix( false, false );
    
            this.add( object );
    
            return this;
    
        },
    
        getObjectById: function ( id ) {
    
            return this.getObjectByProperty( 'id', id );
    
        },
    
        getObjectByName: function ( name ) {
    
            return this.getObjectByProperty( 'name', name );
    
        },
    
        getObjectByProperty: function ( name, value ) {
    
            if ( this[ name ] === value ) return this;
    
            for ( var i = 0, l = this.children.length; i < l; i ++ ) {
    
                var child = this.children[ i ];
                var object = child.getObjectByProperty( name, value );
    
                if ( object !== undefined ) {
    
                    return object;
    
                }
    
            }
    
            return undefined;
    
        },
    
        getWorldPosition: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
                target = new Vector3();
    
            }
    
            this.updateMatrixWorld( true );
    
            return target.setFromMatrixPosition( this.matrixWorld );
    
        },
    
        getWorldQuaternion: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
                target = new Quaternion();
    
            }
    
            this.updateMatrixWorld( true );
    
            this.matrixWorld.decompose( _position, target, _scale );
    
            return target;
    
        },
    
        getWorldScale: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
                target = new Vector3();
    
            }
    
            this.updateMatrixWorld( true );
    
            this.matrixWorld.decompose( _position, _quaternion$2, target );
    
            return target;
    
        },
    
        getWorldDirection: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
                target = new Vector3();
    
            }
    
            this.updateMatrixWorld( true );
    
            var e = this.matrixWorld.elements;
    
            return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();
    
        },
    
        raycast: function () {},
    
        traverse: function ( callback ) {
    
            callback( this );
    
            var children = this.children;
    
            for ( var i = 0, l = children.length; i < l; i ++ ) {
    
                children[ i ].traverse( callback );
    
            }
    
        },
    
        traverseVisible: function ( callback ) {
    
            if ( this.visible === false ) return;
    
            callback( this );
    
            var children = this.children;
    
            for ( var i = 0, l = children.length; i < l; i ++ ) {
    
                children[ i ].traverseVisible( callback );
    
            }
    
        },
    
        traverseAncestors: function ( callback ) {
    
            var parent = this.parent;
    
            if ( parent !== null ) {
    
                callback( parent );
    
                parent.traverseAncestors( callback );
    
            }
    
        },
    
        updateMatrix: function () {
    
            this.matrix.compose( this.position, this.quaternion, this.scale );
    
            this.matrixWorldNeedsUpdate = true;
    
        },
    
        updateMatrixWorld: function ( force ) {
    
            if ( this.matrixAutoUpdate ) this.updateMatrix();
    
            if ( this.matrixWorldNeedsUpdate || force ) {
    
                if ( this.parent === null ) {
    
                    this.matrixWorld.copy( this.matrix );
    
                } else {
    
                    this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
    
                }
    
                this.matrixWorldNeedsUpdate = false;
    
                force = true;
    
            }
    
            // update children
    
            var children = this.children;
    
            for ( var i = 0, l = children.length; i < l; i ++ ) {
    
                children[ i ].updateMatrixWorld( force );
    
            }
    
        },
    
        updateWorldMatrix: function ( updateParents, updateChildren ) {
    
            var parent = this.parent;
    
            if ( updateParents === true && parent !== null ) {
    
                parent.updateWorldMatrix( true, false );
    
            }
    
            if ( this.matrixAutoUpdate ) this.updateMatrix();
    
            if ( this.parent === null ) {
    
                this.matrixWorld.copy( this.matrix );
    
            } else {
    
                this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
    
            }
    
            // update children
    
            if ( updateChildren === true ) {
    
                var children = this.children;
    
                for ( var i = 0, l = children.length; i < l; i ++ ) {
    
                    children[ i ].updateWorldMatrix( false, true );
    
                }
    
            }
    
        },
    
        toJSON: function ( meta ) {
    
            // meta is a string when called from JSON.stringify
            var isRootObject = ( meta === undefined || typeof meta === 'string' );
    
            var output = {};
    
            // meta is a hash used to collect geometries, materials.
            // not providing it implies that this is the root object
            // being serialized.
            if ( isRootObject ) {
    
                // initialize meta obj
                meta = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                };
    
                output.metadata = {
                    version: 4.5,
                    type: 'Object',
                    generator: 'Object3D.toJSON'
                };
    
            }
    
            // standard Object3D serialization
    
            var object = {};
    
            object.uuid = this.uuid;
            object.type = this.type;
    
            if ( this.name !== '' ) object.name = this.name;
            if ( this.castShadow === true ) object.castShadow = true;
            if ( this.receiveShadow === true ) object.receiveShadow = true;
            if ( this.visible === false ) object.visible = false;
            if ( this.frustumCulled === false ) object.frustumCulled = false;
            if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
            if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
    
            object.layers = this.layers.mask;
            object.matrix = this.matrix.toArray();
    
            if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;
    
            // object specific properties
    
            if ( this.isInstancedMesh ) {
    
                object.type = 'InstancedMesh';
                object.count = this.count;
                object.instanceMatrix = this.instanceMatrix.toJSON();
    
            }
    
            //
    
            function serialize( library, element ) {
    
                if ( library[ element.uuid ] === undefined ) {
    
                    library[ element.uuid ] = element.toJSON( meta );
    
                }
    
                return element.uuid;
    
            }
    
            if ( this.isMesh || this.isLine || this.isPoints ) {
    
                object.geometry = serialize( meta.geometries, this.geometry );
    
                var parameters = this.geometry.parameters;
    
                if ( parameters !== undefined && parameters.shapes !== undefined ) {
    
                    var shapes = parameters.shapes;
    
                    if ( Array.isArray( shapes ) ) {
    
                        for ( var i = 0, l = shapes.length; i < l; i ++ ) {
    
                            var shape = shapes[ i ];
    
                            serialize( meta.shapes, shape );
    
                        }
    
                    } else {
    
                        serialize( meta.shapes, shapes );
    
                    }
    
                }
    
            }
    
            if ( this.material !== undefined ) {
    
                if ( Array.isArray( this.material ) ) {
    
                    var uuids = [];
    
                    for ( var i = 0, l = this.material.length; i < l; i ++ ) {
    
                        uuids.push( serialize( meta.materials, this.material[ i ] ) );
    
                    }
    
                    object.material = uuids;
    
                } else {
    
                    object.material = serialize( meta.materials, this.material );
    
                }
    
            }
    
            //
    
            if ( this.children.length > 0 ) {
    
                object.children = [];
    
                for ( var i = 0; i < this.children.length; i ++ ) {
    
                    object.children.push( this.children[ i ].toJSON( meta ).object );
    
                }
    
            }
    
            if ( isRootObject ) {
    
                var geometries = extractFromCache( meta.geometries );
                var materials = extractFromCache( meta.materials );
                var textures = extractFromCache( meta.textures );
                var images = extractFromCache( meta.images );
                var shapes = extractFromCache( meta.shapes );
    
                if ( geometries.length > 0 ) output.geometries = geometries;
                if ( materials.length > 0 ) output.materials = materials;
                if ( textures.length > 0 ) output.textures = textures;
                if ( images.length > 0 ) output.images = images;
                if ( shapes.length > 0 ) output.shapes = shapes;
    
            }
    
            output.object = object;
    
            return output;
    
            // extract data from the cache hash
            // remove metadata on each item
            // and return as array
            function extractFromCache( cache ) {
    
                var values = [];
                for ( var key in cache ) {
    
                    var data = cache[ key ];
                    delete data.metadata;
                    values.push( data );
    
                }
                return values;
    
            }
    
        },
    
        clone: function ( recursive ) {
    
            return new this.constructor().copy( this, recursive );
    
        },
    
        copy: function ( source, recursive ) {
    
            if ( recursive === undefined ) recursive = true;
    
            this.name = source.name;
    
            this.up.copy( source.up );
    
            this.position.copy( source.position );
            this.quaternion.copy( source.quaternion );
            this.scale.copy( source.scale );
    
            this.matrix.copy( source.matrix );
            this.matrixWorld.copy( source.matrixWorld );
    
            this.matrixAutoUpdate = source.matrixAutoUpdate;
            this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    
            this.layers.mask = source.layers.mask;
            this.visible = source.visible;
    
            this.castShadow = source.castShadow;
            this.receiveShadow = source.receiveShadow;
    
            this.frustumCulled = source.frustumCulled;
            this.renderOrder = source.renderOrder;
    
            this.userData = JSON.parse( JSON.stringify( source.userData ) );
    
            if ( recursive === true ) {
    
                for ( var i = 0; i < source.children.length; i ++ ) {
    
                    var child = source.children[ i ];
                    this.add( child.clone() );
    
                }
    
            }
    
            return this;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function Scene() {
    
        Object3D.call( this );
    
        this.type = 'Scene';
    
        this.background = null;
        this.environment = null;
        this.fog = null;
    
        this.overrideMaterial = null;
    
        this.autoUpdate = true; // checked by the renderer
    
        if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {
    
            __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef
    
        }
    
    }
    
    Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: Scene,
    
        isScene: true,
    
        copy: function ( source, recursive ) {
    
            Object3D.prototype.copy.call( this, source, recursive );
    
            if ( source.background !== null ) this.background = source.background.clone();
            if ( source.environment !== null ) this.environment = source.environment.clone();
            if ( source.fog !== null ) this.fog = source.fog.clone();
    
            if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
    
            this.autoUpdate = source.autoUpdate;
            this.matrixAutoUpdate = source.matrixAutoUpdate;
    
            return this;
    
        },
    
        toJSON: function ( meta ) {
    
            var data = Object3D.prototype.toJSON.call( this, meta );
    
            if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
            if ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );
            if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
    
            return data;
    
        },
    
        dispose: function () {
    
            this.dispatchEvent( { type: 'dispose' } );
    
        }
    
    } );
    
    var _points = [
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3()
    ];
    
    var _vector$1 = new Vector3();
    
    var _box = new Box3();
    
    // triangle centered vertices
    
    var _v0 = new Vector3();
    var _v1$2 = new Vector3();
    var _v2 = new Vector3();
    
    // triangle edge vectors
    
    var _f0 = new Vector3();
    var _f1 = new Vector3();
    var _f2 = new Vector3();
    
    var _center = new Vector3();
    var _extents = new Vector3();
    var _triangleNormal = new Vector3();
    var _testAxis = new Vector3();
    
    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */
    
    function Box3( min, max ) {
    
        this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
        this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );
    
    }
    
    
    Object.assign( Box3.prototype, {
    
        isBox3: true,
    
        set: function ( min, max ) {
    
            this.min.copy( min );
            this.max.copy( max );
    
            return this;
    
        },
    
        setFromArray: function ( array ) {
    
            var minX = + Infinity;
            var minY = + Infinity;
            var minZ = + Infinity;
    
            var maxX = - Infinity;
            var maxY = - Infinity;
            var maxZ = - Infinity;
    
            for ( var i = 0, l = array.length; i < l; i += 3 ) {
    
                var x = array[ i ];
                var y = array[ i + 1 ];
                var z = array[ i + 2 ];
    
                if ( x < minX ) minX = x;
                if ( y < minY ) minY = y;
                if ( z < minZ ) minZ = z;
    
                if ( x > maxX ) maxX = x;
                if ( y > maxY ) maxY = y;
                if ( z > maxZ ) maxZ = z;
    
            }
    
            this.min.set( minX, minY, minZ );
            this.max.set( maxX, maxY, maxZ );
    
            return this;
    
        },
    
        setFromBufferAttribute: function ( attribute ) {
    
            var minX = + Infinity;
            var minY = + Infinity;
            var minZ = + Infinity;
    
            var maxX = - Infinity;
            var maxY = - Infinity;
            var maxZ = - Infinity;
    
            for ( var i = 0, l = attribute.count; i < l; i ++ ) {
    
                var x = attribute.getX( i );
                var y = attribute.getY( i );
                var z = attribute.getZ( i );
    
                if ( x < minX ) minX = x;
                if ( y < minY ) minY = y;
                if ( z < minZ ) minZ = z;
    
                if ( x > maxX ) maxX = x;
                if ( y > maxY ) maxY = y;
                if ( z > maxZ ) maxZ = z;
    
            }
    
            this.min.set( minX, minY, minZ );
            this.max.set( maxX, maxY, maxZ );
    
            return this;
    
        },
    
        setFromPoints: function ( points ) {
    
            this.makeEmpty();
    
            for ( var i = 0, il = points.length; i < il; i ++ ) {
    
                this.expandByPoint( points[ i ] );
    
            }
    
            return this;
    
        },
    
        setFromCenterAndSize: function ( center, size ) {
    
            var halfSize = _vector$1.copy( size ).multiplyScalar( 0.5 );
    
            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );
    
            return this;
    
        },
    
        setFromObject: function ( object ) {
    
            this.makeEmpty();
    
            return this.expandByObject( object );
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( box ) {
    
            this.min.copy( box.min );
            this.max.copy( box.max );
    
            return this;
    
        },
    
        makeEmpty: function () {
    
            this.min.x = this.min.y = this.min.z = + Infinity;
            this.max.x = this.max.y = this.max.z = - Infinity;
    
            return this;
    
        },
    
        isEmpty: function () {
    
            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    
            return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
    
        },
    
        getCenter: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Box3: .getCenter() target is now required' );
                target = new Vector3();
    
            }
    
            return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
    
        },
    
        getSize: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Box3: .getSize() target is now required' );
                target = new Vector3();
    
            }
    
            return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );
    
        },
    
        expandByPoint: function ( point ) {
    
            this.min.min( point );
            this.max.max( point );
    
            return this;
    
        },
    
        expandByVector: function ( vector ) {
    
            this.min.sub( vector );
            this.max.add( vector );
    
            return this;
    
        },
    
        expandByScalar: function ( scalar ) {
    
            this.min.addScalar( - scalar );
            this.max.addScalar( scalar );
    
            return this;
    
        },
    
        expandByObject: function ( object ) {
    
            // Computes the world-axis-aligned bounding box of an object (including its children),
            // accounting for both the object's, and children's, world transforms
    
            object.updateWorldMatrix( false, false );
    
            var geometry = object.geometry;
    
            if ( geometry !== undefined ) {
    
                if ( geometry.boundingBox === null ) {
    
                    geometry.computeBoundingBox();
    
                }
    
                _box.copy( geometry.boundingBox );
                _box.applyMatrix4( object.matrixWorld );
    
                this.union( _box );
    
            }
    
            var children = object.children;
    
            for ( var i = 0, l = children.length; i < l; i ++ ) {
    
                this.expandByObject( children[ i ] );
    
            }
    
            return this;
    
        },
    
        containsPoint: function ( point ) {
    
            return point.x < this.min.x || point.x > this.max.x ||
                point.y < this.min.y || point.y > this.max.y ||
                point.z < this.min.z || point.z > this.max.z ? false : true;
    
        },
    
        containsBox: function ( box ) {
    
            return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                this.min.y <= box.min.y && box.max.y <= this.max.y &&
                this.min.z <= box.min.z && box.max.z <= this.max.z;
    
        },
    
        getParameter: function ( point, target ) {
    
            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Box3: .getParameter() target is now required' );
                target = new Vector3();
    
            }
    
            return target.set(
                ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
                ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
                ( point.z - this.min.z ) / ( this.max.z - this.min.z )
            );
    
        },
    
        intersectsBox: function ( box ) {
    
            // using 6 splitting planes to rule out intersections.
            return box.max.x < this.min.x || box.min.x > this.max.x ||
                box.max.y < this.min.y || box.min.y > this.max.y ||
                box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    
        },
    
        intersectsSphere: function ( sphere ) {
    
            // Find the point on the AABB closest to the sphere center.
            this.clampPoint( sphere.center, _vector$1 );
    
            // If that point is inside the sphere, the AABB and sphere intersect.
            return _vector$1.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );
    
        },
    
        intersectsPlane: function ( plane ) {
    
            // We compute the minimum and maximum dot product values. If those values
            // are on the same side (back or front) of the plane, then there is no intersection.
    
            var min, max;
    
            if ( plane.normal.x > 0 ) {
    
                min = plane.normal.x * this.min.x;
                max = plane.normal.x * this.max.x;
    
            } else {
    
                min = plane.normal.x * this.max.x;
                max = plane.normal.x * this.min.x;
    
            }
    
            if ( plane.normal.y > 0 ) {
    
                min += plane.normal.y * this.min.y;
                max += plane.normal.y * this.max.y;
    
            } else {
    
                min += plane.normal.y * this.max.y;
                max += plane.normal.y * this.min.y;
    
            }
    
            if ( plane.normal.z > 0 ) {
    
                min += plane.normal.z * this.min.z;
                max += plane.normal.z * this.max.z;
    
            } else {
    
                min += plane.normal.z * this.max.z;
                max += plane.normal.z * this.min.z;
    
            }
    
            return ( min <= - plane.constant && max >= - plane.constant );
    
        },
    
        intersectsTriangle: function ( triangle ) {
    
            if ( this.isEmpty() ) {
    
                return false;
    
            }
    
            // compute box center and extents
            this.getCenter( _center );
            _extents.subVectors( this.max, _center );
    
            // translate triangle to aabb origin
            _v0.subVectors( triangle.a, _center );
            _v1$2.subVectors( triangle.b, _center );
            _v2.subVectors( triangle.c, _center );
    
            // compute edge vectors for triangle
            _f0.subVectors( _v1$2, _v0 );
            _f1.subVectors( _v2, _v1$2 );
            _f2.subVectors( _v0, _v2 );
    
            // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
            // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
            // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
            var axes = [
                0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
                _f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
                - _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
            ];
            if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {
    
                return false;
    
            }
    
            // test 3 face normals from the aabb
            axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
            if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {
    
                return false;
    
            }
    
            // finally testing the face normal of the triangle
            // use already existing triangle edge vectors here
            _triangleNormal.crossVectors( _f0, _f1 );
            axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];
    
            return satForAxes( axes, _v0, _v1$2, _v2, _extents );
    
        },
    
        clampPoint: function ( point, target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Box3: .clampPoint() target is now required' );
                target = new Vector3();
    
            }
    
            return target.copy( point ).clamp( this.min, this.max );
    
        },
    
        distanceToPoint: function ( point ) {
    
            var clampedPoint = _vector$1.copy( point ).clamp( this.min, this.max );
    
            return clampedPoint.sub( point ).length();
    
        },
    
        getBoundingSphere: function ( target ) {
    
            if ( target === undefined ) {
    
                console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
                //target = new Sphere(); // removed to avoid cyclic dependency
    
            }
    
            this.getCenter( target.center );
    
            target.radius = this.getSize( _vector$1 ).length() * 0.5;
    
            return target;
    
        },
    
        intersect: function ( box ) {
    
            this.min.max( box.min );
            this.max.min( box.max );
    
            // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
            if ( this.isEmpty() ) this.makeEmpty();
    
            return this;
    
        },
    
        union: function ( box ) {
    
            this.min.min( box.min );
            this.max.max( box.max );
    
            return this;
    
        },
    
        applyMatrix4: function ( matrix ) {
    
            // transform of empty box is an empty box.
            if ( this.isEmpty() ) return this;
    
            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            _points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
            _points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
            _points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
            _points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
            _points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
            _points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
            _points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
            _points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111
    
            this.setFromPoints( _points );
    
            return this;
    
        },
    
        translate: function ( offset ) {
    
            this.min.add( offset );
            this.max.add( offset );
    
            return this;
    
        },
    
        equals: function ( box ) {
    
            return box.min.equals( this.min ) && box.max.equals( this.max );
    
        }
    
    } );
    
    function satForAxes( axes, v0, v1, v2, extents ) {
    
        var i, j;
    
        for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {
    
            _testAxis.fromArray( axes, i );
            // project the aabb onto the seperating axis
            var r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
            // project all 3 vertices of the triangle onto the seperating axis
            var p0 = v0.dot( _testAxis );
            var p1 = v1.dot( _testAxis );
            var p2 = v2.dot( _testAxis );
            // actual test, basically see if either of the most extreme of the triangle points intersects r
            if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {
    
                // points of the projected triangle are outside the projected half-length of the aabb
                // the axis is seperating and we can exit
                return false;
    
            }
    
        }
    
        return true;
    
    }
    
    var _box$1 = new Box3();
    
    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */
    
    function Sphere( center, radius ) {
    
        this.center = ( center !== undefined ) ? center : new Vector3();
        this.radius = ( radius !== undefined ) ? radius : 0;
    
    }
    
    Object.assign( Sphere.prototype, {
    
        set: function ( center, radius ) {
    
            this.center.copy( center );
            this.radius = radius;
    
            return this;
    
        },
    
        setFromPoints: function ( points, optionalCenter ) {
    
            var center = this.center;
    
            if ( optionalCenter !== undefined ) {
    
                center.copy( optionalCenter );
    
            } else {
    
                _box$1.setFromPoints( points ).getCenter( center );
    
            }
    
            var maxRadiusSq = 0;
    
            for ( var i = 0, il = points.length; i < il; i ++ ) {
    
                maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
    
            }
    
            this.radius = Math.sqrt( maxRadiusSq );
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( sphere ) {
    
            this.center.copy( sphere.center );
            this.radius = sphere.radius;
    
            return this;
    
        },
    
        empty: function () {
    
            return ( this.radius <= 0 );
    
        },
    
        containsPoint: function ( point ) {
    
            return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
    
        },
    
        distanceToPoint: function ( point ) {
    
            return ( point.distanceTo( this.center ) - this.radius );
    
        },
    
        intersectsSphere: function ( sphere ) {
    
            var radiusSum = this.radius + sphere.radius;
    
            return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
    
        },
    
        intersectsBox: function ( box ) {
    
            return box.intersectsSphere( this );
    
        },
    
        intersectsPlane: function ( plane ) {
    
            return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;
    
        },
    
        clampPoint: function ( point, target ) {
    
            var deltaLengthSq = this.center.distanceToSquared( point );
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
                target = new Vector3();
    
            }
    
            target.copy( point );
    
            if ( deltaLengthSq > ( this.radius * this.radius ) ) {
    
                target.sub( this.center ).normalize();
                target.multiplyScalar( this.radius ).add( this.center );
    
            }
    
            return target;
    
        },
    
        getBoundingBox: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
                target = new Box3();
    
            }
    
            target.set( this.center, this.center );
            target.expandByScalar( this.radius );
    
            return target;
    
        },
    
        applyMatrix4: function ( matrix ) {
    
            this.center.applyMatrix4( matrix );
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
    
            return this;
    
        },
    
        translate: function ( offset ) {
    
            this.center.add( offset );
    
            return this;
    
        },
    
        equals: function ( sphere ) {
    
            return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
    
        }
    
    } );
    
    var _vector$2 = new Vector3();
    var _segCenter = new Vector3();
    var _segDir = new Vector3();
    var _diff = new Vector3();
    
    var _edge1 = new Vector3();
    var _edge2 = new Vector3();
    var _normal = new Vector3();
    
    /**
     * @author bhouston / http://clara.io
     */
    
    function Ray( origin, direction ) {
    
        this.origin = ( origin !== undefined ) ? origin : new Vector3();
        this.direction = ( direction !== undefined ) ? direction : new Vector3( 0, 0, - 1 );
    
    }
    
    Object.assign( Ray.prototype, {
    
        set: function ( origin, direction ) {
    
            this.origin.copy( origin );
            this.direction.copy( direction );
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( ray ) {
    
            this.origin.copy( ray.origin );
            this.direction.copy( ray.direction );
    
            return this;
    
        },
    
        at: function ( t, target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Ray: .at() target is now required' );
                target = new Vector3();
    
            }
    
            return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );
    
        },
    
        lookAt: function ( v ) {
    
            this.direction.copy( v ).sub( this.origin ).normalize();
    
            return this;
    
        },
    
        recast: function ( t ) {
    
            this.origin.copy( this.at( t, _vector$2 ) );
    
            return this;
    
        },
    
        closestPointToPoint: function ( point, target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
                target = new Vector3();
    
            }
    
            target.subVectors( point, this.origin );
    
            var directionDistance = target.dot( this.direction );
    
            if ( directionDistance < 0 ) {
    
                return target.copy( this.origin );
    
            }
    
            return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
    
        },
    
        distanceToPoint: function ( point ) {
    
            return Math.sqrt( this.distanceSqToPoint( point ) );
    
        },
    
        distanceSqToPoint: function ( point ) {
    
            var directionDistance = _vector$2.subVectors( point, this.origin ).dot( this.direction );
    
            // point behind the ray
    
            if ( directionDistance < 0 ) {
    
                return this.origin.distanceToSquared( point );
    
            }
    
            _vector$2.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
    
            return _vector$2.distanceToSquared( point );
    
        },
    
        distanceSqToSegment: function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
    
            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
            // It returns the min distance between the ray and the segment
            // defined by v0 and v1
            // It can also set two optional targets :
            // - The closest point on the ray
            // - The closest point on the segment
    
            _segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
            _segDir.copy( v1 ).sub( v0 ).normalize();
            _diff.copy( this.origin ).sub( _segCenter );
    
            var segExtent = v0.distanceTo( v1 ) * 0.5;
            var a01 = - this.direction.dot( _segDir );
            var b0 = _diff.dot( this.direction );
            var b1 = - _diff.dot( _segDir );
            var c = _diff.lengthSq();
            var det = Math.abs( 1 - a01 * a01 );
            var s0, s1, sqrDist, extDet;
    
            if ( det > 0 ) {
    
                // The ray and segment are not parallel.
    
                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;
    
                if ( s0 >= 0 ) {
    
                    if ( s1 >= - extDet ) {
    
                        if ( s1 <= extDet ) {
    
                            // region 0
                            // Minimum at interior points of ray and segment.
    
                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
    
                        } else {
    
                            // region 1
    
                            s1 = segExtent;
                            s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
    
                        }
    
                    } else {
    
                        // region 5
    
                        s1 = - segExtent;
                        s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
    
                    }
    
                } else {
    
                    if ( s1 <= - extDet ) {
    
                        // region 4
    
                        s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
    
                    } else if ( s1 <= extDet ) {
    
                        // region 3
    
                        s0 = 0;
                        s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = s1 * ( s1 + 2 * b1 ) + c;
    
                    } else {
    
                        // region 2
    
                        s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
                        s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
                        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
    
                    }
    
                }
    
            } else {
    
                // Ray and segment are parallel.
    
                s1 = ( a01 > 0 ) ? - segExtent : segExtent;
                s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
                sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
    
            }
    
            if ( optionalPointOnRay ) {
    
                optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
    
            }
    
            if ( optionalPointOnSegment ) {
    
                optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );
    
            }
    
            return sqrDist;
    
        },
    
        intersectSphere: function ( sphere, target ) {
    
            _vector$2.subVectors( sphere.center, this.origin );
            var tca = _vector$2.dot( this.direction );
            var d2 = _vector$2.dot( _vector$2 ) - tca * tca;
            var radius2 = sphere.radius * sphere.radius;
    
            if ( d2 > radius2 ) return null;
    
            var thc = Math.sqrt( radius2 - d2 );
    
            // t0 = first intersect point - entrance on front of sphere
            var t0 = tca - thc;
    
            // t1 = second intersect point - exit point on back of sphere
            var t1 = tca + thc;
    
            // test to see if both t0 and t1 are behind the ray - if so, return null
            if ( t0 < 0 && t1 < 0 ) return null;
    
            // test to see if t0 is behind the ray:
            // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
            // in order to always return an intersect point that is in front of the ray.
            if ( t0 < 0 ) return this.at( t1, target );
    
            // else t0 is in front of the ray, so return the first collision point scaled by t0
            return this.at( t0, target );
    
        },
    
        intersectsSphere: function ( sphere ) {
    
            return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );
    
        },
    
        distanceToPlane: function ( plane ) {
    
            var denominator = plane.normal.dot( this.direction );
    
            if ( denominator === 0 ) {
    
                // line is coplanar, return origin
                if ( plane.distanceToPoint( this.origin ) === 0 ) {
    
                    return 0;
    
                }
    
                // Null is preferable to undefined since undefined means.... it is undefined
    
                return null;
    
            }
    
            var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
    
            // Return if the ray never intersects the plane
    
            return t >= 0 ? t : null;
    
        },
    
        intersectPlane: function ( plane, target ) {
    
            var t = this.distanceToPlane( plane );
    
            if ( t === null ) {
    
                return null;
    
            }
    
            return this.at( t, target );
    
        },
    
        intersectsPlane: function ( plane ) {
    
            // check if the ray lies on the plane first
    
            var distToPoint = plane.distanceToPoint( this.origin );
    
            if ( distToPoint === 0 ) {
    
                return true;
    
            }
    
            var denominator = plane.normal.dot( this.direction );
    
            if ( denominator * distToPoint < 0 ) {
    
                return true;
    
            }
    
            // ray origin is behind the plane (and is pointing behind it)
    
            return false;
    
        },
    
        intersectBox: function ( box, target ) {
    
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
    
            var invdirx = 1 / this.direction.x,
                invdiry = 1 / this.direction.y,
                invdirz = 1 / this.direction.z;
    
            var origin = this.origin;
    
            if ( invdirx >= 0 ) {
    
                tmin = ( box.min.x - origin.x ) * invdirx;
                tmax = ( box.max.x - origin.x ) * invdirx;
    
            } else {
    
                tmin = ( box.max.x - origin.x ) * invdirx;
                tmax = ( box.min.x - origin.x ) * invdirx;
    
            }
    
            if ( invdiry >= 0 ) {
    
                tymin = ( box.min.y - origin.y ) * invdiry;
                tymax = ( box.max.y - origin.y ) * invdiry;
    
            } else {
    
                tymin = ( box.max.y - origin.y ) * invdiry;
                tymax = ( box.min.y - origin.y ) * invdiry;
    
            }
    
            if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
    
            // These lines also handle the case where tmin or tmax is NaN
            // (result of 0 * Infinity). x !== x returns true if x is NaN
    
            if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
    
            if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
    
            if ( invdirz >= 0 ) {
    
                tzmin = ( box.min.z - origin.z ) * invdirz;
                tzmax = ( box.max.z - origin.z ) * invdirz;
    
            } else {
    
                tzmin = ( box.max.z - origin.z ) * invdirz;
                tzmax = ( box.min.z - origin.z ) * invdirz;
    
            }
    
            if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
    
            if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
    
            if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
    
            //return point closest to the ray (positive side)
    
            if ( tmax < 0 ) return null;
    
            return this.at( tmin >= 0 ? tmin : tmax, target );
    
        },
    
        intersectsBox: function ( box ) {
    
            return this.intersectBox( box, _vector$2 ) !== null;
    
        },
    
        intersectTriangle: function ( a, b, c, backfaceCulling, target ) {
    
            // Compute the offset origin, edges, and normal.
    
            // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
    
            _edge1.subVectors( b, a );
            _edge2.subVectors( c, a );
            _normal.crossVectors( _edge1, _edge2 );
    
            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = this.direction.dot( _normal );
            var sign;
    
            if ( DdN > 0 ) {
    
                if ( backfaceCulling ) return null;
                sign = 1;
    
            } else if ( DdN < 0 ) {
    
                sign = - 1;
                DdN = - DdN;
    
            } else {
    
                return null;
    
            }
    
            _diff.subVectors( this.origin, a );
            var DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );
    
            // b1 < 0, no intersection
            if ( DdQxE2 < 0 ) {
    
                return null;
    
            }
    
            var DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );
    
            // b2 < 0, no intersection
            if ( DdE1xQ < 0 ) {
    
                return null;
    
            }
    
            // b1+b2 > 1, no intersection
            if ( DdQxE2 + DdE1xQ > DdN ) {
    
                return null;
    
            }
    
            // Line intersects triangle, check if ray does.
            var QdN = - sign * _diff.dot( _normal );
    
            // t < 0, no intersection
            if ( QdN < 0 ) {
    
                return null;
    
            }
    
            // Ray intersects triangle.
            return this.at( QdN / DdN, target );
    
        },
    
        applyMatrix4: function ( matrix4 ) {
    
            this.origin.applyMatrix4( matrix4 );
            this.direction.transformDirection( matrix4 );
    
            return this;
    
        },
    
        equals: function ( ray ) {
    
            return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
    
        }
    
    } );
    
    /**
     * @author bhouston / http://clara.io
     */
    
    var _vector1 = new Vector3();
    var _vector2 = new Vector3();
    var _normalMatrix = new Matrix3();
    
    function Plane( normal, constant ) {
    
        // normal is assumed to be normalized
    
        this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
        this.constant = ( constant !== undefined ) ? constant : 0;
    
    }
    
    Object.assign( Plane.prototype, {
    
        isPlane: true,
    
        set: function ( normal, constant ) {
    
            this.normal.copy( normal );
            this.constant = constant;
    
            return this;
    
        },
    
        setComponents: function ( x, y, z, w ) {
    
            this.normal.set( x, y, z );
            this.constant = w;
    
            return this;
    
        },
    
        setFromNormalAndCoplanarPoint: function ( normal, point ) {
    
            this.normal.copy( normal );
            this.constant = - point.dot( this.normal );
    
            return this;
    
        },
    
        setFromCoplanarPoints: function ( a, b, c ) {
    
            var normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();
    
            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
    
            this.setFromNormalAndCoplanarPoint( normal, a );
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( plane ) {
    
            this.normal.copy( plane.normal );
            this.constant = plane.constant;
    
            return this;
    
        },
    
        normalize: function () {
    
            // Note: will lead to a divide by zero if the plane is invalid.
    
            var inverseNormalLength = 1.0 / this.normal.length();
            this.normal.multiplyScalar( inverseNormalLength );
            this.constant *= inverseNormalLength;
    
            return this;
    
        },
    
        negate: function () {
    
            this.constant *= - 1;
            this.normal.negate();
    
            return this;
    
        },
    
        distanceToPoint: function ( point ) {
    
            return this.normal.dot( point ) + this.constant;
    
        },
    
        distanceToSphere: function ( sphere ) {
    
            return this.distanceToPoint( sphere.center ) - sphere.radius;
    
        },
    
        projectPoint: function ( point, target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Plane: .projectPoint() target is now required' );
                target = new Vector3();
    
            }
    
            return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );
    
        },
    
        intersectLine: function ( line, target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Plane: .intersectLine() target is now required' );
                target = new Vector3();
    
            }
    
            var direction = line.delta( _vector1 );
    
            var denominator = this.normal.dot( direction );
    
            if ( denominator === 0 ) {
    
                // line is coplanar, return origin
                if ( this.distanceToPoint( line.start ) === 0 ) {
    
                    return target.copy( line.start );
    
                }
    
                // Unsure if this is the correct method to handle this case.
                return undefined;
    
            }
    
            var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
    
            if ( t < 0 || t > 1 ) {
    
                return undefined;
    
            }
    
            return target.copy( direction ).multiplyScalar( t ).add( line.start );
    
        },
    
        intersectsLine: function ( line ) {
    
            // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
    
            var startSign = this.distanceToPoint( line.start );
            var endSign = this.distanceToPoint( line.end );
    
            return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
    
        },
    
        intersectsBox: function ( box ) {
    
            return box.intersectsPlane( this );
    
        },
    
        intersectsSphere: function ( sphere ) {
    
            return sphere.intersectsPlane( this );
    
        },
    
        coplanarPoint: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
                target = new Vector3();
    
            }
    
            return target.copy( this.normal ).multiplyScalar( - this.constant );
    
        },
    
        applyMatrix4: function ( matrix, optionalNormalMatrix ) {
    
            var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );
    
            var referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );
    
            var normal = this.normal.applyMatrix3( normalMatrix ).normalize();
    
            this.constant = - referencePoint.dot( normal );
    
            return this;
    
        },
    
        translate: function ( offset ) {
    
            this.constant -= offset.dot( this.normal );
    
            return this;
    
        },
    
        equals: function ( plane ) {
    
            return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
    
        }
    
    } );
    
    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */
    
    var _v0$1 = new Vector3();
    var _v1$3 = new Vector3();
    var _v2$1 = new Vector3();
    var _v3 = new Vector3();
    
    var _vab = new Vector3();
    var _vac = new Vector3();
    var _vbc = new Vector3();
    var _vap = new Vector3();
    var _vbp = new Vector3();
    var _vcp = new Vector3();
    
    function Triangle( a, b, c ) {
    
        this.a = ( a !== undefined ) ? a : new Vector3();
        this.b = ( b !== undefined ) ? b : new Vector3();
        this.c = ( c !== undefined ) ? c : new Vector3();
    
    }
    
    Object.assign( Triangle, {
    
        getNormal: function ( a, b, c, target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Triangle: .getNormal() target is now required' );
                target = new Vector3();
    
            }
    
            target.subVectors( c, b );
            _v0$1.subVectors( a, b );
            target.cross( _v0$1 );
    
            var targetLengthSq = target.lengthSq();
            if ( targetLengthSq > 0 ) {
    
                return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );
    
            }
    
            return target.set( 0, 0, 0 );
    
        },
    
        // static/instance method to calculate barycentric coordinates
        // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
        getBarycoord: function ( point, a, b, c, target ) {
    
            _v0$1.subVectors( c, a );
            _v1$3.subVectors( b, a );
            _v2$1.subVectors( point, a );
    
            var dot00 = _v0$1.dot( _v0$1 );
            var dot01 = _v0$1.dot( _v1$3 );
            var dot02 = _v0$1.dot( _v2$1 );
            var dot11 = _v1$3.dot( _v1$3 );
            var dot12 = _v1$3.dot( _v2$1 );
    
            var denom = ( dot00 * dot11 - dot01 * dot01 );
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
                target = new Vector3();
    
            }
    
            // collinear or singular triangle
            if ( denom === 0 ) {
    
                // arbitrary location outside of triangle?
                // not sure if this is the best idea, maybe should be returning undefined
                return target.set( - 2, - 1, - 1 );
    
            }
    
            var invDenom = 1 / denom;
            var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
            var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
    
            // barycentric coordinates must always sum to 1
            return target.set( 1 - u - v, v, u );
    
        },
    
        containsPoint: function ( point, a, b, c ) {
    
            Triangle.getBarycoord( point, a, b, c, _v3 );
    
            return ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );
    
        },
    
        getUV: function ( point, p1, p2, p3, uv1, uv2, uv3, target ) {
    
            this.getBarycoord( point, p1, p2, p3, _v3 );
    
            target.set( 0, 0 );
            target.addScaledVector( uv1, _v3.x );
            target.addScaledVector( uv2, _v3.y );
            target.addScaledVector( uv3, _v3.z );
    
            return target;
    
        },
    
        isFrontFacing: function ( a, b, c, direction ) {
    
            _v0$1.subVectors( c, b );
            _v1$3.subVectors( a, b );
    
            // strictly front facing
            return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;
    
        }
    
    } );
    
    Object.assign( Triangle.prototype, {
    
        set: function ( a, b, c ) {
    
            this.a.copy( a );
            this.b.copy( b );
            this.c.copy( c );
    
            return this;
    
        },
    
        setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
    
            this.a.copy( points[ i0 ] );
            this.b.copy( points[ i1 ] );
            this.c.copy( points[ i2 ] );
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( triangle ) {
    
            this.a.copy( triangle.a );
            this.b.copy( triangle.b );
            this.c.copy( triangle.c );
    
            return this;
    
        },
    
        getArea: function () {
    
            _v0$1.subVectors( this.c, this.b );
            _v1$3.subVectors( this.a, this.b );
    
            return _v0$1.cross( _v1$3 ).length() * 0.5;
    
        },
    
        getMidpoint: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
                target = new Vector3();
    
            }
    
            return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
    
        },
    
        getNormal: function ( target ) {
    
            return Triangle.getNormal( this.a, this.b, this.c, target );
    
        },
    
        getPlane: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Triangle: .getPlane() target is now required' );
                target = new Plane();
    
            }
    
            return target.setFromCoplanarPoints( this.a, this.b, this.c );
    
        },
    
        getBarycoord: function ( point, target ) {
    
            return Triangle.getBarycoord( point, this.a, this.b, this.c, target );
    
        },
    
        getUV: function ( point, uv1, uv2, uv3, target ) {
    
            return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );
    
        },
    
        containsPoint: function ( point ) {
    
            return Triangle.containsPoint( point, this.a, this.b, this.c );
    
        },
    
        isFrontFacing: function ( direction ) {
    
            return Triangle.isFrontFacing( this.a, this.b, this.c, direction );
    
        },
    
        intersectsBox: function ( box ) {
    
            return box.intersectsTriangle( this );
    
        },
    
        closestPointToPoint: function ( p, target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
                target = new Vector3();
    
            }
    
            var a = this.a, b = this.b, c = this.c;
            var v, w;
    
            // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
            // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
            // under the accompanying license; see chapter 5.1.5 for detailed explanation.
            // basically, we're distinguishing which of the voronoi regions of the triangle
            // the point lies in with the minimum amount of redundant computation.
    
            _vab.subVectors( b, a );
            _vac.subVectors( c, a );
            _vap.subVectors( p, a );
            var d1 = _vab.dot( _vap );
            var d2 = _vac.dot( _vap );
            if ( d1 <= 0 && d2 <= 0 ) {
    
                // vertex region of A; barycentric coords (1, 0, 0)
                return target.copy( a );
    
            }
    
            _vbp.subVectors( p, b );
            var d3 = _vab.dot( _vbp );
            var d4 = _vac.dot( _vbp );
            if ( d3 >= 0 && d4 <= d3 ) {
    
                // vertex region of B; barycentric coords (0, 1, 0)
                return target.copy( b );
    
            }
    
            var vc = d1 * d4 - d3 * d2;
            if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {
    
                v = d1 / ( d1 - d3 );
                // edge region of AB; barycentric coords (1-v, v, 0)
                return target.copy( a ).addScaledVector( _vab, v );
    
            }
    
            _vcp.subVectors( p, c );
            var d5 = _vab.dot( _vcp );
            var d6 = _vac.dot( _vcp );
            if ( d6 >= 0 && d5 <= d6 ) {
    
                // vertex region of C; barycentric coords (0, 0, 1)
                return target.copy( c );
    
            }
    
            var vb = d5 * d2 - d1 * d6;
            if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {
    
                w = d2 / ( d2 - d6 );
                // edge region of AC; barycentric coords (1-w, 0, w)
                return target.copy( a ).addScaledVector( _vac, w );
    
            }
    
            var va = d3 * d6 - d5 * d4;
            if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {
    
                _vbc.subVectors( c, b );
                w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
                // edge region of BC; barycentric coords (0, 1-w, w)
                return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC
    
            }
    
            // face region
            var denom = 1 / ( va + vb + vc );
            // u = va * denom
            v = vb * denom;
            w = vc * denom;
    
            return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );
    
        },
    
        equals: function ( triangle ) {
    
            return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    var _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
        'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
        'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
        'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
        'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
        'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
        'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
        'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
        'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
        'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
        'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
        'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
        'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
        'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
        'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
        'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
        'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
        'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
        'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
        'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
        'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
        'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
        'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
        'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
    
    var _hslA = { h: 0, s: 0, l: 0 };
    var _hslB = { h: 0, s: 0, l: 0 };
    
    function Color( r, g, b ) {
    
        if ( g === undefined && b === undefined ) {
    
            // r is THREE.Color, hex or string
            return this.set( r );
    
        }
    
        return this.setRGB( r, g, b );
    
    }
    
    function hue2rgb( p, q, t ) {
    
        if ( t < 0 ) t += 1;
        if ( t > 1 ) t -= 1;
        if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
        if ( t < 1 / 2 ) return q;
        if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
        return p;
    
    }
    
    function SRGBToLinear( c ) {
    
        return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );
    
    }
    
    function LinearToSRGB( c ) {
    
        return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;
    
    }
    
    Object.assign( Color.prototype, {
    
        isColor: true,
    
        r: 1, g: 1, b: 1,
    
        set: function ( value ) {
    
            if ( value && value.isColor ) {
    
                this.copy( value );
    
            } else if ( typeof value === 'number' ) {
    
                this.setHex( value );
    
            } else if ( typeof value === 'string' ) {
    
                this.setStyle( value );
    
            }
    
            return this;
    
        },
    
        setScalar: function ( scalar ) {
    
            this.r = scalar;
            this.g = scalar;
            this.b = scalar;
    
            return this;
    
        },
    
        setHex: function ( hex ) {
    
            hex = Math.floor( hex );
    
            this.r = ( hex >> 16 & 255 ) / 255;
            this.g = ( hex >> 8 & 255 ) / 255;
            this.b = ( hex & 255 ) / 255;
    
            return this;
    
        },
    
        setRGB: function ( r, g, b ) {
    
            this.r = r;
            this.g = g;
            this.b = b;
    
            return this;
    
        },
    
        setHSL: function ( h, s, l ) {
    
            // h,s,l ranges are in 0.0 - 1.0
            h = MathUtils.euclideanModulo( h, 1 );
            s = MathUtils.clamp( s, 0, 1 );
            l = MathUtils.clamp( l, 0, 1 );
    
            if ( s === 0 ) {
    
                this.r = this.g = this.b = l;
    
            } else {
    
                var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
                var q = ( 2 * l ) - p;
    
                this.r = hue2rgb( q, p, h + 1 / 3 );
                this.g = hue2rgb( q, p, h );
                this.b = hue2rgb( q, p, h - 1 / 3 );
    
            }
    
            return this;
    
        },
    
        setStyle: function ( style ) {
    
            function handleAlpha( string ) {
    
                if ( string === undefined ) return;
    
                if ( parseFloat( string ) < 1 ) {
    
                    console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
    
                }
    
            }
    
    
            var m;
    
            if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
    
                // rgb / hsl
    
                var color;
                var name = m[ 1 ];
                var components = m[ 2 ];
    
                switch ( name ) {
    
                    case 'rgb':
                    case 'rgba':
    
                        if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
    
                            // rgb(255,0,0) rgba(255,0,0,0.5)
                            this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
                            this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
                            this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
    
                            handleAlpha( color[ 5 ] );
    
                            return this;
    
                        }
    
                        if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
    
                            // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                            this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
                            this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
                            this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
    
                            handleAlpha( color[ 5 ] );
    
                            return this;
    
                        }
    
                        break;
    
                    case 'hsl':
                    case 'hsla':
    
                        if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
    
                            // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                            var h = parseFloat( color[ 1 ] ) / 360;
                            var s = parseInt( color[ 2 ], 10 ) / 100;
                            var l = parseInt( color[ 3 ], 10 ) / 100;
    
                            handleAlpha( color[ 5 ] );
    
                            return this.setHSL( h, s, l );
    
                        }
    
                        break;
    
                }
    
            } else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
    
                // hex color
    
                var hex = m[ 1 ];
                var size = hex.length;
    
                if ( size === 3 ) {
    
                    // #ff0
                    this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
                    this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
                    this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
    
                    return this;
    
                } else if ( size === 6 ) {
    
                    // #ff0000
                    this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
                    this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
                    this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
    
                    return this;
    
                }
    
            }
    
            if ( style && style.length > 0 ) {
    
                return this.setColorName( style );
    
            }
    
            return this;
    
        },
    
        setColorName: function ( style ) {
    
            // color keywords
            var hex = _colorKeywords[ style ];
    
            if ( hex !== undefined ) {
    
                // red
                this.setHex( hex );
    
            } else {
    
                // unknown color
                console.warn( 'THREE.Color: Unknown color ' + style );
    
            }
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor( this.r, this.g, this.b );
    
        },
    
        copy: function ( color ) {
    
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
    
            return this;
    
        },
    
        copyGammaToLinear: function ( color, gammaFactor ) {
    
            if ( gammaFactor === undefined ) gammaFactor = 2.0;
    
            this.r = Math.pow( color.r, gammaFactor );
            this.g = Math.pow( color.g, gammaFactor );
            this.b = Math.pow( color.b, gammaFactor );
    
            return this;
    
        },
    
        copyLinearToGamma: function ( color, gammaFactor ) {
    
            if ( gammaFactor === undefined ) gammaFactor = 2.0;
    
            var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
    
            this.r = Math.pow( color.r, safeInverse );
            this.g = Math.pow( color.g, safeInverse );
            this.b = Math.pow( color.b, safeInverse );
    
            return this;
    
        },
    
        convertGammaToLinear: function ( gammaFactor ) {
    
            this.copyGammaToLinear( this, gammaFactor );
    
            return this;
    
        },
    
        convertLinearToGamma: function ( gammaFactor ) {
    
            this.copyLinearToGamma( this, gammaFactor );
    
            return this;
    
        },
    
        copySRGBToLinear: function ( color ) {
    
            this.r = SRGBToLinear( color.r );
            this.g = SRGBToLinear( color.g );
            this.b = SRGBToLinear( color.b );
    
            return this;
    
        },
    
        copyLinearToSRGB: function ( color ) {
    
            this.r = LinearToSRGB( color.r );
            this.g = LinearToSRGB( color.g );
            this.b = LinearToSRGB( color.b );
    
            return this;
    
        },
    
        convertSRGBToLinear: function () {
    
            this.copySRGBToLinear( this );
    
            return this;
    
        },
    
        convertLinearToSRGB: function () {
    
            this.copyLinearToSRGB( this );
    
            return this;
    
        },
    
        getHex: function () {
    
            return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
    
        },
    
        getHexString: function () {
    
            return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
    
        },
    
        getHSL: function ( target ) {
    
            // h,s,l ranges are in 0.0 - 1.0
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Color: .getHSL() target is now required' );
                target = { h: 0, s: 0, l: 0 };
    
            }
    
            var r = this.r, g = this.g, b = this.b;
    
            var max = Math.max( r, g, b );
            var min = Math.min( r, g, b );
    
            var hue, saturation;
            var lightness = ( min + max ) / 2.0;
    
            if ( min === max ) {
    
                hue = 0;
                saturation = 0;
    
            } else {
    
                var delta = max - min;
    
                saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
    
                switch ( max ) {
    
                    case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
                    case g: hue = ( b - r ) / delta + 2; break;
                    case b: hue = ( r - g ) / delta + 4; break;
    
                }
    
                hue /= 6;
    
            }
    
            target.h = hue;
            target.s = saturation;
            target.l = lightness;
    
            return target;
    
        },
    
        getStyle: function () {
    
            return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
    
        },
    
        offsetHSL: function ( h, s, l ) {
    
            this.getHSL( _hslA );
    
            _hslA.h += h; _hslA.s += s; _hslA.l += l;
    
            this.setHSL( _hslA.h, _hslA.s, _hslA.l );
    
            return this;
    
        },
    
        add: function ( color ) {
    
            this.r += color.r;
            this.g += color.g;
            this.b += color.b;
    
            return this;
    
        },
    
        addColors: function ( color1, color2 ) {
    
            this.r = color1.r + color2.r;
            this.g = color1.g + color2.g;
            this.b = color1.b + color2.b;
    
            return this;
    
        },
    
        addScalar: function ( s ) {
    
            this.r += s;
            this.g += s;
            this.b += s;
    
            return this;
    
        },
    
        sub: function ( color ) {
    
            this.r = Math.max( 0, this.r - color.r );
            this.g = Math.max( 0, this.g - color.g );
            this.b = Math.max( 0, this.b - color.b );
    
            return this;
    
        },
    
        multiply: function ( color ) {
    
            this.r *= color.r;
            this.g *= color.g;
            this.b *= color.b;
    
            return this;
    
        },
    
        multiplyScalar: function ( s ) {
    
            this.r *= s;
            this.g *= s;
            this.b *= s;
    
            return this;
    
        },
    
        lerp: function ( color, alpha ) {
    
            this.r += ( color.r - this.r ) * alpha;
            this.g += ( color.g - this.g ) * alpha;
            this.b += ( color.b - this.b ) * alpha;
    
            return this;
    
        },
    
        lerpHSL: function ( color, alpha ) {
    
            this.getHSL( _hslA );
            color.getHSL( _hslB );
    
            var h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );
            var s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );
            var l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );
    
            this.setHSL( h, s, l );
    
            return this;
    
        },
    
        equals: function ( c ) {
    
            return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
    
        },
    
        fromArray: function ( array, offset ) {
    
            if ( offset === undefined ) offset = 0;
    
            this.r = array[ offset ];
            this.g = array[ offset + 1 ];
            this.b = array[ offset + 2 ];
    
            return this;
    
        },
    
        toArray: function ( array, offset ) {
    
            if ( array === undefined ) array = [];
            if ( offset === undefined ) offset = 0;
    
            array[ offset ] = this.r;
            array[ offset + 1 ] = this.g;
            array[ offset + 2 ] = this.b;
    
            return array;
    
        },
    
        toJSON: function () {
    
            return this.getHex();
    
        }
    
    } );
    
    Color.NAMES = _colorKeywords;
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    
    function Face3( a, b, c, normal, color, materialIndex ) {
    
        this.a = a;
        this.b = b;
        this.c = c;
    
        this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
        this.vertexNormals = Array.isArray( normal ) ? normal : [];
    
        this.color = ( color && color.isColor ) ? color : new Color();
        this.vertexColors = Array.isArray( color ) ? color : [];
    
        this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
    
    }
    
    Object.assign( Face3.prototype, {
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( source ) {
    
            this.a = source.a;
            this.b = source.b;
            this.c = source.c;
    
            this.normal.copy( source.normal );
            this.color.copy( source.color );
    
            this.materialIndex = source.materialIndex;
    
            for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {
    
                this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
    
            }
    
            for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {
    
                this.vertexColors[ i ] = source.vertexColors[ i ].clone();
    
            }
    
            return this;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    
    var materialId = 0;
    
    function Material() {
    
        Object.defineProperty( this, 'id', { value: materialId ++ } );
    
        this.uuid = MathUtils.generateUUID();
    
        this.name = '';
        this.type = 'Material';
    
        this.fog = true;
    
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.flatShading = false;
        this.vertexColors = false;
    
        this.opacity = 1;
        this.transparent = false;
    
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
    
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
    
        this.stencilWriteMask = 0xff;
        this.stencilFunc = AlwaysStencilFunc;
        this.stencilRef = 0;
        this.stencilFuncMask = 0xff;
        this.stencilFail = KeepStencilOp;
        this.stencilZFail = KeepStencilOp;
        this.stencilZPass = KeepStencilOp;
        this.stencilWrite = false;
    
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
    
        this.shadowSide = null;
    
        this.colorWrite = true;
    
        this.precision = null; // override the renderer's default precision for this material
    
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
    
        this.dithering = false;
    
        this.alphaTest = 0;
        this.premultipliedAlpha = false;
    
        this.visible = true;
    
        this.toneMapped = true;
    
        this.userData = {};
    
        this.version = 0;
    
    }
    
    Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
    
        constructor: Material,
    
        isMaterial: true,
    
        onBeforeCompile: function () {},
    
        setValues: function ( values ) {
    
            if ( values === undefined ) return;
    
            for ( var key in values ) {
    
                var newValue = values[ key ];
    
                if ( newValue === undefined ) {
    
                    console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
                    continue;
    
                }
    
                // for backward compatability if shading is set in the constructor
                if ( key === 'shading' ) {
    
                    console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
                    this.flatShading = ( newValue === FlatShading ) ? true : false;
                    continue;
    
                }
    
                var currentValue = this[ key ];
    
                if ( currentValue === undefined ) {
    
                    console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
                    continue;
    
                }
    
                if ( currentValue && currentValue.isColor ) {
    
                    currentValue.set( newValue );
    
                } else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {
    
                    currentValue.copy( newValue );
    
                } else {
    
                    this[ key ] = newValue;
    
                }
    
            }
    
        },
    
        toJSON: function ( meta ) {
    
            var isRoot = ( meta === undefined || typeof meta === 'string' );
    
            if ( isRoot ) {
    
                meta = {
                    textures: {},
                    images: {}
                };
    
            }
    
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Material',
                    generator: 'Material.toJSON'
                }
            };
    
            // standard Material serialization
            data.uuid = this.uuid;
            data.type = this.type;
    
            if ( this.name !== '' ) data.name = this.name;
    
            if ( this.color && this.color.isColor ) data.color = this.color.getHex();
    
            if ( this.roughness !== undefined ) data.roughness = this.roughness;
            if ( this.metalness !== undefined ) data.metalness = this.metalness;
    
            if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
            if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
            if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;
    
            if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
            if ( this.shininess !== undefined ) data.shininess = this.shininess;
            if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
            if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;
    
            if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {
    
                data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
                data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    
            }
    
            if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
            if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
            if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
            if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
    
            if ( this.aoMap && this.aoMap.isTexture ) {
    
                data.aoMap = this.aoMap.toJSON( meta ).uuid;
                data.aoMapIntensity = this.aoMapIntensity;
    
            }
    
            if ( this.bumpMap && this.bumpMap.isTexture ) {
    
                data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
                data.bumpScale = this.bumpScale;
    
            }
    
            if ( this.normalMap && this.normalMap.isTexture ) {
    
                data.normalMap = this.normalMap.toJSON( meta ).uuid;
                data.normalMapType = this.normalMapType;
                data.normalScale = this.normalScale.toArray();
    
            }
    
            if ( this.displacementMap && this.displacementMap.isTexture ) {
    
                data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
                data.displacementScale = this.displacementScale;
                data.displacementBias = this.displacementBias;
    
            }
    
            if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
            if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
    
            if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
            if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
    
            if ( this.envMap && this.envMap.isTexture ) {
    
                data.envMap = this.envMap.toJSON( meta ).uuid;
                data.reflectivity = this.reflectivity; // Scale behind envMap
                data.refractionRatio = this.refractionRatio;
    
                if ( this.combine !== undefined ) data.combine = this.combine;
                if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
    
            }
    
            if ( this.gradientMap && this.gradientMap.isTexture ) {
    
                data.gradientMap = this.gradientMap.toJSON( meta ).uuid;
    
            }
    
            if ( this.size !== undefined ) data.size = this.size;
            if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
    
            if ( this.blending !== NormalBlending ) data.blending = this.blending;
            if ( this.flatShading === true ) data.flatShading = this.flatShading;
            if ( this.side !== FrontSide ) data.side = this.side;
            if ( this.vertexColors ) data.vertexColors = true;
    
            if ( this.opacity < 1 ) data.opacity = this.opacity;
            if ( this.transparent === true ) data.transparent = this.transparent;
    
            data.depthFunc = this.depthFunc;
            data.depthTest = this.depthTest;
            data.depthWrite = this.depthWrite;
    
            data.stencilWrite = this.stencilWrite;
            data.stencilWriteMask = this.stencilWriteMask;
            data.stencilFunc = this.stencilFunc;
            data.stencilRef = this.stencilRef;
            data.stencilFuncMask = this.stencilFuncMask;
            data.stencilFail = this.stencilFail;
            data.stencilZFail = this.stencilZFail;
            data.stencilZPass = this.stencilZPass;
    
            // rotation (SpriteMaterial)
            if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;
    
            if ( this.polygonOffset === true ) data.polygonOffset = true;
            if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
            if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;
    
            if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
            if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
            if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
            if ( this.scale !== undefined ) data.scale = this.scale;
    
            if ( this.dithering === true ) data.dithering = true;
    
            if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
            if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
    
            if ( this.wireframe === true ) data.wireframe = this.wireframe;
            if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
            if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
            if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;
    
            if ( this.morphTargets === true ) data.morphTargets = true;
            if ( this.morphNormals === true ) data.morphNormals = true;
            if ( this.skinning === true ) data.skinning = true;
    
            if ( this.visible === false ) data.visible = false;
    
            if ( this.toneMapped === false ) data.toneMapped = false;
    
            if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
    
            // TODO: Copied from Object3D.toJSON
    
            function extractFromCache( cache ) {
    
                var values = [];
    
                for ( var key in cache ) {
    
                    var data = cache[ key ];
                    delete data.metadata;
                    values.push( data );
    
                }
    
                return values;
    
            }
    
            if ( isRoot ) {
    
                var textures = extractFromCache( meta.textures );
                var images = extractFromCache( meta.images );
    
                if ( textures.length > 0 ) data.textures = textures;
                if ( images.length > 0 ) data.images = images;
    
            }
    
            return data;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( source ) {
    
            this.name = source.name;
    
            this.fog = source.fog;
    
            this.blending = source.blending;
            this.side = source.side;
            this.flatShading = source.flatShading;
            this.vertexColors = source.vertexColors;
    
            this.opacity = source.opacity;
            this.transparent = source.transparent;
    
            this.blendSrc = source.blendSrc;
            this.blendDst = source.blendDst;
            this.blendEquation = source.blendEquation;
            this.blendSrcAlpha = source.blendSrcAlpha;
            this.blendDstAlpha = source.blendDstAlpha;
            this.blendEquationAlpha = source.blendEquationAlpha;
    
            this.depthFunc = source.depthFunc;
            this.depthTest = source.depthTest;
            this.depthWrite = source.depthWrite;
    
            this.stencilWriteMask = source.stencilWriteMask;
            this.stencilFunc = source.stencilFunc;
            this.stencilRef = source.stencilRef;
            this.stencilFuncMask = source.stencilFuncMask;
            this.stencilFail = source.stencilFail;
            this.stencilZFail = source.stencilZFail;
            this.stencilZPass = source.stencilZPass;
            this.stencilWrite = source.stencilWrite;
    
            var srcPlanes = source.clippingPlanes,
                dstPlanes = null;
    
            if ( srcPlanes !== null ) {
    
                var n = srcPlanes.length;
                dstPlanes = new Array( n );
    
                for ( var i = 0; i !== n; ++ i )
                    dstPlanes[ i ] = srcPlanes[ i ].clone();
    
            }
    
            this.clippingPlanes = dstPlanes;
            this.clipIntersection = source.clipIntersection;
            this.clipShadows = source.clipShadows;
    
            this.shadowSide = source.shadowSide;
    
            this.colorWrite = source.colorWrite;
    
            this.precision = source.precision;
    
            this.polygonOffset = source.polygonOffset;
            this.polygonOffsetFactor = source.polygonOffsetFactor;
            this.polygonOffsetUnits = source.polygonOffsetUnits;
    
            this.dithering = source.dithering;
    
            this.alphaTest = source.alphaTest;
            this.premultipliedAlpha = source.premultipliedAlpha;
    
            this.visible = source.visible;
    
            this.toneMapped = source.toneMapped;
    
            this.userData = JSON.parse( JSON.stringify( source.userData ) );
    
            return this;
    
        },
    
        dispose: function () {
    
            this.dispatchEvent( { type: 'dispose' } );
    
        }
    
    } );
    
    Object.defineProperty( Material.prototype, 'needsUpdate', {
    
        set: function ( value ) {
    
            if ( value === true ) this.version ++;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>
     * }
     */
    
    function MeshBasicMaterial( parameters ) {
    
        Material.call( this );
    
        this.type = 'MeshBasicMaterial';
    
        this.color = new Color( 0xffffff ); // emissive
    
        this.map = null;
    
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
    
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
    
        this.specularMap = null;
    
        this.alphaMap = null;
    
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
    
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
    
        this.skinning = false;
        this.morphTargets = false;
    
        this.setValues( parameters );
    
    }
    
    MeshBasicMaterial.prototype = Object.create( Material.prototype );
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
    
    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
    
    MeshBasicMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.color.copy( source.color );
    
        this.map = source.map;
    
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
    
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
    
        this.specularMap = source.specularMap;
    
        this.alphaMap = source.alphaMap;
    
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
    
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
    
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
    
        return this;
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    var _vector$3 = new Vector3();
    
    function BufferAttribute( array, itemSize, normalized ) {
    
        if ( Array.isArray( array ) ) {
    
            throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
    
        }
    
        this.name = '';
    
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== undefined ? array.length / itemSize : 0;
        this.normalized = normalized === true;
    
        this.usage = StaticDrawUsage;
        this.updateRange = { offset: 0, count: - 1 };
    
        this.version = 0;
    
    }
    
    Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {
    
        set: function ( value ) {
    
            if ( value === true ) this.version ++;
    
        }
    
    } );
    
    Object.assign( BufferAttribute.prototype, {
    
        isBufferAttribute: true,
    
        onUploadCallback: function () {},
    
        setUsage: function ( value ) {
    
            this.usage = value;
    
            return this;
    
        },
    
        copy: function ( source ) {
    
            this.name = source.name;
            this.array = new source.array.constructor( source.array );
            this.itemSize = source.itemSize;
            this.count = source.count;
            this.normalized = source.normalized;
    
            this.usage = source.usage;
    
            return this;
    
        },
    
        copyAt: function ( index1, attribute, index2 ) {
    
            index1 *= this.itemSize;
            index2 *= attribute.itemSize;
    
            for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
    
                this.array[ index1 + i ] = attribute.array[ index2 + i ];
    
            }
    
            return this;
    
        },
    
        copyArray: function ( array ) {
    
            this.array.set( array );
    
            return this;
    
        },
    
        copyColorsArray: function ( colors ) {
    
            var array = this.array, offset = 0;
    
            for ( var i = 0, l = colors.length; i < l; i ++ ) {
    
                var color = colors[ i ];
    
                if ( color === undefined ) {
    
                    console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
                    color = new Color();
    
                }
    
                array[ offset ++ ] = color.r;
                array[ offset ++ ] = color.g;
                array[ offset ++ ] = color.b;
    
            }
    
            return this;
    
        },
    
        copyVector2sArray: function ( vectors ) {
    
            var array = this.array, offset = 0;
    
            for ( var i = 0, l = vectors.length; i < l; i ++ ) {
    
                var vector = vectors[ i ];
    
                if ( vector === undefined ) {
    
                    console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
                    vector = new Vector2();
    
                }
    
                array[ offset ++ ] = vector.x;
                array[ offset ++ ] = vector.y;
    
            }
    
            return this;
    
        },
    
        copyVector3sArray: function ( vectors ) {
    
            var array = this.array, offset = 0;
    
            for ( var i = 0, l = vectors.length; i < l; i ++ ) {
    
                var vector = vectors[ i ];
    
                if ( vector === undefined ) {
    
                    console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
                    vector = new Vector3();
    
                }
    
                array[ offset ++ ] = vector.x;
                array[ offset ++ ] = vector.y;
                array[ offset ++ ] = vector.z;
    
            }
    
            return this;
    
        },
    
        copyVector4sArray: function ( vectors ) {
    
            var array = this.array, offset = 0;
    
            for ( var i = 0, l = vectors.length; i < l; i ++ ) {
    
                var vector = vectors[ i ];
    
                if ( vector === undefined ) {
    
                    console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
                    vector = new Vector4();
    
                }
    
                array[ offset ++ ] = vector.x;
                array[ offset ++ ] = vector.y;
                array[ offset ++ ] = vector.z;
                array[ offset ++ ] = vector.w;
    
            }
    
            return this;
    
        },
    
        applyMatrix3: function ( m ) {
    
            for ( var i = 0, l = this.count; i < l; i ++ ) {
    
                _vector$3.x = this.getX( i );
                _vector$3.y = this.getY( i );
                _vector$3.z = this.getZ( i );
    
                _vector$3.applyMatrix3( m );
    
                this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );
    
            }
    
            return this;
    
        },
    
        applyMatrix4: function ( m ) {
    
            for ( var i = 0, l = this.count; i < l; i ++ ) {
    
                _vector$3.x = this.getX( i );
                _vector$3.y = this.getY( i );
                _vector$3.z = this.getZ( i );
    
                _vector$3.applyMatrix4( m );
    
                this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );
    
            }
    
            return this;
    
        },
    
        applyNormalMatrix: function ( m ) {
    
            for ( var i = 0, l = this.count; i < l; i ++ ) {
    
                _vector$3.x = this.getX( i );
                _vector$3.y = this.getY( i );
                _vector$3.z = this.getZ( i );
    
                _vector$3.applyNormalMatrix( m );
    
                this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );
    
            }
    
            return this;
    
        },
    
        transformDirection: function ( m ) {
    
            for ( var i = 0, l = this.count; i < l; i ++ ) {
    
                _vector$3.x = this.getX( i );
                _vector$3.y = this.getY( i );
                _vector$3.z = this.getZ( i );
    
                _vector$3.transformDirection( m );
    
                this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );
    
            }
    
            return this;
    
        },
    
        set: function ( value, offset ) {
    
            if ( offset === undefined ) offset = 0;
    
            this.array.set( value, offset );
    
            return this;
    
        },
    
        getX: function ( index ) {
    
            return this.array[ index * this.itemSize ];
    
        },
    
        setX: function ( index, x ) {
    
            this.array[ index * this.itemSize ] = x;
    
            return this;
    
        },
    
        getY: function ( index ) {
    
            return this.array[ index * this.itemSize + 1 ];
    
        },
    
        setY: function ( index, y ) {
    
            this.array[ index * this.itemSize + 1 ] = y;
    
            return this;
    
        },
    
        getZ: function ( index ) {
    
            return this.array[ index * this.itemSize + 2 ];
    
        },
    
        setZ: function ( index, z ) {
    
            this.array[ index * this.itemSize + 2 ] = z;
    
            return this;
    
        },
    
        getW: function ( index ) {
    
            return this.array[ index * this.itemSize + 3 ];
    
        },
    
        setW: function ( index, w ) {
    
            this.array[ index * this.itemSize + 3 ] = w;
    
            return this;
    
        },
    
        setXY: function ( index, x, y ) {
    
            index *= this.itemSize;
    
            this.array[ index + 0 ] = x;
            this.array[ index + 1 ] = y;
    
            return this;
    
        },
    
        setXYZ: function ( index, x, y, z ) {
    
            index *= this.itemSize;
    
            this.array[ index + 0 ] = x;
            this.array[ index + 1 ] = y;
            this.array[ index + 2 ] = z;
    
            return this;
    
        },
    
        setXYZW: function ( index, x, y, z, w ) {
    
            index *= this.itemSize;
    
            this.array[ index + 0 ] = x;
            this.array[ index + 1 ] = y;
            this.array[ index + 2 ] = z;
            this.array[ index + 3 ] = w;
    
            return this;
    
        },
    
        onUpload: function ( callback ) {
    
            this.onUploadCallback = callback;
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor( this.array, this.itemSize ).copy( this );
    
        },
    
        toJSON: function () {
    
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call( this.array ),
                normalized: this.normalized
            };
    
        }
    
    } );
    
    //
    
    function Int8BufferAttribute( array, itemSize, normalized ) {
    
        BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );
    
    }
    
    Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
    
    
    function Uint8BufferAttribute( array, itemSize, normalized ) {
    
        BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );
    
    }
    
    Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
    
    
    function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {
    
        BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );
    
    }
    
    Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
    
    
    function Int16BufferAttribute( array, itemSize, normalized ) {
    
        BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );
    
    }
    
    Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
    
    
    function Uint16BufferAttribute( array, itemSize, normalized ) {
    
        BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );
    
    }
    
    Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
    
    
    function Int32BufferAttribute( array, itemSize, normalized ) {
    
        BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );
    
    }
    
    Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
    
    
    function Uint32BufferAttribute( array, itemSize, normalized ) {
    
        BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );
    
    }
    
    Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
    
    
    function Float32BufferAttribute( array, itemSize, normalized ) {
    
        BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );
    
    }
    
    Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
    
    
    function Float64BufferAttribute( array, itemSize, normalized ) {
    
        BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );
    
    }
    
    Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function DirectGeometry() {
    
        this.vertices = [];
        this.normals = [];
        this.colors = [];
        this.uvs = [];
        this.uvs2 = [];
    
        this.groups = [];
    
        this.morphTargets = {};
    
        this.skinWeights = [];
        this.skinIndices = [];
    
        // this.lineDistances = [];
    
        this.boundingBox = null;
        this.boundingSphere = null;
    
        // update flags
    
        this.verticesNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.groupsNeedUpdate = false;
    
    }
    
    Object.assign( DirectGeometry.prototype, {
    
        computeGroups: function ( geometry ) {
    
            var group;
            var groups = [];
            var materialIndex = undefined;
    
            var faces = geometry.faces;
    
            for ( var i = 0; i < faces.length; i ++ ) {
    
                var face = faces[ i ];
    
                // materials
    
                if ( face.materialIndex !== materialIndex ) {
    
                    materialIndex = face.materialIndex;
    
                    if ( group !== undefined ) {
    
                        group.count = ( i * 3 ) - group.start;
                        groups.push( group );
    
                    }
    
                    group = {
                        start: i * 3,
                        materialIndex: materialIndex
                    };
    
                }
    
            }
    
            if ( group !== undefined ) {
    
                group.count = ( i * 3 ) - group.start;
                groups.push( group );
    
            }
    
            this.groups = groups;
    
        },
    
        fromGeometry: function ( geometry ) {
    
            var faces = geometry.faces;
            var vertices = geometry.vertices;
            var faceVertexUvs = geometry.faceVertexUvs;
    
            var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
            var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;
    
            // morphs
    
            var morphTargets = geometry.morphTargets;
            var morphTargetsLength = morphTargets.length;
    
            var morphTargetsPosition;
    
            if ( morphTargetsLength > 0 ) {
    
                morphTargetsPosition = [];
    
                for ( var i = 0; i < morphTargetsLength; i ++ ) {
    
                    morphTargetsPosition[ i ] = {
                        name: morphTargets[ i ].name,
                         data: []
                    };
    
                }
    
                this.morphTargets.position = morphTargetsPosition;
    
            }
    
            var morphNormals = geometry.morphNormals;
            var morphNormalsLength = morphNormals.length;
    
            var morphTargetsNormal;
    
            if ( morphNormalsLength > 0 ) {
    
                morphTargetsNormal = [];
    
                for ( var i = 0; i < morphNormalsLength; i ++ ) {
    
                    morphTargetsNormal[ i ] = {
                        name: morphNormals[ i ].name,
                         data: []
                    };
    
                }
    
                this.morphTargets.normal = morphTargetsNormal;
    
            }
    
            // skins
    
            var skinIndices = geometry.skinIndices;
            var skinWeights = geometry.skinWeights;
    
            var hasSkinIndices = skinIndices.length === vertices.length;
            var hasSkinWeights = skinWeights.length === vertices.length;
    
            //
    
            if ( vertices.length > 0 && faces.length === 0 ) {
    
                console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );
    
            }
    
            for ( var i = 0; i < faces.length; i ++ ) {
    
                var face = faces[ i ];
    
                this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
    
                var vertexNormals = face.vertexNormals;
    
                if ( vertexNormals.length === 3 ) {
    
                    this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
    
                } else {
    
                    var normal = face.normal;
    
                    this.normals.push( normal, normal, normal );
    
                }
    
                var vertexColors = face.vertexColors;
    
                if ( vertexColors.length === 3 ) {
    
                    this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
    
                } else {
    
                    var color = face.color;
    
                    this.colors.push( color, color, color );
    
                }
    
                if ( hasFaceVertexUv === true ) {
    
                    var vertexUvs = faceVertexUvs[ 0 ][ i ];
    
                    if ( vertexUvs !== undefined ) {
    
                        this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
    
                    } else {
    
                        console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
    
                        this.uvs.push( new Vector2(), new Vector2(), new Vector2() );
    
                    }
    
                }
    
                if ( hasFaceVertexUv2 === true ) {
    
                    var vertexUvs = faceVertexUvs[ 1 ][ i ];
    
                    if ( vertexUvs !== undefined ) {
    
                        this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
    
                    } else {
    
                        console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
    
                        this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );
    
                    }
    
                }
    
                // morphs
    
                for ( var j = 0; j < morphTargetsLength; j ++ ) {
    
                    var morphTarget = morphTargets[ j ].vertices;
    
                    morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
    
                }
    
                for ( var j = 0; j < morphNormalsLength; j ++ ) {
    
                    var morphNormal = morphNormals[ j ].vertexNormals[ i ];
    
                    morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );
    
                }
    
                // skins
    
                if ( hasSkinIndices ) {
    
                    this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
    
                }
    
                if ( hasSkinWeights ) {
    
                    this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
    
                }
    
            }
    
            this.computeGroups( geometry );
    
            this.verticesNeedUpdate = geometry.verticesNeedUpdate;
            this.normalsNeedUpdate = geometry.normalsNeedUpdate;
            this.colorsNeedUpdate = geometry.colorsNeedUpdate;
            this.uvsNeedUpdate = geometry.uvsNeedUpdate;
            this.groupsNeedUpdate = geometry.groupsNeedUpdate;
    
            if ( geometry.boundingSphere !== null ) {
    
                this.boundingSphere = geometry.boundingSphere.clone();
    
            }
    
            if ( geometry.boundingBox !== null ) {
    
                this.boundingBox = geometry.boundingBox.clone();
    
            }
    
            return this;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function arrayMax( array ) {
    
        if ( array.length === 0 ) return - Infinity;
    
        var max = array[ 0 ];
    
        for ( var i = 1, l = array.length; i < l; ++ i ) {
    
            if ( array[ i ] > max ) max = array[ i ];
    
        }
    
        return max;
    
    }
    
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    
    var _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id
    
    var _m1$2 = new Matrix4();
    var _obj = new Object3D();
    var _offset = new Vector3();
    var _box$2 = new Box3();
    var _boxMorphTargets = new Box3();
    var _vector$4 = new Vector3();
    
    function BufferGeometry() {
    
        Object.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );
    
        this.uuid = MathUtils.generateUUID();
    
        this.name = '';
        this.type = 'BufferGeometry';
    
        this.index = null;
        this.attributes = {};
    
        this.morphAttributes = {};
        this.morphTargetsRelative = false;
    
        this.groups = [];
    
        this.boundingBox = null;
        this.boundingSphere = null;
    
        this.drawRange = { start: 0, count: Infinity };
    
        this.userData = {};
    
    }
    
    BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
    
        constructor: BufferGeometry,
    
        isBufferGeometry: true,
    
        getIndex: function () {
    
            return this.index;
    
        },
    
        setIndex: function ( index ) {
    
            if ( Array.isArray( index ) ) {
    
                this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );
    
            } else {
    
                this.index = index;
    
            }
    
        },
    
        getAttribute: function ( name ) {
    
            return this.attributes[ name ];
    
        },
    
        setAttribute: function ( name, attribute ) {
    
            this.attributes[ name ] = attribute;
    
            return this;
    
        },
    
        deleteAttribute: function ( name ) {
    
            delete this.attributes[ name ];
    
            return this;
    
        },
    
        addGroup: function ( start, count, materialIndex ) {
    
            this.groups.push( {
    
                start: start,
                count: count,
                materialIndex: materialIndex !== undefined ? materialIndex : 0
    
            } );
    
        },
    
        clearGroups: function () {
    
            this.groups = [];
    
        },
    
        setDrawRange: function ( start, count ) {
    
            this.drawRange.start = start;
            this.drawRange.count = count;
    
        },
    
        applyMatrix4: function ( matrix ) {
    
            var position = this.attributes.position;
    
            if ( position !== undefined ) {
    
                position.applyMatrix4( matrix );
    
                position.needsUpdate = true;
    
            }
    
            var normal = this.attributes.normal;
    
            if ( normal !== undefined ) {
    
                var normalMatrix = new Matrix3().getNormalMatrix( matrix );
    
                normal.applyNormalMatrix( normalMatrix );
    
                normal.needsUpdate = true;
    
            }
    
            var tangent = this.attributes.tangent;
    
            if ( tangent !== undefined ) {
    
                tangent.transformDirection( matrix );
    
                tangent.needsUpdate = true;
    
            }
    
            if ( this.boundingBox !== null ) {
    
                this.computeBoundingBox();
    
            }
    
            if ( this.boundingSphere !== null ) {
    
                this.computeBoundingSphere();
    
            }
    
            return this;
    
        },
    
        rotateX: function ( angle ) {
    
            // rotate geometry around world x-axis
    
            _m1$2.makeRotationX( angle );
    
            this.applyMatrix4( _m1$2 );
    
            return this;
    
        },
    
        rotateY: function ( angle ) {
    
            // rotate geometry around world y-axis
    
            _m1$2.makeRotationY( angle );
    
            this.applyMatrix4( _m1$2 );
    
            return this;
    
        },
    
        rotateZ: function ( angle ) {
    
            // rotate geometry around world z-axis
    
            _m1$2.makeRotationZ( angle );
    
            this.applyMatrix4( _m1$2 );
    
            return this;
    
        },
    
        translate: function ( x, y, z ) {
    
            // translate geometry
    
            _m1$2.makeTranslation( x, y, z );
    
            this.applyMatrix4( _m1$2 );
    
            return this;
    
        },
    
        scale: function ( x, y, z ) {
    
            // scale geometry
    
            _m1$2.makeScale( x, y, z );
    
            this.applyMatrix4( _m1$2 );
    
            return this;
    
        },
    
        lookAt: function ( vector ) {
    
            _obj.lookAt( vector );
    
            _obj.updateMatrix();
    
            this.applyMatrix4( _obj.matrix );
    
            return this;
    
        },
    
        center: function () {
    
            this.computeBoundingBox();
    
            this.boundingBox.getCenter( _offset ).negate();
    
            this.translate( _offset.x, _offset.y, _offset.z );
    
            return this;
    
        },
    
        setFromObject: function ( object ) {
    
            // console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
    
            var geometry = object.geometry;
    
            if ( object.isPoints || object.isLine ) {
    
                var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
                var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );
    
                this.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
                this.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
    
                if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {
    
                    var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );
    
                    this.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
    
                }
    
                if ( geometry.boundingSphere !== null ) {
    
                    this.boundingSphere = geometry.boundingSphere.clone();
    
                }
    
                if ( geometry.boundingBox !== null ) {
    
                    this.boundingBox = geometry.boundingBox.clone();
    
                }
    
            } else if ( object.isMesh ) {
    
                if ( geometry && geometry.isGeometry ) {
    
                    this.fromGeometry( geometry );
    
                }
    
            }
    
            return this;
    
        },
    
        setFromPoints: function ( points ) {
    
            var position = [];
    
            for ( var i = 0, l = points.length; i < l; i ++ ) {
    
                var point = points[ i ];
                position.push( point.x, point.y, point.z || 0 );
    
            }
    
            this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );
    
            return this;
    
        },
    
        updateFromObject: function ( object ) {
    
            var geometry = object.geometry;
    
            if ( object.isMesh ) {
    
                var direct = geometry.__directGeometry;
    
                if ( geometry.elementsNeedUpdate === true ) {
    
                    direct = undefined;
                    geometry.elementsNeedUpdate = false;
    
                }
    
                if ( direct === undefined ) {
    
                    return this.fromGeometry( geometry );
    
                }
    
                direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
                direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
                direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
                direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
                direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
    
                geometry.verticesNeedUpdate = false;
                geometry.normalsNeedUpdate = false;
                geometry.colorsNeedUpdate = false;
                geometry.uvsNeedUpdate = false;
                geometry.groupsNeedUpdate = false;
    
                geometry = direct;
    
            }
    
            var attribute;
    
            if ( geometry.verticesNeedUpdate === true ) {
    
                attribute = this.attributes.position;
    
                if ( attribute !== undefined ) {
    
                    attribute.copyVector3sArray( geometry.vertices );
                    attribute.needsUpdate = true;
    
                }
    
                geometry.verticesNeedUpdate = false;
    
            }
    
            if ( geometry.normalsNeedUpdate === true ) {
    
                attribute = this.attributes.normal;
    
                if ( attribute !== undefined ) {
    
                    attribute.copyVector3sArray( geometry.normals );
                    attribute.needsUpdate = true;
    
                }
    
                geometry.normalsNeedUpdate = false;
    
            }
    
            if ( geometry.colorsNeedUpdate === true ) {
    
                attribute = this.attributes.color;
    
                if ( attribute !== undefined ) {
    
                    attribute.copyColorsArray( geometry.colors );
                    attribute.needsUpdate = true;
    
                }
    
                geometry.colorsNeedUpdate = false;
    
            }
    
            if ( geometry.uvsNeedUpdate ) {
    
                attribute = this.attributes.uv;
    
                if ( attribute !== undefined ) {
    
                    attribute.copyVector2sArray( geometry.uvs );
                    attribute.needsUpdate = true;
    
                }
    
                geometry.uvsNeedUpdate = false;
    
            }
    
            if ( geometry.lineDistancesNeedUpdate ) {
    
                attribute = this.attributes.lineDistance;
    
                if ( attribute !== undefined ) {
    
                    attribute.copyArray( geometry.lineDistances );
                    attribute.needsUpdate = true;
    
                }
    
                geometry.lineDistancesNeedUpdate = false;
    
            }
    
            if ( geometry.groupsNeedUpdate ) {
    
                geometry.computeGroups( object.geometry );
                this.groups = geometry.groups;
    
                geometry.groupsNeedUpdate = false;
    
            }
    
            return this;
    
        },
    
        fromGeometry: function ( geometry ) {
    
            geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );
    
            return this.fromDirectGeometry( geometry.__directGeometry );
    
        },
    
        fromDirectGeometry: function ( geometry ) {
    
            var positions = new Float32Array( geometry.vertices.length * 3 );
            this.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
    
            if ( geometry.normals.length > 0 ) {
    
                var normals = new Float32Array( geometry.normals.length * 3 );
                this.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
    
            }
    
            if ( geometry.colors.length > 0 ) {
    
                var colors = new Float32Array( geometry.colors.length * 3 );
                this.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
    
            }
    
            if ( geometry.uvs.length > 0 ) {
    
                var uvs = new Float32Array( geometry.uvs.length * 2 );
                this.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
    
            }
    
            if ( geometry.uvs2.length > 0 ) {
    
                var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
                this.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
    
            }
    
            // groups
    
            this.groups = geometry.groups;
    
            // morphs
    
            for ( var name in geometry.morphTargets ) {
    
                var array = [];
                var morphTargets = geometry.morphTargets[ name ];
    
                for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {
    
                    var morphTarget = morphTargets[ i ];
    
                    var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
                    attribute.name = morphTarget.name;
    
                    array.push( attribute.copyVector3sArray( morphTarget.data ) );
    
                }
    
                this.morphAttributes[ name ] = array;
    
            }
    
            // skinning
    
            if ( geometry.skinIndices.length > 0 ) {
    
                var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
                this.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
    
            }
    
            if ( geometry.skinWeights.length > 0 ) {
    
                var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
                this.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
    
            }
    
            //
    
            if ( geometry.boundingSphere !== null ) {
    
                this.boundingSphere = geometry.boundingSphere.clone();
    
            }
    
            if ( geometry.boundingBox !== null ) {
    
                this.boundingBox = geometry.boundingBox.clone();
    
            }
    
            return this;
    
        },
    
        computeBoundingBox: function () {
    
            if ( this.boundingBox === null ) {
    
                this.boundingBox = new Box3();
    
            }
    
            var position = this.attributes.position;
            var morphAttributesPosition = this.morphAttributes.position;
    
            if ( position !== undefined ) {
    
                this.boundingBox.setFromBufferAttribute( position );
    
                // process morph attributes if present
    
                if ( morphAttributesPosition ) {
    
                    for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {
    
                        var morphAttribute = morphAttributesPosition[ i ];
                        _box$2.setFromBufferAttribute( morphAttribute );
    
                        if ( this.morphTargetsRelative ) {
    
                            _vector$4.addVectors( this.boundingBox.min, _box$2.min );
                            this.boundingBox.expandByPoint( _vector$4 );
    
                            _vector$4.addVectors( this.boundingBox.max, _box$2.max );
                            this.boundingBox.expandByPoint( _vector$4 );
    
                        } else {
    
                            this.boundingBox.expandByPoint( _box$2.min );
                            this.boundingBox.expandByPoint( _box$2.max );
    
                        }
    
                    }
    
                }
    
            } else {
    
                this.boundingBox.makeEmpty();
    
            }
    
            if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
    
                console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
    
            }
    
        },
    
        computeBoundingSphere: function () {
    
            if ( this.boundingSphere === null ) {
    
                this.boundingSphere = new Sphere();
    
            }
    
            var position = this.attributes.position;
            var morphAttributesPosition = this.morphAttributes.position;
    
            if ( position ) {
    
                // first, find the center of the bounding sphere
    
                var center = this.boundingSphere.center;
    
                _box$2.setFromBufferAttribute( position );
    
                // process morph attributes if present
    
                if ( morphAttributesPosition ) {
    
                    for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {
    
                        var morphAttribute = morphAttributesPosition[ i ];
                        _boxMorphTargets.setFromBufferAttribute( morphAttribute );
    
                        if ( this.morphTargetsRelative ) {
    
                            _vector$4.addVectors( _box$2.min, _boxMorphTargets.min );
                            _box$2.expandByPoint( _vector$4 );
    
                            _vector$4.addVectors( _box$2.max, _boxMorphTargets.max );
                            _box$2.expandByPoint( _vector$4 );
    
                        } else {
    
                            _box$2.expandByPoint( _boxMorphTargets.min );
                            _box$2.expandByPoint( _boxMorphTargets.max );
    
                        }
    
                    }
    
                }
    
                _box$2.getCenter( center );
    
                // second, try to find a boundingSphere with a radius smaller than the
                // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
    
                var maxRadiusSq = 0;
    
                for ( var i = 0, il = position.count; i < il; i ++ ) {
    
                    _vector$4.fromBufferAttribute( position, i );
    
                    maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );
    
                }
    
                // process morph attributes if present
    
                if ( morphAttributesPosition ) {
    
                    for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {
    
                        var morphAttribute = morphAttributesPosition[ i ];
                        var morphTargetsRelative = this.morphTargetsRelative;
    
                        for ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {
    
                            _vector$4.fromBufferAttribute( morphAttribute, j );
    
                            if ( morphTargetsRelative ) {
    
                                _offset.fromBufferAttribute( position, j );
                                _vector$4.add( _offset );
    
                            }
    
                            maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );
    
                        }
    
                    }
    
                }
    
                this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
    
                if ( isNaN( this.boundingSphere.radius ) ) {
    
                    console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
    
                }
    
            }
    
        },
    
        computeFaceNormals: function () {
    
            // backwards compatibility
    
        },
    
        computeVertexNormals: function () {
    
            var index = this.index;
            var attributes = this.attributes;
    
            if ( attributes.position ) {
    
                var positions = attributes.position.array;
    
                if ( attributes.normal === undefined ) {
    
                    this.setAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );
    
                } else {
    
                    // reset existing normals to zero
    
                    var array = attributes.normal.array;
    
                    for ( var i = 0, il = array.length; i < il; i ++ ) {
    
                        array[ i ] = 0;
    
                    }
    
                }
    
                var normals = attributes.normal.array;
    
                var vA, vB, vC;
                var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
                var cb = new Vector3(), ab = new Vector3();
    
                // indexed elements
    
                if ( index ) {
    
                    var indices = index.array;
    
                    for ( var i = 0, il = index.count; i < il; i += 3 ) {
    
                        vA = indices[ i + 0 ] * 3;
                        vB = indices[ i + 1 ] * 3;
                        vC = indices[ i + 2 ] * 3;
    
                        pA.fromArray( positions, vA );
                        pB.fromArray( positions, vB );
                        pC.fromArray( positions, vC );
    
                        cb.subVectors( pC, pB );
                        ab.subVectors( pA, pB );
                        cb.cross( ab );
    
                        normals[ vA ] += cb.x;
                        normals[ vA + 1 ] += cb.y;
                        normals[ vA + 2 ] += cb.z;
    
                        normals[ vB ] += cb.x;
                        normals[ vB + 1 ] += cb.y;
                        normals[ vB + 2 ] += cb.z;
    
                        normals[ vC ] += cb.x;
                        normals[ vC + 1 ] += cb.y;
                        normals[ vC + 2 ] += cb.z;
    
                    }
    
                } else {
    
                    // non-indexed elements (unconnected triangle soup)
    
                    for ( var i = 0, il = positions.length; i < il; i += 9 ) {
    
                        pA.fromArray( positions, i );
                        pB.fromArray( positions, i + 3 );
                        pC.fromArray( positions, i + 6 );
    
                        cb.subVectors( pC, pB );
                        ab.subVectors( pA, pB );
                        cb.cross( ab );
    
                        normals[ i ] = cb.x;
                        normals[ i + 1 ] = cb.y;
                        normals[ i + 2 ] = cb.z;
    
                        normals[ i + 3 ] = cb.x;
                        normals[ i + 4 ] = cb.y;
                        normals[ i + 5 ] = cb.z;
    
                        normals[ i + 6 ] = cb.x;
                        normals[ i + 7 ] = cb.y;
                        normals[ i + 8 ] = cb.z;
    
                    }
    
                }
    
                this.normalizeNormals();
    
                attributes.normal.needsUpdate = true;
    
            }
    
        },
    
        merge: function ( geometry, offset ) {
    
            if ( ! ( geometry && geometry.isBufferGeometry ) ) {
    
                console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
                return;
    
            }
    
            if ( offset === undefined ) {
    
                offset = 0;
    
                console.warn(
                    'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
                    + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
                );
    
            }
    
            var attributes = this.attributes;
    
            for ( var key in attributes ) {
    
                if ( geometry.attributes[ key ] === undefined ) continue;
    
                var attribute1 = attributes[ key ];
                var attributeArray1 = attribute1.array;
    
                var attribute2 = geometry.attributes[ key ];
                var attributeArray2 = attribute2.array;
    
                var attributeOffset = attribute2.itemSize * offset;
                var length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );
    
                for ( var i = 0, j = attributeOffset; i < length; i ++, j ++ ) {
    
                    attributeArray1[ j ] = attributeArray2[ i ];
    
                }
    
            }
    
            return this;
    
        },
    
        normalizeNormals: function () {
    
            var normals = this.attributes.normal;
    
            for ( var i = 0, il = normals.count; i < il; i ++ ) {
    
                _vector$4.x = normals.getX( i );
                _vector$4.y = normals.getY( i );
                _vector$4.z = normals.getZ( i );
    
                _vector$4.normalize();
    
                normals.setXYZ( i, _vector$4.x, _vector$4.y, _vector$4.z );
    
            }
    
        },
    
        toNonIndexed: function () {
    
            function convertBufferAttribute( attribute, indices ) {
    
                var array = attribute.array;
                var itemSize = attribute.itemSize;
    
                var array2 = new array.constructor( indices.length * itemSize );
    
                var index = 0, index2 = 0;
    
                for ( var i = 0, l = indices.length; i < l; i ++ ) {
    
                    index = indices[ i ] * itemSize;
    
                    for ( var j = 0; j < itemSize; j ++ ) {
    
                        array2[ index2 ++ ] = array[ index ++ ];
    
                    }
    
                }
    
                return new BufferAttribute( array2, itemSize );
    
            }
    
            //
    
            if ( this.index === null ) {
    
                console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
                return this;
    
            }
    
            var geometry2 = new BufferGeometry();
    
            var indices = this.index.array;
            var attributes = this.attributes;
    
            // attributes
    
            for ( var name in attributes ) {
    
                var attribute = attributes[ name ];
    
                var newAttribute = convertBufferAttribute( attribute, indices );
    
                geometry2.setAttribute( name, newAttribute );
    
            }
    
            // morph attributes
    
            var morphAttributes = this.morphAttributes;
    
            for ( name in morphAttributes ) {
    
                var morphArray = [];
                var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes
    
                for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {
    
                    var attribute = morphAttribute[ i ];
    
                    var newAttribute = convertBufferAttribute( attribute, indices );
    
                    morphArray.push( newAttribute );
    
                }
    
                geometry2.morphAttributes[ name ] = morphArray;
    
            }
    
            geometry2.morphTargetsRelative = this.morphTargetsRelative;
    
            // groups
    
            var groups = this.groups;
    
            for ( var i = 0, l = groups.length; i < l; i ++ ) {
    
                var group = groups[ i ];
                geometry2.addGroup( group.start, group.count, group.materialIndex );
    
            }
    
            return geometry2;
    
        },
    
        toJSON: function () {
    
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'BufferGeometry',
                    generator: 'BufferGeometry.toJSON'
                }
            };
    
            // standard BufferGeometry serialization
    
            data.uuid = this.uuid;
            data.type = this.type;
            if ( this.name !== '' ) data.name = this.name;
            if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;
    
            if ( this.parameters !== undefined ) {
    
                var parameters = this.parameters;
    
                for ( var key in parameters ) {
    
                    if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
    
                }
    
                return data;
    
            }
    
            data.data = { attributes: {} };
    
            var index = this.index;
    
            if ( index !== null ) {
    
                data.data.index = {
                    type: index.array.constructor.name,
                    array: Array.prototype.slice.call( index.array )
                };
    
            }
    
            var attributes = this.attributes;
    
            for ( var key in attributes ) {
    
                var attribute = attributes[ key ];
    
                var attributeData = attribute.toJSON();
    
                if ( attribute.name !== '' ) attributeData.name = attribute.name;
    
                data.data.attributes[ key ] = attributeData;
    
            }
    
            var morphAttributes = {};
            var hasMorphAttributes = false;
    
            for ( var key in this.morphAttributes ) {
    
                var attributeArray = this.morphAttributes[ key ];
    
                var array = [];
    
                for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {
    
                    var attribute = attributeArray[ i ];
    
                    var attributeData = attribute.toJSON();
    
                    if ( attribute.name !== '' ) attributeData.name = attribute.name;
    
                    array.push( attributeData );
    
                }
    
                if ( array.length > 0 ) {
    
                    morphAttributes[ key ] = array;
    
                    hasMorphAttributes = true;
    
                }
    
            }
    
            if ( hasMorphAttributes ) {
    
                data.data.morphAttributes = morphAttributes;
                data.data.morphTargetsRelative = this.morphTargetsRelative;
    
            }
    
            var groups = this.groups;
    
            if ( groups.length > 0 ) {
    
                data.data.groups = JSON.parse( JSON.stringify( groups ) );
    
            }
    
            var boundingSphere = this.boundingSphere;
    
            if ( boundingSphere !== null ) {
    
                data.data.boundingSphere = {
                    center: boundingSphere.center.toArray(),
                    radius: boundingSphere.radius
                };
    
            }
    
            return data;
    
        },
    
        clone: function () {
    
            /*
             // Handle primitives
    
             var parameters = this.parameters;
    
             if ( parameters !== undefined ) {
    
             var values = [];
    
             for ( var key in parameters ) {
    
             values.push( parameters[ key ] );
    
             }
    
             var geometry = Object.create( this.constructor.prototype );
             this.constructor.apply( geometry, values );
             return geometry;
    
             }
    
             return new this.constructor().copy( this );
             */
    
            return new BufferGeometry().copy( this );
    
        },
    
        copy: function ( source ) {
    
            var name, i, l;
    
            // reset
    
            this.index = null;
            this.attributes = {};
            this.morphAttributes = {};
            this.groups = [];
            this.boundingBox = null;
            this.boundingSphere = null;
    
            // name
    
            this.name = source.name;
    
            // index
    
            var index = source.index;
    
            if ( index !== null ) {
    
                this.setIndex( index.clone() );
    
            }
    
            // attributes
    
            var attributes = source.attributes;
    
            for ( name in attributes ) {
    
                var attribute = attributes[ name ];
                this.setAttribute( name, attribute.clone() );
    
            }
    
            // morph attributes
    
            var morphAttributes = source.morphAttributes;
    
            for ( name in morphAttributes ) {
    
                var array = [];
                var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes
    
                for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {
    
                    array.push( morphAttribute[ i ].clone() );
    
                }
    
                this.morphAttributes[ name ] = array;
    
            }
    
            this.morphTargetsRelative = source.morphTargetsRelative;
    
            // groups
    
            var groups = source.groups;
    
            for ( i = 0, l = groups.length; i < l; i ++ ) {
    
                var group = groups[ i ];
                this.addGroup( group.start, group.count, group.materialIndex );
    
            }
    
            // bounding box
    
            var boundingBox = source.boundingBox;
    
            if ( boundingBox !== null ) {
    
                this.boundingBox = boundingBox.clone();
    
            }
    
            // bounding sphere
    
            var boundingSphere = source.boundingSphere;
    
            if ( boundingSphere !== null ) {
    
                this.boundingSphere = boundingSphere.clone();
    
            }
    
            // draw range
    
            this.drawRange.start = source.drawRange.start;
            this.drawRange.count = source.drawRange.count;
    
            // user data
    
            this.userData = source.userData;
    
            return this;
    
        },
    
        dispose: function () {
    
            this.dispatchEvent( { type: 'dispose' } );
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author jonobr1 / http://jonobr1.com/
     */
    
    var _inverseMatrix = new Matrix4();
    var _ray = new Ray();
    var _sphere = new Sphere();
    
    var _vA = new Vector3();
    var _vB = new Vector3();
    var _vC = new Vector3();
    
    var _tempA = new Vector3();
    var _tempB = new Vector3();
    var _tempC = new Vector3();
    
    var _morphA = new Vector3();
    var _morphB = new Vector3();
    var _morphC = new Vector3();
    
    var _uvA = new Vector2();
    var _uvB = new Vector2();
    var _uvC = new Vector2();
    
    var _intersectionPoint = new Vector3();
    var _intersectionPointWorld = new Vector3();
    
    function Mesh( geometry, material ) {
    
        Object3D.call( this );
    
        this.type = 'Mesh';
    
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new MeshBasicMaterial();
    
        this.updateMorphTargets();
    
    }
    
    Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: Mesh,
    
        isMesh: true,
    
        copy: function ( source ) {
    
            Object3D.prototype.copy.call( this, source );
    
            if ( source.morphTargetInfluences !== undefined ) {
    
                this.morphTargetInfluences = source.morphTargetInfluences.slice();
    
            }
    
            if ( source.morphTargetDictionary !== undefined ) {
    
                this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );
    
            }
    
            return this;
    
        },
    
        updateMorphTargets: function () {
    
            var geometry = this.geometry;
            var m, ml, name;
    
            if ( geometry.isBufferGeometry ) {
    
                var morphAttributes = geometry.morphAttributes;
                var keys = Object.keys( morphAttributes );
    
                if ( keys.length > 0 ) {
    
                    var morphAttribute = morphAttributes[ keys[ 0 ] ];
    
                    if ( morphAttribute !== undefined ) {
    
                        this.morphTargetInfluences = [];
                        this.morphTargetDictionary = {};
    
                        for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {
    
                            name = morphAttribute[ m ].name || String( m );
    
                            this.morphTargetInfluences.push( 0 );
                            this.morphTargetDictionary[ name ] = m;
    
                        }
    
                    }
    
                }
    
            } else {
    
                var morphTargets = geometry.morphTargets;
    
                if ( morphTargets !== undefined && morphTargets.length > 0 ) {
    
                    console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
    
                }
    
            }
    
        },
    
        raycast: function ( raycaster, intersects ) {
    
            var geometry = this.geometry;
            var material = this.material;
            var matrixWorld = this.matrixWorld;
    
            if ( material === undefined ) return;
    
            // Checking boundingSphere distance to ray
    
            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
    
            _sphere.copy( geometry.boundingSphere );
            _sphere.applyMatrix4( matrixWorld );
    
            if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;
    
            //
    
            _inverseMatrix.getInverse( matrixWorld );
            _ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );
    
            // Check boundingBox before continuing
    
            if ( geometry.boundingBox !== null ) {
    
                if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;
    
            }
    
            var intersection;
    
            if ( geometry.isBufferGeometry ) {
    
                var a, b, c;
                var index = geometry.index;
                var position = geometry.attributes.position;
                var morphPosition = geometry.morphAttributes.position;
                var morphTargetsRelative = geometry.morphTargetsRelative;
                var uv = geometry.attributes.uv;
                var uv2 = geometry.attributes.uv2;
                var groups = geometry.groups;
                var drawRange = geometry.drawRange;
                var i, j, il, jl;
                var group, groupMaterial;
                var start, end;
    
                if ( index !== null ) {
    
                    // indexed buffer geometry
    
                    if ( Array.isArray( material ) ) {
    
                        for ( i = 0, il = groups.length; i < il; i ++ ) {
    
                            group = groups[ i ];
                            groupMaterial = material[ group.materialIndex ];
    
                            start = Math.max( group.start, drawRange.start );
                            end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );
    
                            for ( j = start, jl = end; j < jl; j += 3 ) {
    
                                a = index.getX( j );
                                b = index.getX( j + 1 );
                                c = index.getX( j + 2 );
    
                                intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );
    
                                if ( intersection ) {
    
                                    intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
                                    intersection.face.materialIndex = group.materialIndex;
                                    intersects.push( intersection );
    
                                }
    
                            }
    
                        }
    
                    } else {
    
                        start = Math.max( 0, drawRange.start );
                        end = Math.min( index.count, ( drawRange.start + drawRange.count ) );
    
                        for ( i = start, il = end; i < il; i += 3 ) {
    
                            a = index.getX( i );
                            b = index.getX( i + 1 );
                            c = index.getX( i + 2 );
    
                            intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );
    
                            if ( intersection ) {
    
                                intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
                                intersects.push( intersection );
    
                            }
    
                        }
    
                    }
    
                } else if ( position !== undefined ) {
    
                    // non-indexed buffer geometry
    
                    if ( Array.isArray( material ) ) {
    
                        for ( i = 0, il = groups.length; i < il; i ++ ) {
    
                            group = groups[ i ];
                            groupMaterial = material[ group.materialIndex ];
    
                            start = Math.max( group.start, drawRange.start );
                            end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );
    
                            for ( j = start, jl = end; j < jl; j += 3 ) {
    
                                a = j;
                                b = j + 1;
                                c = j + 2;
    
                                intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );
    
                                if ( intersection ) {
    
                                    intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
                                    intersection.face.materialIndex = group.materialIndex;
                                    intersects.push( intersection );
    
                                }
    
                            }
    
                        }
    
                    } else {
    
                        start = Math.max( 0, drawRange.start );
                        end = Math.min( position.count, ( drawRange.start + drawRange.count ) );
    
                        for ( i = start, il = end; i < il; i += 3 ) {
    
                            a = i;
                            b = i + 1;
                            c = i + 2;
    
                            intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );
    
                            if ( intersection ) {
    
                                intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
                                intersects.push( intersection );
    
                            }
    
                        }
    
                    }
    
                }
    
            } else if ( geometry.isGeometry ) {
    
                var fvA, fvB, fvC;
                var isMultiMaterial = Array.isArray( material );
    
                var vertices = geometry.vertices;
                var faces = geometry.faces;
                var uvs;
    
                var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
                if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
    
                for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
    
                    var face = faces[ f ];
                    var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;
    
                    if ( faceMaterial === undefined ) continue;
    
                    fvA = vertices[ face.a ];
                    fvB = vertices[ face.b ];
                    fvC = vertices[ face.c ];
    
                    intersection = checkIntersection( this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint );
    
                    if ( intersection ) {
    
                        if ( uvs && uvs[ f ] ) {
    
                            var uvs_f = uvs[ f ];
                            _uvA.copy( uvs_f[ 0 ] );
                            _uvB.copy( uvs_f[ 1 ] );
                            _uvC.copy( uvs_f[ 2 ] );
    
                            intersection.uv = Triangle.getUV( _intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2() );
    
                        }
    
                        intersection.face = face;
                        intersection.faceIndex = f;
                        intersects.push( intersection );
    
                    }
    
                }
    
            }
    
        },
    
        clone: function () {
    
            return new this.constructor( this.geometry, this.material ).copy( this );
    
        }
    
    } );
    
    function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {
    
        var intersect;
    
        if ( material.side === BackSide ) {
    
            intersect = ray.intersectTriangle( pC, pB, pA, true, point );
    
        } else {
    
            intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );
    
        }
    
        if ( intersect === null ) return null;
    
        _intersectionPointWorld.copy( point );
        _intersectionPointWorld.applyMatrix4( object.matrixWorld );
    
        var distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );
    
        if ( distance < raycaster.near || distance > raycaster.far ) return null;
    
        return {
            distance: distance,
            point: _intersectionPointWorld.clone(),
            object: object
        };
    
    }
    
    function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {
    
        _vA.fromBufferAttribute( position, a );
        _vB.fromBufferAttribute( position, b );
        _vC.fromBufferAttribute( position, c );
    
        var morphInfluences = object.morphTargetInfluences;
    
        if ( material.morphTargets && morphPosition && morphInfluences ) {
    
            _morphA.set( 0, 0, 0 );
            _morphB.set( 0, 0, 0 );
            _morphC.set( 0, 0, 0 );
    
            for ( var i = 0, il = morphPosition.length; i < il; i ++ ) {
    
                var influence = morphInfluences[ i ];
                var morphAttribute = morphPosition[ i ];
    
                if ( influence === 0 ) continue;
    
                _tempA.fromBufferAttribute( morphAttribute, a );
                _tempB.fromBufferAttribute( morphAttribute, b );
                _tempC.fromBufferAttribute( morphAttribute, c );
    
                if ( morphTargetsRelative ) {
    
                    _morphA.addScaledVector( _tempA, influence );
                    _morphB.addScaledVector( _tempB, influence );
                    _morphC.addScaledVector( _tempC, influence );
    
                } else {
    
                    _morphA.addScaledVector( _tempA.sub( _vA ), influence );
                    _morphB.addScaledVector( _tempB.sub( _vB ), influence );
                    _morphC.addScaledVector( _tempC.sub( _vC ), influence );
    
                }
    
            }
    
            _vA.add( _morphA );
            _vB.add( _morphB );
            _vC.add( _morphC );
    
        }
    
        var intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );
    
        if ( intersection ) {
    
            if ( uv ) {
    
                _uvA.fromBufferAttribute( uv, a );
                _uvB.fromBufferAttribute( uv, b );
                _uvC.fromBufferAttribute( uv, c );
    
                intersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );
    
            }
    
            if ( uv2 ) {
    
                _uvA.fromBufferAttribute( uv2, a );
                _uvB.fromBufferAttribute( uv2, b );
                _uvC.fromBufferAttribute( uv2, c );
    
                intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );
    
            }
    
            var face = new Face3( a, b, c );
            Triangle.getNormal( _vA, _vB, _vC, face.normal );
    
            intersection.face = face;
    
        }
    
        return intersection;
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author kile / http://kile.stravaganza.org/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author bhouston / http://clara.io
     */
    
    var _geometryId = 0; // Geometry uses even numbers as Id
    var _m1$3 = new Matrix4();
    var _obj$1 = new Object3D();
    var _offset$1 = new Vector3();
    
    function Geometry() {
    
        Object.defineProperty( this, 'id', { value: _geometryId += 2 } );
    
        this.uuid = MathUtils.generateUUID();
    
        this.name = '';
        this.type = 'Geometry';
    
        this.vertices = [];
        this.colors = [];
        this.faces = [];
        this.faceVertexUvs = [[]];
    
        this.morphTargets = [];
        this.morphNormals = [];
    
        this.skinWeights = [];
        this.skinIndices = [];
    
        this.lineDistances = [];
    
        this.boundingBox = null;
        this.boundingSphere = null;
    
        // update flags
    
        this.elementsNeedUpdate = false;
        this.verticesNeedUpdate = false;
        this.uvsNeedUpdate = false;
        this.normalsNeedUpdate = false;
        this.colorsNeedUpdate = false;
        this.lineDistancesNeedUpdate = false;
        this.groupsNeedUpdate = false;
    
    }
    
    Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
    
        constructor: Geometry,
    
        isGeometry: true,
    
        applyMatrix4: function ( matrix ) {
    
            var normalMatrix = new Matrix3().getNormalMatrix( matrix );
    
            for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
    
                var vertex = this.vertices[ i ];
                vertex.applyMatrix4( matrix );
    
            }
    
            for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
    
                var face = this.faces[ i ];
                face.normal.applyMatrix3( normalMatrix ).normalize();
    
                for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
    
                    face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
    
                }
    
            }
    
            if ( this.boundingBox !== null ) {
    
                this.computeBoundingBox();
    
            }
    
            if ( this.boundingSphere !== null ) {
    
                this.computeBoundingSphere();
    
            }
    
            this.verticesNeedUpdate = true;
            this.normalsNeedUpdate = true;
    
            return this;
    
        },
    
        rotateX: function ( angle ) {
    
            // rotate geometry around world x-axis
    
            _m1$3.makeRotationX( angle );
    
            this.applyMatrix4( _m1$3 );
    
            return this;
    
        },
    
        rotateY: function ( angle ) {
    
            // rotate geometry around world y-axis
    
            _m1$3.makeRotationY( angle );
    
            this.applyMatrix4( _m1$3 );
    
            return this;
    
        },
    
        rotateZ: function ( angle ) {
    
            // rotate geometry around world z-axis
    
            _m1$3.makeRotationZ( angle );
    
            this.applyMatrix4( _m1$3 );
    
            return this;
    
        },
    
        translate: function ( x, y, z ) {
    
            // translate geometry
    
            _m1$3.makeTranslation( x, y, z );
    
            this.applyMatrix4( _m1$3 );
    
            return this;
    
        },
    
        scale: function ( x, y, z ) {
    
            // scale geometry
    
            _m1$3.makeScale( x, y, z );
    
            this.applyMatrix4( _m1$3 );
    
            return this;
    
        },
    
        lookAt: function ( vector ) {
    
            _obj$1.lookAt( vector );
    
            _obj$1.updateMatrix();
    
            this.applyMatrix4( _obj$1.matrix );
    
            return this;
    
        },
    
        fromBufferGeometry: function ( geometry ) {
    
            var scope = this;
    
            var indices = geometry.index !== null ? geometry.index.array : undefined;
            var attributes = geometry.attributes;
    
            if ( attributes.position === undefined ) {
    
                console.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );
                return this;
    
            }
    
            var positions = attributes.position.array;
            var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
            var colors = attributes.color !== undefined ? attributes.color.array : undefined;
            var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
            var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
    
            if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
    
            for ( var i = 0; i < positions.length; i += 3 ) {
    
                scope.vertices.push( new Vector3().fromArray( positions, i ) );
    
                if ( colors !== undefined ) {
    
                    scope.colors.push( new Color().fromArray( colors, i ) );
    
                }
    
            }
    
            function addFace( a, b, c, materialIndex ) {
    
                var vertexColors = ( colors === undefined ) ? [] : [
                    scope.colors[ a ].clone(),
                    scope.colors[ b ].clone(),
                    scope.colors[ c ].clone() ];
    
                var vertexNormals = ( normals === undefined ) ? [] : [
                    new Vector3().fromArray( normals, a * 3 ),
                    new Vector3().fromArray( normals, b * 3 ),
                    new Vector3().fromArray( normals, c * 3 )
                ];
    
                var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );
    
                scope.faces.push( face );
    
                if ( uvs !== undefined ) {
    
                    scope.faceVertexUvs[ 0 ].push( [
                        new Vector2().fromArray( uvs, a * 2 ),
                        new Vector2().fromArray( uvs, b * 2 ),
                        new Vector2().fromArray( uvs, c * 2 )
                    ] );
    
                }
    
                if ( uvs2 !== undefined ) {
    
                    scope.faceVertexUvs[ 1 ].push( [
                        new Vector2().fromArray( uvs2, a * 2 ),
                        new Vector2().fromArray( uvs2, b * 2 ),
                        new Vector2().fromArray( uvs2, c * 2 )
                    ] );
    
                }
    
            }
    
            var groups = geometry.groups;
    
            if ( groups.length > 0 ) {
    
                for ( var i = 0; i < groups.length; i ++ ) {
    
                    var group = groups[ i ];
    
                    var start = group.start;
                    var count = group.count;
    
                    for ( var j = start, jl = start + count; j < jl; j += 3 ) {
    
                        if ( indices !== undefined ) {
    
                            addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );
    
                        } else {
    
                            addFace( j, j + 1, j + 2, group.materialIndex );
    
                        }
    
                    }
    
                }
    
            } else {
    
                if ( indices !== undefined ) {
    
                    for ( var i = 0; i < indices.length; i += 3 ) {
    
                        addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
    
                    }
    
                } else {
    
                    for ( var i = 0; i < positions.length / 3; i += 3 ) {
    
                        addFace( i, i + 1, i + 2 );
    
                    }
    
                }
    
            }
    
            this.computeFaceNormals();
    
            if ( geometry.boundingBox !== null ) {
    
                this.boundingBox = geometry.boundingBox.clone();
    
            }
    
            if ( geometry.boundingSphere !== null ) {
    
                this.boundingSphere = geometry.boundingSphere.clone();
    
            }
    
            return this;
    
        },
    
        center: function () {
    
            this.computeBoundingBox();
    
            this.boundingBox.getCenter( _offset$1 ).negate();
    
            this.translate( _offset$1.x, _offset$1.y, _offset$1.z );
    
            return this;
    
        },
    
        normalize: function () {
    
            this.computeBoundingSphere();
    
            var center = this.boundingSphere.center;
            var radius = this.boundingSphere.radius;
    
            var s = radius === 0 ? 1 : 1.0 / radius;
    
            var matrix = new Matrix4();
            matrix.set(
                s, 0, 0, - s * center.x,
                0, s, 0, - s * center.y,
                0, 0, s, - s * center.z,
                0, 0, 0, 1
            );
    
            this.applyMatrix4( matrix );
    
            return this;
    
        },
    
        computeFaceNormals: function () {
    
            var cb = new Vector3(), ab = new Vector3();
    
            for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
    
                var face = this.faces[ f ];
    
                var vA = this.vertices[ face.a ];
                var vB = this.vertices[ face.b ];
                var vC = this.vertices[ face.c ];
    
                cb.subVectors( vC, vB );
                ab.subVectors( vA, vB );
                cb.cross( ab );
    
                cb.normalize();
    
                face.normal.copy( cb );
    
            }
    
        },
    
        computeVertexNormals: function ( areaWeighted ) {
    
            if ( areaWeighted === undefined ) areaWeighted = true;
    
            var v, vl, f, fl, face, vertices;
    
            vertices = new Array( this.vertices.length );
    
            for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
    
                vertices[ v ] = new Vector3();
    
            }
    
            if ( areaWeighted ) {
    
                // vertex normals weighted by triangle areas
                // http://www.iquilezles.org/www/articles/normals/normals.htm
    
                var vA, vB, vC;
                var cb = new Vector3(), ab = new Vector3();
    
                for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
    
                    face = this.faces[ f ];
    
                    vA = this.vertices[ face.a ];
                    vB = this.vertices[ face.b ];
                    vC = this.vertices[ face.c ];
    
                    cb.subVectors( vC, vB );
                    ab.subVectors( vA, vB );
                    cb.cross( ab );
    
                    vertices[ face.a ].add( cb );
                    vertices[ face.b ].add( cb );
                    vertices[ face.c ].add( cb );
    
                }
    
            } else {
    
                this.computeFaceNormals();
    
                for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
    
                    face = this.faces[ f ];
    
                    vertices[ face.a ].add( face.normal );
                    vertices[ face.b ].add( face.normal );
                    vertices[ face.c ].add( face.normal );
    
                }
    
            }
    
            for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
    
                vertices[ v ].normalize();
    
            }
    
            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
    
                face = this.faces[ f ];
    
                var vertexNormals = face.vertexNormals;
    
                if ( vertexNormals.length === 3 ) {
    
                    vertexNormals[ 0 ].copy( vertices[ face.a ] );
                    vertexNormals[ 1 ].copy( vertices[ face.b ] );
                    vertexNormals[ 2 ].copy( vertices[ face.c ] );
    
                } else {
    
                    vertexNormals[ 0 ] = vertices[ face.a ].clone();
                    vertexNormals[ 1 ] = vertices[ face.b ].clone();
                    vertexNormals[ 2 ] = vertices[ face.c ].clone();
    
                }
    
            }
    
            if ( this.faces.length > 0 ) {
    
                this.normalsNeedUpdate = true;
    
            }
    
        },
    
        computeFlatVertexNormals: function () {
    
            var f, fl, face;
    
            this.computeFaceNormals();
    
            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
    
                face = this.faces[ f ];
    
                var vertexNormals = face.vertexNormals;
    
                if ( vertexNormals.length === 3 ) {
    
                    vertexNormals[ 0 ].copy( face.normal );
                    vertexNormals[ 1 ].copy( face.normal );
                    vertexNormals[ 2 ].copy( face.normal );
    
                } else {
    
                    vertexNormals[ 0 ] = face.normal.clone();
                    vertexNormals[ 1 ] = face.normal.clone();
                    vertexNormals[ 2 ] = face.normal.clone();
    
                }
    
            }
    
            if ( this.faces.length > 0 ) {
    
                this.normalsNeedUpdate = true;
    
            }
    
        },
    
        computeMorphNormals: function () {
    
            var i, il, f, fl, face;
    
            // save original normals
            // - create temp variables on first access
            //   otherwise just copy (for faster repeated calls)
    
            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
    
                face = this.faces[ f ];
    
                if ( ! face.__originalFaceNormal ) {
    
                    face.__originalFaceNormal = face.normal.clone();
    
                } else {
    
                    face.__originalFaceNormal.copy( face.normal );
    
                }
    
                if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
    
                for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
    
                    if ( ! face.__originalVertexNormals[ i ] ) {
    
                        face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
    
                    } else {
    
                        face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
    
                    }
    
                }
    
            }
    
            // use temp geometry to compute face and vertex normals for each morph
    
            var tmpGeo = new Geometry();
            tmpGeo.faces = this.faces;
    
            for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
    
                // create on first access
    
                if ( ! this.morphNormals[ i ] ) {
    
                    this.morphNormals[ i ] = {};
                    this.morphNormals[ i ].faceNormals = [];
                    this.morphNormals[ i ].vertexNormals = [];
    
                    var dstNormalsFace = this.morphNormals[ i ].faceNormals;
                    var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
    
                    var faceNormal, vertexNormals;
    
                    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
    
                        faceNormal = new Vector3();
                        vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
    
                        dstNormalsFace.push( faceNormal );
                        dstNormalsVertex.push( vertexNormals );
    
                    }
    
                }
    
                var morphNormals = this.morphNormals[ i ];
    
                // set vertices to morph target
    
                tmpGeo.vertices = this.morphTargets[ i ].vertices;
    
                // compute morph normals
    
                tmpGeo.computeFaceNormals();
                tmpGeo.computeVertexNormals();
    
                // store morph normals
    
                var faceNormal, vertexNormals;
    
                for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
    
                    face = this.faces[ f ];
    
                    faceNormal = morphNormals.faceNormals[ f ];
                    vertexNormals = morphNormals.vertexNormals[ f ];
    
                    faceNormal.copy( face.normal );
    
                    vertexNormals.a.copy( face.vertexNormals[ 0 ] );
                    vertexNormals.b.copy( face.vertexNormals[ 1 ] );
                    vertexNormals.c.copy( face.vertexNormals[ 2 ] );
    
                }
    
            }
    
            // restore original normals
    
            for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
    
                face = this.faces[ f ];
    
                face.normal = face.__originalFaceNormal;
                face.vertexNormals = face.__originalVertexNormals;
    
            }
    
        },
    
        computeBoundingBox: function () {
    
            if ( this.boundingBox === null ) {
    
                this.boundingBox = new Box3();
    
            }
    
            this.boundingBox.setFromPoints( this.vertices );
    
        },
    
        computeBoundingSphere: function () {
    
            if ( this.boundingSphere === null ) {
    
                this.boundingSphere = new Sphere();
    
            }
    
            this.boundingSphere.setFromPoints( this.vertices );
    
        },
    
        merge: function ( geometry, matrix, materialIndexOffset ) {
    
            if ( ! ( geometry && geometry.isGeometry ) ) {
    
                console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
                return;
    
            }
    
            var normalMatrix,
                vertexOffset = this.vertices.length,
                vertices1 = this.vertices,
                vertices2 = geometry.vertices,
                faces1 = this.faces,
                faces2 = geometry.faces,
                colors1 = this.colors,
                colors2 = geometry.colors;
    
            if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
    
            if ( matrix !== undefined ) {
    
                normalMatrix = new Matrix3().getNormalMatrix( matrix );
    
            }
    
            // vertices
    
            for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
    
                var vertex = vertices2[ i ];
    
                var vertexCopy = vertex.clone();
    
                if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
    
                vertices1.push( vertexCopy );
    
            }
    
            // colors
    
            for ( var i = 0, il = colors2.length; i < il; i ++ ) {
    
                colors1.push( colors2[ i ].clone() );
    
            }
    
            // faces
    
            for ( i = 0, il = faces2.length; i < il; i ++ ) {
    
                var face = faces2[ i ], faceCopy, normal, color,
                    faceVertexNormals = face.vertexNormals,
                    faceVertexColors = face.vertexColors;
    
                faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
                faceCopy.normal.copy( face.normal );
    
                if ( normalMatrix !== undefined ) {
    
                    faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
    
                }
    
                for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
    
                    normal = faceVertexNormals[ j ].clone();
    
                    if ( normalMatrix !== undefined ) {
    
                        normal.applyMatrix3( normalMatrix ).normalize();
    
                    }
    
                    faceCopy.vertexNormals.push( normal );
    
                }
    
                faceCopy.color.copy( face.color );
    
                for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
    
                    color = faceVertexColors[ j ];
                    faceCopy.vertexColors.push( color.clone() );
    
                }
    
                faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
    
                faces1.push( faceCopy );
    
            }
    
            // uvs
    
            for ( var i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {
    
                var faceVertexUvs2 = geometry.faceVertexUvs[ i ];
    
                if ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];
    
                for ( var j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {
    
                    var uvs2 = faceVertexUvs2[ j ], uvsCopy = [];
    
                    for ( var k = 0, kl = uvs2.length; k < kl; k ++ ) {
    
                        uvsCopy.push( uvs2[ k ].clone() );
    
                    }
    
                    this.faceVertexUvs[ i ].push( uvsCopy );
    
                }
    
            }
    
        },
    
        mergeMesh: function ( mesh ) {
    
            if ( ! ( mesh && mesh.isMesh ) ) {
    
                console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
                return;
    
            }
    
            if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();
    
            this.merge( mesh.geometry, mesh.matrix );
    
        },
    
        /*
         * Checks for duplicate vertices with hashmap.
         * Duplicated vertices are removed
         * and faces' vertices are updated.
         */
    
        mergeVertices: function () {
    
            var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
            var unique = [], changes = [];
    
            var v, key;
            var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
            var precision = Math.pow( 10, precisionPoints );
            var i, il, face;
            var indices, j, jl;
    
            for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
    
                v = this.vertices[ i ];
                key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
    
                if ( verticesMap[ key ] === undefined ) {
    
                    verticesMap[ key ] = i;
                    unique.push( this.vertices[ i ] );
                    changes[ i ] = unique.length - 1;
    
                } else {
    
                    //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
                    changes[ i ] = changes[ verticesMap[ key ] ];
    
                }
    
            }
    
    
            // if faces are completely degenerate after merging vertices, we
            // have to remove them from the geometry.
            var faceIndicesToRemove = [];
    
            for ( i = 0, il = this.faces.length; i < il; i ++ ) {
    
                face = this.faces[ i ];
    
                face.a = changes[ face.a ];
                face.b = changes[ face.b ];
                face.c = changes[ face.c ];
    
                indices = [ face.a, face.b, face.c ];
    
                // if any duplicate vertices are found in a Face3
                // we have to remove the face as nothing can be saved
                for ( var n = 0; n < 3; n ++ ) {
    
                    if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
    
                        faceIndicesToRemove.push( i );
                        break;
    
                    }
    
                }
    
            }
    
            for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
    
                var idx = faceIndicesToRemove[ i ];
    
                this.faces.splice( idx, 1 );
    
                for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
    
                    this.faceVertexUvs[ j ].splice( idx, 1 );
    
                }
    
            }
    
            // Use unique set of vertices
    
            var diff = this.vertices.length - unique.length;
            this.vertices = unique;
            return diff;
    
        },
    
        setFromPoints: function ( points ) {
    
            this.vertices = [];
    
            for ( var i = 0, l = points.length; i < l; i ++ ) {
    
                var point = points[ i ];
                this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
    
            }
    
            return this;
    
        },
    
        sortFacesByMaterialIndex: function () {
    
            var faces = this.faces;
            var length = faces.length;
    
            // tag faces
    
            for ( var i = 0; i < length; i ++ ) {
    
                faces[ i ]._id = i;
    
            }
    
            // sort faces
    
            function materialIndexSort( a, b ) {
    
                return a.materialIndex - b.materialIndex;
    
            }
    
            faces.sort( materialIndexSort );
    
            // sort uvs
    
            var uvs1 = this.faceVertexUvs[ 0 ];
            var uvs2 = this.faceVertexUvs[ 1 ];
    
            var newUvs1, newUvs2;
    
            if ( uvs1 && uvs1.length === length ) newUvs1 = [];
            if ( uvs2 && uvs2.length === length ) newUvs2 = [];
    
            for ( var i = 0; i < length; i ++ ) {
    
                var id = faces[ i ]._id;
    
                if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
                if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
    
            }
    
            if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
            if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
    
        },
    
        toJSON: function () {
    
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Geometry',
                    generator: 'Geometry.toJSON'
                }
            };
    
            // standard Geometry serialization
    
            data.uuid = this.uuid;
            data.type = this.type;
            if ( this.name !== '' ) data.name = this.name;
    
            if ( this.parameters !== undefined ) {
    
                var parameters = this.parameters;
    
                for ( var key in parameters ) {
    
                    if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
    
                }
    
                return data;
    
            }
    
            var vertices = [];
    
            for ( var i = 0; i < this.vertices.length; i ++ ) {
    
                var vertex = this.vertices[ i ];
                vertices.push( vertex.x, vertex.y, vertex.z );
    
            }
    
            var faces = [];
            var normals = [];
            var normalsHash = {};
            var colors = [];
            var colorsHash = {};
            var uvs = [];
            var uvsHash = {};
    
            for ( var i = 0; i < this.faces.length; i ++ ) {
    
                var face = this.faces[ i ];
    
                var hasMaterial = true;
                var hasFaceUv = false; // deprecated
                var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
                var hasFaceNormal = face.normal.length() > 0;
                var hasFaceVertexNormal = face.vertexNormals.length > 0;
                var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
                var hasFaceVertexColor = face.vertexColors.length > 0;
    
                var faceType = 0;
    
                faceType = setBit( faceType, 0, 0 ); // isQuad
                faceType = setBit( faceType, 1, hasMaterial );
                faceType = setBit( faceType, 2, hasFaceUv );
                faceType = setBit( faceType, 3, hasFaceVertexUv );
                faceType = setBit( faceType, 4, hasFaceNormal );
                faceType = setBit( faceType, 5, hasFaceVertexNormal );
                faceType = setBit( faceType, 6, hasFaceColor );
                faceType = setBit( faceType, 7, hasFaceVertexColor );
    
                faces.push( faceType );
                faces.push( face.a, face.b, face.c );
                faces.push( face.materialIndex );
    
                if ( hasFaceVertexUv ) {
    
                    var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
    
                    faces.push(
                        getUvIndex( faceVertexUvs[ 0 ] ),
                        getUvIndex( faceVertexUvs[ 1 ] ),
                        getUvIndex( faceVertexUvs[ 2 ] )
                    );
    
                }
    
                if ( hasFaceNormal ) {
    
                    faces.push( getNormalIndex( face.normal ) );
    
                }
    
                if ( hasFaceVertexNormal ) {
    
                    var vertexNormals = face.vertexNormals;
    
                    faces.push(
                        getNormalIndex( vertexNormals[ 0 ] ),
                        getNormalIndex( vertexNormals[ 1 ] ),
                        getNormalIndex( vertexNormals[ 2 ] )
                    );
    
                }
    
                if ( hasFaceColor ) {
    
                    faces.push( getColorIndex( face.color ) );
    
                }
    
                if ( hasFaceVertexColor ) {
    
                    var vertexColors = face.vertexColors;
    
                    faces.push(
                        getColorIndex( vertexColors[ 0 ] ),
                        getColorIndex( vertexColors[ 1 ] ),
                        getColorIndex( vertexColors[ 2 ] )
                    );
    
                }
    
            }
    
            function setBit( value, position, enabled ) {
    
                return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );
    
            }
    
            function getNormalIndex( normal ) {
    
                var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
    
                if ( normalsHash[ hash ] !== undefined ) {
    
                    return normalsHash[ hash ];
    
                }
    
                normalsHash[ hash ] = normals.length / 3;
                normals.push( normal.x, normal.y, normal.z );
    
                return normalsHash[ hash ];
    
            }
    
            function getColorIndex( color ) {
    
                var hash = color.r.toString() + color.g.toString() + color.b.toString();
    
                if ( colorsHash[ hash ] !== undefined ) {
    
                    return colorsHash[ hash ];
    
                }
    
                colorsHash[ hash ] = colors.length;
                colors.push( color.getHex() );
    
                return colorsHash[ hash ];
    
            }
    
            function getUvIndex( uv ) {
    
                var hash = uv.x.toString() + uv.y.toString();
    
                if ( uvsHash[ hash ] !== undefined ) {
    
                    return uvsHash[ hash ];
    
                }
    
                uvsHash[ hash ] = uvs.length / 2;
                uvs.push( uv.x, uv.y );
    
                return uvsHash[ hash ];
    
            }
    
            data.data = {};
    
            data.data.vertices = vertices;
            data.data.normals = normals;
            if ( colors.length > 0 ) data.data.colors = colors;
            if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
            data.data.faces = faces;
    
            return data;
    
        },
    
        clone: function () {
    
            /*
             // Handle primitives
    
             var parameters = this.parameters;
    
             if ( parameters !== undefined ) {
    
             var values = [];
    
             for ( var key in parameters ) {
    
             values.push( parameters[ key ] );
    
             }
    
             var geometry = Object.create( this.constructor.prototype );
             this.constructor.apply( geometry, values );
             return geometry;
    
             }
    
             return new this.constructor().copy( this );
             */
    
            return new Geometry().copy( this );
    
        },
    
        copy: function ( source ) {
    
            var i, il, j, jl, k, kl;
    
            // reset
    
            this.vertices = [];
            this.colors = [];
            this.faces = [];
            this.faceVertexUvs = [[]];
            this.morphTargets = [];
            this.morphNormals = [];
            this.skinWeights = [];
            this.skinIndices = [];
            this.lineDistances = [];
            this.boundingBox = null;
            this.boundingSphere = null;
    
            // name
    
            this.name = source.name;
    
            // vertices
    
            var vertices = source.vertices;
    
            for ( i = 0, il = vertices.length; i < il; i ++ ) {
    
                this.vertices.push( vertices[ i ].clone() );
    
            }
    
            // colors
    
            var colors = source.colors;
    
            for ( i = 0, il = colors.length; i < il; i ++ ) {
    
                this.colors.push( colors[ i ].clone() );
    
            }
    
            // faces
    
            var faces = source.faces;
    
            for ( i = 0, il = faces.length; i < il; i ++ ) {
    
                this.faces.push( faces[ i ].clone() );
    
            }
    
            // face vertex uvs
    
            for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {
    
                var faceVertexUvs = source.faceVertexUvs[ i ];
    
                if ( this.faceVertexUvs[ i ] === undefined ) {
    
                    this.faceVertexUvs[ i ] = [];
    
                }
    
                for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
    
                    var uvs = faceVertexUvs[ j ], uvsCopy = [];
    
                    for ( k = 0, kl = uvs.length; k < kl; k ++ ) {
    
                        var uv = uvs[ k ];
    
                        uvsCopy.push( uv.clone() );
    
                    }
    
                    this.faceVertexUvs[ i ].push( uvsCopy );
    
                }
    
            }
    
            // morph targets
    
            var morphTargets = source.morphTargets;
    
            for ( i = 0, il = morphTargets.length; i < il; i ++ ) {
    
                var morphTarget = {};
                morphTarget.name = morphTargets[ i ].name;
    
                // vertices
    
                if ( morphTargets[ i ].vertices !== undefined ) {
    
                    morphTarget.vertices = [];
    
                    for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {
    
                        morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );
    
                    }
    
                }
    
                // normals
    
                if ( morphTargets[ i ].normals !== undefined ) {
    
                    morphTarget.normals = [];
    
                    for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {
    
                        morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );
    
                    }
    
                }
    
                this.morphTargets.push( morphTarget );
    
            }
    
            // morph normals
    
            var morphNormals = source.morphNormals;
    
            for ( i = 0, il = morphNormals.length; i < il; i ++ ) {
    
                var morphNormal = {};
    
                // vertex normals
    
                if ( morphNormals[ i ].vertexNormals !== undefined ) {
    
                    morphNormal.vertexNormals = [];
    
                    for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {
    
                        var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
                        var destVertexNormal = {};
    
                        destVertexNormal.a = srcVertexNormal.a.clone();
                        destVertexNormal.b = srcVertexNormal.b.clone();
                        destVertexNormal.c = srcVertexNormal.c.clone();
    
                        morphNormal.vertexNormals.push( destVertexNormal );
    
                    }
    
                }
    
                // face normals
    
                if ( morphNormals[ i ].faceNormals !== undefined ) {
    
                    morphNormal.faceNormals = [];
    
                    for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {
    
                        morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );
    
                    }
    
                }
    
                this.morphNormals.push( morphNormal );
    
            }
    
            // skin weights
    
            var skinWeights = source.skinWeights;
    
            for ( i = 0, il = skinWeights.length; i < il; i ++ ) {
    
                this.skinWeights.push( skinWeights[ i ].clone() );
    
            }
    
            // skin indices
    
            var skinIndices = source.skinIndices;
    
            for ( i = 0, il = skinIndices.length; i < il; i ++ ) {
    
                this.skinIndices.push( skinIndices[ i ].clone() );
    
            }
    
            // line distances
    
            var lineDistances = source.lineDistances;
    
            for ( i = 0, il = lineDistances.length; i < il; i ++ ) {
    
                this.lineDistances.push( lineDistances[ i ] );
    
            }
    
            // bounding box
    
            var boundingBox = source.boundingBox;
    
            if ( boundingBox !== null ) {
    
                this.boundingBox = boundingBox.clone();
    
            }
    
            // bounding sphere
    
            var boundingSphere = source.boundingSphere;
    
            if ( boundingSphere !== null ) {
    
                this.boundingSphere = boundingSphere.clone();
    
            }
    
            // update flags
    
            this.elementsNeedUpdate = source.elementsNeedUpdate;
            this.verticesNeedUpdate = source.verticesNeedUpdate;
            this.uvsNeedUpdate = source.uvsNeedUpdate;
            this.normalsNeedUpdate = source.normalsNeedUpdate;
            this.colorsNeedUpdate = source.colorsNeedUpdate;
            this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
            this.groupsNeedUpdate = source.groupsNeedUpdate;
    
            return this;
    
        },
    
        dispose: function () {
    
            this.dispatchEvent( { type: 'dispose' } );
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // BoxGeometry
    
    class BoxGeometry extends Geometry {
    
        constructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {
    
            super();
    
            this.type = 'BoxGeometry';
    
            this.parameters = {
                width: width,
                height: height,
                depth: depth,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                depthSegments: depthSegments
            };
    
            this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
            this.mergeVertices();
    
        }
    
    }
    
    // BoxBufferGeometry
    
    class BoxBufferGeometry extends BufferGeometry {
    
        constructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {
    
            super();
    
            this.type = 'BoxBufferGeometry';
    
            this.parameters = {
                width: width,
                height: height,
                depth: depth,
                widthSegments: widthSegments,
                heightSegments: heightSegments,
                depthSegments: depthSegments
            };
    
            var scope = this;
    
            width = width || 1;
            height = height || 1;
            depth = depth || 1;
    
            // segments
    
            widthSegments = Math.floor( widthSegments ) || 1;
            heightSegments = Math.floor( heightSegments ) || 1;
            depthSegments = Math.floor( depthSegments ) || 1;
    
            // buffers
    
            var indices = [];
            var vertices = [];
            var normals = [];
            var uvs = [];
    
            // helper variables
    
            var numberOfVertices = 0;
            var groupStart = 0;
    
            // build each side of the box geometry
    
            buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
            buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
            buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
            buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
            buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
            buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz
    
            // build geometry
    
            this.setIndex( indices );
            this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
            this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
            this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
            function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {
    
                var segmentWidth = width / gridX;
                var segmentHeight = height / gridY;
    
                var widthHalf = width / 2;
                var heightHalf = height / 2;
                var depthHalf = depth / 2;
    
                var gridX1 = gridX + 1;
                var gridY1 = gridY + 1;
    
                var vertexCounter = 0;
                var groupCount = 0;
    
                var ix, iy;
    
                var vector = new Vector3();
    
                // generate vertices, normals and uvs
    
                for ( iy = 0; iy < gridY1; iy ++ ) {
    
                    var y = iy * segmentHeight - heightHalf;
    
                    for ( ix = 0; ix < gridX1; ix ++ ) {
    
                        var x = ix * segmentWidth - widthHalf;
    
                        // set values to correct vector component
    
                        vector[ u ] = x * udir;
                        vector[ v ] = y * vdir;
                        vector[ w ] = depthHalf;
    
                        // now apply vector to vertex buffer
    
                        vertices.push( vector.x, vector.y, vector.z );
    
                        // set values to correct vector component
    
                        vector[ u ] = 0;
                        vector[ v ] = 0;
                        vector[ w ] = depth > 0 ? 1 : - 1;
    
                        // now apply vector to normal buffer
    
                        normals.push( vector.x, vector.y, vector.z );
    
                        // uvs
    
                        uvs.push( ix / gridX );
                        uvs.push( 1 - ( iy / gridY ) );
    
                        // counters
    
                        vertexCounter += 1;
    
                    }
    
                }
    
                // indices
    
                // 1. you need three indices to draw a single face
                // 2. a single segment consists of two faces
                // 3. so we need to generate six (2*3) indices per segment
    
                for ( iy = 0; iy < gridY; iy ++ ) {
    
                    for ( ix = 0; ix < gridX; ix ++ ) {
    
                        var a = numberOfVertices + ix + gridX1 * iy;
                        var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
                        var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
                        var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;
    
                        // faces
    
                        indices.push( a, b, d );
                        indices.push( b, c, d );
    
                        // increase counter
    
                        groupCount += 6;
    
                    }
    
                }
    
                // add a group to the geometry. this will ensure multi material support
    
                scope.addGroup( groupStart, groupCount, materialIndex );
    
                // calculate new start value for groups
    
                groupStart += groupCount;
    
                // update total number of vertices
    
                numberOfVertices += vertexCounter;
    
            }
    
        }
    
    }
    
    /**
     * Uniform Utilities
     */
    
    function cloneUniforms( src ) {
    
        var dst = {};
    
        for ( var u in src ) {
    
            dst[ u ] = {};
    
            for ( var p in src[ u ] ) {
    
                var property = src[ u ][ p ];
    
                if ( property && ( property.isColor ||
                    property.isMatrix3 || property.isMatrix4 ||
                    property.isVector2 || property.isVector3 || property.isVector4 ||
                    property.isTexture ) ) {
    
                    dst[ u ][ p ] = property.clone();
    
                } else if ( Array.isArray( property ) ) {
    
                    dst[ u ][ p ] = property.slice();
    
                } else {
    
                    dst[ u ][ p ] = property;
    
                }
    
            }
    
        }
    
        return dst;
    
    }
    
    function mergeUniforms( uniforms ) {
    
        var merged = {};
    
        for ( var u = 0; u < uniforms.length; u ++ ) {
    
            var tmp = cloneUniforms( uniforms[ u ] );
    
            for ( var p in tmp ) {
    
                merged[ p ] = tmp[ p ];
    
            }
    
        }
    
        return merged;
    
    }
    
    // Legacy
    
    var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
    
    var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    
    var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    
    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  defines: { "label" : "value" },
     *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
     *
     *  fragmentShader: <string>,
     *  vertexShader: <string>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  lights: <bool>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    
    function ShaderMaterial( parameters ) {
    
        Material.call( this );
    
        this.type = 'ShaderMaterial';
    
        this.defines = {};
        this.uniforms = {};
    
        this.vertexShader = default_vertex;
        this.fragmentShader = default_fragment;
    
        this.linewidth = 1;
    
        this.wireframe = false;
        this.wireframeLinewidth = 1;
    
        this.fog = false; // set to use scene fog
        this.lights = false; // set to use scene lights
        this.clipping = false; // set to use user-defined clipping planes
    
        this.skinning = false; // set to use skinning attribute streams
        this.morphTargets = false; // set to use morph targets
        this.morphNormals = false; // set to use morph normals
    
        this.extensions = {
            derivatives: false, // set to use derivatives
            fragDepth: false, // set to use fragment depth values
            drawBuffers: false, // set to use draw buffers
            shaderTextureLOD: false // set to use shader texture LOD
        };
    
        // When rendered geometry doesn't include these attributes but the material does,
        // use these default values in WebGL. This avoids errors when buffer data is missing.
        this.defaultAttributeValues = {
            'color': [ 1, 1, 1 ],
            'uv': [ 0, 0 ],
            'uv2': [ 0, 0 ]
        };
    
        this.index0AttributeName = undefined;
        this.uniformsNeedUpdate = false;
    
        if ( parameters !== undefined ) {
    
            if ( parameters.attributes !== undefined ) {
    
                console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
    
            }
    
            this.setValues( parameters );
    
        }
    
    }
    
    ShaderMaterial.prototype = Object.create( Material.prototype );
    ShaderMaterial.prototype.constructor = ShaderMaterial;
    
    ShaderMaterial.prototype.isShaderMaterial = true;
    
    ShaderMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
    
        this.uniforms = cloneUniforms( source.uniforms );
    
        this.defines = Object.assign( {}, source.defines );
    
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
    
        this.lights = source.lights;
        this.clipping = source.clipping;
    
        this.skinning = source.skinning;
    
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
    
        this.extensions = source.extensions;
    
        return this;
    
    };
    
    ShaderMaterial.prototype.toJSON = function ( meta ) {
    
        var data = Material.prototype.toJSON.call( this, meta );
    
        data.uniforms = {};
    
        for ( var name in this.uniforms ) {
    
            var uniform = this.uniforms[ name ];
            var value = uniform.value;
    
            if ( value && value.isTexture ) {
    
                data.uniforms[ name ] = {
                    type: 't',
                    value: value.toJSON( meta ).uuid
                };
    
            } else if ( value && value.isColor ) {
    
                data.uniforms[ name ] = {
                    type: 'c',
                    value: value.getHex()
                };
    
            } else if ( value && value.isVector2 ) {
    
                data.uniforms[ name ] = {
                    type: 'v2',
                    value: value.toArray()
                };
    
            } else if ( value && value.isVector3 ) {
    
                data.uniforms[ name ] = {
                    type: 'v3',
                    value: value.toArray()
                };
    
            } else if ( value && value.isVector4 ) {
    
                data.uniforms[ name ] = {
                    type: 'v4',
                    value: value.toArray()
                };
    
            } else if ( value && value.isMatrix3 ) {
    
                data.uniforms[ name ] = {
                    type: 'm3',
                    value: value.toArray()
                };
    
            } else if ( value && value.isMatrix4 ) {
    
                data.uniforms[ name ] = {
                    type: 'm4',
                    value: value.toArray()
                };
    
            } else {
    
                data.uniforms[ name ] = {
                    value: value
                };
    
                // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
    
            }
    
        }
    
        if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;
    
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
    
        var extensions = {};
    
        for ( var key in this.extensions ) {
    
            if ( this.extensions[ key ] === true ) extensions[ key ] = true;
    
        }
    
        if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;
    
        return data;
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author WestLangley / http://github.com/WestLangley
    */
    
    function Camera() {
    
        Object3D.call( this );
    
        this.type = 'Camera';
    
        this.matrixWorldInverse = new Matrix4();
    
        this.projectionMatrix = new Matrix4();
        this.projectionMatrixInverse = new Matrix4();
    
    }
    
    Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: Camera,
    
        isCamera: true,
    
        copy: function ( source, recursive ) {
    
            Object3D.prototype.copy.call( this, source, recursive );
    
            this.matrixWorldInverse.copy( source.matrixWorldInverse );
    
            this.projectionMatrix.copy( source.projectionMatrix );
            this.projectionMatrixInverse.copy( source.projectionMatrixInverse );
    
            return this;
    
        },
    
        getWorldDirection: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
                target = new Vector3();
    
            }
    
            this.updateMatrixWorld( true );
    
            var e = this.matrixWorld.elements;
    
            return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();
    
        },
    
        updateMatrixWorld: function ( force ) {
    
            Object3D.prototype.updateMatrixWorld.call( this, force );
    
            this.matrixWorldInverse.getInverse( this.matrixWorld );
    
        },
    
        updateWorldMatrix: function ( updateParents, updateChildren ) {
    
            Object3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );
    
            this.matrixWorldInverse.getInverse( this.matrixWorld );
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author greggman / http://games.greggman.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author tschw
     */
    
    function PerspectiveCamera( fov, aspect, near, far ) {
    
        Camera.call( this );
    
        this.type = 'PerspectiveCamera';
    
        this.fov = fov !== undefined ? fov : 50;
        this.zoom = 1;
    
        this.near = near !== undefined ? near : 0.1;
        this.far = far !== undefined ? far : 2000;
        this.focus = 10;
    
        this.aspect = aspect !== undefined ? aspect : 1;
        this.view = null;
    
        this.filmGauge = 35;	// width of the film (default in millimeters)
        this.filmOffset = 0;	// horizontal film offset (same unit as gauge)
    
        this.updateProjectionMatrix();
    
    }
    
    PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
    
        constructor: PerspectiveCamera,
    
        isPerspectiveCamera: true,
    
        copy: function ( source, recursive ) {
    
            Camera.prototype.copy.call( this, source, recursive );
    
            this.fov = source.fov;
            this.zoom = source.zoom;
    
            this.near = source.near;
            this.far = source.far;
            this.focus = source.focus;
    
            this.aspect = source.aspect;
            this.view = source.view === null ? null : Object.assign( {}, source.view );
    
            this.filmGauge = source.filmGauge;
            this.filmOffset = source.filmOffset;
    
            return this;
    
        },
    
        /**
         * Sets the FOV by focal length in respect to the current .filmGauge.
         *
         * The default film gauge is 35, so that the focal length can be specified for
         * a 35mm (full frame) camera.
         *
         * Values for focal length and film gauge must have the same unit.
         */
        setFocalLength: function ( focalLength ) {
    
            // see http://www.bobatkins.com/photography/technical/field_of_view.html
            var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    
            this.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );
            this.updateProjectionMatrix();
    
        },
    
        /**
         * Calculates the focal length from the current .fov and .filmGauge.
         */
        getFocalLength: function () {
    
            var vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );
    
            return 0.5 * this.getFilmHeight() / vExtentSlope;
    
        },
    
        getEffectiveFOV: function () {
    
            return MathUtils.RAD2DEG * 2 * Math.atan(
                Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );
    
        },
    
        getFilmWidth: function () {
    
            // film not completely covered in portrait format (aspect < 1)
            return this.filmGauge * Math.min( this.aspect, 1 );
    
        },
    
        getFilmHeight: function () {
    
            // film not completely covered in landscape format (aspect > 1)
            return this.filmGauge / Math.max( this.aspect, 1 );
    
        },
    
        /**
         * Sets an offset in a larger frustum. This is useful for multi-window or
         * multi-monitor/multi-machine setups.
         *
         * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
         * the monitors are in grid like this
         *
         *   +---+---+---+
         *   | A | B | C |
         *   +---+---+---+
         *   | D | E | F |
         *   +---+---+---+
         *
         * then for each monitor you would call it like this
         *
         *   var w = 1920;
         *   var h = 1080;
         *   var fullWidth = w * 3;
         *   var fullHeight = h * 2;
         *
         *   --A--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
         *   --B--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
         *   --C--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
         *   --D--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
         *   --E--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
         *   --F--
         *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
         *
         *   Note there is no reason monitors have to be the same size or in a grid.
         */
        setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
    
            this.aspect = fullWidth / fullHeight;
    
            if ( this.view === null ) {
    
                this.view = {
                    enabled: true,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                };
    
            }
    
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
    
            this.updateProjectionMatrix();
    
        },
    
        clearViewOffset: function () {
    
            if ( this.view !== null ) {
    
                this.view.enabled = false;
    
            }
    
            this.updateProjectionMatrix();
    
        },
    
        updateProjectionMatrix: function () {
    
            var near = this.near,
                top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom,
                height = 2 * top,
                width = this.aspect * height,
                left = - 0.5 * width,
                view = this.view;
    
            if ( this.view !== null && this.view.enabled ) {
    
                var fullWidth = view.fullWidth,
                    fullHeight = view.fullHeight;
    
                left += view.offsetX * width / fullWidth;
                top -= view.offsetY * height / fullHeight;
                width *= view.width / fullWidth;
                height *= view.height / fullHeight;
    
            }
    
            var skew = this.filmOffset;
            if ( skew !== 0 ) left += near * skew / this.getFilmWidth();
    
            this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );
    
            this.projectionMatrixInverse.getInverse( this.projectionMatrix );
    
        },
    
        toJSON: function ( meta ) {
    
            var data = Object3D.prototype.toJSON.call( this, meta );
    
            data.object.fov = this.fov;
            data.object.zoom = this.zoom;
    
            data.object.near = this.near;
            data.object.far = this.far;
            data.object.focus = this.focus;
    
            data.object.aspect = this.aspect;
    
            if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
    
            data.object.filmGauge = this.filmGauge;
            data.object.filmOffset = this.filmOffset;
    
            return data;
    
        }
    
    } );
    
    /**
     * Camera for rendering cube maps
     *	- renders scene into axis-aligned cube
     *
     * @author alteredq / http://alteredqualia.com/
     */
    
    var fov = 90, aspect = 1;
    
    function CubeCamera( near, far, cubeResolution, options ) {
    
        Object3D.call( this );
    
        this.type = 'CubeCamera';
    
        var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
        cameraPX.up.set( 0, - 1, 0 );
        cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
        this.add( cameraPX );
    
        var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
        cameraNX.up.set( 0, - 1, 0 );
        cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
        this.add( cameraNX );
    
        var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
        cameraPY.up.set( 0, 0, 1 );
        cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
        this.add( cameraPY );
    
        var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
        cameraNY.up.set( 0, 0, - 1 );
        cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
        this.add( cameraNY );
    
        var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
        cameraPZ.up.set( 0, - 1, 0 );
        cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
        this.add( cameraPZ );
    
        var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
        cameraNZ.up.set( 0, - 1, 0 );
        cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
        this.add( cameraNZ );
    
        options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
    
        this.renderTarget = new WebGLCubeRenderTarget( cubeResolution, options );
        this.renderTarget.texture.name = "CubeCamera";
    
        this.update = function ( renderer, scene ) {
    
            if ( this.parent === null ) this.updateMatrixWorld();
    
            var currentRenderTarget = renderer.getRenderTarget();
    
            var renderTarget = this.renderTarget;
            var generateMipmaps = renderTarget.texture.generateMipmaps;
    
            renderTarget.texture.generateMipmaps = false;
    
            renderer.setRenderTarget( renderTarget, 0 );
            renderer.render( scene, cameraPX );
    
            renderer.setRenderTarget( renderTarget, 1 );
            renderer.render( scene, cameraNX );
    
            renderer.setRenderTarget( renderTarget, 2 );
            renderer.render( scene, cameraPY );
    
            renderer.setRenderTarget( renderTarget, 3 );
            renderer.render( scene, cameraNY );
    
            renderer.setRenderTarget( renderTarget, 4 );
            renderer.render( scene, cameraPZ );
    
            renderTarget.texture.generateMipmaps = generateMipmaps;
    
            renderer.setRenderTarget( renderTarget, 5 );
            renderer.render( scene, cameraNZ );
    
            renderer.setRenderTarget( currentRenderTarget );
    
        };
    
        this.clear = function ( renderer, color, depth, stencil ) {
    
            var currentRenderTarget = renderer.getRenderTarget();
    
            var renderTarget = this.renderTarget;
    
            for ( var i = 0; i < 6; i ++ ) {
    
                renderer.setRenderTarget( renderTarget, i );
    
                renderer.clear( color, depth, stencil );
    
            }
    
            renderer.setRenderTarget( currentRenderTarget );
    
        };
    
    }
    
    CubeCamera.prototype = Object.create( Object3D.prototype );
    CubeCamera.prototype.constructor = CubeCamera;
    
    /**
     * @author alteredq / http://alteredqualia.com
     * @author WestLangley / http://github.com/WestLangley
     */
    
    function WebGLCubeRenderTarget( size, options, dummy ) {
    
        if ( Number.isInteger( options ) ) {
    
            console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );
    
            options = dummy;
    
        }
    
        WebGLRenderTarget.call( this, size, size, options );
    
    }
    
    WebGLCubeRenderTarget.prototype = Object.create( WebGLRenderTarget.prototype );
    WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
    
    WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
    
    WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function ( renderer, texture ) {
    
        this.texture.type = texture.type;
        this.texture.format = texture.format;
        this.texture.encoding = texture.encoding;
    
        var scene = new Scene();
    
        var shader = {
    
            uniforms: {
                tEquirect: { value: null },
            },
    
            vertexShader: [
    
                "varying vec3 vWorldDirection;",
    
                "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {",
    
                "	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );",
    
                "}",
    
                "void main() {",
    
                "	vWorldDirection = transformDirection( position, modelMatrix );",
    
                "	#include <begin_vertex>",
                "	#include <project_vertex>",
    
                "}"
    
            ].join( '\n' ),
    
            fragmentShader: [
    
                "uniform sampler2D tEquirect;",
    
                "varying vec3 vWorldDirection;",
    
                "#define RECIPROCAL_PI 0.31830988618",
                "#define RECIPROCAL_PI2 0.15915494",
    
                "void main() {",
    
                "	vec3 direction = normalize( vWorldDirection );",
    
                "	vec2 sampleUV;",
    
                "	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;",
    
                "	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
    
                "	gl_FragColor = texture2D( tEquirect, sampleUV );",
    
                "}"
    
            ].join( '\n' ),
        };
    
        var material = new ShaderMaterial( {
    
            type: 'CubemapFromEquirect',
    
            uniforms: cloneUniforms( shader.uniforms ),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader,
            side: BackSide,
            blending: NoBlending
    
        } );
    
        material.uniforms.tEquirect.value = texture;
    
        var mesh = new Mesh( new BoxBufferGeometry( 5, 5, 5 ), material );
    
        scene.add( mesh );
    
        var camera = new CubeCamera( 1, 10, 1 );
    
        camera.renderTarget = this;
        camera.renderTarget.texture.name = 'CubeCameraTexture';
    
        camera.update( renderer, scene );
    
        mesh.geometry.dispose();
        mesh.material.dispose();
    
        return this;
    
    };
    
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    
    function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
    
        Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
    
        this.image = { data: data || null, width: width || 1, height: height || 1 };
    
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
    
        this.needsUpdate = true;
    
    }
    
    DataTexture.prototype = Object.create( Texture.prototype );
    DataTexture.prototype.constructor = DataTexture;
    
    DataTexture.prototype.isDataTexture = true;
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / http://clara.io
     */
    
    var _sphere$1 = new Sphere();
    var _vector$5 = new Vector3();
    
    function Frustum( p0, p1, p2, p3, p4, p5 ) {
    
        this.planes = [
    
            ( p0 !== undefined ) ? p0 : new Plane(),
            ( p1 !== undefined ) ? p1 : new Plane(),
            ( p2 !== undefined ) ? p2 : new Plane(),
            ( p3 !== undefined ) ? p3 : new Plane(),
            ( p4 !== undefined ) ? p4 : new Plane(),
            ( p5 !== undefined ) ? p5 : new Plane()
    
        ];
    
    }
    
    Object.assign( Frustum.prototype, {
    
        set: function ( p0, p1, p2, p3, p4, p5 ) {
    
            var planes = this.planes;
    
            planes[ 0 ].copy( p0 );
            planes[ 1 ].copy( p1 );
            planes[ 2 ].copy( p2 );
            planes[ 3 ].copy( p3 );
            planes[ 4 ].copy( p4 );
            planes[ 5 ].copy( p5 );
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( frustum ) {
    
            var planes = this.planes;
    
            for ( var i = 0; i < 6; i ++ ) {
    
                planes[ i ].copy( frustum.planes[ i ] );
    
            }
    
            return this;
    
        },
    
        setFromProjectionMatrix: function ( m ) {
    
            var planes = this.planes;
            var me = m.elements;
            var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
            var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
            var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
            var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
    
            planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
            planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
            planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
            planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
            planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
            planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
    
            return this;
    
        },
    
        intersectsObject: function ( object ) {
    
            var geometry = object.geometry;
    
            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
    
            _sphere$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );
    
            return this.intersectsSphere( _sphere$1 );
    
        },
    
        intersectsSprite: function ( sprite ) {
    
            _sphere$1.center.set( 0, 0, 0 );
            _sphere$1.radius = 0.7071067811865476;
            _sphere$1.applyMatrix4( sprite.matrixWorld );
    
            return this.intersectsSphere( _sphere$1 );
    
        },
    
        intersectsSphere: function ( sphere ) {
    
            var planes = this.planes;
            var center = sphere.center;
            var negRadius = - sphere.radius;
    
            for ( var i = 0; i < 6; i ++ ) {
    
                var distance = planes[ i ].distanceToPoint( center );
    
                if ( distance < negRadius ) {
    
                    return false;
    
                }
    
            }
    
            return true;
    
        },
    
        intersectsBox: function ( box ) {
    
            var planes = this.planes;
    
            for ( var i = 0; i < 6; i ++ ) {
    
                var plane = planes[ i ];
    
                // corner at max distance
    
                _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
    
                if ( plane.distanceToPoint( _vector$5 ) < 0 ) {
    
                    return false;
    
                }
    
            }
    
            return true;
    
        },
    
        containsPoint: function ( point ) {
    
            var planes = this.planes;
    
            for ( var i = 0; i < 6; i ++ ) {
    
                if ( planes[ i ].distanceToPoint( point ) < 0 ) {
    
                    return false;
    
                }
    
            }
    
            return true;
    
        }
    
    } );
    
    /**
     * Uniforms library for shared webgl shaders
     */
    
    var UniformsLib = {
    
        common: {
    
            diffuse: { value: new Color( 0xeeeeee ) },
            opacity: { value: 1.0 },
    
            map: { value: null },
            uvTransform: { value: new Matrix3() },
            uv2Transform: { value: new Matrix3() },
    
            alphaMap: { value: null },
    
        },
    
        specularmap: {
    
            specularMap: { value: null },
    
        },
    
        envmap: {
    
            envMap: { value: null },
            flipEnvMap: { value: - 1 },
            reflectivity: { value: 1.0 },
            refractionRatio: { value: 0.98 },
            maxMipLevel: { value: 0 }
    
        },
    
        aomap: {
    
            aoMap: { value: null },
            aoMapIntensity: { value: 1 }
    
        },
    
        lightmap: {
    
            lightMap: { value: null },
            lightMapIntensity: { value: 1 }
    
        },
    
        emissivemap: {
    
            emissiveMap: { value: null }
    
        },
    
        bumpmap: {
    
            bumpMap: { value: null },
            bumpScale: { value: 1 }
    
        },
    
        normalmap: {
    
            normalMap: { value: null },
            normalScale: { value: new Vector2( 1, 1 ) }
    
        },
    
        displacementmap: {
    
            displacementMap: { value: null },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 }
    
        },
    
        roughnessmap: {
    
            roughnessMap: { value: null }
    
        },
    
        metalnessmap: {
    
            metalnessMap: { value: null }
    
        },
    
        gradientmap: {
    
            gradientMap: { value: null }
    
        },
    
        fog: {
    
            fogDensity: { value: 0.00025 },
            fogNear: { value: 1 },
            fogFar: { value: 2000 },
            fogColor: { value: new Color( 0xffffff ) }
    
        },
    
        lights: {
    
            ambientLightColor: { value: [] },
    
            lightProbe: { value: [] },
    
            directionalLights: { value: [], properties: {
                direction: {},
                color: {}
            } },
    
            directionalLightShadows: { value: [], properties: {
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            } },
    
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
    
            spotLights: { value: [], properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            } },
    
            spotLightShadows: { value: [], properties: {
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            } },
    
            spotShadowMap: { value: [] },
            spotShadowMatrix: { value: [] },
    
            pointLights: { value: [], properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            } },
    
            pointLightShadows: { value: [], properties: {
                shadowBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            } },
    
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
    
            hemisphereLights: { value: [], properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            } },
    
            // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
            rectAreaLights: { value: [], properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            } }
    
        },
    
        points: {
    
            diffuse: { value: new Color( 0xeeeeee ) },
            opacity: { value: 1.0 },
            size: { value: 1.0 },
            scale: { value: 1.0 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new Matrix3() }
    
        },
    
        sprite: {
    
            diffuse: { value: new Color( 0xeeeeee ) },
            opacity: { value: 1.0 },
            center: { value: new Vector2( 0.5, 0.5 ) },
            rotation: { value: 0.0 },
            map: { value: null },
            alphaMap: { value: null },
            uvTransform: { value: new Matrix3() }
    
        }
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLAnimation() {
    
        var context = null;
        var isAnimating = false;
        var animationLoop = null;
    
        function onAnimationFrame( time, frame ) {
    
            if ( isAnimating === false ) return;
    
            animationLoop( time, frame );
    
            context.requestAnimationFrame( onAnimationFrame );
    
        }
    
        return {
    
            start: function () {
    
                if ( isAnimating === true ) return;
                if ( animationLoop === null ) return;
    
                context.requestAnimationFrame( onAnimationFrame );
    
                isAnimating = true;
    
            },
    
            stop: function () {
    
                isAnimating = false;
    
            },
    
            setAnimationLoop: function ( callback ) {
    
                animationLoop = callback;
    
            },
    
            setContext: function ( value ) {
    
                context = value;
    
            }
    
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLAttributes( gl, capabilities ) {
    
        var isWebGL2 = capabilities.isWebGL2;
    
        var buffers = new WeakMap();
    
        function createBuffer( attribute, bufferType ) {
    
            var array = attribute.array;
            var usage = attribute.usage;
    
            var buffer = gl.createBuffer();
    
            gl.bindBuffer( bufferType, buffer );
            gl.bufferData( bufferType, array, usage );
    
            attribute.onUploadCallback();
    
            var type = 5126;
    
            if ( array instanceof Float32Array ) {
    
                type = 5126;
    
            } else if ( array instanceof Float64Array ) {
    
                console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );
    
            } else if ( array instanceof Uint16Array ) {
    
                type = 5123;
    
            } else if ( array instanceof Int16Array ) {
    
                type = 5122;
    
            } else if ( array instanceof Uint32Array ) {
    
                type = 5125;
    
            } else if ( array instanceof Int32Array ) {
    
                type = 5124;
    
            } else if ( array instanceof Int8Array ) {
    
                type = 5120;
    
            } else if ( array instanceof Uint8Array ) {
    
                type = 5121;
    
            }
    
            return {
                buffer: buffer,
                type: type,
                bytesPerElement: array.BYTES_PER_ELEMENT,
                version: attribute.version
            };
    
        }
    
        function updateBuffer( buffer, attribute, bufferType ) {
    
            var array = attribute.array;
            var updateRange = attribute.updateRange;
    
            gl.bindBuffer( bufferType, buffer );
    
            if ( updateRange.count === - 1 ) {
    
                // Not using update ranges
    
                gl.bufferSubData( bufferType, 0, array );
    
            } else {
    
                if ( isWebGL2 ) {
    
                    gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
                        array, updateRange.offset, updateRange.count );
    
                } else {
    
                    gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
                        array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );
    
                }
    
                updateRange.count = - 1; // reset range
    
            }
    
        }
    
        //
    
        function get( attribute ) {
    
            if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
    
            return buffers.get( attribute );
    
        }
    
        function remove( attribute ) {
    
            if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
    
            var data = buffers.get( attribute );
    
            if ( data ) {
    
                gl.deleteBuffer( data.buffer );
    
                buffers.delete( attribute );
    
            }
    
        }
    
        function update( attribute, bufferType ) {
    
            if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
    
            var data = buffers.get( attribute );
    
            if ( data === undefined ) {
    
                buffers.set( attribute, createBuffer( attribute, bufferType ) );
    
            } else if ( data.version < attribute.version ) {
    
                updateBuffer( data.buffer, attribute, bufferType );
    
                data.version = attribute.version;
    
            }
    
        }
    
        return {
    
            get: get,
            remove: remove,
            update: update
    
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // PlaneGeometry
    
    function PlaneGeometry( width, height, widthSegments, heightSegments ) {
    
        Geometry.call( this );
    
        this.type = 'PlaneGeometry';
    
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
    
        this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
        this.mergeVertices();
    
    }
    
    PlaneGeometry.prototype = Object.create( Geometry.prototype );
    PlaneGeometry.prototype.constructor = PlaneGeometry;
    
    // PlaneBufferGeometry
    
    function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {
    
        BufferGeometry.call( this );
    
        this.type = 'PlaneBufferGeometry';
    
        this.parameters = {
            width: width,
            height: height,
            widthSegments: widthSegments,
            heightSegments: heightSegments
        };
    
        width = width || 1;
        height = height || 1;
    
        var width_half = width / 2;
        var height_half = height / 2;
    
        var gridX = Math.floor( widthSegments ) || 1;
        var gridY = Math.floor( heightSegments ) || 1;
    
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
    
        var segment_width = width / gridX;
        var segment_height = height / gridY;
    
        var ix, iy;
    
        // buffers
    
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
    
        // generate vertices, normals and uvs
    
        for ( iy = 0; iy < gridY1; iy ++ ) {
    
            var y = iy * segment_height - height_half;
    
            for ( ix = 0; ix < gridX1; ix ++ ) {
    
                var x = ix * segment_width - width_half;
    
                vertices.push( x, - y, 0 );
    
                normals.push( 0, 0, 1 );
    
                uvs.push( ix / gridX );
                uvs.push( 1 - ( iy / gridY ) );
    
            }
    
        }
    
        // indices
    
        for ( iy = 0; iy < gridY; iy ++ ) {
    
            for ( ix = 0; ix < gridX; ix ++ ) {
    
                var a = ix + gridX1 * iy;
                var b = ix + gridX1 * ( iy + 1 );
                var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
                var d = ( ix + 1 ) + gridX1 * iy;
    
                // faces
    
                indices.push( a, b, d );
                indices.push( b, c, d );
    
            }
    
        }
    
        // build geometry
    
        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
    }
    
    PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
    
    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
    
    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
    
    var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
    
    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
    
    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
    
    var begin_vertex = "vec3 transformed = vec3( position );";
    
    var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
    
    var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
    
    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
    
    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
    
    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP ) && ! defined( TOON )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
    
    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP ) && ! defined( TOON )\n\tvarying vec3 vViewPosition;\n#endif";
    
    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP ) && ! defined( TOON )\n\tvViewPosition = - mvPosition.xyz;\n#endif";
    
    var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
    
    var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
    
    var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
    
    var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
    
    var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}";
    
    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";
    
    var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
    
    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
    
    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
    
    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
    
    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
    
    var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
    
    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
    
    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
    
    var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
    
    var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
    
    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
    
    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
    
    var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";
    
    var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
    
    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
    
    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
    
    var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
    
    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
    
    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
    
    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";
    
    var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
    
    var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
    
    var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
    
    var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
    
    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
    
    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
    
    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = max( clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
    
    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
    
    var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
    
    var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
    
    var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
    
    var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    
    var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
    
    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
    
    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
    
    var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
    
    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
    
    var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
    
    var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
    
    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
    
    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
    
    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
    
    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
    
    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
    
    var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
    
    var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
    
    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";
    
    var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
    
    var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";
    
    var clearcoat_normalmap_pars_fragment = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
    
    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
    
    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
    
    var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
    
    var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
    
    var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
    
    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
    
    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
    
    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
    
    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
    
    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";
    
    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";
    
    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    
    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
    
    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
    
    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
    
    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
    
    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
    
    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
    
    var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";
    
    var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
    
    var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
    
    var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
    
    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
    
    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
    
    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
    
    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
    
    var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
    
    var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
    
    var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
    
    var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
    
    var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
    
    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
    
    var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
    
    var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
    
    var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
    
    var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
    
    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
    
    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
    
    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
    
    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
    
    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    
    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    
    var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
    
    var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
    
    var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    
    var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    
    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    
    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    
    var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
    
    var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    
    var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
    
    var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
    
    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
    
    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
    
    var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
    
    var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
    
    var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
    
    var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
    
    var ShaderChunk = {
        alphamap_fragment: alphamap_fragment,
        alphamap_pars_fragment: alphamap_pars_fragment,
        alphatest_fragment: alphatest_fragment,
        aomap_fragment: aomap_fragment,
        aomap_pars_fragment: aomap_pars_fragment,
        begin_vertex: begin_vertex,
        beginnormal_vertex: beginnormal_vertex,
        bsdfs: bsdfs,
        bumpmap_pars_fragment: bumpmap_pars_fragment,
        clipping_planes_fragment: clipping_planes_fragment,
        clipping_planes_pars_fragment: clipping_planes_pars_fragment,
        clipping_planes_pars_vertex: clipping_planes_pars_vertex,
        clipping_planes_vertex: clipping_planes_vertex,
        color_fragment: color_fragment,
        color_pars_fragment: color_pars_fragment,
        color_pars_vertex: color_pars_vertex,
        color_vertex: color_vertex,
        common: common,
        cube_uv_reflection_fragment: cube_uv_reflection_fragment,
        defaultnormal_vertex: defaultnormal_vertex,
        displacementmap_pars_vertex: displacementmap_pars_vertex,
        displacementmap_vertex: displacementmap_vertex,
        emissivemap_fragment: emissivemap_fragment,
        emissivemap_pars_fragment: emissivemap_pars_fragment,
        encodings_fragment: encodings_fragment,
        encodings_pars_fragment: encodings_pars_fragment,
        envmap_fragment: envmap_fragment,
        envmap_common_pars_fragment: envmap_common_pars_fragment,
        envmap_pars_fragment: envmap_pars_fragment,
        envmap_pars_vertex: envmap_pars_vertex,
        envmap_physical_pars_fragment: envmap_physical_pars_fragment,
        envmap_vertex: envmap_vertex,
        fog_vertex: fog_vertex,
        fog_pars_vertex: fog_pars_vertex,
        fog_fragment: fog_fragment,
        fog_pars_fragment: fog_pars_fragment,
        gradientmap_pars_fragment: gradientmap_pars_fragment,
        lightmap_fragment: lightmap_fragment,
        lightmap_pars_fragment: lightmap_pars_fragment,
        lights_lambert_vertex: lights_lambert_vertex,
        lights_pars_begin: lights_pars_begin,
        lights_toon_fragment: lights_toon_fragment,
        lights_toon_pars_fragment: lights_toon_pars_fragment,
        lights_phong_fragment: lights_phong_fragment,
        lights_phong_pars_fragment: lights_phong_pars_fragment,
        lights_physical_fragment: lights_physical_fragment,
        lights_physical_pars_fragment: lights_physical_pars_fragment,
        lights_fragment_begin: lights_fragment_begin,
        lights_fragment_maps: lights_fragment_maps,
        lights_fragment_end: lights_fragment_end,
        logdepthbuf_fragment: logdepthbuf_fragment,
        logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
        logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
        logdepthbuf_vertex: logdepthbuf_vertex,
        map_fragment: map_fragment,
        map_pars_fragment: map_pars_fragment,
        map_particle_fragment: map_particle_fragment,
        map_particle_pars_fragment: map_particle_pars_fragment,
        metalnessmap_fragment: metalnessmap_fragment,
        metalnessmap_pars_fragment: metalnessmap_pars_fragment,
        morphnormal_vertex: morphnormal_vertex,
        morphtarget_pars_vertex: morphtarget_pars_vertex,
        morphtarget_vertex: morphtarget_vertex,
        normal_fragment_begin: normal_fragment_begin,
        normal_fragment_maps: normal_fragment_maps,
        normalmap_pars_fragment: normalmap_pars_fragment,
        clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
        clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
        clearcoat_normalmap_pars_fragment: clearcoat_normalmap_pars_fragment,
        packing: packing,
        premultiplied_alpha_fragment: premultiplied_alpha_fragment,
        project_vertex: project_vertex,
        dithering_fragment: dithering_fragment,
        dithering_pars_fragment: dithering_pars_fragment,
        roughnessmap_fragment: roughnessmap_fragment,
        roughnessmap_pars_fragment: roughnessmap_pars_fragment,
        shadowmap_pars_fragment: shadowmap_pars_fragment,
        shadowmap_pars_vertex: shadowmap_pars_vertex,
        shadowmap_vertex: shadowmap_vertex,
        shadowmask_pars_fragment: shadowmask_pars_fragment,
        skinbase_vertex: skinbase_vertex,
        skinning_pars_vertex: skinning_pars_vertex,
        skinning_vertex: skinning_vertex,
        skinnormal_vertex: skinnormal_vertex,
        specularmap_fragment: specularmap_fragment,
        specularmap_pars_fragment: specularmap_pars_fragment,
        tonemapping_fragment: tonemapping_fragment,
        tonemapping_pars_fragment: tonemapping_pars_fragment,
        uv_pars_fragment: uv_pars_fragment,
        uv_pars_vertex: uv_pars_vertex,
        uv_vertex: uv_vertex,
        uv2_pars_fragment: uv2_pars_fragment,
        uv2_pars_vertex: uv2_pars_vertex,
        uv2_vertex: uv2_vertex,
        worldpos_vertex: worldpos_vertex,
    
        background_frag: background_frag,
        background_vert: background_vert,
        cube_frag: cube_frag,
        cube_vert: cube_vert,
        depth_frag: depth_frag,
        depth_vert: depth_vert,
        distanceRGBA_frag: distanceRGBA_frag,
        distanceRGBA_vert: distanceRGBA_vert,
        equirect_frag: equirect_frag,
        equirect_vert: equirect_vert,
        linedashed_frag: linedashed_frag,
        linedashed_vert: linedashed_vert,
        meshbasic_frag: meshbasic_frag,
        meshbasic_vert: meshbasic_vert,
        meshlambert_frag: meshlambert_frag,
        meshlambert_vert: meshlambert_vert,
        meshmatcap_frag: meshmatcap_frag,
        meshmatcap_vert: meshmatcap_vert,
        meshtoon_frag: meshtoon_frag,
        meshtoon_vert: meshtoon_vert,
        meshphong_frag: meshphong_frag,
        meshphong_vert: meshphong_vert,
        meshphysical_frag: meshphysical_frag,
        meshphysical_vert: meshphysical_vert,
        normal_frag: normal_frag,
        normal_vert: normal_vert,
        points_frag: points_frag,
        points_vert: points_vert,
        shadow_frag: shadow_frag,
        shadow_vert: shadow_vert,
        sprite_frag: sprite_frag,
        sprite_vert: sprite_vert
    };
    
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     */
    
    var ShaderLib = {
    
        basic: {
    
            uniforms: mergeUniforms( [
                UniformsLib.common,
                UniformsLib.specularmap,
                UniformsLib.envmap,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.fog
            ] ),
    
            vertexShader: ShaderChunk.meshbasic_vert,
            fragmentShader: ShaderChunk.meshbasic_frag
    
        },
    
        lambert: {
    
            uniforms: mergeUniforms( [
                UniformsLib.common,
                UniformsLib.specularmap,
                UniformsLib.envmap,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.emissivemap,
                UniformsLib.fog,
                UniformsLib.lights,
                {
                    emissive: { value: new Color( 0x000000 ) }
                }
            ] ),
    
            vertexShader: ShaderChunk.meshlambert_vert,
            fragmentShader: ShaderChunk.meshlambert_frag
    
        },
    
        phong: {
    
            uniforms: mergeUniforms( [
                UniformsLib.common,
                UniformsLib.specularmap,
                UniformsLib.envmap,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.emissivemap,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                UniformsLib.fog,
                UniformsLib.lights,
                {
                    emissive: { value: new Color( 0x000000 ) },
                    specular: { value: new Color( 0x111111 ) },
                    shininess: { value: 30 }
                }
            ] ),
    
            vertexShader: ShaderChunk.meshphong_vert,
            fragmentShader: ShaderChunk.meshphong_frag
    
        },
    
        standard: {
    
            uniforms: mergeUniforms( [
                UniformsLib.common,
                UniformsLib.envmap,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.emissivemap,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                UniformsLib.roughnessmap,
                UniformsLib.metalnessmap,
                UniformsLib.fog,
                UniformsLib.lights,
                {
                    emissive: { value: new Color( 0x000000 ) },
                    roughness: { value: 0.5 },
                    metalness: { value: 0.5 },
                    envMapIntensity: { value: 1 } // temporary
                }
            ] ),
    
            vertexShader: ShaderChunk.meshphysical_vert,
            fragmentShader: ShaderChunk.meshphysical_frag
    
        },
    
        toon: {
    
            uniforms: mergeUniforms( [
                UniformsLib.common,
                UniformsLib.specularmap,
                UniformsLib.aomap,
                UniformsLib.lightmap,
                UniformsLib.emissivemap,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                UniformsLib.gradientmap,
                UniformsLib.fog,
                UniformsLib.lights,
                {
                    emissive: { value: new Color( 0x000000 ) },
                    specular: { value: new Color( 0x111111 ) },
                    shininess: { value: 30 }
                }
            ] ),
    
            vertexShader: ShaderChunk.meshtoon_vert,
            fragmentShader: ShaderChunk.meshtoon_frag
    
        },
    
        matcap: {
    
            uniforms: mergeUniforms( [
                UniformsLib.common,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                UniformsLib.fog,
                {
                    matcap: { value: null }
                }
            ] ),
    
            vertexShader: ShaderChunk.meshmatcap_vert,
            fragmentShader: ShaderChunk.meshmatcap_frag
    
        },
    
        points: {
    
            uniforms: mergeUniforms( [
                UniformsLib.points,
                UniformsLib.fog
            ] ),
    
            vertexShader: ShaderChunk.points_vert,
            fragmentShader: ShaderChunk.points_frag
    
        },
    
        dashed: {
    
            uniforms: mergeUniforms( [
                UniformsLib.common,
                UniformsLib.fog,
                {
                    scale: { value: 1 },
                    dashSize: { value: 1 },
                    totalSize: { value: 2 }
                }
            ] ),
    
            vertexShader: ShaderChunk.linedashed_vert,
            fragmentShader: ShaderChunk.linedashed_frag
    
        },
    
        depth: {
    
            uniforms: mergeUniforms( [
                UniformsLib.common,
                UniformsLib.displacementmap
            ] ),
    
            vertexShader: ShaderChunk.depth_vert,
            fragmentShader: ShaderChunk.depth_frag
    
        },
    
        normal: {
    
            uniforms: mergeUniforms( [
                UniformsLib.common,
                UniformsLib.bumpmap,
                UniformsLib.normalmap,
                UniformsLib.displacementmap,
                {
                    opacity: { value: 1.0 }
                }
            ] ),
    
            vertexShader: ShaderChunk.normal_vert,
            fragmentShader: ShaderChunk.normal_frag
    
        },
    
        sprite: {
    
            uniforms: mergeUniforms( [
                UniformsLib.sprite,
                UniformsLib.fog
            ] ),
    
            vertexShader: ShaderChunk.sprite_vert,
            fragmentShader: ShaderChunk.sprite_frag
    
        },
    
        background: {
    
            uniforms: {
                uvTransform: { value: new Matrix3() },
                t2D: { value: null },
            },
    
            vertexShader: ShaderChunk.background_vert,
            fragmentShader: ShaderChunk.background_frag
    
        },
        /* -------------------------------------------------------------------------
        //	Cube map shader
         ------------------------------------------------------------------------- */
    
        cube: {
    
            uniforms: mergeUniforms( [
                UniformsLib.envmap,
                {
                    opacity: { value: 1.0 }
                }
            ] ),
    
            vertexShader: ShaderChunk.cube_vert,
            fragmentShader: ShaderChunk.cube_frag
    
        },
    
        equirect: {
    
            uniforms: {
                tEquirect: { value: null },
            },
    
            vertexShader: ShaderChunk.equirect_vert,
            fragmentShader: ShaderChunk.equirect_frag
    
        },
    
        distanceRGBA: {
    
            uniforms: mergeUniforms( [
                UniformsLib.common,
                UniformsLib.displacementmap,
                {
                    referencePosition: { value: new Vector3() },
                    nearDistance: { value: 1 },
                    farDistance: { value: 1000 }
                }
            ] ),
    
            vertexShader: ShaderChunk.distanceRGBA_vert,
            fragmentShader: ShaderChunk.distanceRGBA_frag
    
        },
    
        shadow: {
    
            uniforms: mergeUniforms( [
                UniformsLib.lights,
                UniformsLib.fog,
                {
                    color: { value: new Color( 0x00000 ) },
                    opacity: { value: 1.0 }
                },
            ] ),
    
            vertexShader: ShaderChunk.shadow_vert,
            fragmentShader: ShaderChunk.shadow_frag
    
        }
    
    };
    
    ShaderLib.physical = {
    
        uniforms: mergeUniforms( [
            ShaderLib.standard.uniforms,
            {
                transparency: { value: 0 },
                clearcoat: { value: 0 },
                clearcoatRoughness: { value: 0 },
                sheen: { value: new Color( 0x000000 ) },
                clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
                clearcoatNormalMap: { value: null },
            }
        ] ),
    
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {
    
        var clearColor = new Color( 0x000000 );
        var clearAlpha = 0;
    
        var planeMesh;
        var boxMesh;
    
        var currentBackground = null;
        var currentBackgroundVersion = 0;
        var currentTonemapping = null;
    
        function render( renderList, scene, camera, forceClear ) {
    
            var background = scene.background;
    
            // Ignore background in AR
            // TODO: Reconsider this.
    
            var xr = renderer.xr;
            var session = xr.getSession && xr.getSession();
    
            if ( session && session.environmentBlendMode === 'additive' ) {
    
                background = null;
    
            }
    
            if ( background === null ) {
    
                setClear( clearColor, clearAlpha );
    
            } else if ( background && background.isColor ) {
    
                setClear( background, 1 );
                forceClear = true;
    
            }
    
            if ( renderer.autoClear || forceClear ) {
    
                renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
    
            }
    
            if ( background && ( background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping ) ) {
    
                if ( boxMesh === undefined ) {
    
                    boxMesh = new Mesh(
                        new BoxBufferGeometry( 1, 1, 1 ),
                        new ShaderMaterial( {
                            type: 'BackgroundCubeMaterial',
                            uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
                            vertexShader: ShaderLib.cube.vertexShader,
                            fragmentShader: ShaderLib.cube.fragmentShader,
                            side: BackSide,
                            depthTest: false,
                            depthWrite: false,
                            fog: false
                        } )
                    );
    
                    boxMesh.geometry.deleteAttribute( 'normal' );
                    boxMesh.geometry.deleteAttribute( 'uv' );
    
                    boxMesh.onBeforeRender = function ( renderer, scene, camera ) {
    
                        this.matrixWorld.copyPosition( camera.matrixWorld );
    
                    };
    
                    // enable code injection for non-built-in material
                    Object.defineProperty( boxMesh.material, 'envMap', {
    
                        get: function () {
    
                            return this.uniforms.envMap.value;
    
                        }
    
                    } );
    
                    objects.update( boxMesh );
    
                }
    
                var texture = background.isWebGLCubeRenderTarget ? background.texture : background;
    
                boxMesh.material.uniforms.envMap.value = texture;
                boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? - 1 : 1;
    
                if ( currentBackground !== background ||
                    currentBackgroundVersion !== texture.version ||
                    currentTonemapping !== renderer.toneMapping ) {
    
                    boxMesh.material.needsUpdate = true;
    
                    currentBackground = background;
                    currentBackgroundVersion = texture.version;
                    currentTonemapping = renderer.toneMapping;
    
                }
    
                // push to the pre-sorted opaque render list
                renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );
    
            } else if ( background && background.isTexture ) {
    
                if ( planeMesh === undefined ) {
    
                    planeMesh = new Mesh(
                        new PlaneBufferGeometry( 2, 2 ),
                        new ShaderMaterial( {
                            type: 'BackgroundMaterial',
                            uniforms: cloneUniforms( ShaderLib.background.uniforms ),
                            vertexShader: ShaderLib.background.vertexShader,
                            fragmentShader: ShaderLib.background.fragmentShader,
                            side: FrontSide,
                            depthTest: false,
                            depthWrite: false,
                            fog: false
                        } )
                    );
    
                    planeMesh.geometry.deleteAttribute( 'normal' );
    
                    // enable code injection for non-built-in material
                    Object.defineProperty( planeMesh.material, 'map', {
    
                        get: function () {
    
                            return this.uniforms.t2D.value;
    
                        }
    
                    } );
    
                    objects.update( planeMesh );
    
                }
    
                planeMesh.material.uniforms.t2D.value = background;
    
                if ( background.matrixAutoUpdate === true ) {
    
                    background.updateMatrix();
    
                }
    
                planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );
    
                if ( currentBackground !== background ||
                    currentBackgroundVersion !== background.version ||
                    currentTonemapping !== renderer.toneMapping ) {
    
                    planeMesh.material.needsUpdate = true;
    
                    currentBackground = background;
                    currentBackgroundVersion = background.version;
                    currentTonemapping = renderer.toneMapping;
    
                }
    
    
                // push to the pre-sorted opaque render list
                renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );
    
            }
    
        }
    
        function setClear( color, alpha ) {
    
            state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );
    
        }
    
        return {
    
            getClearColor: function () {
    
                return clearColor;
    
            },
            setClearColor: function ( color, alpha ) {
    
                clearColor.set( color );
                clearAlpha = alpha !== undefined ? alpha : 1;
                setClear( clearColor, clearAlpha );
    
            },
            getClearAlpha: function () {
    
                return clearAlpha;
    
            },
            setClearAlpha: function ( alpha ) {
    
                clearAlpha = alpha;
                setClear( clearColor, clearAlpha );
    
            },
            render: render
    
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLBufferRenderer( gl, extensions, info, capabilities ) {
    
        var isWebGL2 = capabilities.isWebGL2;
    
        var mode;
    
        function setMode( value ) {
    
            mode = value;
    
        }
    
        function render( start, count ) {
    
            gl.drawArrays( mode, start, count );
    
            info.update( count, mode );
    
        }
    
        function renderInstances( geometry, start, count, primcount ) {
    
            if ( primcount === 0 ) return;
    
            var extension, methodName;
    
            if ( isWebGL2 ) {
    
                extension = gl;
                methodName = 'drawArraysInstanced';
    
            } else {
    
                extension = extensions.get( 'ANGLE_instanced_arrays' );
                methodName = 'drawArraysInstancedANGLE';
    
                if ( extension === null ) {
    
                    console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
                    return;
    
                }
    
            }
    
            extension[ methodName ]( mode, start, count, primcount );
    
            info.update( count, mode, primcount );
    
        }
    
        //
    
        this.setMode = setMode;
        this.render = render;
        this.renderInstances = renderInstances;
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLCapabilities( gl, extensions, parameters ) {
    
        var maxAnisotropy;
    
        function getMaxAnisotropy() {
    
            if ( maxAnisotropy !== undefined ) return maxAnisotropy;
    
            var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
    
            if ( extension !== null ) {
    
                maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
    
            } else {
    
                maxAnisotropy = 0;
    
            }
    
            return maxAnisotropy;
    
        }
    
        function getMaxPrecision( precision ) {
    
            if ( precision === 'highp' ) {
    
                if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
                    gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {
    
                    return 'highp';
    
                }
    
                precision = 'mediump';
    
            }
    
            if ( precision === 'mediump' ) {
    
                if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
                    gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {
    
                    return 'mediump';
    
                }
    
            }
    
            return 'lowp';
    
        }
    
        /* eslint-disable no-undef */
        var isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
            ( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
        /* eslint-enable no-undef */
    
        var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
        var maxPrecision = getMaxPrecision( precision );
    
        if ( maxPrecision !== precision ) {
    
            console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
            precision = maxPrecision;
    
        }
    
        var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    
        var maxTextures = gl.getParameter( 34930 );
        var maxVertexTextures = gl.getParameter( 35660 );
        var maxTextureSize = gl.getParameter( 3379 );
        var maxCubemapSize = gl.getParameter( 34076 );
    
        var maxAttributes = gl.getParameter( 34921 );
        var maxVertexUniforms = gl.getParameter( 36347 );
        var maxVaryings = gl.getParameter( 36348 );
        var maxFragmentUniforms = gl.getParameter( 36349 );
    
        var vertexTextures = maxVertexTextures > 0;
        var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
        var floatVertexTextures = vertexTextures && floatFragmentTextures;
    
        var maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;
    
        return {
    
            isWebGL2: isWebGL2,
    
            getMaxAnisotropy: getMaxAnisotropy,
            getMaxPrecision: getMaxPrecision,
    
            precision: precision,
            logarithmicDepthBuffer: logarithmicDepthBuffer,
    
            maxTextures: maxTextures,
            maxVertexTextures: maxVertexTextures,
            maxTextureSize: maxTextureSize,
            maxCubemapSize: maxCubemapSize,
    
            maxAttributes: maxAttributes,
            maxVertexUniforms: maxVertexUniforms,
            maxVaryings: maxVaryings,
            maxFragmentUniforms: maxFragmentUniforms,
    
            vertexTextures: vertexTextures,
            floatFragmentTextures: floatFragmentTextures,
            floatVertexTextures: floatVertexTextures,
    
            maxSamples: maxSamples
    
        };
    
    }
    
    /**
     * @author tschw
     */
    
    function WebGLClipping() {
    
        var scope = this,
    
            globalState = null,
            numGlobalPlanes = 0,
            localClippingEnabled = false,
            renderingShadows = false,
    
            plane = new Plane(),
            viewNormalMatrix = new Matrix3(),
    
            uniform = { value: null, needsUpdate: false };
    
        this.uniform = uniform;
        this.numPlanes = 0;
        this.numIntersection = 0;
    
        this.init = function ( planes, enableLocalClipping, camera ) {
    
            var enabled =
                planes.length !== 0 ||
                enableLocalClipping ||
                // enable state of previous frame - the clipping code has to
                // run another frame in order to reset the state:
                numGlobalPlanes !== 0 ||
                localClippingEnabled;
    
            localClippingEnabled = enableLocalClipping;
    
            globalState = projectPlanes( planes, camera, 0 );
            numGlobalPlanes = planes.length;
    
            return enabled;
    
        };
    
        this.beginShadows = function () {
    
            renderingShadows = true;
            projectPlanes( null );
    
        };
    
        this.endShadows = function () {
    
            renderingShadows = false;
            resetGlobalState();
    
        };
    
        this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {
    
            if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {
    
                // there's no local clipping
    
                if ( renderingShadows ) {
    
                    // there's no global clipping
    
                    projectPlanes( null );
    
                } else {
    
                    resetGlobalState();
    
                }
    
            } else {
    
                var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
                    lGlobal = nGlobal * 4,
    
                    dstArray = cache.clippingState || null;
    
                uniform.value = dstArray; // ensure unique state
    
                dstArray = projectPlanes( planes, camera, lGlobal, fromCache );
    
                for ( var i = 0; i !== lGlobal; ++ i ) {
    
                    dstArray[ i ] = globalState[ i ];
    
                }
    
                cache.clippingState = dstArray;
                this.numIntersection = clipIntersection ? this.numPlanes : 0;
                this.numPlanes += nGlobal;
    
            }
    
    
        };
    
        function resetGlobalState() {
    
            if ( uniform.value !== globalState ) {
    
                uniform.value = globalState;
                uniform.needsUpdate = numGlobalPlanes > 0;
    
            }
    
            scope.numPlanes = numGlobalPlanes;
            scope.numIntersection = 0;
    
        }
    
        function projectPlanes( planes, camera, dstOffset, skipTransform ) {
    
            var nPlanes = planes !== null ? planes.length : 0,
                dstArray = null;
    
            if ( nPlanes !== 0 ) {
    
                dstArray = uniform.value;
    
                if ( skipTransform !== true || dstArray === null ) {
    
                    var flatSize = dstOffset + nPlanes * 4,
                        viewMatrix = camera.matrixWorldInverse;
    
                    viewNormalMatrix.getNormalMatrix( viewMatrix );
    
                    if ( dstArray === null || dstArray.length < flatSize ) {
    
                        dstArray = new Float32Array( flatSize );
    
                    }
    
                    for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {
    
                        plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );
    
                        plane.normal.toArray( dstArray, i4 );
                        dstArray[ i4 + 3 ] = plane.constant;
    
                    }
    
                }
    
                uniform.value = dstArray;
                uniform.needsUpdate = true;
    
            }
    
            scope.numPlanes = nPlanes;
            scope.numIntersection = 0;
    
            return dstArray;
    
        }
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLExtensions( gl ) {
    
        var extensions = {};
    
        return {
    
            get: function ( name ) {
    
                if ( extensions[ name ] !== undefined ) {
    
                    return extensions[ name ];
    
                }
    
                var extension;
    
                switch ( name ) {
    
                    case 'WEBGL_depth_texture':
                        extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
                        break;
    
                    case 'EXT_texture_filter_anisotropic':
                        extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
                        break;
    
                    case 'WEBGL_compressed_texture_s3tc':
                        extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
                        break;
    
                    case 'WEBGL_compressed_texture_pvrtc':
                        extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
                        break;
    
                    default:
                        extension = gl.getExtension( name );
    
                }
    
                if ( extension === null ) {
    
                    console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
    
                }
    
                extensions[ name ] = extension;
    
                return extension;
    
            }
    
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLGeometries( gl, attributes, info ) {
    
        var geometries = new WeakMap();
        var wireframeAttributes = new WeakMap();
    
        function onGeometryDispose( event ) {
    
            var geometry = event.target;
            var buffergeometry = geometries.get( geometry );
    
            if ( buffergeometry.index !== null ) {
    
                attributes.remove( buffergeometry.index );
    
            }
    
            for ( var name in buffergeometry.attributes ) {
    
                attributes.remove( buffergeometry.attributes[ name ] );
    
            }
    
            geometry.removeEventListener( 'dispose', onGeometryDispose );
    
            geometries.delete( geometry );
    
            var attribute = wireframeAttributes.get( buffergeometry );
    
            if ( attribute ) {
    
                attributes.remove( attribute );
                wireframeAttributes.delete( buffergeometry );
    
            }
    
            //
    
            info.memory.geometries --;
    
        }
    
        function get( object, geometry ) {
    
            var buffergeometry = geometries.get( geometry );
    
            if ( buffergeometry ) return buffergeometry;
    
            geometry.addEventListener( 'dispose', onGeometryDispose );
    
            if ( geometry.isBufferGeometry ) {
    
                buffergeometry = geometry;
    
            } else if ( geometry.isGeometry ) {
    
                if ( geometry._bufferGeometry === undefined ) {
    
                    geometry._bufferGeometry = new BufferGeometry().setFromObject( object );
    
                }
    
                buffergeometry = geometry._bufferGeometry;
    
            }
    
            geometries.set( geometry, buffergeometry );
    
            info.memory.geometries ++;
    
            return buffergeometry;
    
        }
    
        function update( geometry ) {
    
            var index = geometry.index;
            var geometryAttributes = geometry.attributes;
    
            if ( index !== null ) {
    
                attributes.update( index, 34963 );
    
            }
    
            for ( var name in geometryAttributes ) {
    
                attributes.update( geometryAttributes[ name ], 34962 );
    
            }
    
            // morph targets
    
            var morphAttributes = geometry.morphAttributes;
    
            for ( var name in morphAttributes ) {
    
                var array = morphAttributes[ name ];
    
                for ( var i = 0, l = array.length; i < l; i ++ ) {
    
                    attributes.update( array[ i ], 34962 );
    
                }
    
            }
    
        }
    
        function updateWireframeAttribute( geometry ) {
    
            var indices = [];
    
            var geometryIndex = geometry.index;
            var geometryPosition = geometry.attributes.position;
            var version = 0;
    
            if ( geometryIndex !== null ) {
    
                var array = geometryIndex.array;
                version = geometryIndex.version;
    
                for ( var i = 0, l = array.length; i < l; i += 3 ) {
    
                    var a = array[ i + 0 ];
                    var b = array[ i + 1 ];
                    var c = array[ i + 2 ];
    
                    indices.push( a, b, b, c, c, a );
    
                }
    
            } else {
    
                var array = geometryPosition.array;
                version = geometryPosition.version;
    
                for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {
    
                    var a = i + 0;
                    var b = i + 1;
                    var c = i + 2;
    
                    indices.push( a, b, b, c, c, a );
    
                }
    
            }
    
            var attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
            attribute.version = version;
    
            attributes.update( attribute, 34963 );
    
            //
    
            var previousAttribute = wireframeAttributes.get( geometry );
    
            if ( previousAttribute ) attributes.remove( previousAttribute );
    
            //
    
            wireframeAttributes.set( geometry, attribute );
    
        }
    
        function getWireframeAttribute( geometry ) {
    
            var currentAttribute = wireframeAttributes.get( geometry );
    
            if ( currentAttribute ) {
    
                var geometryIndex = geometry.index;
    
                if ( geometryIndex !== null ) {
    
                    // if the attribute is obsolete, create a new one
    
                    if ( currentAttribute.version < geometryIndex.version ) {
    
                        updateWireframeAttribute( geometry );
    
                    }
    
                }
    
            } else {
    
                updateWireframeAttribute( geometry );
    
            }
    
            return wireframeAttributes.get( geometry );
    
        }
    
        return {
    
            get: get,
            update: update,
    
            getWireframeAttribute: getWireframeAttribute
    
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {
    
        var isWebGL2 = capabilities.isWebGL2;
    
        var mode;
    
        function setMode( value ) {
    
            mode = value;
    
        }
    
        var type, bytesPerElement;
    
        function setIndex( value ) {
    
            type = value.type;
            bytesPerElement = value.bytesPerElement;
    
        }
    
        function render( start, count ) {
    
            gl.drawElements( mode, count, type, start * bytesPerElement );
    
            info.update( count, mode );
    
        }
    
        function renderInstances( geometry, start, count, primcount ) {
    
            if ( primcount === 0 ) return;
    
            var extension, methodName;
    
            if ( isWebGL2 ) {
    
                extension = gl;
                methodName = 'drawElementsInstanced';
    
            } else {
    
                extension = extensions.get( 'ANGLE_instanced_arrays' );
                methodName = 'drawElementsInstancedANGLE';
    
                if ( extension === null ) {
    
                    console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
                    return;
    
                }
    
            }
    
            extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );
    
            info.update( count, mode, primcount );
    
        }
    
        //
    
        this.setMode = setMode;
        this.setIndex = setIndex;
        this.render = render;
        this.renderInstances = renderInstances;
    
    }
    
    /**
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    function WebGLInfo( gl ) {
    
        var memory = {
            geometries: 0,
            textures: 0
        };
    
        var render = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
    
        function update( count, mode, instanceCount ) {
    
            instanceCount = instanceCount || 1;
    
            render.calls ++;
    
            switch ( mode ) {
    
                case 4:
                    render.triangles += instanceCount * ( count / 3 );
                    break;
    
                case 1:
                    render.lines += instanceCount * ( count / 2 );
                    break;
    
                case 3:
                    render.lines += instanceCount * ( count - 1 );
                    break;
    
                case 2:
                    render.lines += instanceCount * count;
                    break;
    
                case 0:
                    render.points += instanceCount * count;
                    break;
    
                default:
                    console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
                    break;
    
            }
    
        }
    
        function reset() {
    
            render.frame ++;
            render.calls = 0;
            render.triangles = 0;
            render.points = 0;
            render.lines = 0;
    
        }
    
        return {
            memory: memory,
            render: render,
            programs: null,
            autoReset: true,
            reset: reset,
            update: update
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function absNumericalSort( a, b ) {
    
        return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );
    
    }
    
    function WebGLMorphtargets( gl ) {
    
        var influencesList = {};
        var morphInfluences = new Float32Array( 8 );
    
        function update( object, geometry, material, program ) {
    
            var objectInfluences = object.morphTargetInfluences;
    
            // When object doesn't have morph target influences defined, we treat it as a 0-length array
            // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
    
            var length = objectInfluences === undefined ? 0 : objectInfluences.length;
    
            var influences = influencesList[ geometry.id ];
    
            if ( influences === undefined ) {
    
                // initialise list
    
                influences = [];
    
                for ( var i = 0; i < length; i ++ ) {
    
                    influences[ i ] = [ i, 0 ];
    
                }
    
                influencesList[ geometry.id ] = influences;
    
            }
    
            var morphTargets = material.morphTargets && geometry.morphAttributes.position;
            var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
    
            // Remove current morphAttributes
    
            for ( var i = 0; i < length; i ++ ) {
    
                var influence = influences[ i ];
    
                if ( influence[ 1 ] !== 0 ) {
    
                    if ( morphTargets ) geometry.deleteAttribute( 'morphTarget' + i );
                    if ( morphNormals ) geometry.deleteAttribute( 'morphNormal' + i );
    
                }
    
            }
    
            // Collect influences
    
            for ( var i = 0; i < length; i ++ ) {
    
                var influence = influences[ i ];
    
                influence[ 0 ] = i;
                influence[ 1 ] = objectInfluences[ i ];
    
            }
    
            influences.sort( absNumericalSort );
    
            // Add morphAttributes
    
            var morphInfluencesSum = 0;
    
            for ( var i = 0; i < 8; i ++ ) {
    
                var influence = influences[ i ];
    
                if ( influence ) {
    
                    var index = influence[ 0 ];
                    var value = influence[ 1 ];
    
                    if ( value ) {
    
                        if ( morphTargets ) geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );
                        if ( morphNormals ) geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );
    
                        morphInfluences[ i ] = value;
                        morphInfluencesSum += value;
                        continue;
    
                    }
    
                }
    
                morphInfluences[ i ] = 0;
    
            }
    
            // GLSL shader uses formula baseinfluence * base + sum(target * influence)
            // This allows us to switch between absolute morphs and relative morphs without changing shader code
            // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
            var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    
            program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
            program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );
    
        }
    
        return {
    
            update: update
    
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLObjects( gl, geometries, attributes, info ) {
    
        var updateMap = new WeakMap();
    
        function update( object ) {
    
            var frame = info.render.frame;
    
            var geometry = object.geometry;
            var buffergeometry = geometries.get( object, geometry );
    
            // Update once per frame
    
            if ( updateMap.get( buffergeometry ) !== frame ) {
    
                if ( geometry.isGeometry ) {
    
                    buffergeometry.updateFromObject( object );
    
                }
    
                geometries.update( buffergeometry );
    
                updateMap.set( buffergeometry, frame );
    
            }
    
            if ( object.isInstancedMesh ) {
    
                attributes.update( object.instanceMatrix, 34962 );
    
            }
    
            return buffergeometry;
    
        }
    
        function dispose() {
    
            updateMap = new WeakMap();
    
        }
    
        return {
    
            update: update,
            dispose: dispose
    
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
    
        images = images !== undefined ? images : [];
        mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
        format = format !== undefined ? format : RGBFormat;
    
        Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
    
        this.flipY = false;
    
    }
    
    CubeTexture.prototype = Object.create( Texture.prototype );
    CubeTexture.prototype.constructor = CubeTexture;
    
    CubeTexture.prototype.isCubeTexture = true;
    
    Object.defineProperty( CubeTexture.prototype, 'images', {
    
        get: function () {
    
            return this.image;
    
        },
    
        set: function ( value ) {
    
            this.image = value;
    
        }
    
    } );
    
    /**
     * @author Takahiro https://github.com/takahirox
     */
    
    function DataTexture2DArray( data, width, height, depth ) {
    
        Texture.call( this, null );
    
        this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };
    
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
    
        this.wrapR = ClampToEdgeWrapping;
    
        this.generateMipmaps = false;
        this.flipY = false;
    
        this.needsUpdate = true;
    
    }
    
    DataTexture2DArray.prototype = Object.create( Texture.prototype );
    DataTexture2DArray.prototype.constructor = DataTexture2DArray;
    DataTexture2DArray.prototype.isDataTexture2DArray = true;
    
    /**
     * @author Artur Trzesiok
     */
    
    function DataTexture3D( data, width, height, depth ) {
    
        // We're going to add .setXXX() methods for setting properties later.
        // Users can still set in DataTexture3D directly.
        //
        //	var texture = new THREE.DataTexture3D( data, width, height, depth );
        // 	texture.anisotropy = 16;
        //
        // See #14839
    
        Texture.call( this, null );
    
        this.image = { data: data || null, width: width || 1, height: height || 1, depth: depth || 1 };
    
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
    
        this.wrapR = ClampToEdgeWrapping;
    
        this.generateMipmaps = false;
        this.flipY = false;
    
        this.needsUpdate = true;
    
    
    }
    
    DataTexture3D.prototype = Object.create( Texture.prototype );
    DataTexture3D.prototype.constructor = DataTexture3D;
    DataTexture3D.prototype.isDataTexture3D = true;
    
    /**
     * @author tschw
     * @author Mugen87 / https://github.com/Mugen87
     * @author mrdoob / http://mrdoob.com/
     *
     * Uniforms of a program.
     * Those form a tree structure with a special top-level container for the root,
     * which you get by calling 'new WebGLUniforms( gl, program )'.
     *
     *
     * Properties of inner nodes including the top-level container:
     *
     * .seq - array of nested uniforms
     * .map - nested uniforms by name
     *
     *
     * Methods of all nodes except the top-level container:
     *
     * .setValue( gl, value, [textures] )
     *
     * 		uploads a uniform value(s)
     *  	the 'textures' parameter is needed for sampler uniforms
     *
     *
     * Static methods of the top-level container (textures factorizations):
     *
     * .upload( gl, seq, values, textures )
     *
     * 		sets uniforms in 'seq' to 'values[id].value'
     *
     * .seqWithValue( seq, values ) : filteredSeq
     *
     * 		filters 'seq' entries with corresponding entry in values
     *
     *
     * Methods of the top-level container (textures factorizations):
     *
     * .setValue( gl, name, value, textures )
     *
     * 		sets uniform with  name 'name' to 'value'
     *
     * .setOptional( gl, obj, prop )
     *
     * 		like .set for an optional property of the object
     *
     */
    
    var emptyTexture = new Texture();
    var emptyTexture2dArray = new DataTexture2DArray();
    var emptyTexture3d = new DataTexture3D();
    var emptyCubeTexture = new CubeTexture();
    
    // --- Utilities ---
    
    // Array Caches (provide typed arrays for temporary by size)
    
    var arrayCacheF32 = [];
    var arrayCacheI32 = [];
    
    // Float32Array caches used for uploading Matrix uniforms
    
    var mat4array = new Float32Array( 16 );
    var mat3array = new Float32Array( 9 );
    var mat2array = new Float32Array( 4 );
    
    // Flattening for arrays of vectors and matrices
    
    function flatten( array, nBlocks, blockSize ) {
    
        var firstElem = array[ 0 ];
    
        if ( firstElem <= 0 || firstElem > 0 ) return array;
        // unoptimized: ! isNaN( firstElem )
        // see http://jacksondunstan.com/articles/983
    
        var n = nBlocks * blockSize,
            r = arrayCacheF32[ n ];
    
        if ( r === undefined ) {
    
            r = new Float32Array( n );
            arrayCacheF32[ n ] = r;
    
        }
    
        if ( nBlocks !== 0 ) {
    
            firstElem.toArray( r, 0 );
    
            for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {
    
                offset += blockSize;
                array[ i ].toArray( r, offset );
    
            }
    
        }
    
        return r;
    
    }
    
    function arraysEqual( a, b ) {
    
        if ( a.length !== b.length ) return false;
    
        for ( var i = 0, l = a.length; i < l; i ++ ) {
    
            if ( a[ i ] !== b[ i ] ) return false;
    
        }
    
        return true;
    
    }
    
    function copyArray( a, b ) {
    
        for ( var i = 0, l = b.length; i < l; i ++ ) {
    
            a[ i ] = b[ i ];
    
        }
    
    }
    
    // Texture unit allocation
    
    function allocTexUnits( textures, n ) {
    
        var r = arrayCacheI32[ n ];
    
        if ( r === undefined ) {
    
            r = new Int32Array( n );
            arrayCacheI32[ n ] = r;
    
        }
    
        for ( var i = 0; i !== n; ++ i )
            r[ i ] = textures.allocateTextureUnit();
    
        return r;
    
    }
    
    // --- Setters ---
    
    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.
    
    // Single scalar
    
    function setValueV1f( gl, v ) {
    
        var cache = this.cache;
    
        if ( cache[ 0 ] === v ) return;
    
        gl.uniform1f( this.addr, v );
    
        cache[ 0 ] = v;
    
    }
    
    // Single float vector (from flat array or THREE.VectorN)
    
    function setValueV2f( gl, v ) {
    
        var cache = this.cache;
    
        if ( v.x !== undefined ) {
    
            if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {
    
                gl.uniform2f( this.addr, v.x, v.y );
    
                cache[ 0 ] = v.x;
                cache[ 1 ] = v.y;
    
            }
    
        } else {
    
            if ( arraysEqual( cache, v ) ) return;
    
            gl.uniform2fv( this.addr, v );
    
            copyArray( cache, v );
    
        }
    
    }
    
    function setValueV3f( gl, v ) {
    
        var cache = this.cache;
    
        if ( v.x !== undefined ) {
    
            if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {
    
                gl.uniform3f( this.addr, v.x, v.y, v.z );
    
                cache[ 0 ] = v.x;
                cache[ 1 ] = v.y;
                cache[ 2 ] = v.z;
    
            }
    
        } else if ( v.r !== undefined ) {
    
            if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {
    
                gl.uniform3f( this.addr, v.r, v.g, v.b );
    
                cache[ 0 ] = v.r;
                cache[ 1 ] = v.g;
                cache[ 2 ] = v.b;
    
            }
    
        } else {
    
            if ( arraysEqual( cache, v ) ) return;
    
            gl.uniform3fv( this.addr, v );
    
            copyArray( cache, v );
    
        }
    
    }
    
    function setValueV4f( gl, v ) {
    
        var cache = this.cache;
    
        if ( v.x !== undefined ) {
    
            if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {
    
                gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );
    
                cache[ 0 ] = v.x;
                cache[ 1 ] = v.y;
                cache[ 2 ] = v.z;
                cache[ 3 ] = v.w;
    
            }
    
        } else {
    
            if ( arraysEqual( cache, v ) ) return;
    
            gl.uniform4fv( this.addr, v );
    
            copyArray( cache, v );
    
        }
    
    }
    
    // Single matrix (from flat array or MatrixN)
    
    function setValueM2( gl, v ) {
    
        var cache = this.cache;
        var elements = v.elements;
    
        if ( elements === undefined ) {
    
            if ( arraysEqual( cache, v ) ) return;
    
            gl.uniformMatrix2fv( this.addr, false, v );
    
            copyArray( cache, v );
    
        } else {
    
            if ( arraysEqual( cache, elements ) ) return;
    
            mat2array.set( elements );
    
            gl.uniformMatrix2fv( this.addr, false, mat2array );
    
            copyArray( cache, elements );
    
        }
    
    }
    
    function setValueM3( gl, v ) {
    
        var cache = this.cache;
        var elements = v.elements;
    
        if ( elements === undefined ) {
    
            if ( arraysEqual( cache, v ) ) return;
    
            gl.uniformMatrix3fv( this.addr, false, v );
    
            copyArray( cache, v );
    
        } else {
    
            if ( arraysEqual( cache, elements ) ) return;
    
            mat3array.set( elements );
    
            gl.uniformMatrix3fv( this.addr, false, mat3array );
    
            copyArray( cache, elements );
    
        }
    
    }
    
    function setValueM4( gl, v ) {
    
        var cache = this.cache;
        var elements = v.elements;
    
        if ( elements === undefined ) {
    
            if ( arraysEqual( cache, v ) ) return;
    
            gl.uniformMatrix4fv( this.addr, false, v );
    
            copyArray( cache, v );
    
        } else {
    
            if ( arraysEqual( cache, elements ) ) return;
    
            mat4array.set( elements );
    
            gl.uniformMatrix4fv( this.addr, false, mat4array );
    
            copyArray( cache, elements );
    
        }
    
    }
    
    // Single texture (2D / Cube)
    
    function setValueT1( gl, v, textures ) {
    
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
    
        if ( cache[ 0 ] !== unit ) {
    
            gl.uniform1i( this.addr, unit );
            cache[ 0 ] = unit;
    
        }
    
        textures.safeSetTexture2D( v || emptyTexture, unit );
    
    }
    
    function setValueT2DArray1( gl, v, textures ) {
    
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
    
        if ( cache[ 0 ] !== unit ) {
    
            gl.uniform1i( this.addr, unit );
            cache[ 0 ] = unit;
    
        }
    
        textures.setTexture2DArray( v || emptyTexture2dArray, unit );
    
    }
    
    function setValueT3D1( gl, v, textures ) {
    
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
    
        if ( cache[ 0 ] !== unit ) {
    
            gl.uniform1i( this.addr, unit );
            cache[ 0 ] = unit;
    
        }
    
        textures.setTexture3D( v || emptyTexture3d, unit );
    
    }
    
    function setValueT6( gl, v, textures ) {
    
        var cache = this.cache;
        var unit = textures.allocateTextureUnit();
    
        if ( cache[ 0 ] !== unit ) {
    
            gl.uniform1i( this.addr, unit );
            cache[ 0 ] = unit;
    
        }
    
        textures.safeSetTextureCube( v || emptyCubeTexture, unit );
    
    }
    
    // Integer / Boolean vectors or arrays thereof (always flat arrays)
    
    function setValueV1i( gl, v ) {
    
        var cache = this.cache;
    
        if ( cache[ 0 ] === v ) return;
    
        gl.uniform1i( this.addr, v );
    
        cache[ 0 ] = v;
    
    }
    
    function setValueV2i( gl, v ) {
    
        var cache = this.cache;
    
        if ( arraysEqual( cache, v ) ) return;
    
        gl.uniform2iv( this.addr, v );
    
        copyArray( cache, v );
    
    }
    
    function setValueV3i( gl, v ) {
    
        var cache = this.cache;
    
        if ( arraysEqual( cache, v ) ) return;
    
        gl.uniform3iv( this.addr, v );
    
        copyArray( cache, v );
    
    }
    
    function setValueV4i( gl, v ) {
    
        var cache = this.cache;
    
        if ( arraysEqual( cache, v ) ) return;
    
        gl.uniform4iv( this.addr, v );
    
        copyArray( cache, v );
    
    }
    
    // uint
    
    function setValueV1ui( gl, v ) {
    
        var cache = this.cache;
    
        if ( cache[ 0 ] === v ) return;
    
        gl.uniform1ui( this.addr, v );
    
        cache[ 0 ] = v;
    
    }
    
    // Helper to pick the right setter for the singular case
    
    function getSingularSetter( type ) {
    
        switch ( type ) {
    
            case 0x1406: return setValueV1f; // FLOAT
            case 0x8b50: return setValueV2f; // _VEC2
            case 0x8b51: return setValueV3f; // _VEC3
            case 0x8b52: return setValueV4f; // _VEC4
    
            case 0x8b5a: return setValueM2; // _MAT2
            case 0x8b5b: return setValueM3; // _MAT3
            case 0x8b5c: return setValueM4; // _MAT4
    
            case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
            case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
            case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
            case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4
    
            case 0x1405: return setValueV1ui; // UINT
    
            case 0x8b5e: // SAMPLER_2D
            case 0x8d66: // SAMPLER_EXTERNAL_OES
            case 0x8dca: // INT_SAMPLER_2D
            case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
            case 0x8b62: // SAMPLER_2D_SHADOW
                return setValueT1;
    
            case 0x8b5f: // SAMPLER_3D
            case 0x8dcb: // INT_SAMPLER_3D
            case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
                return setValueT3D1;
    
            case 0x8b60: // SAMPLER_CUBE
            case 0x8dcc: // INT_SAMPLER_CUBE
            case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
            case 0x8dc5: // SAMPLER_CUBE_SHADOW
                return setValueT6;
    
            case 0x8dc1: // SAMPLER_2D_ARRAY
            case 0x8dcf: // INT_SAMPLER_2D_ARRAY
            case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
            case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
                return setValueT2DArray1;
    
        }
    
    }
    
    // Array of scalars
    function setValueV1fArray( gl, v ) {
    
        gl.uniform1fv( this.addr, v );
    
    }
    
    // Integer / Boolean vectors or arrays thereof (always flat arrays)
    function setValueV1iArray( gl, v ) {
    
        gl.uniform1iv( this.addr, v );
    
    }
    
    function setValueV2iArray( gl, v ) {
    
        gl.uniform2iv( this.addr, v );
    
    }
    
    function setValueV3iArray( gl, v ) {
    
        gl.uniform3iv( this.addr, v );
    
    }
    
    function setValueV4iArray( gl, v ) {
    
        gl.uniform4iv( this.addr, v );
    
    }
    
    
    // Array of vectors (flat or from THREE classes)
    
    function setValueV2fArray( gl, v ) {
    
        var data = flatten( v, this.size, 2 );
    
        gl.uniform2fv( this.addr, data );
    
    }
    
    function setValueV3fArray( gl, v ) {
    
        var data = flatten( v, this.size, 3 );
    
        gl.uniform3fv( this.addr, data );
    
    }
    
    function setValueV4fArray( gl, v ) {
    
        var data = flatten( v, this.size, 4 );
    
        gl.uniform4fv( this.addr, data );
    
    }
    
    // Array of matrices (flat or from THREE clases)
    
    function setValueM2Array( gl, v ) {
    
        var data = flatten( v, this.size, 4 );
    
        gl.uniformMatrix2fv( this.addr, false, data );
    
    }
    
    function setValueM3Array( gl, v ) {
    
        var data = flatten( v, this.size, 9 );
    
        gl.uniformMatrix3fv( this.addr, false, data );
    
    }
    
    function setValueM4Array( gl, v ) {
    
        var data = flatten( v, this.size, 16 );
    
        gl.uniformMatrix4fv( this.addr, false, data );
    
    }
    
    // Array of textures (2D / Cube)
    
    function setValueT1Array( gl, v, textures ) {
    
        var n = v.length;
    
        var units = allocTexUnits( textures, n );
    
        gl.uniform1iv( this.addr, units );
    
        for ( var i = 0; i !== n; ++ i ) {
    
            textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );
    
        }
    
    }
    
    function setValueT6Array( gl, v, textures ) {
    
        var n = v.length;
    
        var units = allocTexUnits( textures, n );
    
        gl.uniform1iv( this.addr, units );
    
        for ( var i = 0; i !== n; ++ i ) {
    
            textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );
    
        }
    
    }
    
    // Helper to pick the right setter for a pure (bottom-level) array
    
    function getPureArraySetter( type ) {
    
        switch ( type ) {
    
            case 0x1406: return setValueV1fArray; // FLOAT
            case 0x8b50: return setValueV2fArray; // _VEC2
            case 0x8b51: return setValueV3fArray; // _VEC3
            case 0x8b52: return setValueV4fArray; // _VEC4
    
            case 0x8b5a: return setValueM2Array; // _MAT2
            case 0x8b5b: return setValueM3Array; // _MAT3
            case 0x8b5c: return setValueM4Array; // _MAT4
    
            case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
            case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
            case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
            case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4
    
            case 0x8b5e: // SAMPLER_2D
            case 0x8d66: // SAMPLER_EXTERNAL_OES
            case 0x8dca: // INT_SAMPLER_2D
            case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
            case 0x8b62: // SAMPLER_2D_SHADOW
                return setValueT1Array;
    
            case 0x8b60: // SAMPLER_CUBE
            case 0x8dcc: // INT_SAMPLER_CUBE
            case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
            case 0x8dc5: // SAMPLER_CUBE_SHADOW
                return setValueT6Array;
    
        }
    
    }
    
    // --- Uniform Classes ---
    
    function SingleUniform( id, activeInfo, addr ) {
    
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.setValue = getSingularSetter( activeInfo.type );
    
        // this.path = activeInfo.name; // DEBUG
    
    }
    
    function PureArrayUniform( id, activeInfo, addr ) {
    
        this.id = id;
        this.addr = addr;
        this.cache = [];
        this.size = activeInfo.size;
        this.setValue = getPureArraySetter( activeInfo.type );
    
        // this.path = activeInfo.name; // DEBUG
    
    }
    
    PureArrayUniform.prototype.updateCache = function ( data ) {
    
        var cache = this.cache;
    
        if ( data instanceof Float32Array && cache.length !== data.length ) {
    
            this.cache = new Float32Array( data.length );
    
        }
    
        copyArray( cache, data );
    
    };
    
    function StructuredUniform( id ) {
    
        this.id = id;
    
        this.seq = [];
        this.map = {};
    
    }
    
    StructuredUniform.prototype.setValue = function ( gl, value, textures ) {
    
        var seq = this.seq;
    
        for ( var i = 0, n = seq.length; i !== n; ++ i ) {
    
            var u = seq[ i ];
            u.setValue( gl, value[ u.id ], textures );
    
        }
    
    };
    
    // --- Top-level ---
    
    // Parser - builds up the property tree from the path strings
    
    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
    
    // extracts
    // 	- the identifier (member name or array index)
    //  - followed by an optional right bracket (found when array index)
    //  - followed by an optional left bracket or dot (type of subscript)
    //
    // Note: These portions can be read in a non-overlapping fashion and
    // allow straightforward parsing of the hierarchy that WebGL encodes
    // in the uniform names.
    
    function addUniform( container, uniformObject ) {
    
        container.seq.push( uniformObject );
        container.map[ uniformObject.id ] = uniformObject;
    
    }
    
    function parseUniform( activeInfo, addr, container ) {
    
        var path = activeInfo.name,
            pathLength = path.length;
    
        // reset RegExp object, because of the early exit of a previous run
        RePathPart.lastIndex = 0;
    
        while ( true ) {
    
            var match = RePathPart.exec( path ),
                matchEnd = RePathPart.lastIndex,
    
                id = match[ 1 ],
                idIsIndex = match[ 2 ] === ']',
                subscript = match[ 3 ];
    
            if ( idIsIndex ) id = id | 0; // convert to integer
    
            if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {
    
                // bare name or "pure" bottom-level array "[0]" suffix
    
                addUniform( container, subscript === undefined ?
                    new SingleUniform( id, activeInfo, addr ) :
                    new PureArrayUniform( id, activeInfo, addr ) );
    
                break;
    
            } else {
    
                // step into inner node / create it in case it doesn't exist
    
                var map = container.map, next = map[ id ];
    
                if ( next === undefined ) {
    
                    next = new StructuredUniform( id );
                    addUniform( container, next );
    
                }
    
                container = next;
    
            }
    
        }
    
    }
    
    // Root Container
    
    function WebGLUniforms( gl, program ) {
    
        this.seq = [];
        this.map = {};
    
        var n = gl.getProgramParameter( program, 35718 );
    
        for ( var i = 0; i < n; ++ i ) {
    
            var info = gl.getActiveUniform( program, i ),
                addr = gl.getUniformLocation( program, info.name );
    
            parseUniform( info, addr, this );
    
        }
    
    }
    
    WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {
    
        var u = this.map[ name ];
    
        if ( u !== undefined ) u.setValue( gl, value, textures );
    
    };
    
    WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {
    
        var v = object[ name ];
    
        if ( v !== undefined ) this.setValue( gl, name, v );
    
    };
    
    
    // Static interface
    
    WebGLUniforms.upload = function ( gl, seq, values, textures ) {
    
        for ( var i = 0, n = seq.length; i !== n; ++ i ) {
    
            var u = seq[ i ],
                v = values[ u.id ];
    
            if ( v.needsUpdate !== false ) {
    
                // note: always updating when .needsUpdate is undefined
                u.setValue( gl, v.value, textures );
    
            }
    
        }
    
    };
    
    WebGLUniforms.seqWithValue = function ( seq, values ) {
    
        var r = [];
    
        for ( var i = 0, n = seq.length; i !== n; ++ i ) {
    
            var u = seq[ i ];
            if ( u.id in values ) r.push( u );
    
        }
    
        return r;
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLShader( gl, type, string ) {
    
        var shader = gl.createShader( type );
    
        gl.shaderSource( shader, string );
        gl.compileShader( shader );
    
        return shader;
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    var programIdCount = 0;
    
    function addLineNumbers( string ) {
    
        var lines = string.split( '\n' );
    
        for ( var i = 0; i < lines.length; i ++ ) {
    
            lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
    
        }
    
        return lines.join( '\n' );
    
    }
    
    function getEncodingComponents( encoding ) {
    
        switch ( encoding ) {
    
            case LinearEncoding:
                return [ 'Linear', '( value )' ];
            case sRGBEncoding:
                return [ 'sRGB', '( value )' ];
            case RGBEEncoding:
                return [ 'RGBE', '( value )' ];
            case RGBM7Encoding:
                return [ 'RGBM', '( value, 7.0 )' ];
            case RGBM16Encoding:
                return [ 'RGBM', '( value, 16.0 )' ];
            case RGBDEncoding:
                return [ 'RGBD', '( value, 256.0 )' ];
            case GammaEncoding:
                return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
            case LogLuvEncoding:
                return [ 'LogLuv', '( value )' ];
            default:
                throw new Error( 'unsupported encoding: ' + encoding );
    
        }
    
    }
    
    function getShaderErrors( gl, shader, type ) {
    
        var status = gl.getShaderParameter( shader, 35713 );
        var log = gl.getShaderInfoLog( shader ).trim();
    
        if ( status && log === '' ) return '';
    
        // --enable-privileged-webgl-extension
        // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
    
        var source = gl.getShaderSource( shader );
    
        return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );
    
    }
    
    function getTexelDecodingFunction( functionName, encoding ) {
    
        var components = getEncodingComponents( encoding );
        return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';
    
    }
    
    function getTexelEncodingFunction( functionName, encoding ) {
    
        var components = getEncodingComponents( encoding );
        return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';
    
    }
    
    function getToneMappingFunction( functionName, toneMapping ) {
    
        var toneMappingName;
    
        switch ( toneMapping ) {
    
            case LinearToneMapping:
                toneMappingName = 'Linear';
                break;
    
            case ReinhardToneMapping:
                toneMappingName = 'Reinhard';
                break;
    
            case Uncharted2ToneMapping:
                toneMappingName = 'Uncharted2';
                break;
    
            case CineonToneMapping:
                toneMappingName = 'OptimizedCineon';
                break;
    
            case ACESFilmicToneMapping:
                toneMappingName = 'ACESFilmic';
                break;
    
            default:
                throw new Error( 'unsupported toneMapping: ' + toneMapping );
    
        }
    
        return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
    
    }
    
    function generateExtensions( parameters ) {
    
        var chunks = [
            ( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
            ( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
            ( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
            ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
        ];
    
        return chunks.filter( filterEmptyLine ).join( '\n' );
    
    }
    
    function generateDefines( defines ) {
    
        var chunks = [];
    
        for ( var name in defines ) {
    
            var value = defines[ name ];
    
            if ( value === false ) continue;
    
            chunks.push( '#define ' + name + ' ' + value );
    
        }
    
        return chunks.join( '\n' );
    
    }
    
    function fetchAttributeLocations( gl, program ) {
    
        var attributes = {};
    
        var n = gl.getProgramParameter( program, 35721 );
    
        for ( var i = 0; i < n; i ++ ) {
    
            var info = gl.getActiveAttrib( program, i );
            var name = info.name;
    
            // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
    
            attributes[ name ] = gl.getAttribLocation( program, name );
    
        }
    
        return attributes;
    
    }
    
    function filterEmptyLine( string ) {
    
        return string !== '';
    
    }
    
    function replaceLightNums( string, parameters ) {
    
        return string
            .replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
            .replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
            .replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
            .replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
            .replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
            .replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
            .replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
            .replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );
    
    }
    
    function replaceClippingPlaneNums( string, parameters ) {
    
        return string
            .replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
            .replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );
    
    }
    
    // Resolve Includes
    
    var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
    
    function resolveIncludes( string ) {
    
        return string.replace( includePattern, includeReplacer );
    
    }
    
    function includeReplacer( match, include ) {
    
        var string = ShaderChunk[ include ];
    
        if ( string === undefined ) {
    
            throw new Error( 'Can not resolve #include <' + include + '>' );
    
        }
    
        return resolveIncludes( string );
    
    }
    
    // Unroll Loops
    
    var loopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    
    function unrollLoops( string ) {
    
        return string.replace( loopPattern, loopReplacer );
    
    }
    
    function loopReplacer( match, start, end, snippet ) {
    
        var string = '';
    
        for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {
    
            string += snippet
                .replace( /\[ i \]/g, '[ ' + i + ' ]' )
                .replace( /UNROLLED_LOOP_INDEX/g, i );
    
        }
    
        return string;
    
    }
    
    //
    
    function generatePrecision( parameters ) {
    
        var precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    
        if ( parameters.precision === "highp" ) {
    
            precisionstring += "\n#define HIGH_PRECISION";
    
        } else if ( parameters.precision === "mediump" ) {
    
            precisionstring += "\n#define MEDIUM_PRECISION";
    
        } else if ( parameters.precision === "lowp" ) {
    
            precisionstring += "\n#define LOW_PRECISION";
    
        }
    
        return precisionstring;
    
    }
    
    function generateShadowMapTypeDefine( parameters ) {
    
        var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
    
        if ( parameters.shadowMapType === PCFShadowMap ) {
    
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
    
        } else if ( parameters.shadowMapType === PCFSoftShadowMap ) {
    
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
    
        } else if ( parameters.shadowMapType === VSMShadowMap ) {
    
            shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
    
        }
    
        return shadowMapTypeDefine;
    
    }
    
    function generateEnvMapTypeDefine( parameters ) {
    
        var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    
        if ( parameters.envMap ) {
    
            switch ( parameters.envMapMode ) {
    
                case CubeReflectionMapping:
                case CubeRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    break;
    
                case CubeUVReflectionMapping:
                case CubeUVRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                    break;
    
                case EquirectangularReflectionMapping:
                case EquirectangularRefractionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
                    break;
    
                case SphericalReflectionMapping:
                    envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
                    break;
    
            }
    
        }
    
        return envMapTypeDefine;
    
    }
    
    function generateEnvMapModeDefine( parameters ) {
    
        var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    
        if ( parameters.envMap ) {
    
            switch ( parameters.envMapMode ) {
    
                case CubeRefractionMapping:
                case EquirectangularRefractionMapping:
                    envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                    break;
    
            }
    
        }
    
        return envMapModeDefine;
    
    }
    
    function generateEnvMapBlendingDefine( parameters ) {
    
        var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
    
        if ( parameters.envMap ) {
    
            switch ( parameters.combine ) {
    
                case MultiplyOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                    break;
    
                case MixOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                    break;
    
                case AddOperation:
                    envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                    break;
    
            }
    
        }
    
        return envMapBlendingDefine;
    
    }
    
    function WebGLProgram( renderer, cacheKey, parameters ) {
    
        var gl = renderer.getContext();
    
        var defines = parameters.defines;
    
        var vertexShader = parameters.vertexShader;
        var fragmentShader = parameters.fragmentShader;
        var shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
        var envMapTypeDefine = generateEnvMapTypeDefine( parameters );
        var envMapModeDefine = generateEnvMapModeDefine( parameters );
        var envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );
    
    
        var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
    
        var customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );
    
        var customDefines = generateDefines( defines );
    
        var program = gl.createProgram();
    
        var prefixVertex, prefixFragment;
    
        if ( parameters.isRawShaderMaterial ) {
    
            prefixVertex = [
    
                customDefines
    
            ].filter( filterEmptyLine ).join( '\n' );
    
            if ( prefixVertex.length > 0 ) {
    
                prefixVertex += '\n';
    
            }
    
            prefixFragment = [
    
                customExtensions,
                customDefines
    
            ].filter( filterEmptyLine ).join( '\n' );
    
            if ( prefixFragment.length > 0 ) {
    
                prefixFragment += '\n';
    
            }
    
        } else {
    
            prefixVertex = [
    
                generatePrecision( parameters ),
    
                '#define SHADER_NAME ' + parameters.shaderName,
    
                customDefines,
    
                parameters.instancing ? '#define USE_INSTANCING' : '',
                parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
    
                '#define GAMMA_FACTOR ' + gammaFactorDefine,
    
                '#define MAX_BONES ' + parameters.maxBones,
                ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
                ( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',
    
                parameters.map ? '#define USE_MAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                ( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
                ( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
    
                parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
    
                parameters.vertexTangents ? '#define USE_TANGENT' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',
                parameters.vertexUvs ? '#define USE_UV' : '',
                parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
    
                parameters.flatShading ? '#define FLAT_SHADED' : '',
    
                parameters.skinning ? '#define USE_SKINNING' : '',
                parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
    
                parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',
    
                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
    
                parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
    
                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                ( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
    
                'uniform mat4 modelMatrix;',
                'uniform mat4 modelViewMatrix;',
                'uniform mat4 projectionMatrix;',
                'uniform mat4 viewMatrix;',
                'uniform mat3 normalMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
    
                '#ifdef USE_INSTANCING',
    
                ' attribute mat4 instanceMatrix;',
    
                '#endif',
    
                'attribute vec3 position;',
                'attribute vec3 normal;',
                'attribute vec2 uv;',
    
                '#ifdef USE_TANGENT',
    
                '	attribute vec4 tangent;',
    
                '#endif',
    
                '#ifdef USE_COLOR',
    
                '	attribute vec3 color;',
    
                '#endif',
    
                '#ifdef USE_MORPHTARGETS',
    
                '	attribute vec3 morphTarget0;',
                '	attribute vec3 morphTarget1;',
                '	attribute vec3 morphTarget2;',
                '	attribute vec3 morphTarget3;',
    
                '	#ifdef USE_MORPHNORMALS',
    
                '		attribute vec3 morphNormal0;',
                '		attribute vec3 morphNormal1;',
                '		attribute vec3 morphNormal2;',
                '		attribute vec3 morphNormal3;',
    
                '	#else',
    
                '		attribute vec3 morphTarget4;',
                '		attribute vec3 morphTarget5;',
                '		attribute vec3 morphTarget6;',
                '		attribute vec3 morphTarget7;',
    
                '	#endif',
    
                '#endif',
    
                '#ifdef USE_SKINNING',
    
                '	attribute vec4 skinIndex;',
                '	attribute vec4 skinWeight;',
    
                '#endif',
    
                '\n'
    
            ].filter( filterEmptyLine ).join( '\n' );
    
            prefixFragment = [
    
                customExtensions,
    
                generatePrecision( parameters ),
    
                '#define SHADER_NAME ' + parameters.shaderName,
    
                customDefines,
    
                parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer
    
                '#define GAMMA_FACTOR ' + gammaFactorDefine,
    
                ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
                ( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',
    
                parameters.map ? '#define USE_MAP' : '',
                parameters.matcap ? '#define USE_MATCAP' : '',
                parameters.envMap ? '#define USE_ENVMAP' : '',
                parameters.envMap ? '#define ' + envMapTypeDefine : '',
                parameters.envMap ? '#define ' + envMapModeDefine : '',
                parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                parameters.aoMap ? '#define USE_AOMAP' : '',
                parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                parameters.normalMap ? '#define USE_NORMALMAP' : '',
                ( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
                ( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
                parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
    
                parameters.sheen ? '#define USE_SHEEN' : '',
    
                parameters.vertexTangents ? '#define USE_TANGENT' : '',
                parameters.vertexColors ? '#define USE_COLOR' : '',
                parameters.vertexUvs ? '#define USE_UV' : '',
                parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
    
                parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
    
                parameters.flatShading ? '#define FLAT_SHADED' : '',
    
                parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                parameters.flipSided ? '#define FLIP_SIDED' : '',
    
                parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
    
                parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
    
                parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
    
                parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                ( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
    
                ( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',
    
                'uniform mat4 viewMatrix;',
                'uniform vec3 cameraPosition;',
                'uniform bool isOrthographic;',
    
                ( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
                ( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
                ( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',
    
                parameters.dithering ? '#define DITHERING' : '',
    
                ( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding || parameters.lightMapEncoding ) ?
                    ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
                parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
                parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
                parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
                parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
                parameters.lightMapEncoding ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
                parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',
    
                parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',
    
                '\n'
    
            ].filter( filterEmptyLine ).join( '\n' );
    
        }
    
        vertexShader = resolveIncludes( vertexShader );
        vertexShader = replaceLightNums( vertexShader, parameters );
        vertexShader = replaceClippingPlaneNums( vertexShader, parameters );
    
        fragmentShader = resolveIncludes( fragmentShader );
        fragmentShader = replaceLightNums( fragmentShader, parameters );
        fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );
    
        vertexShader = unrollLoops( vertexShader );
        fragmentShader = unrollLoops( fragmentShader );
    
        if ( parameters.isWebGL2 && ! parameters.isRawShaderMaterial ) {
    
            var isGLSL3ShaderMaterial = false;
    
            var versionRegex = /^\s*#version\s+300\s+es\s*\n/;
    
            if ( parameters.isShaderMaterial &&
                vertexShader.match( versionRegex ) !== null &&
                fragmentShader.match( versionRegex ) !== null ) {
    
                isGLSL3ShaderMaterial = true;
    
                vertexShader = vertexShader.replace( versionRegex, '' );
                fragmentShader = fragmentShader.replace( versionRegex, '' );
    
            }
    
            // GLSL 3.0 conversion
    
            prefixVertex = [
                '#version 300 es\n',
                '#define attribute in',
                '#define varying out',
                '#define texture2D texture'
            ].join( '\n' ) + '\n' + prefixVertex;
    
            prefixFragment = [
                '#version 300 es\n',
                '#define varying in',
                isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
                isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
                '#define gl_FragDepthEXT gl_FragDepth',
                '#define texture2D texture',
                '#define textureCube texture',
                '#define texture2DProj textureProj',
                '#define texture2DLodEXT textureLod',
                '#define texture2DProjLodEXT textureProjLod',
                '#define textureCubeLodEXT textureLod',
                '#define texture2DGradEXT textureGrad',
                '#define texture2DProjGradEXT textureProjGrad',
                '#define textureCubeGradEXT textureGrad'
            ].join( '\n' ) + '\n' + prefixFragment;
    
        }
    
        var vertexGlsl = prefixVertex + vertexShader;
        var fragmentGlsl = prefixFragment + fragmentShader;
    
        // console.log( '*VERTEX*', vertexGlsl );
        // console.log( '*FRAGMENT*', fragmentGlsl );
    
        var glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
        var glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );
    
        gl.attachShader( program, glVertexShader );
        gl.attachShader( program, glFragmentShader );
    
        // Force a particular attribute to index 0.
    
        if ( parameters.index0AttributeName !== undefined ) {
    
            gl.bindAttribLocation( program, 0, parameters.index0AttributeName );
    
        } else if ( parameters.morphTargets === true ) {
    
            // programs with morphTargets displace position out of attribute 0
            gl.bindAttribLocation( program, 0, 'position' );
    
        }
    
        gl.linkProgram( program );
    
        // check for link errors
        if ( renderer.debug.checkShaderErrors ) {
    
            var programLog = gl.getProgramInfoLog( program ).trim();
            var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
            var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();
    
            var runnable = true;
            var haveDiagnostics = true;
    
            if ( gl.getProgramParameter( program, 35714 ) === false ) {
    
                runnable = false;
    
                var vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
                var fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );
    
                console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );
    
            } else if ( programLog !== '' ) {
    
                console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
    
            } else if ( vertexLog === '' || fragmentLog === '' ) {
    
                haveDiagnostics = false;
    
            }
    
            if ( haveDiagnostics ) {
    
                this.diagnostics = {
    
                    runnable: runnable,
    
                    programLog: programLog,
    
                    vertexShader: {
    
                        log: vertexLog,
                        prefix: prefixVertex
    
                    },
    
                    fragmentShader: {
    
                        log: fragmentLog,
                        prefix: prefixFragment
    
                    }
    
                };
    
            }
    
        }
    
        // clean up
    
        gl.detachShader( program, glVertexShader );
        gl.detachShader( program, glFragmentShader );
    
        gl.deleteShader( glVertexShader );
        gl.deleteShader( glFragmentShader );
    
        // set up caching for uniform locations
    
        var cachedUniforms;
    
        this.getUniforms = function () {
    
            if ( cachedUniforms === undefined ) {
    
                cachedUniforms = new WebGLUniforms( gl, program );
    
            }
    
            return cachedUniforms;
    
        };
    
        // set up caching for attribute locations
    
        var cachedAttributes;
    
        this.getAttributes = function () {
    
            if ( cachedAttributes === undefined ) {
    
                cachedAttributes = fetchAttributeLocations( gl, program );
    
            }
    
            return cachedAttributes;
    
        };
    
        // free resource
    
        this.destroy = function () {
    
            gl.deleteProgram( program );
            this.program = undefined;
    
        };
    
        //
    
        this.name = parameters.shaderName;
        this.id = programIdCount ++;
        this.cacheKey = cacheKey;
        this.usedTimes = 1;
        this.program = program;
        this.vertexShader = glVertexShader;
        this.fragmentShader = glFragmentShader;
    
        return this;
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLPrograms( renderer, extensions, capabilities ) {
    
        var programs = [];
    
        var isWebGL2 = capabilities.isWebGL2;
        var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
        var floatVertexTextures = capabilities.floatVertexTextures;
        var precision = capabilities.precision;
        var maxVertexUniforms = capabilities.maxVertexUniforms;
        var vertexTextures = capabilities.vertexTextures;
    
        var shaderIDs = {
            MeshDepthMaterial: 'depth',
            MeshDistanceMaterial: 'distanceRGBA',
            MeshNormalMaterial: 'normal',
            MeshBasicMaterial: 'basic',
            MeshLambertMaterial: 'lambert',
            MeshPhongMaterial: 'phong',
            MeshToonMaterial: 'toon',
            MeshStandardMaterial: 'physical',
            MeshPhysicalMaterial: 'physical',
            MeshMatcapMaterial: 'matcap',
            LineBasicMaterial: 'basic',
            LineDashedMaterial: 'dashed',
            PointsMaterial: 'points',
            ShadowMaterial: 'shadow',
            SpriteMaterial: 'sprite'
        };
    
        var parameterNames = [
            "precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing",
            "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV",
            "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap",
            "roughnessMap", "metalnessMap", "gradientMap",
            "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2",
            "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
            "maxBones", "useVertexTexture", "morphTargets", "morphNormals",
            "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
            "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
            "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows",
            "shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
            "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering",
            "sheen"
        ];
    
        function getShaderObject( material, shaderID ) {
    
            var shaderobject;
    
            if ( shaderID ) {
    
                var shader = ShaderLib[ shaderID ];
    
                shaderobject = {
                    name: material.type,
                    uniforms: UniformsUtils.clone( shader.uniforms ),
                    vertexShader: shader.vertexShader,
                    fragmentShader: shader.fragmentShader
                };
    
            } else {
    
                shaderobject = {
                    name: material.type,
                    uniforms: material.uniforms,
                    vertexShader: material.vertexShader,
                    fragmentShader: material.fragmentShader
                };
    
            }
    
            return shaderobject;
    
        }
    
        function allocateBones( object ) {
    
            var skeleton = object.skeleton;
            var bones = skeleton.bones;
    
            if ( floatVertexTextures ) {
    
                return 1024;
    
            } else {
    
                // default for when object is not specified
                // ( for example when prebuilding shader to be used with multiple objects )
                //
                //  - leave some extra space for other uniforms
                //  - limit here is ANGLE's 254 max uniform vectors
                //    (up to 54 should be safe)
    
                var nVertexUniforms = maxVertexUniforms;
                var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
    
                var maxBones = Math.min( nVertexMatrices, bones.length );
    
                if ( maxBones < bones.length ) {
    
                    console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
                    return 0;
    
                }
    
                return maxBones;
    
            }
    
        }
    
        function getTextureEncodingFromMap( map ) {
    
            var encoding;
    
            if ( ! map ) {
    
                encoding = LinearEncoding;
    
            } else if ( map.isTexture ) {
    
                encoding = map.encoding;
    
            } else if ( map.isWebGLRenderTarget ) {
    
                console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
                encoding = map.texture.encoding;
    
            }
    
            return encoding;
    
        }
    
        this.getParameters = function ( material, lights, shadows, scene, nClipPlanes, nClipIntersection, object ) {
    
            var fog = scene.fog;
            var environment = material.isMeshStandardMaterial ? scene.environment : null;
    
            var envMap = material.envMap || environment;
    
            var shaderID = shaderIDs[ material.type ];
    
            // heuristics to create shader parameters according to lights in the scene
            // (not to blow over maxLights budget)
    
            var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
    
            if ( material.precision !== null ) {
    
                precision = capabilities.getMaxPrecision( material.precision );
    
                if ( precision !== material.precision ) {
    
                    console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
    
                }
    
            }
    
            var shaderobject = getShaderObject( material, shaderID );
            material.onBeforeCompile( shaderobject, renderer );
    
            var currentRenderTarget = renderer.getRenderTarget();
    
            var parameters = {
    
                isWebGL2: isWebGL2,
    
                shaderID: shaderID,
                shaderName: shaderobject.name,
    
                uniforms: shaderobject.uniforms,
                vertexShader: shaderobject.vertexShader,
                fragmentShader: shaderobject.fragmentShader,
                defines: material.defines,
    
                isRawShaderMaterial: material.isRawShaderMaterial,
                isShaderMaterial: material.isShaderMaterial,
    
                precision: precision,
    
                instancing: object.isInstancedMesh === true,
    
                supportsVertexTextures: vertexTextures,
                outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
                map: !! material.map,
                mapEncoding: getTextureEncodingFromMap( material.map ),
                matcap: !! material.matcap,
                matcapEncoding: getTextureEncodingFromMap( material.matcap ),
                envMap: !! envMap,
                envMapMode: envMap && envMap.mapping,
                envMapEncoding: getTextureEncodingFromMap( envMap ),
                envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
                lightMap: !! material.lightMap,
                lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
                aoMap: !! material.aoMap,
                emissiveMap: !! material.emissiveMap,
                emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
                bumpMap: !! material.bumpMap,
                normalMap: !! material.normalMap,
                objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
                tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
                clearcoatNormalMap: !! material.clearcoatNormalMap,
                displacementMap: !! material.displacementMap,
                roughnessMap: !! material.roughnessMap,
                metalnessMap: !! material.metalnessMap,
                specularMap: !! material.specularMap,
                alphaMap: !! material.alphaMap,
    
                gradientMap: !! material.gradientMap,
    
                sheen: !! material.sheen,
    
                combine: material.combine,
    
                vertexTangents: ( material.normalMap && material.vertexTangents ),
                vertexColors: material.vertexColors,
                vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.displacementMap,
                uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap ) && !! material.displacementMap,
    
                fog: !! fog,
                useFog: material.fog,
                fogExp2: ( fog && fog.isFogExp2 ),
    
                flatShading: material.flatShading,
    
                sizeAttenuation: material.sizeAttenuation,
                logarithmicDepthBuffer: logarithmicDepthBuffer,
    
                skinning: material.skinning && maxBones > 0,
                maxBones: maxBones,
                useVertexTexture: floatVertexTextures,
    
                morphTargets: material.morphTargets,
                morphNormals: material.morphNormals,
                maxMorphTargets: renderer.maxMorphTargets,
                maxMorphNormals: renderer.maxMorphNormals,
    
                numDirLights: lights.directional.length,
                numPointLights: lights.point.length,
                numSpotLights: lights.spot.length,
                numRectAreaLights: lights.rectArea.length,
                numHemiLights: lights.hemi.length,
    
                numDirLightShadows: lights.directionalShadowMap.length,
                numPointLightShadows: lights.pointShadowMap.length,
                numSpotLightShadows: lights.spotShadowMap.length,
    
                numClippingPlanes: nClipPlanes,
                numClipIntersection: nClipIntersection,
    
                dithering: material.dithering,
    
                shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
                shadowMapType: renderer.shadowMap.type,
    
                toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
                physicallyCorrectLights: renderer.physicallyCorrectLights,
    
                premultipliedAlpha: material.premultipliedAlpha,
    
                alphaTest: material.alphaTest,
                doubleSided: material.side === DoubleSide,
                flipSided: material.side === BackSide,
    
                depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,
    
                index0AttributeName: material.index0AttributeName,
    
                extensionDerivatives: material.extensions && material.extensions.derivatives,
                extensionFragDepth: material.extensions && material.extensions.fragDepth,
                extensionDrawbuffers: material.extensions && material.extensions.drawBuffers,
                extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
    
                rendererExtensionFragDepth: isWebGL2 || extensions.get( 'EXT_frag_depth' ) !== null,
                rendererExtensionDrawBuffers: isWebGL2 || extensions.get( 'WEBGL_draw_buffers' ) !== null,
                rendererExtensionShaderTextureLod: isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) !== null,
    
                onBeforeCompile: material.onBeforeCompile
    
            };
    
            return parameters;
    
        };
    
        this.getProgramCacheKey = function ( parameters ) {
    
            var array = [];
    
            if ( parameters.shaderID ) {
    
                array.push( parameters.shaderID );
    
            } else {
    
                array.push( parameters.fragmentShader );
                array.push( parameters.vertexShader );
    
            }
    
            if ( parameters.defines !== undefined ) {
    
                for ( var name in parameters.defines ) {
    
                    array.push( name );
                    array.push( parameters.defines[ name ] );
    
                }
    
            }
    
            if ( parameters.isRawShaderMaterial === undefined ) {
    
                for ( var i = 0; i < parameterNames.length; i ++ ) {
    
                    array.push( parameters[ parameterNames[ i ] ] );
    
                }
    
                array.push( renderer.outputEncoding );
                array.push( renderer.gammaFactor );
    
            }
    
            array.push( parameters.onBeforeCompile.toString() );
    
            return array.join();
    
        };
    
        this.acquireProgram = function ( parameters, cacheKey ) {
    
            var program;
    
            // Check if code has been already compiled
            for ( var p = 0, pl = programs.length; p < pl; p ++ ) {
    
                var preexistingProgram = programs[ p ];
    
                if ( preexistingProgram.cacheKey === cacheKey ) {
    
                    program = preexistingProgram;
                    ++ program.usedTimes;
    
                    break;
    
                }
    
            }
    
            if ( program === undefined ) {
    
                program = new WebGLProgram( renderer, cacheKey, parameters );
                programs.push( program );
    
            }
    
            return program;
    
        };
    
        this.releaseProgram = function ( program ) {
    
            if ( -- program.usedTimes === 0 ) {
    
                // Remove from unordered set
                var i = programs.indexOf( program );
                programs[ i ] = programs[ programs.length - 1 ];
                programs.pop();
    
                // Free WebGL resources
                program.destroy();
    
            }
    
        };
    
        // Exposed for resource monitoring & error feedback via renderer.info:
        this.programs = programs;
    
    }
    
    /**
     * @author fordacious / fordacious.github.io
     */
    
    function WebGLProperties() {
    
        var properties = new WeakMap();
    
        function get( object ) {
    
            var map = properties.get( object );
    
            if ( map === undefined ) {
    
                map = {};
                properties.set( object, map );
    
            }
    
            return map;
    
        }
    
        function remove( object ) {
    
            properties.delete( object );
    
        }
    
        function update( object, key, value ) {
    
            properties.get( object )[ key ] = value;
    
        }
    
        function dispose() {
    
            properties = new WeakMap();
    
        }
    
        return {
            get: get,
            remove: remove,
            update: update,
            dispose: dispose
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function painterSortStable( a, b ) {
    
        if ( a.groupOrder !== b.groupOrder ) {
    
            return a.groupOrder - b.groupOrder;
    
        } else if ( a.renderOrder !== b.renderOrder ) {
    
            return a.renderOrder - b.renderOrder;
    
        } else if ( a.program !== b.program ) {
    
            return a.program.id - b.program.id;
    
        } else if ( a.material.id !== b.material.id ) {
    
            return a.material.id - b.material.id;
    
        } else if ( a.z !== b.z ) {
    
            return a.z - b.z;
    
        } else {
    
            return a.id - b.id;
    
        }
    
    }
    
    function reversePainterSortStable( a, b ) {
    
        if ( a.groupOrder !== b.groupOrder ) {
    
            return a.groupOrder - b.groupOrder;
    
        } else if ( a.renderOrder !== b.renderOrder ) {
    
            return a.renderOrder - b.renderOrder;
    
        } else if ( a.z !== b.z ) {
    
            return b.z - a.z;
    
        } else {
    
            return a.id - b.id;
    
        }
    
    }
    
    
    function WebGLRenderList() {
    
        var renderItems = [];
        var renderItemsIndex = 0;
    
        var opaque = [];
        var transparent = [];
    
        var defaultProgram = { id: - 1 };
    
        function init() {
    
            renderItemsIndex = 0;
    
            opaque.length = 0;
            transparent.length = 0;
    
        }
    
        function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {
    
            var renderItem = renderItems[ renderItemsIndex ];
    
            if ( renderItem === undefined ) {
    
                renderItem = {
                    id: object.id,
                    object: object,
                    geometry: geometry,
                    material: material,
                    program: material.program || defaultProgram,
                    groupOrder: groupOrder,
                    renderOrder: object.renderOrder,
                    z: z,
                    group: group
                };
    
                renderItems[ renderItemsIndex ] = renderItem;
    
            } else {
    
                renderItem.id = object.id;
                renderItem.object = object;
                renderItem.geometry = geometry;
                renderItem.material = material;
                renderItem.program = material.program || defaultProgram;
                renderItem.groupOrder = groupOrder;
                renderItem.renderOrder = object.renderOrder;
                renderItem.z = z;
                renderItem.group = group;
    
            }
    
            renderItemsIndex ++;
    
            return renderItem;
    
        }
    
        function push( object, geometry, material, groupOrder, z, group ) {
    
            var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );
    
            ( material.transparent === true ? transparent : opaque ).push( renderItem );
    
        }
    
        function unshift( object, geometry, material, groupOrder, z, group ) {
    
            var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );
    
            ( material.transparent === true ? transparent : opaque ).unshift( renderItem );
    
        }
    
        function sort( customOpaqueSort, customTransparentSort ) {
    
            if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
            if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );
    
        }
    
        function finish() {
    
            // Clear references from inactive renderItems in the list
    
            for ( var i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {
    
                var renderItem = renderItems[ i ];
    
                if ( renderItem.id === null ) break;
    
                renderItem.id = null;
                renderItem.object = null;
                renderItem.geometry = null;
                renderItem.material = null;
                renderItem.program = null;
                renderItem.group = null;
    
            }
    
        }
    
        return {
            opaque: opaque,
            transparent: transparent,
    
            init: init,
            push: push,
            unshift: unshift,
            finish: finish,
    
            sort: sort
        };
    
    }
    
    function WebGLRenderLists() {
    
        var lists = new WeakMap();
    
        function onSceneDispose( event ) {
    
            var scene = event.target;
    
            scene.removeEventListener( 'dispose', onSceneDispose );
    
            lists.delete( scene );
    
        }
    
        function get( scene, camera ) {
    
            var cameras = lists.get( scene );
            var list;
            if ( cameras === undefined ) {
    
                list = new WebGLRenderList();
                lists.set( scene, new WeakMap() );
                lists.get( scene ).set( camera, list );
    
                scene.addEventListener( 'dispose', onSceneDispose );
    
            } else {
    
                list = cameras.get( camera );
                if ( list === undefined ) {
    
                    list = new WebGLRenderList();
                    cameras.set( camera, list );
    
                }
    
            }
    
            return list;
    
        }
    
        function dispose() {
    
            lists = new WeakMap();
    
        }
    
        return {
            get: get,
            dispose: dispose
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function UniformsCache() {
    
        var lights = {};
    
        return {
    
            get: function ( light ) {
    
                if ( lights[ light.id ] !== undefined ) {
    
                    return lights[ light.id ];
    
                }
    
                var uniforms;
    
                switch ( light.type ) {
    
                    case 'DirectionalLight':
                        uniforms = {
                            direction: new Vector3(),
                            color: new Color()
                        };
                        break;
    
                    case 'SpotLight':
                        uniforms = {
                            position: new Vector3(),
                            direction: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
    
                    case 'PointLight':
                        uniforms = {
                            position: new Vector3(),
                            color: new Color(),
                            distance: 0,
                            decay: 0
                        };
                        break;
    
                    case 'HemisphereLight':
                        uniforms = {
                            direction: new Vector3(),
                            skyColor: new Color(),
                            groundColor: new Color()
                        };
                        break;
    
                    case 'RectAreaLight':
                        uniforms = {
                            color: new Color(),
                            position: new Vector3(),
                            halfWidth: new Vector3(),
                            halfHeight: new Vector3()
                        };
                        break;
    
                }
    
                lights[ light.id ] = uniforms;
    
                return uniforms;
    
            }
    
        };
    
    }
    
    function ShadowUniformsCache() {
    
        var lights = {};
    
        return {
    
            get: function ( light ) {
    
                if ( lights[ light.id ] !== undefined ) {
    
                    return lights[ light.id ];
    
                }
    
                var uniforms;
    
                switch ( light.type ) {
    
                    case 'DirectionalLight':
                        uniforms = {
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;
    
                    case 'SpotLight':
                        uniforms = {
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2()
                        };
                        break;
    
                    case 'PointLight':
                        uniforms = {
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new Vector2(),
                            shadowCameraNear: 1,
                            shadowCameraFar: 1000
                        };
                        break;
    
                    // TODO (abelnation): set RectAreaLight shadow uniforms
    
                }
    
                lights[ light.id ] = uniforms;
    
                return uniforms;
    
            }
    
        };
    
    }
    
    
    
    var nextVersion = 0;
    
    function shadowCastingLightsFirst( lightA, lightB ) {
    
        return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );
    
    }
    
    function WebGLLights() {
    
        var cache = new UniformsCache();
    
        var shadowCache = ShadowUniformsCache();
    
        var state = {
    
            version: 0,
    
            hash: {
                directionalLength: - 1,
                pointLength: - 1,
                spotLength: - 1,
                rectAreaLength: - 1,
                hemiLength: - 1,
    
                numDirectionalShadows: - 1,
                numPointShadows: - 1,
                numSpotShadows: - 1
            },
    
            ambient: [ 0, 0, 0 ],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
    
        };
    
        for ( var i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );
    
        var vector3 = new Vector3();
        var matrix4 = new Matrix4();
        var matrix42 = new Matrix4();
    
        function setup( lights, shadows, camera ) {
    
            var r = 0, g = 0, b = 0;
    
            for ( var i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );
    
            var directionalLength = 0;
            var pointLength = 0;
            var spotLength = 0;
            var rectAreaLength = 0;
            var hemiLength = 0;
    
            var numDirectionalShadows = 0;
            var numPointShadows = 0;
            var numSpotShadows = 0;
    
            var viewMatrix = camera.matrixWorldInverse;
    
            lights.sort( shadowCastingLightsFirst );
    
            for ( var i = 0, l = lights.length; i < l; i ++ ) {
    
                var light = lights[ i ];
    
                var color = light.color;
                var intensity = light.intensity;
                var distance = light.distance;
    
                var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;
    
                if ( light.isAmbientLight ) {
    
                    r += color.r * intensity;
                    g += color.g * intensity;
                    b += color.b * intensity;
    
                } else if ( light.isLightProbe ) {
    
                    for ( var j = 0; j < 9; j ++ ) {
    
                        state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );
    
                    }
    
                } else if ( light.isDirectionalLight ) {
    
                    var uniforms = cache.get( light );
    
                    uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
                    uniforms.direction.setFromMatrixPosition( light.matrixWorld );
                    vector3.setFromMatrixPosition( light.target.matrixWorld );
                    uniforms.direction.sub( vector3 );
                    uniforms.direction.transformDirection( viewMatrix );
    
                    if ( light.castShadow ) {
    
                        var shadow = light.shadow;
    
                        var shadowUniforms = shadowCache.get( light );
    
                        shadowUniforms.shadowBias = shadow.bias;
                        shadowUniforms.shadowRadius = shadow.radius;
                        shadowUniforms.shadowMapSize = shadow.mapSize;
    
                        state.directionalShadow[ directionalLength ] = shadowUniforms;
                        state.directionalShadowMap[ directionalLength ] = shadowMap;
                        state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
    
                        numDirectionalShadows ++;
    
                    }
    
                    state.directional[ directionalLength ] = uniforms;
    
                    directionalLength ++;
    
                } else if ( light.isSpotLight ) {
    
                    var uniforms = cache.get( light );
    
                    uniforms.position.setFromMatrixPosition( light.matrixWorld );
                    uniforms.position.applyMatrix4( viewMatrix );
    
                    uniforms.color.copy( color ).multiplyScalar( intensity );
                    uniforms.distance = distance;
    
                    uniforms.direction.setFromMatrixPosition( light.matrixWorld );
                    vector3.setFromMatrixPosition( light.target.matrixWorld );
                    uniforms.direction.sub( vector3 );
                    uniforms.direction.transformDirection( viewMatrix );
    
                    uniforms.coneCos = Math.cos( light.angle );
                    uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
                    uniforms.decay = light.decay;
    
                    if ( light.castShadow ) {
    
                        var shadow = light.shadow;
    
                        var shadowUniforms = shadowCache.get( light );
    
                        shadowUniforms.shadowBias = shadow.bias;
                        shadowUniforms.shadowRadius = shadow.radius;
                        shadowUniforms.shadowMapSize = shadow.mapSize;
    
                        state.spotShadow[ spotLength ] = shadowUniforms;
                        state.spotShadowMap[ spotLength ] = shadowMap;
                        state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
    
                        numSpotShadows ++;
    
                    }
    
                    state.spot[ spotLength ] = uniforms;
    
                    spotLength ++;
    
                } else if ( light.isRectAreaLight ) {
    
                    var uniforms = cache.get( light );
    
                    // (a) intensity is the total visible light emitted
                    //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
    
                    // (b) intensity is the brightness of the light
                    uniforms.color.copy( color ).multiplyScalar( intensity );
    
                    uniforms.position.setFromMatrixPosition( light.matrixWorld );
                    uniforms.position.applyMatrix4( viewMatrix );
    
                    // extract local rotation of light to derive width/height half vectors
                    matrix42.identity();
                    matrix4.copy( light.matrixWorld );
                    matrix4.premultiply( viewMatrix );
                    matrix42.extractRotation( matrix4 );
    
                    uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
                    uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );
    
                    uniforms.halfWidth.applyMatrix4( matrix42 );
                    uniforms.halfHeight.applyMatrix4( matrix42 );
    
                    // TODO (abelnation): RectAreaLight distance?
                    // uniforms.distance = distance;
    
                    state.rectArea[ rectAreaLength ] = uniforms;
    
                    rectAreaLength ++;
    
                } else if ( light.isPointLight ) {
    
                    var uniforms = cache.get( light );
    
                    uniforms.position.setFromMatrixPosition( light.matrixWorld );
                    uniforms.position.applyMatrix4( viewMatrix );
    
                    uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
                    uniforms.distance = light.distance;
                    uniforms.decay = light.decay;
    
                    if ( light.castShadow ) {
    
                        var shadow = light.shadow;
    
                        var shadowUniforms = shadowCache.get( light );
    
                        shadowUniforms.shadowBias = shadow.bias;
                        shadowUniforms.shadowRadius = shadow.radius;
                        shadowUniforms.shadowMapSize = shadow.mapSize;
                        shadowUniforms.shadowCameraNear = shadow.camera.near;
                        shadowUniforms.shadowCameraFar = shadow.camera.far;
    
                        state.pointShadow[ pointLength ] = shadowUniforms;
                        state.pointShadowMap[ pointLength ] = shadowMap;
                        state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
    
                        numPointShadows ++;
    
                    }
    
                    state.point[ pointLength ] = uniforms;
    
                    pointLength ++;
    
                } else if ( light.isHemisphereLight ) {
    
                    var uniforms = cache.get( light );
    
                    uniforms.direction.setFromMatrixPosition( light.matrixWorld );
                    uniforms.direction.transformDirection( viewMatrix );
                    uniforms.direction.normalize();
    
                    uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
                    uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );
    
                    state.hemi[ hemiLength ] = uniforms;
    
                    hemiLength ++;
    
                }
    
            }
    
            state.ambient[ 0 ] = r;
            state.ambient[ 1 ] = g;
            state.ambient[ 2 ] = b;
    
            var hash = state.hash;
    
            if ( hash.directionalLength !== directionalLength ||
                hash.pointLength !== pointLength ||
                hash.spotLength !== spotLength ||
                hash.rectAreaLength !== rectAreaLength ||
                hash.hemiLength !== hemiLength ||
                hash.numDirectionalShadows !== numDirectionalShadows ||
                hash.numPointShadows !== numPointShadows ||
                hash.numSpotShadows !== numSpotShadows ) {
    
                state.directional.length = directionalLength;
                state.spot.length = spotLength;
                state.rectArea.length = rectAreaLength;
                state.point.length = pointLength;
                state.hemi.length = hemiLength;
    
                state.directionalShadow.length = numDirectionalShadows;
                state.directionalShadowMap.length = numDirectionalShadows;
                state.pointShadow.length = numPointShadows;
                state.pointShadowMap.length = numPointShadows;
                state.spotShadow.length = numSpotShadows;
                state.spotShadowMap.length = numSpotShadows;
                state.directionalShadowMatrix.length = numDirectionalShadows;
                state.pointShadowMatrix.length = numPointShadows;
                state.spotShadowMatrix.length = numSpotShadows;
    
                hash.directionalLength = directionalLength;
                hash.pointLength = pointLength;
                hash.spotLength = spotLength;
                hash.rectAreaLength = rectAreaLength;
                hash.hemiLength = hemiLength;
    
                hash.numDirectionalShadows = numDirectionalShadows;
                hash.numPointShadows = numPointShadows;
                hash.numSpotShadows = numSpotShadows;
    
                state.version = nextVersion ++;
    
            }
    
        }
    
        return {
            setup: setup,
            state: state
        };
    
    }
    
    /**
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    function WebGLRenderState() {
    
        var lights = new WebGLLights();
    
        var lightsArray = [];
        var shadowsArray = [];
    
        function init() {
    
            lightsArray.length = 0;
            shadowsArray.length = 0;
    
        }
    
        function pushLight( light ) {
    
            lightsArray.push( light );
    
        }
    
        function pushShadow( shadowLight ) {
    
            shadowsArray.push( shadowLight );
    
        }
    
        function setupLights( camera ) {
    
            lights.setup( lightsArray, shadowsArray, camera );
    
        }
    
        var state = {
            lightsArray: lightsArray,
            shadowsArray: shadowsArray,
    
            lights: lights
        };
    
        return {
            init: init,
            state: state,
            setupLights: setupLights,
    
            pushLight: pushLight,
            pushShadow: pushShadow
        };
    
    }
    
    function WebGLRenderStates() {
    
        var renderStates = new WeakMap();
    
        function onSceneDispose( event ) {
    
            var scene = event.target;
    
            scene.removeEventListener( 'dispose', onSceneDispose );
    
            renderStates.delete( scene );
    
        }
    
        function get( scene, camera ) {
    
            var renderState;
    
            if ( renderStates.has( scene ) === false ) {
    
                renderState = new WebGLRenderState();
                renderStates.set( scene, new WeakMap() );
                renderStates.get( scene ).set( camera, renderState );
    
                scene.addEventListener( 'dispose', onSceneDispose );
    
            } else {
    
                if ( renderStates.get( scene ).has( camera ) === false ) {
    
                    renderState = new WebGLRenderState();
                    renderStates.get( scene ).set( camera, renderState );
    
                } else {
    
                    renderState = renderStates.get( scene ).get( camera );
    
                }
    
            }
    
            return renderState;
    
        }
    
        function dispose() {
    
            renderStates = new WeakMap();
    
        }
    
        return {
            get: get,
            dispose: dispose
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / https://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */
    
    function MeshDepthMaterial( parameters ) {
    
        Material.call( this );
    
        this.type = 'MeshDepthMaterial';
    
        this.depthPacking = BasicDepthPacking;
    
        this.skinning = false;
        this.morphTargets = false;
    
        this.map = null;
    
        this.alphaMap = null;
    
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
    
        this.wireframe = false;
        this.wireframeLinewidth = 1;
    
        this.fog = false;
    
        this.setValues( parameters );
    
    }
    
    MeshDepthMaterial.prototype = Object.create( Material.prototype );
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
    
    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
    
    MeshDepthMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.depthPacking = source.depthPacking;
    
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
    
        this.map = source.map;
    
        this.alphaMap = source.alphaMap;
    
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
    
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
    
        return this;
    
    };
    
    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *
     *  referencePosition: <float>,
     *  nearDistance: <float>,
     *  farDistance: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>
     *
     * }
     */
    
    function MeshDistanceMaterial( parameters ) {
    
        Material.call( this );
    
        this.type = 'MeshDistanceMaterial';
    
        this.referencePosition = new Vector3();
        this.nearDistance = 1;
        this.farDistance = 1000;
    
        this.skinning = false;
        this.morphTargets = false;
    
        this.map = null;
    
        this.alphaMap = null;
    
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
    
        this.fog = false;
    
        this.setValues( parameters );
    
    }
    
    MeshDistanceMaterial.prototype = Object.create( Material.prototype );
    MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
    
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
    
    MeshDistanceMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.referencePosition.copy( source.referencePosition );
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
    
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
    
        this.map = source.map;
    
        this.alphaMap = source.alphaMap;
    
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
    
        return this;
    
    };
    
    var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
    
    var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
    
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {
    
        var _frustum = new Frustum(),
    
            _shadowMapSize = new Vector2(),
            _viewportSize = new Vector2(),
    
            _viewport = new Vector4(),
    
            _depthMaterials = [],
            _distanceMaterials = [],
    
            _materialCache = {};
    
        var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
    
        var shadowMaterialVertical = new ShaderMaterial( {
    
            defines: {
                SAMPLE_RATE: 2.0 / 8.0,
                HALF_SAMPLE_RATE: 1.0 / 8.0
            },
    
            uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new Vector2() },
                radius: { value: 4.0 }
            },
    
            vertexShader: vsm_vert,
    
            fragmentShader: vsm_frag
    
        } );
    
        var shadowMaterialHorizonal = shadowMaterialVertical.clone();
        shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
    
        var fullScreenTri = new BufferGeometry();
        fullScreenTri.setAttribute(
            "position",
            new BufferAttribute(
                new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
                3
            )
        );
    
        var fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );
    
        var scope = this;
    
        this.enabled = false;
    
        this.autoUpdate = true;
        this.needsUpdate = false;
    
        this.type = PCFShadowMap;
    
        this.render = function ( lights, scene, camera ) {
    
            if ( scope.enabled === false ) return;
            if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
    
            if ( lights.length === 0 ) return;
    
            var currentRenderTarget = _renderer.getRenderTarget();
            var activeCubeFace = _renderer.getActiveCubeFace();
            var activeMipmapLevel = _renderer.getActiveMipmapLevel();
    
            var _state = _renderer.state;
    
            // Set GL state for depth map.
            _state.setBlending( NoBlending );
            _state.buffers.color.setClear( 1, 1, 1, 1 );
            _state.buffers.depth.setTest( true );
            _state.setScissorTest( false );
    
            // render depth map
    
            for ( var i = 0, il = lights.length; i < il; i ++ ) {
    
                var light = lights[ i ];
                var shadow = light.shadow;
    
                if ( shadow === undefined ) {
    
                    console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
                    continue;
    
                }
    
                _shadowMapSize.copy( shadow.mapSize );
    
                var shadowFrameExtents = shadow.getFrameExtents();
    
                _shadowMapSize.multiply( shadowFrameExtents );
    
                _viewportSize.copy( shadow.mapSize );
    
                if ( _shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize ) {
    
                    console.warn( 'THREE.WebGLShadowMap:', light, 'has shadow exceeding max texture size, reducing' );
    
                    if ( _shadowMapSize.x > maxTextureSize ) {
    
                        _viewportSize.x = Math.floor( maxTextureSize / shadowFrameExtents.x );
                        _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                        shadow.mapSize.x = _viewportSize.x;
    
                    }
    
                    if ( _shadowMapSize.y > maxTextureSize ) {
    
                        _viewportSize.y = Math.floor( maxTextureSize / shadowFrameExtents.y );
                        _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                        shadow.mapSize.y = _viewportSize.y;
    
                    }
    
                }
    
                if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {
    
                    var pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
    
                    shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
                    shadow.map.texture.name = light.name + ".shadowMap";
    
                    shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
    
                    shadow.camera.updateProjectionMatrix();
    
                }
    
                if ( shadow.map === null ) {
    
                    var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
    
                    shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
                    shadow.map.texture.name = light.name + ".shadowMap";
    
                    shadow.camera.updateProjectionMatrix();
    
                }
    
                _renderer.setRenderTarget( shadow.map );
                _renderer.clear();
    
                var viewportCount = shadow.getViewportCount();
    
                for ( var vp = 0; vp < viewportCount; vp ++ ) {
    
                    var viewport = shadow.getViewport( vp );
    
                    _viewport.set(
                        _viewportSize.x * viewport.x,
                        _viewportSize.y * viewport.y,
                        _viewportSize.x * viewport.z,
                        _viewportSize.y * viewport.w
                    );
    
                    _state.viewport( _viewport );
    
                    shadow.updateMatrices( light, vp );
    
                    _frustum = shadow.getFrustum();
    
                    renderObject( scene, camera, shadow.camera, light, this.type );
    
                }
    
                // do blur pass for VSM
    
                if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {
    
                    VSMPass( shadow, camera );
    
                }
    
            }
    
            scope.needsUpdate = false;
    
            _renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );
    
        };
    
        function VSMPass( shadow, camera ) {
    
            var geometry = _objects.update( fullScreenMesh );
    
            // vertical pass
    
            shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
            shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
            shadowMaterialVertical.uniforms.radius.value = shadow.radius;
            _renderer.setRenderTarget( shadow.mapPass );
            _renderer.clear();
            _renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );
    
            // horizonal pass
    
            shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
            shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
            shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
            _renderer.setRenderTarget( shadow.map );
            _renderer.clear();
            _renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null );
    
        }
    
        function getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {
    
            var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    
            var material = _depthMaterials[ index ];
    
            if ( material === undefined ) {
    
                material = new MeshDepthMaterial( {
    
                    depthPacking: RGBADepthPacking,
    
                    morphTargets: useMorphing,
                    skinning: useSkinning
    
                } );
    
                _depthMaterials[ index ] = material;
    
            }
    
            return material;
    
        }
    
        function getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {
    
            var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
    
            var material = _distanceMaterials[ index ];
    
            if ( material === undefined ) {
    
                material = new MeshDistanceMaterial( {
    
                    morphTargets: useMorphing,
                    skinning: useSkinning
    
                } );
    
                _distanceMaterials[ index ] = material;
    
            }
    
            return material;
    
        }
    
        function getDepthMaterial( object, material, light, shadowCameraNear, shadowCameraFar, type ) {
    
            var geometry = object.geometry;
    
            var result = null;
    
            var getMaterialVariant = getDepthMaterialVariant;
            var customMaterial = object.customDepthMaterial;
    
            if ( light.isPointLight === true ) {
    
                getMaterialVariant = getDistanceMaterialVariant;
                customMaterial = object.customDistanceMaterial;
    
            }
    
            if ( customMaterial === undefined ) {
    
                var useMorphing = false;
    
                if ( material.morphTargets === true ) {
    
                    if ( geometry.isBufferGeometry === true ) {
    
                        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
    
                    } else if ( geometry.isGeometry === true ) {
    
                        useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
    
                    }
    
                }
    
                var useSkinning = false;
    
                if ( object.isSkinnedMesh === true ) {
    
                    if ( material.skinning === true ) {
    
                        useSkinning = true;
    
                    } else {
    
                        console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );
    
                    }
    
                }
    
                var useInstancing = object.isInstancedMesh === true;
    
                result = getMaterialVariant( useMorphing, useSkinning, useInstancing );
    
            } else {
    
                result = customMaterial;
    
            }
    
            if ( _renderer.localClippingEnabled &&
                    material.clipShadows === true &&
                    material.clippingPlanes.length !== 0 ) {
    
                // in this case we need a unique material instance reflecting the
                // appropriate state
    
                var keyA = result.uuid, keyB = material.uuid;
    
                var materialsForVariant = _materialCache[ keyA ];
    
                if ( materialsForVariant === undefined ) {
    
                    materialsForVariant = {};
                    _materialCache[ keyA ] = materialsForVariant;
    
                }
    
                var cachedMaterial = materialsForVariant[ keyB ];
    
                if ( cachedMaterial === undefined ) {
    
                    cachedMaterial = result.clone();
                    materialsForVariant[ keyB ] = cachedMaterial;
    
                }
    
                result = cachedMaterial;
    
            }
    
            result.visible = material.visible;
            result.wireframe = material.wireframe;
    
            if ( type === VSMShadowMap ) {
    
                result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;
    
            } else {
    
                result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];
    
            }
    
            result.clipShadows = material.clipShadows;
            result.clippingPlanes = material.clippingPlanes;
            result.clipIntersection = material.clipIntersection;
    
            result.wireframeLinewidth = material.wireframeLinewidth;
            result.linewidth = material.linewidth;
    
            if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {
    
                result.referencePosition.setFromMatrixPosition( light.matrixWorld );
                result.nearDistance = shadowCameraNear;
                result.farDistance = shadowCameraFar;
    
            }
    
            return result;
    
        }
    
        function renderObject( object, camera, shadowCamera, light, type ) {
    
            if ( object.visible === false ) return;
    
            var visible = object.layers.test( camera.layers );
    
            if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {
    
                if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {
    
                    object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
    
                    var geometry = _objects.update( object );
                    var material = object.material;
    
                    if ( Array.isArray( material ) ) {
    
                        var groups = geometry.groups;
    
                        for ( var k = 0, kl = groups.length; k < kl; k ++ ) {
    
                            var group = groups[ k ];
                            var groupMaterial = material[ group.materialIndex ];
    
                            if ( groupMaterial && groupMaterial.visible ) {
    
                                var depthMaterial = getDepthMaterial( object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );
    
                                _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
    
                            }
    
                        }
    
                    } else if ( material.visible ) {
    
                        var depthMaterial = getDepthMaterial( object, material, light, shadowCamera.near, shadowCamera.far, type );
    
                        _renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );
    
                    }
    
                }
    
            }
    
            var children = object.children;
    
            for ( var i = 0, l = children.length; i < l; i ++ ) {
    
                renderObject( children[ i ], camera, shadowCamera, light, type );
    
            }
    
        }
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLState( gl, extensions, capabilities ) {
    
        var isWebGL2 = capabilities.isWebGL2;
    
        function ColorBuffer() {
    
            var locked = false;
    
            var color = new Vector4();
            var currentColorMask = null;
            var currentColorClear = new Vector4( 0, 0, 0, 0 );
    
            return {
    
                setMask: function ( colorMask ) {
    
                    if ( currentColorMask !== colorMask && ! locked ) {
    
                        gl.colorMask( colorMask, colorMask, colorMask, colorMask );
                        currentColorMask = colorMask;
    
                    }
    
                },
    
                setLocked: function ( lock ) {
    
                    locked = lock;
    
                },
    
                setClear: function ( r, g, b, a, premultipliedAlpha ) {
    
                    if ( premultipliedAlpha === true ) {
    
                        r *= a; g *= a; b *= a;
    
                    }
    
                    color.set( r, g, b, a );
    
                    if ( currentColorClear.equals( color ) === false ) {
    
                        gl.clearColor( r, g, b, a );
                        currentColorClear.copy( color );
    
                    }
    
                },
    
                reset: function () {
    
                    locked = false;
    
                    currentColorMask = null;
                    currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state
    
                }
    
            };
    
        }
    
        function DepthBuffer() {
    
            var locked = false;
    
            var currentDepthMask = null;
            var currentDepthFunc = null;
            var currentDepthClear = null;
    
            return {
    
                setTest: function ( depthTest ) {
    
                    if ( depthTest ) {
    
                        enable( 2929 );
    
                    } else {
    
                        disable( 2929 );
    
                    }
    
                },
    
                setMask: function ( depthMask ) {
    
                    if ( currentDepthMask !== depthMask && ! locked ) {
    
                        gl.depthMask( depthMask );
                        currentDepthMask = depthMask;
    
                    }
    
                },
    
                setFunc: function ( depthFunc ) {
    
                    if ( currentDepthFunc !== depthFunc ) {
    
                        if ( depthFunc ) {
    
                            switch ( depthFunc ) {
    
                                case NeverDepth:
    
                                    gl.depthFunc( 512 );
                                    break;
    
                                case AlwaysDepth:
    
                                    gl.depthFunc( 519 );
                                    break;
    
                                case LessDepth:
    
                                    gl.depthFunc( 513 );
                                    break;
    
                                case LessEqualDepth:
    
                                    gl.depthFunc( 515 );
                                    break;
    
                                case EqualDepth:
    
                                    gl.depthFunc( 514 );
                                    break;
    
                                case GreaterEqualDepth:
    
                                    gl.depthFunc( 518 );
                                    break;
    
                                case GreaterDepth:
    
                                    gl.depthFunc( 516 );
                                    break;
    
                                case NotEqualDepth:
    
                                    gl.depthFunc( 517 );
                                    break;
    
                                default:
    
                                    gl.depthFunc( 515 );
    
                            }
    
                        } else {
    
                            gl.depthFunc( 515 );
    
                        }
    
                        currentDepthFunc = depthFunc;
    
                    }
    
                },
    
                setLocked: function ( lock ) {
    
                    locked = lock;
    
                },
    
                setClear: function ( depth ) {
    
                    if ( currentDepthClear !== depth ) {
    
                        gl.clearDepth( depth );
                        currentDepthClear = depth;
    
                    }
    
                },
    
                reset: function () {
    
                    locked = false;
    
                    currentDepthMask = null;
                    currentDepthFunc = null;
                    currentDepthClear = null;
    
                }
    
            };
    
        }
    
        function StencilBuffer() {
    
            var locked = false;
    
            var currentStencilMask = null;
            var currentStencilFunc = null;
            var currentStencilRef = null;
            var currentStencilFuncMask = null;
            var currentStencilFail = null;
            var currentStencilZFail = null;
            var currentStencilZPass = null;
            var currentStencilClear = null;
    
            return {
    
                setTest: function ( stencilTest ) {
    
                    if ( ! locked ) {
    
                        if ( stencilTest ) {
    
                            enable( 2960 );
    
                        } else {
    
                            disable( 2960 );
    
                        }
    
                    }
    
                },
    
                setMask: function ( stencilMask ) {
    
                    if ( currentStencilMask !== stencilMask && ! locked ) {
    
                        gl.stencilMask( stencilMask );
                        currentStencilMask = stencilMask;
    
                    }
    
                },
    
                setFunc: function ( stencilFunc, stencilRef, stencilMask ) {
    
                    if ( currentStencilFunc !== stencilFunc ||
                         currentStencilRef 	!== stencilRef 	||
                         currentStencilFuncMask !== stencilMask ) {
    
                        gl.stencilFunc( stencilFunc, stencilRef, stencilMask );
    
                        currentStencilFunc = stencilFunc;
                        currentStencilRef = stencilRef;
                        currentStencilFuncMask = stencilMask;
    
                    }
    
                },
    
                setOp: function ( stencilFail, stencilZFail, stencilZPass ) {
    
                    if ( currentStencilFail	 !== stencilFail 	||
                         currentStencilZFail !== stencilZFail ||
                         currentStencilZPass !== stencilZPass ) {
    
                        gl.stencilOp( stencilFail, stencilZFail, stencilZPass );
    
                        currentStencilFail = stencilFail;
                        currentStencilZFail = stencilZFail;
                        currentStencilZPass = stencilZPass;
    
                    }
    
                },
    
                setLocked: function ( lock ) {
    
                    locked = lock;
    
                },
    
                setClear: function ( stencil ) {
    
                    if ( currentStencilClear !== stencil ) {
    
                        gl.clearStencil( stencil );
                        currentStencilClear = stencil;
    
                    }
    
                },
    
                reset: function () {
    
                    locked = false;
    
                    currentStencilMask = null;
                    currentStencilFunc = null;
                    currentStencilRef = null;
                    currentStencilFuncMask = null;
                    currentStencilFail = null;
                    currentStencilZFail = null;
                    currentStencilZPass = null;
                    currentStencilClear = null;
    
                }
    
            };
    
        }
    
        //
    
        var colorBuffer = new ColorBuffer();
        var depthBuffer = new DepthBuffer();
        var stencilBuffer = new StencilBuffer();
    
        var maxVertexAttributes = gl.getParameter( 34921 );
        var newAttributes = new Uint8Array( maxVertexAttributes );
        var enabledAttributes = new Uint8Array( maxVertexAttributes );
        var attributeDivisors = new Uint8Array( maxVertexAttributes );
    
        var enabledCapabilities = {};
    
        var currentProgram = null;
    
        var currentBlendingEnabled = null;
        var currentBlending = null;
        var currentBlendEquation = null;
        var currentBlendSrc = null;
        var currentBlendDst = null;
        var currentBlendEquationAlpha = null;
        var currentBlendSrcAlpha = null;
        var currentBlendDstAlpha = null;
        var currentPremultipledAlpha = false;
    
        var currentFlipSided = null;
        var currentCullFace = null;
    
        var currentLineWidth = null;
    
        var currentPolygonOffsetFactor = null;
        var currentPolygonOffsetUnits = null;
    
        var maxTextures = gl.getParameter( 35661 );
    
        var lineWidthAvailable = false;
        var version = 0;
        var glVersion = gl.getParameter( 7938 );
    
        if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {
    
            version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
            lineWidthAvailable = ( version >= 1.0 );
    
        } else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {
    
            version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
            lineWidthAvailable = ( version >= 2.0 );
    
        }
    
        var currentTextureSlot = null;
        var currentBoundTextures = {};
    
        var currentScissor = new Vector4();
        var currentViewport = new Vector4();
    
        function createTexture( type, target, count ) {
    
            var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
            var texture = gl.createTexture();
    
            gl.bindTexture( type, texture );
            gl.texParameteri( type, 10241, 9728 );
            gl.texParameteri( type, 10240, 9728 );
    
            for ( var i = 0; i < count; i ++ ) {
    
                gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );
    
            }
    
            return texture;
    
        }
    
        var emptyTextures = {};
        emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
        emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );
    
        // init
    
        colorBuffer.setClear( 0, 0, 0, 1 );
        depthBuffer.setClear( 1 );
        stencilBuffer.setClear( 0 );
    
        enable( 2929 );
        depthBuffer.setFunc( LessEqualDepth );
    
        setFlipSided( false );
        setCullFace( CullFaceBack );
        enable( 2884 );
    
        setBlending( NoBlending );
    
        //
    
        function initAttributes() {
    
            for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
    
                newAttributes[ i ] = 0;
    
            }
    
        }
    
        function enableAttribute( attribute ) {
    
            enableAttributeAndDivisor( attribute, 0 );
    
        }
    
        function enableAttributeAndDivisor( attribute, meshPerAttribute ) {
    
            newAttributes[ attribute ] = 1;
    
            if ( enabledAttributes[ attribute ] === 0 ) {
    
                gl.enableVertexAttribArray( attribute );
                enabledAttributes[ attribute ] = 1;
    
            }
    
            if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
    
                var extension = isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );
    
                extension[ isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
                attributeDivisors[ attribute ] = meshPerAttribute;
    
            }
    
        }
    
        function disableUnusedAttributes() {
    
            for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {
    
                if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
    
                    gl.disableVertexAttribArray( i );
                    enabledAttributes[ i ] = 0;
    
                }
    
            }
    
        }
    
        function enable( id ) {
    
            if ( enabledCapabilities[ id ] !== true ) {
    
                gl.enable( id );
                enabledCapabilities[ id ] = true;
    
            }
    
        }
    
        function disable( id ) {
    
            if ( enabledCapabilities[ id ] !== false ) {
    
                gl.disable( id );
                enabledCapabilities[ id ] = false;
    
            }
    
        }
    
        function useProgram( program ) {
    
            if ( currentProgram !== program ) {
    
                gl.useProgram( program );
    
                currentProgram = program;
    
                return true;
    
            }
    
            return false;
    
        }
    
        var equationToGL = {
            [ AddEquation ]: 32774,
            [ SubtractEquation ]: 32778,
            [ ReverseSubtractEquation ]: 32779
        };
    
        if ( isWebGL2 ) {
    
            equationToGL[ MinEquation ] = 32775;
            equationToGL[ MaxEquation ] = 32776;
    
        } else {
    
            var extension = extensions.get( 'EXT_blend_minmax' );
    
            if ( extension !== null ) {
    
                equationToGL[ MinEquation ] = extension.MIN_EXT;
                equationToGL[ MaxEquation ] = extension.MAX_EXT;
    
            }
    
        }
    
        var factorToGL = {
            [ ZeroFactor ]: 0,
            [ OneFactor ]: 1,
            [ SrcColorFactor ]: 768,
            [ SrcAlphaFactor ]: 770,
            [ SrcAlphaSaturateFactor ]: 776,
            [ DstColorFactor ]: 774,
            [ DstAlphaFactor ]: 772,
            [ OneMinusSrcColorFactor ]: 769,
            [ OneMinusSrcAlphaFactor ]: 771,
            [ OneMinusDstColorFactor ]: 775,
            [ OneMinusDstAlphaFactor ]: 773
        };
    
        function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {
    
            if ( blending === NoBlending ) {
    
                if ( currentBlendingEnabled ) {
    
                    disable( 3042 );
                    currentBlendingEnabled = false;
    
                }
    
                return;
    
            }
    
            if ( ! currentBlendingEnabled ) {
    
                enable( 3042 );
                currentBlendingEnabled = true;
    
            }
    
            if ( blending !== CustomBlending ) {
    
                if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {
    
                    if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {
    
                        gl.blendEquation( 32774 );
    
                        currentBlendEquation = AddEquation;
                        currentBlendEquationAlpha = AddEquation;
    
                    }
    
                    if ( premultipliedAlpha ) {
    
                        switch ( blending ) {
    
                            case NormalBlending:
                                gl.blendFuncSeparate( 1, 771, 1, 771 );
                                break;
    
                            case AdditiveBlending:
                                gl.blendFunc( 1, 1 );
                                break;
    
                            case SubtractiveBlending:
                                gl.blendFuncSeparate( 0, 0, 769, 771 );
                                break;
    
                            case MultiplyBlending:
                                gl.blendFuncSeparate( 0, 768, 0, 770 );
                                break;
    
                            default:
                                console.error( 'THREE.WebGLState: Invalid blending: ', blending );
                                break;
    
                        }
    
                    } else {
    
                        switch ( blending ) {
    
                            case NormalBlending:
                                gl.blendFuncSeparate( 770, 771, 1, 771 );
                                break;
    
                            case AdditiveBlending:
                                gl.blendFunc( 770, 1 );
                                break;
    
                            case SubtractiveBlending:
                                gl.blendFunc( 0, 769 );
                                break;
    
                            case MultiplyBlending:
                                gl.blendFunc( 0, 768 );
                                break;
    
                            default:
                                console.error( 'THREE.WebGLState: Invalid blending: ', blending );
                                break;
    
                        }
    
                    }
    
                    currentBlendSrc = null;
                    currentBlendDst = null;
                    currentBlendSrcAlpha = null;
                    currentBlendDstAlpha = null;
    
                    currentBlending = blending;
                    currentPremultipledAlpha = premultipliedAlpha;
    
                }
    
                return;
    
            }
    
            // custom blending
    
            blendEquationAlpha = blendEquationAlpha || blendEquation;
            blendSrcAlpha = blendSrcAlpha || blendSrc;
            blendDstAlpha = blendDstAlpha || blendDst;
    
            if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
    
                gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );
    
                currentBlendEquation = blendEquation;
                currentBlendEquationAlpha = blendEquationAlpha;
    
            }
    
            if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
    
                gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );
    
                currentBlendSrc = blendSrc;
                currentBlendDst = blendDst;
                currentBlendSrcAlpha = blendSrcAlpha;
                currentBlendDstAlpha = blendDstAlpha;
    
            }
    
            currentBlending = blending;
            currentPremultipledAlpha = null;
    
        }
    
        function setMaterial( material, frontFaceCW ) {
    
            material.side === DoubleSide
                ? disable( 2884 )
                : enable( 2884 );
    
            var flipSided = ( material.side === BackSide );
            if ( frontFaceCW ) flipSided = ! flipSided;
    
            setFlipSided( flipSided );
    
            ( material.blending === NormalBlending && material.transparent === false )
                ? setBlending( NoBlending )
                : setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
    
            depthBuffer.setFunc( material.depthFunc );
            depthBuffer.setTest( material.depthTest );
            depthBuffer.setMask( material.depthWrite );
            colorBuffer.setMask( material.colorWrite );
    
            var stencilWrite = material.stencilWrite;
            stencilBuffer.setTest( stencilWrite );
            if ( stencilWrite ) {
    
                stencilBuffer.setMask( material.stencilWriteMask );
                stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
                stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );
    
            }
    
            setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
    
        }
    
        //
    
        function setFlipSided( flipSided ) {
    
            if ( currentFlipSided !== flipSided ) {
    
                if ( flipSided ) {
    
                    gl.frontFace( 2304 );
    
                } else {
    
                    gl.frontFace( 2305 );
    
                }
    
                currentFlipSided = flipSided;
    
            }
    
        }
    
        function setCullFace( cullFace ) {
    
            if ( cullFace !== CullFaceNone ) {
    
                enable( 2884 );
    
                if ( cullFace !== currentCullFace ) {
    
                    if ( cullFace === CullFaceBack ) {
    
                        gl.cullFace( 1029 );
    
                    } else if ( cullFace === CullFaceFront ) {
    
                        gl.cullFace( 1028 );
    
                    } else {
    
                        gl.cullFace( 1032 );
    
                    }
    
                }
    
            } else {
    
                disable( 2884 );
    
            }
    
            currentCullFace = cullFace;
    
        }
    
        function setLineWidth( width ) {
    
            if ( width !== currentLineWidth ) {
    
                if ( lineWidthAvailable ) gl.lineWidth( width );
    
                currentLineWidth = width;
    
            }
    
        }
    
        function setPolygonOffset( polygonOffset, factor, units ) {
    
            if ( polygonOffset ) {
    
                enable( 32823 );
    
                if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {
    
                    gl.polygonOffset( factor, units );
    
                    currentPolygonOffsetFactor = factor;
                    currentPolygonOffsetUnits = units;
    
                }
    
            } else {
    
                disable( 32823 );
    
            }
    
        }
    
        function setScissorTest( scissorTest ) {
    
            if ( scissorTest ) {
    
                enable( 3089 );
    
            } else {
    
                disable( 3089 );
    
            }
    
        }
    
        // texture
    
        function activeTexture( webglSlot ) {
    
            if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;
    
            if ( currentTextureSlot !== webglSlot ) {
    
                gl.activeTexture( webglSlot );
                currentTextureSlot = webglSlot;
    
            }
    
        }
    
        function bindTexture( webglType, webglTexture ) {
    
            if ( currentTextureSlot === null ) {
    
                activeTexture();
    
            }
    
            var boundTexture = currentBoundTextures[ currentTextureSlot ];
    
            if ( boundTexture === undefined ) {
    
                boundTexture = { type: undefined, texture: undefined };
                currentBoundTextures[ currentTextureSlot ] = boundTexture;
    
            }
    
            if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
    
                gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );
    
                boundTexture.type = webglType;
                boundTexture.texture = webglTexture;
    
            }
    
        }
    
        function unbindTexture() {
    
            var boundTexture = currentBoundTextures[ currentTextureSlot ];
    
            if ( boundTexture !== undefined && boundTexture.type !== undefined ) {
    
                gl.bindTexture( boundTexture.type, null );
    
                boundTexture.type = undefined;
                boundTexture.texture = undefined;
    
            }
    
        }
    
        function compressedTexImage2D() {
    
            try {
    
                gl.compressedTexImage2D.apply( gl, arguments );
    
            } catch ( error ) {
    
                console.error( 'THREE.WebGLState:', error );
    
            }
    
        }
    
        function texImage2D() {
    
            try {
    
                gl.texImage2D.apply( gl, arguments );
    
            } catch ( error ) {
    
                console.error( 'THREE.WebGLState:', error );
    
            }
    
        }
    
        function texImage3D() {
    
            try {
    
                gl.texImage3D.apply( gl, arguments );
    
            } catch ( error ) {
    
                console.error( 'THREE.WebGLState:', error );
    
            }
    
        }
    
        //
    
        function scissor( scissor ) {
    
            if ( currentScissor.equals( scissor ) === false ) {
    
                gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
                currentScissor.copy( scissor );
    
            }
    
        }
    
        function viewport( viewport ) {
    
            if ( currentViewport.equals( viewport ) === false ) {
    
                gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
                currentViewport.copy( viewport );
    
            }
    
        }
    
        //
    
        function reset() {
    
            for ( var i = 0; i < enabledAttributes.length; i ++ ) {
    
                if ( enabledAttributes[ i ] === 1 ) {
    
                    gl.disableVertexAttribArray( i );
                    enabledAttributes[ i ] = 0;
    
                }
    
            }
    
            enabledCapabilities = {};
    
            currentTextureSlot = null;
            currentBoundTextures = {};
    
            currentProgram = null;
    
            currentBlending = null;
    
            currentFlipSided = null;
            currentCullFace = null;
    
            colorBuffer.reset();
            depthBuffer.reset();
            stencilBuffer.reset();
    
        }
    
        return {
    
            buffers: {
                color: colorBuffer,
                depth: depthBuffer,
                stencil: stencilBuffer
            },
    
            initAttributes: initAttributes,
            enableAttribute: enableAttribute,
            enableAttributeAndDivisor: enableAttributeAndDivisor,
            disableUnusedAttributes: disableUnusedAttributes,
            enable: enable,
            disable: disable,
    
            useProgram: useProgram,
    
            setBlending: setBlending,
            setMaterial: setMaterial,
    
            setFlipSided: setFlipSided,
            setCullFace: setCullFace,
    
            setLineWidth: setLineWidth,
            setPolygonOffset: setPolygonOffset,
    
            setScissorTest: setScissorTest,
    
            activeTexture: activeTexture,
            bindTexture: bindTexture,
            unbindTexture: unbindTexture,
            compressedTexImage2D: compressedTexImage2D,
            texImage2D: texImage2D,
            texImage3D: texImage3D,
    
            scissor: scissor,
            viewport: viewport,
    
            reset: reset
    
        };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {
    
        var isWebGL2 = capabilities.isWebGL2;
        var maxTextures = capabilities.maxTextures;
        var maxCubemapSize = capabilities.maxCubemapSize;
        var maxTextureSize = capabilities.maxTextureSize;
        var maxSamples = capabilities.maxSamples;
    
        var _videoTextures = new WeakMap();
        var _canvas;
    
        // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
        // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
        // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
    
        var useOffscreenCanvas = false;
    
        try {
    
            useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
                && ( new OffscreenCanvas( 1, 1 ).getContext( "2d" ) ) !== null;
    
        } catch ( err ) {
    
            // Ignore any errors
    
        }
    
        function createCanvas( width, height ) {
    
            // Use OffscreenCanvas when available. Specially needed in web workers
    
            return useOffscreenCanvas ?
                new OffscreenCanvas( width, height ) :
                document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    
        }
    
        function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {
    
            var scale = 1;
    
            // handle case if texture exceeds max size
    
            if ( image.width > maxSize || image.height > maxSize ) {
    
                scale = maxSize / Math.max( image.width, image.height );
    
            }
    
            // only perform resize if necessary
    
            if ( scale < 1 || needsPowerOfTwo === true ) {
    
                // only perform resize for certain image types
    
                if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
                    ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
                    ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {
    
                    var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
    
                    var width = floor( scale * image.width );
                    var height = floor( scale * image.height );
    
                    if ( _canvas === undefined ) _canvas = createCanvas( width, height );
    
                    // cube textures can't reuse the same canvas
    
                    var canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;
    
                    canvas.width = width;
                    canvas.height = height;
    
                    var context = canvas.getContext( '2d' );
                    context.drawImage( image, 0, 0, width, height );
    
                    console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );
    
                    return canvas;
    
                } else {
    
                    if ( 'data' in image ) {
    
                        console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );
    
                    }
    
                    return image;
    
                }
    
            }
    
            return image;
    
        }
    
        function isPowerOfTwo( image ) {
    
            return MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );
    
        }
    
        function textureNeedsPowerOfTwo( texture ) {
    
            if ( isWebGL2 ) return false;
    
            return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
                ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );
    
        }
    
        function textureNeedsGenerateMipmaps( texture, supportsMips ) {
    
            return texture.generateMipmaps && supportsMips &&
                texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    
        }
    
        function generateMipmap( target, texture, width, height ) {
    
            _gl.generateMipmap( target );
    
            var textureProperties = properties.get( texture );
    
            // Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
            textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;
    
        }
    
        function getInternalFormat( internalFormatName, glFormat, glType ) {
    
            if ( isWebGL2 === false ) return glFormat;
    
            if ( internalFormatName !== null ) {
    
                if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];
    
                console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );
    
            }
    
            var internalFormat = glFormat;
    
            if ( glFormat === 6403 ) {
    
                if ( glType === 5126 ) internalFormat = 33326;
                if ( glType === 5131 ) internalFormat = 33325;
                if ( glType === 5121 ) internalFormat = 33321;
    
            }
    
            if ( glFormat === 6407 ) {
    
                if ( glType === 5126 ) internalFormat = 34837;
                if ( glType === 5131 ) internalFormat = 34843;
                if ( glType === 5121 ) internalFormat = 32849;
    
            }
    
            if ( glFormat === 6408 ) {
    
                if ( glType === 5126 ) internalFormat = 34836;
                if ( glType === 5131 ) internalFormat = 34842;
                if ( glType === 5121 ) internalFormat = 32856;
    
            }
    
            if ( internalFormat === 33325 || internalFormat === 33326 ||
                internalFormat === 34842 || internalFormat === 34836 ) {
    
                extensions.get( 'EXT_color_buffer_float' );
    
            } else if ( internalFormat === 34843 || internalFormat === 34837 ) {
    
                console.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' );
    
            }
    
            return internalFormat;
    
        }
    
        // Fallback filters for non-power-of-2 textures
    
        function filterFallback( f ) {
    
            if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {
    
                return 9728;
    
            }
    
            return 9729;
    
        }
    
        //
    
        function onTextureDispose( event ) {
    
            var texture = event.target;
    
            texture.removeEventListener( 'dispose', onTextureDispose );
    
            deallocateTexture( texture );
    
            if ( texture.isVideoTexture ) {
    
                _videoTextures.delete( texture );
    
            }
    
            info.memory.textures --;
    
        }
    
        function onRenderTargetDispose( event ) {
    
            var renderTarget = event.target;
    
            renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
    
            deallocateRenderTarget( renderTarget );
    
            info.memory.textures --;
    
        }
    
        //
    
        function deallocateTexture( texture ) {
    
            var textureProperties = properties.get( texture );
    
            if ( textureProperties.__webglInit === undefined ) return;
    
            _gl.deleteTexture( textureProperties.__webglTexture );
    
            properties.remove( texture );
    
        }
    
        function deallocateRenderTarget( renderTarget ) {
    
            var renderTargetProperties = properties.get( renderTarget );
            var textureProperties = properties.get( renderTarget.texture );
    
            if ( ! renderTarget ) return;
    
            if ( textureProperties.__webglTexture !== undefined ) {
    
                _gl.deleteTexture( textureProperties.__webglTexture );
    
            }
    
            if ( renderTarget.depthTexture ) {
    
                renderTarget.depthTexture.dispose();
    
            }
    
            if ( renderTarget.isWebGLCubeRenderTarget ) {
    
                for ( var i = 0; i < 6; i ++ ) {
    
                    _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
                    if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );
    
                }
    
            } else {
    
                _gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
                if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
    
            }
    
            properties.remove( renderTarget.texture );
            properties.remove( renderTarget );
    
        }
    
        //
    
        var textureUnits = 0;
    
        function resetTextureUnits() {
    
            textureUnits = 0;
    
        }
    
        function allocateTextureUnit() {
    
            var textureUnit = textureUnits;
    
            if ( textureUnit >= maxTextures ) {
    
                console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );
    
            }
    
            textureUnits += 1;
    
            return textureUnit;
    
        }
    
        //
    
        function setTexture2D( texture, slot ) {
    
            var textureProperties = properties.get( texture );
    
            if ( texture.isVideoTexture ) updateVideoTexture( texture );
    
            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
    
                var image = texture.image;
    
                if ( image === undefined ) {
    
                    console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );
    
                } else if ( image.complete === false ) {
    
                    console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );
    
                } else {
    
                    uploadTexture( textureProperties, texture, slot );
                    return;
    
                }
    
            }
    
            state.activeTexture( 33984 + slot );
            state.bindTexture( 3553, textureProperties.__webglTexture );
    
        }
    
        function setTexture2DArray( texture, slot ) {
    
            var textureProperties = properties.get( texture );
    
            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
    
                uploadTexture( textureProperties, texture, slot );
                return;
    
            }
    
            state.activeTexture( 33984 + slot );
            state.bindTexture( 35866, textureProperties.__webglTexture );
    
        }
    
        function setTexture3D( texture, slot ) {
    
            var textureProperties = properties.get( texture );
    
            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
    
                uploadTexture( textureProperties, texture, slot );
                return;
    
            }
    
            state.activeTexture( 33984 + slot );
            state.bindTexture( 32879, textureProperties.__webglTexture );
    
        }
    
        function setTextureCube( texture, slot ) {
    
            if ( texture.image.length !== 6 ) return;
    
            var textureProperties = properties.get( texture );
    
            if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
    
                initTexture( textureProperties, texture );
    
                state.activeTexture( 33984 + slot );
                state.bindTexture( 34067, textureProperties.__webglTexture );
    
                _gl.pixelStorei( 37440, texture.flipY );
    
                var isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
                var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );
    
                var cubeImage = [];
    
                for ( var i = 0; i < 6; i ++ ) {
    
                    if ( ! isCompressed && ! isDataTexture ) {
    
                        cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );
    
                    } else {
    
                        cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
    
                    }
    
                }
    
                var image = cubeImage[ 0 ],
                    supportsMips = isPowerOfTwo( image ) || isWebGL2,
                    glFormat = utils.convert( texture.format ),
                    glType = utils.convert( texture.type ),
                    glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );
    
                setTextureParameters( 34067, texture, supportsMips );
    
                var mipmaps;
    
                if ( isCompressed ) {
    
                    for ( var i = 0; i < 6; i ++ ) {
    
                        mipmaps = cubeImage[ i ].mipmaps;
    
                        for ( var j = 0; j < mipmaps.length; j ++ ) {
    
                            var mipmap = mipmaps[ j ];
    
                            if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
    
                                if ( glFormat !== null ) {
    
                                    state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );
    
                                } else {
    
                                    console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );
    
                                }
    
                            } else {
    
                                state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
    
                            }
    
                        }
    
                    }
    
                    textureProperties.__maxMipLevel = mipmaps.length - 1;
    
                } else {
    
                    mipmaps = texture.mipmaps;
    
                    for ( var i = 0; i < 6; i ++ ) {
    
                        if ( isDataTexture ) {
    
                            state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
    
                            for ( var j = 0; j < mipmaps.length; j ++ ) {
    
                                var mipmap = mipmaps[ j ];
                                var mipmapImage = mipmap.image[ i ].image;
    
                                state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );
    
                            }
    
                        } else {
    
                            state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );
    
                            for ( var j = 0; j < mipmaps.length; j ++ ) {
    
                                var mipmap = mipmaps[ j ];
    
                                state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );
    
                            }
    
                        }
    
                    }
    
                    textureProperties.__maxMipLevel = mipmaps.length;
    
                }
    
                if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {
    
                    // We assume images for cube map have the same size.
                    generateMipmap( 34067, texture, image.width, image.height );
    
                }
    
                textureProperties.__version = texture.version;
    
                if ( texture.onUpdate ) texture.onUpdate( texture );
    
            } else {
    
                state.activeTexture( 33984 + slot );
                state.bindTexture( 34067, textureProperties.__webglTexture );
    
            }
    
        }
    
        function setTextureCubeDynamic( texture, slot ) {
    
            state.activeTexture( 33984 + slot );
            state.bindTexture( 34067, properties.get( texture ).__webglTexture );
    
        }
    
        var wrappingToGL = {
            [ RepeatWrapping ]: 10497,
            [ ClampToEdgeWrapping ]: 33071,
            [ MirroredRepeatWrapping ]: 33648
        };
    
        var filterToGL = {
            [ NearestFilter ]: 9728,
            [ NearestMipmapNearestFilter ]: 9984,
            [ NearestMipmapLinearFilter ]: 9986,
    
            [ LinearFilter ]: 9729,
            [ LinearMipmapNearestFilter ]: 9985,
            [ LinearMipmapLinearFilter ]: 9987
        };
    
        function setTextureParameters( textureType, texture, supportsMips ) {
    
            if ( supportsMips ) {
    
                _gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
                _gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );
    
                if ( textureType === 32879 || textureType === 35866 ) {
    
                    _gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );
    
                }
    
                _gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
                _gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );
    
            } else {
    
                _gl.texParameteri( textureType, 10242, 33071 );
                _gl.texParameteri( textureType, 10243, 33071 );
    
                if ( textureType === 32879 || textureType === 35866 ) {
    
                    _gl.texParameteri( textureType, 32882, 33071 );
    
                }
    
                if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {
    
                    console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );
    
                }
    
                _gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
                _gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );
    
                if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {
    
                    console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );
    
                }
    
            }
    
            var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
    
            if ( extension ) {
    
                if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
                if ( texture.type === HalfFloatType && ( isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;
    
                if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
    
                    _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
                    properties.get( texture ).__currentAnisotropy = texture.anisotropy;
    
                }
    
            }
    
        }
    
        function initTexture( textureProperties, texture ) {
    
            if ( textureProperties.__webglInit === undefined ) {
    
                textureProperties.__webglInit = true;
    
                texture.addEventListener( 'dispose', onTextureDispose );
    
                textureProperties.__webglTexture = _gl.createTexture();
    
                info.memory.textures ++;
    
            }
    
        }
    
        function uploadTexture( textureProperties, texture, slot ) {
    
            var textureType = 3553;
    
            if ( texture.isDataTexture2DArray ) textureType = 35866;
            if ( texture.isDataTexture3D ) textureType = 32879;
    
            initTexture( textureProperties, texture );
    
            state.activeTexture( 33984 + slot );
            state.bindTexture( textureType, textureProperties.__webglTexture );
    
            _gl.pixelStorei( 37440, texture.flipY );
            _gl.pixelStorei( 37441, texture.premultiplyAlpha );
            _gl.pixelStorei( 3317, texture.unpackAlignment );
    
            var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
            var image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );
    
            var supportsMips = isPowerOfTwo( image ) || isWebGL2,
                glFormat = utils.convert( texture.format ),
                glType = utils.convert( texture.type ),
                glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );
    
            setTextureParameters( textureType, texture, supportsMips );
    
            var mipmap, mipmaps = texture.mipmaps;
    
            if ( texture.isDepthTexture ) {
    
                // populate depth texture with dummy data
    
                glInternalFormat = 6402;
    
                if ( texture.type === FloatType ) {
    
                    if ( isWebGL2 === false ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
                    glInternalFormat = 36012;
    
                } else if ( isWebGL2 ) {
    
                    // WebGL 2.0 requires signed internalformat for glTexImage2D
                    glInternalFormat = 33189;
    
                }
    
                if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {
    
                    // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                    // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {
    
                        console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );
    
                        texture.type = UnsignedShortType;
                        glType = utils.convert( texture.type );
    
                    }
    
                }
    
                // Depth stencil textures need the DEPTH_STENCIL internal format
                // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                if ( texture.format === DepthStencilFormat ) {
    
                    glInternalFormat = 34041;
    
                    // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                    // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                    if ( texture.type !== UnsignedInt248Type ) {
    
                        console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );
    
                        texture.type = UnsignedInt248Type;
                        glType = utils.convert( texture.type );
    
                    }
    
                }
    
                state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );
    
            } else if ( texture.isDataTexture ) {
    
                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels
    
                if ( mipmaps.length > 0 && supportsMips ) {
    
                    for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
    
                        mipmap = mipmaps[ i ];
                        state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
    
                    }
    
                    texture.generateMipmaps = false;
                    textureProperties.__maxMipLevel = mipmaps.length - 1;
    
                } else {
    
                    state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
                    textureProperties.__maxMipLevel = 0;
    
                }
    
            } else if ( texture.isCompressedTexture ) {
    
                for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
    
                    mipmap = mipmaps[ i ];
    
                    if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
    
                        if ( glFormat !== null ) {
    
                            state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );
    
                        } else {
    
                            console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );
    
                        }
    
                    } else {
    
                        state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
    
                    }
    
                }
    
                textureProperties.__maxMipLevel = mipmaps.length - 1;
    
            } else if ( texture.isDataTexture2DArray ) {
    
                state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
                textureProperties.__maxMipLevel = 0;
    
            } else if ( texture.isDataTexture3D ) {
    
                state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
                textureProperties.__maxMipLevel = 0;
    
            } else {
    
                // regular Texture (image, video, canvas)
    
                // use manually created mipmaps if available
                // if there are no manual mipmaps
                // set 0 level mipmap and then use GL to generate other mipmap levels
    
                if ( mipmaps.length > 0 && supportsMips ) {
    
                    for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
    
                        mipmap = mipmaps[ i ];
                        state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );
    
                    }
    
                    texture.generateMipmaps = false;
                    textureProperties.__maxMipLevel = mipmaps.length - 1;
    
                } else {
    
                    state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
                    textureProperties.__maxMipLevel = 0;
    
                }
    
            }
    
            if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {
    
                generateMipmap( textureType, texture, image.width, image.height );
    
            }
    
            textureProperties.__version = texture.version;
    
            if ( texture.onUpdate ) texture.onUpdate( texture );
    
        }
    
        // Render targets
    
        // Setup storage for target texture and bind it to correct framebuffer
        function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {
    
            var glFormat = utils.convert( renderTarget.texture.format );
            var glType = utils.convert( renderTarget.texture.type );
            var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
            state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
            _gl.bindFramebuffer( 36160, framebuffer );
            _gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
            _gl.bindFramebuffer( 36160, null );
    
        }
    
        // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
        function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {
    
            _gl.bindRenderbuffer( 36161, renderbuffer );
    
            if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
    
                if ( isMultisample ) {
    
                    var samples = getRenderTargetSamples( renderTarget );
    
                    _gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height );
    
                } else {
    
                    _gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height );
    
                }
    
                _gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );
    
            } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
    
                if ( isMultisample ) {
    
                    var samples = getRenderTargetSamples( renderTarget );
    
                    _gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );
    
                } else {
    
                    _gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );
    
                }
    
    
                _gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );
    
            } else {
    
                var glFormat = utils.convert( renderTarget.texture.format );
                var glType = utils.convert( renderTarget.texture.type );
                var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
    
                if ( isMultisample ) {
    
                    var samples = getRenderTargetSamples( renderTarget );
    
                    _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );
    
                } else {
    
                    _gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );
    
                }
    
            }
    
            _gl.bindRenderbuffer( 36161, null );
    
        }
    
        // Setup resources for a Depth Texture for a FBO (needs an extension)
        function setupDepthTexture( framebuffer, renderTarget ) {
    
            var isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
            if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );
    
            _gl.bindFramebuffer( 36160, framebuffer );
    
            if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {
    
                throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );
    
            }
    
            // upload an empty depth texture with framebuffer size
            if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
                    renderTarget.depthTexture.image.width !== renderTarget.width ||
                    renderTarget.depthTexture.image.height !== renderTarget.height ) {
    
                renderTarget.depthTexture.image.width = renderTarget.width;
                renderTarget.depthTexture.image.height = renderTarget.height;
                renderTarget.depthTexture.needsUpdate = true;
    
            }
    
            setTexture2D( renderTarget.depthTexture, 0 );
    
            var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
    
            if ( renderTarget.depthTexture.format === DepthFormat ) {
    
                _gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );
    
            } else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {
    
                _gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );
    
            } else {
    
                throw new Error( 'Unknown depthTexture format' );
    
            }
    
        }
    
        // Setup GL resources for a non-texture depth buffer
        function setupDepthRenderbuffer( renderTarget ) {
    
            var renderTargetProperties = properties.get( renderTarget );
    
            var isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
    
            if ( renderTarget.depthTexture ) {
    
                if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );
    
                setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );
    
            } else {
    
                if ( isCube ) {
    
                    renderTargetProperties.__webglDepthbuffer = [];
    
                    for ( var i = 0; i < 6; i ++ ) {
    
                        _gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
                        renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
                        setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );
    
                    }
    
                } else {
    
                    _gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
                    renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                    setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );
    
                }
    
            }
    
            _gl.bindFramebuffer( 36160, null );
    
        }
    
        // Set up GL resources for the render target
        function setupRenderTarget( renderTarget ) {
    
            var renderTargetProperties = properties.get( renderTarget );
            var textureProperties = properties.get( renderTarget.texture );
    
            renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
    
            textureProperties.__webglTexture = _gl.createTexture();
    
            info.memory.textures ++;
    
            var isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
            var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
            var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;
    
            // Setup framebuffer
    
            if ( isCube ) {
    
                renderTargetProperties.__webglFramebuffer = [];
    
                for ( var i = 0; i < 6; i ++ ) {
    
                    renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
    
                }
    
            } else {
    
                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
    
                if ( isMultisample ) {
    
                    if ( isWebGL2 ) {
    
                        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                        renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
    
                        _gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );
    
                        var glFormat = utils.convert( renderTarget.texture.format );
                        var glType = utils.convert( renderTarget.texture.type );
                        var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
                        var samples = getRenderTargetSamples( renderTarget );
                        _gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );
    
                        _gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
                        _gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
                        _gl.bindRenderbuffer( 36161, null );
    
                        if ( renderTarget.depthBuffer ) {
    
                            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                            setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );
    
                        }
    
                        _gl.bindFramebuffer( 36160, null );
    
    
                    } else {
    
                        console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );
    
                    }
    
                }
    
            }
    
            // Setup color buffer
    
            if ( isCube ) {
    
                state.bindTexture( 34067, textureProperties.__webglTexture );
                setTextureParameters( 34067, renderTarget.texture, supportsMips );
    
                for ( var i = 0; i < 6; i ++ ) {
    
                    setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );
    
                }
    
                if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {
    
                    generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );
    
                }
    
                state.bindTexture( 34067, null );
    
            } else {
    
                state.bindTexture( 3553, textureProperties.__webglTexture );
                setTextureParameters( 3553, renderTarget.texture, supportsMips );
                setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );
    
                if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {
    
                    generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );
    
                }
    
                state.bindTexture( 3553, null );
    
            }
    
            // Setup depth and stencil buffers
    
            if ( renderTarget.depthBuffer ) {
    
                setupDepthRenderbuffer( renderTarget );
    
            }
    
        }
    
        function updateRenderTargetMipmap( renderTarget ) {
    
            var texture = renderTarget.texture;
            var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;
    
            if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {
    
                var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
                var webglTexture = properties.get( texture ).__webglTexture;
    
                state.bindTexture( target, webglTexture );
                generateMipmap( target, texture, renderTarget.width, renderTarget.height );
                state.bindTexture( target, null );
    
            }
    
        }
    
        function updateMultisampleRenderTarget( renderTarget ) {
    
            if ( renderTarget.isWebGLMultisampleRenderTarget ) {
    
                if ( isWebGL2 ) {
    
                    var renderTargetProperties = properties.get( renderTarget );
    
                    _gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
                    _gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );
    
                    var width = renderTarget.width;
                    var height = renderTarget.height;
                    var mask = 16384;
    
                    if ( renderTarget.depthBuffer ) mask |= 256;
                    if ( renderTarget.stencilBuffer ) mask |= 1024;
    
                    _gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );
    
                } else {
    
                    console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );
    
                }
    
            }
    
        }
    
        function getRenderTargetSamples( renderTarget ) {
    
            return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
                Math.min( maxSamples, renderTarget.samples ) : 0;
    
        }
    
        function updateVideoTexture( texture ) {
    
            var frame = info.render.frame;
    
            // Check the last frame we updated the VideoTexture
    
            if ( _videoTextures.get( texture ) !== frame ) {
    
                _videoTextures.set( texture, frame );
                texture.update();
    
            }
    
        }
    
        // backwards compatibility
    
        var warnedTexture2D = false;
        var warnedTextureCube = false;
    
        function safeSetTexture2D( texture, slot ) {
    
            if ( texture && texture.isWebGLRenderTarget ) {
    
                if ( warnedTexture2D === false ) {
    
                    console.warn( "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead." );
                    warnedTexture2D = true;
    
                }
    
                texture = texture.texture;
    
            }
    
            setTexture2D( texture, slot );
    
        }
    
        function safeSetTextureCube( texture, slot ) {
    
            if ( texture && texture.isWebGLCubeRenderTarget ) {
    
                if ( warnedTextureCube === false ) {
    
                    console.warn( "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
                    warnedTextureCube = true;
    
                }
    
                texture = texture.texture;
    
            }
    
            // currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
            // TODO: unify these code paths
            if ( ( texture && texture.isCubeTexture ) ||
                ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {
    
                // CompressedTexture can have Array in image :/
    
                // this function alone should take care of cube textures
                setTextureCube( texture, slot );
    
            } else {
    
                // assumed: texture property of THREE.WebGLCubeRenderTarget
                setTextureCubeDynamic( texture, slot );
    
            }
    
        }
    
        //
    
        this.allocateTextureUnit = allocateTextureUnit;
        this.resetTextureUnits = resetTextureUnits;
    
        this.setTexture2D = setTexture2D;
        this.setTexture2DArray = setTexture2DArray;
        this.setTexture3D = setTexture3D;
        this.setTextureCube = setTextureCube;
        this.setTextureCubeDynamic = setTextureCubeDynamic;
        this.setupRenderTarget = setupRenderTarget;
        this.updateRenderTargetMipmap = updateRenderTargetMipmap;
        this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    
        this.safeSetTexture2D = safeSetTexture2D;
        this.safeSetTextureCube = safeSetTextureCube;
    
    }
    
    /**
     * @author thespite / http://www.twitter.com/thespite
     */
    
    function WebGLUtils( gl, extensions, capabilities ) {
    
        var isWebGL2 = capabilities.isWebGL2;
    
        function convert( p ) {
    
            var extension;
    
            if ( p === UnsignedByteType ) return 5121;
            if ( p === UnsignedShort4444Type ) return 32819;
            if ( p === UnsignedShort5551Type ) return 32820;
            if ( p === UnsignedShort565Type ) return 33635;
    
            if ( p === ByteType ) return 5120;
            if ( p === ShortType ) return 5122;
            if ( p === UnsignedShortType ) return 5123;
            if ( p === IntType ) return 5124;
            if ( p === UnsignedIntType ) return 5125;
            if ( p === FloatType ) return 5126;
    
            if ( p === HalfFloatType ) {
    
                if ( isWebGL2 ) return 5131;
    
                extension = extensions.get( 'OES_texture_half_float' );
    
                if ( extension !== null ) {
    
                    return extension.HALF_FLOAT_OES;
    
                } else {
    
                    return null;
    
                }
    
            }
    
            if ( p === AlphaFormat ) return 6406;
            if ( p === RGBFormat ) return 6407;
            if ( p === RGBAFormat ) return 6408;
            if ( p === LuminanceFormat ) return 6409;
            if ( p === LuminanceAlphaFormat ) return 6410;
            if ( p === DepthFormat ) return 6402;
            if ( p === DepthStencilFormat ) return 34041;
            if ( p === RedFormat ) return 6403;
    
            // WebGL2 formats.
    
            if ( p === RedIntegerFormat ) return 36244;
            if ( p === RGFormat ) return 33319;
            if ( p === RGIntegerFormat ) return 33320;
            if ( p === RGBIntegerFormat ) return 36248;
            if ( p === RGBAIntegerFormat ) return 36249;
    
            if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
                p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {
    
                extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
    
                if ( extension !== null ) {
    
                    if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    
                } else {
    
                    return null;
    
                }
    
            }
    
            if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
                p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {
    
                extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
    
                if ( extension !== null ) {
    
                    if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    
                } else {
    
                    return null;
    
                }
    
            }
    
            if ( p === RGB_ETC1_Format ) {
    
                extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
    
                if ( extension !== null ) {
    
                    return extension.COMPRESSED_RGB_ETC1_WEBGL;
    
                } else {
    
                    return null;
    
                }
    
            }
    
            if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {
    
                extension = extensions.get( 'WEBGL_compressed_texture_etc' );
    
                if ( extension !== null ) {
    
                    if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
                    if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;
    
                }
    
            }
    
            if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
                p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
                p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
                p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
                p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
                p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
                p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
                p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
                p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
                p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {
    
                extension = extensions.get( 'WEBGL_compressed_texture_astc' );
    
                if ( extension !== null ) {
    
                    // TODO Complete?
    
                    return p;
    
                } else {
    
                    return null;
    
                }
    
            }
    
            if ( p === UnsignedInt248Type ) {
    
                if ( isWebGL2 ) return 34042;
    
                extension = extensions.get( 'WEBGL_depth_texture' );
    
                if ( extension !== null ) {
    
                    return extension.UNSIGNED_INT_24_8_WEBGL;
    
                } else {
    
                    return null;
    
                }
    
            }
    
        }
    
        return { convert: convert };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function ArrayCamera( array ) {
    
        PerspectiveCamera.call( this );
    
        this.cameras = array || [];
    
    }
    
    ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {
    
        constructor: ArrayCamera,
    
        isArrayCamera: true
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function Group() {
    
        Object3D.call( this );
    
        this.type = 'Group';
    
    }
    
    Group.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: Group,
    
        isGroup: true
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function WebXRManager( renderer, gl ) {
    
        var scope = this;
    
        var session = null;
    
        var framebufferScaleFactor = 1.0;
    
        var referenceSpace = null;
        var referenceSpaceType = 'local-floor';
    
        var pose = null;
    
        var controllers = [];
        var inputSourcesMap = new Map();
    
        //
    
        var cameraL = new PerspectiveCamera();
        cameraL.layers.enable( 1 );
        cameraL.viewport = new Vector4();
    
        var cameraR = new PerspectiveCamera();
        cameraR.layers.enable( 2 );
        cameraR.viewport = new Vector4();
    
        var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
        cameraVR.layers.enable( 1 );
        cameraVR.layers.enable( 2 );
    
        var _currentDepthNear = null;
        var _currentDepthFar = null;
    
        //
    
        this.enabled = false;
    
        this.isPresenting = false;
    
        this.getController = function ( id ) {
    
            var controller = controllers[ id ];
    
            if ( controller === undefined ) {
    
                controller = {};
                controllers[ id ] = controller;
    
            }
    
            if ( controller.targetRay === undefined ) {
    
                controller.targetRay = new Group();
                controller.targetRay.matrixAutoUpdate = false;
                controller.targetRay.visible = false;
    
            }
    
            return controller.targetRay;
    
        };
    
        this.getControllerGrip = function ( id ) {
    
            var controller = controllers[ id ];
    
            if ( controller === undefined ) {
    
                controller = {};
                controllers[ id ] = controller;
    
            }
    
            if ( controller.grip === undefined ) {
    
                controller.grip = new Group();
                controller.grip.matrixAutoUpdate = false;
                controller.grip.visible = false;
    
            }
    
            return controller.grip;
    
        };
    
        //
    
        function onSessionEvent( event ) {
    
            var controller = inputSourcesMap.get( event.inputSource );
    
            if ( controller ) {
    
                if ( controller.targetRay ) {
    
                    controller.targetRay.dispatchEvent( { type: event.type } );
    
                }
    
                if ( controller.grip ) {
    
                    controller.grip.dispatchEvent( { type: event.type } );
    
                }
    
            }
    
        }
    
        function onSessionEnd() {
    
            inputSourcesMap.forEach( function ( controller, inputSource ) {
    
                if ( controller.targetRay ) {
    
                    controller.targetRay.dispatchEvent( { type: 'disconnected', data: inputSource } );
                    controller.targetRay.visible = false;
    
                }
    
                if ( controller.grip ) {
    
                    controller.grip.dispatchEvent( { type: 'disconnected', data: inputSource } );
                    controller.grip.visible = false;
    
                }
    
            } );
    
            inputSourcesMap.clear();
    
            //
    
            renderer.setFramebuffer( null );
            renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
            animation.stop();
    
            scope.isPresenting = false;
    
            scope.dispatchEvent( { type: 'sessionend' } );
    
        }
    
        function onRequestReferenceSpace( value ) {
    
            referenceSpace = value;
    
            animation.setContext( session );
            animation.start();
    
            scope.isPresenting = true;
    
            scope.dispatchEvent( { type: 'sessionstart' } );
    
        }
    
        this.setFramebufferScaleFactor = function ( value ) {
    
            framebufferScaleFactor = value;
    
            // Warn if function is used while presenting
            if ( scope.isPresenting == true ) {
    
                console.warn( "WebXRManager: Cannot change framebuffer scale while presenting VR content" );
    
            }
    
        };
    
        this.setReferenceSpaceType = function ( value ) {
    
            referenceSpaceType = value;
    
        };
    
        this.getReferenceSpace = function () {
    
            return referenceSpace;
    
        };
    
        this.getSession = function () {
    
            return session;
    
        };
    
        this.setSession = function ( value ) {
    
            session = value;
    
            if ( session !== null ) {
    
                session.addEventListener( 'select', onSessionEvent );
                session.addEventListener( 'selectstart', onSessionEvent );
                session.addEventListener( 'selectend', onSessionEvent );
                session.addEventListener( 'squeeze', onSessionEvent );
                session.addEventListener( 'squeezestart', onSessionEvent );
                session.addEventListener( 'squeezeend', onSessionEvent );
                session.addEventListener( 'end', onSessionEnd );
    
                var attributes = gl.getContextAttributes();
    
                var layerInit = {
                    antialias: attributes.antialias,
                    alpha: attributes.alpha,
                    depth: attributes.depth,
                    stencil: attributes.stencil,
                    framebufferScaleFactor: framebufferScaleFactor
                };
    
                // eslint-disable-next-line no-undef
                var baseLayer = new XRWebGLLayer( session, gl, layerInit );
    
                session.updateRenderState( { baseLayer: baseLayer } );
    
                session.requestReferenceSpace( referenceSpaceType ).then( onRequestReferenceSpace );
    
                //
    
                session.addEventListener( 'inputsourceschange', updateInputSources );
    
            }
    
        };
    
        function updateInputSources( event ) {
    
            var inputSources = session.inputSources;
    
            // Assign inputSources to available controllers
    
            for ( var i = 0; i < controllers.length; i ++ ) {
    
                inputSourcesMap.set( inputSources[ i ], controllers[ i ] );
    
            }
    
            // Notify disconnected
    
            for ( var i = 0; i < event.removed.length; i ++ ) {
    
                var inputSource = event.removed[ i ];
                var controller = inputSourcesMap.get( inputSource );
    
                if ( controller ) {
    
                    if ( controller.targetRay ) {
    
                        controller.targetRay.dispatchEvent( { type: 'disconnected', data: inputSource } );
    
                    }
    
                    if ( controller.grip ) {
    
                        controller.grip.dispatchEvent( { type: 'disconnected', data: inputSource } );
    
                    }
    
                    inputSourcesMap.delete( inputSource );
    
                }
    
            }
    
            // Notify connected
    
            for ( var i = 0; i < event.added.length; i ++ ) {
    
                var inputSource = event.added[ i ];
                var controller = inputSourcesMap.get( inputSource );
    
                if ( controller ) {
    
                    if ( controller.targetRay ) {
    
                        controller.targetRay.dispatchEvent( { type: 'connected', data: inputSource } );
    
                    }
    
                    if ( controller.grip ) {
    
                        controller.grip.dispatchEvent( { type: 'connected', data: inputSource } );
    
                    }
    
                }
    
            }
    
        }
    
        //
    
        var cameraLPos = new Vector3();
        var cameraRPos = new Vector3();
    
        /**
         * @author jsantell / https://www.jsantell.com/
         *
         * Assumes 2 cameras that are parallel and share an X-axis, and that
         * the cameras' projection and world matrices have already been set.
         * And that near and far planes are identical for both cameras.
         * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
         */
        function setProjectionFromUnion( camera, cameraL, cameraR ) {
    
            cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
            cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );
    
            var ipd = cameraLPos.distanceTo( cameraRPos );
    
            var projL = cameraL.projectionMatrix.elements;
            var projR = cameraR.projectionMatrix.elements;
    
            // VR systems will have identical far and near planes, and
            // most likely identical top and bottom frustum extents.
            // Use the left camera for these values.
            var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
            var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
            var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
            var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];
    
            var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
            var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
            var left = near * leftFov;
            var right = near * rightFov;
    
            // Calculate the new camera's position offset from the
            // left camera. xOffset should be roughly half `ipd`.
            var zOffset = ipd / ( - leftFov + rightFov );
            var xOffset = zOffset * - leftFov;
    
            // TODO: Better way to apply this offset?
            cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
            camera.translateX( xOffset );
            camera.translateZ( zOffset );
            camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
            camera.matrixWorldInverse.getInverse( camera.matrixWorld );
    
            // Find the union of the frustum values of the cameras and scale
            // the values so that the near plane's position does not change in world space,
            // although must now be relative to the new union camera.
            var near2 = near + zOffset;
            var far2 = far + zOffset;
            var left2 = left - xOffset;
            var right2 = right + ( ipd - xOffset );
            var top2 = topFov * far / far2 * near2;
            var bottom2 = bottomFov * far / far2 * near2;
    
            camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
    
        }
    
        function updateCamera( camera, parent ) {
    
            if ( parent === null ) {
    
                camera.matrixWorld.copy( camera.matrix );
    
            } else {
    
                camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );
    
            }
    
            camera.matrixWorldInverse.getInverse( camera.matrixWorld );
    
        }
    
        this.getCamera = function ( camera ) {
    
            cameraVR.near = cameraR.near = cameraL.near = camera.near;
            cameraVR.far = cameraR.far = cameraL.far = camera.far;
    
            if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {
    
                // Note that the new renderState won't apply until the next frame. See #18320
    
                session.updateRenderState( {
                    depthNear: cameraVR.near,
                    depthFar: cameraVR.far
                } );
    
                _currentDepthNear = cameraVR.near;
                _currentDepthFar = cameraVR.far;
    
            }
    
            var parent = camera.parent;
            var cameras = cameraVR.cameras;
    
            updateCamera( cameraVR, parent );
    
            for ( var i = 0; i < cameras.length; i ++ ) {
    
                updateCamera( cameras[ i ], parent );
    
            }
    
            // update camera and its children
    
            camera.matrixWorld.copy( cameraVR.matrixWorld );
    
            var children = camera.children;
    
            for ( var i = 0, l = children.length; i < l; i ++ ) {
    
                children[ i ].updateMatrixWorld( true );
    
            }
    
            setProjectionFromUnion( cameraVR, cameraL, cameraR );
    
            return cameraVR;
    
        };
    
        // Animation Loop
    
        var onAnimationFrameCallback = null;
    
        function onAnimationFrame( time, frame ) {
    
            pose = frame.getViewerPose( referenceSpace );
    
            if ( pose !== null ) {
    
                var views = pose.views;
                var baseLayer = session.renderState.baseLayer;
    
                renderer.setFramebuffer( baseLayer.framebuffer );
    
                for ( var i = 0; i < views.length; i ++ ) {
    
                    var view = views[ i ];
                    var viewport = baseLayer.getViewport( view );
    
                    var camera = cameraVR.cameras[ i ];
                    camera.matrix.fromArray( view.transform.matrix );
                    camera.projectionMatrix.fromArray( view.projectionMatrix );
                    camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );
    
                    if ( i === 0 ) {
    
                        cameraVR.matrix.copy( camera.matrix );
    
                    }
    
                }
    
            }
    
            //
    
            var inputSources = session.inputSources;
    
            for ( var i = 0; i < controllers.length; i ++ ) {
    
                var controller = controllers[ i ];
    
                var inputSource = inputSources[ i ];
    
                var inputPose = null;
                var gripPose = null;
    
                if ( inputSource ) {
    
                    if ( controller.targetRay ) {
    
                        inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );
    
                        if ( inputPose !== null ) {
    
                            controller.targetRay.matrix.fromArray( inputPose.transform.matrix );
                            controller.targetRay.matrix.decompose( controller.targetRay.position, controller.targetRay.rotation, controller.targetRay.scale );
    
                        }
    
                    }
    
                    if ( controller.grip && inputSource.gripSpace ) {
    
                        gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );
    
                        if ( gripPose !== null ) {
    
                            controller.grip.matrix.fromArray( gripPose.transform.matrix );
                            controller.grip.matrix.decompose( controller.grip.position, controller.grip.rotation, controller.grip.scale );
    
                        }
    
                    }
    
                }
    
                if ( controller.targetRay ) {
    
                    controller.targetRay.visible = inputPose !== null;
    
                }
    
                if ( controller.grip ) {
    
                    controller.grip.visible = gripPose !== null;
    
                }
    
            }
    
            if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );
    
        }
    
        var animation = new WebGLAnimation();
        animation.setAnimationLoop( onAnimationFrame );
    
        this.setAnimationLoop = function ( callback ) {
    
            onAnimationFrameCallback = callback;
    
        };
    
        this.dispose = function () {};
    
    }
    
    Object.assign( WebXRManager.prototype, EventDispatcher.prototype );
    
    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     * @author tschw
     */
    
    function WebGLRenderer( parameters ) {
    
        parameters = parameters || {};
    
        var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
            _context = parameters.context !== undefined ? parameters.context : null,
    
            _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
            _depth = parameters.depth !== undefined ? parameters.depth : true,
            _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
            _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
            _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
            _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
            _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
            _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
    
        var currentRenderList = null;
        var currentRenderState = null;
    
        // public properties
    
        this.domElement = _canvas;
    
        // Debug configuration container
        this.debug = {
    
            /**
             * Enables error checking and reporting when shader programs are being compiled
             * @type {boolean}
             */
            checkShaderErrors: true
        };
    
        // clearing
    
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
    
        // scene graph
    
        this.sortObjects = true;
    
        // user-defined clipping
    
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
    
        // physically based shading
    
        this.gammaFactor = 2.0;	// for backwards compatibility
        this.outputEncoding = LinearEncoding;
    
        // physical lights
    
        this.physicallyCorrectLights = false;
    
        // tone mapping
    
        this.toneMapping = LinearToneMapping;
        this.toneMappingExposure = 1.0;
        this.toneMappingWhitePoint = 1.0;
    
        // morphs
    
        this.maxMorphTargets = 8;
        this.maxMorphNormals = 4;
    
        // internal properties
    
        var _this = this,
    
            _isContextLost = false,
    
            // internal state cache
    
            _framebuffer = null,
    
            _currentActiveCubeFace = 0,
            _currentActiveMipmapLevel = 0,
            _currentRenderTarget = null,
            _currentFramebuffer = null,
            _currentMaterialId = - 1,
    
            // geometry and program caching
    
            _currentGeometryProgram = {
                geometry: null,
                program: null,
                wireframe: false
            },
    
            _currentCamera = null,
            _currentArrayCamera = null,
    
            _currentViewport = new Vector4(),
            _currentScissor = new Vector4(),
            _currentScissorTest = null,
    
            //
    
            _width = _canvas.width,
            _height = _canvas.height,
    
            _pixelRatio = 1,
            _opaqueSort = null,
            _transparentSort = null,
    
            _viewport = new Vector4( 0, 0, _width, _height ),
            _scissor = new Vector4( 0, 0, _width, _height ),
            _scissorTest = false,
    
            // frustum
    
            _frustum = new Frustum(),
    
            // clipping
    
            _clipping = new WebGLClipping(),
            _clippingEnabled = false,
            _localClippingEnabled = false,
    
            // camera matrices cache
    
            _projScreenMatrix = new Matrix4(),
    
            _vector3 = new Vector3();
    
        function getTargetPixelRatio() {
    
            return _currentRenderTarget === null ? _pixelRatio : 1;
    
        }
    
        // initialize
    
        var _gl;
    
        try {
    
            var contextAttributes = {
                alpha: _alpha,
                depth: _depth,
                stencil: _stencil,
                antialias: _antialias,
                premultipliedAlpha: _premultipliedAlpha,
                preserveDrawingBuffer: _preserveDrawingBuffer,
                powerPreference: _powerPreference,
                failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
                xrCompatible: true
            };
    
            // event listeners must be registered before WebGL context is created, see #12753
    
            _canvas.addEventListener( 'webglcontextlost', onContextLost, false );
            _canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
    
            _gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );
    
            if ( _gl === null ) {
    
                if ( _canvas.getContext( 'webgl' ) !== null ) {
    
                    throw new Error( 'Error creating WebGL context with your selected attributes.' );
    
                } else {
    
                    throw new Error( 'Error creating WebGL context.' );
    
                }
    
            }
    
            // Some experimental-webgl implementations do not have getShaderPrecisionFormat
    
            if ( _gl.getShaderPrecisionFormat === undefined ) {
    
                _gl.getShaderPrecisionFormat = function () {
    
                    return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
    
                };
    
            }
    
        } catch ( error ) {
    
            console.error( 'THREE.WebGLRenderer: ' + error.message );
            throw error;
    
        }
    
        var extensions, capabilities, state, info;
        var properties, textures, attributes, geometries, objects;
        var programCache, renderLists, renderStates;
    
        var background, morphtargets, bufferRenderer, indexedBufferRenderer;
    
        var utils;
    
        function initGLContext() {
    
            extensions = new WebGLExtensions( _gl );
    
            capabilities = new WebGLCapabilities( _gl, extensions, parameters );
    
            if ( capabilities.isWebGL2 === false ) {
    
                extensions.get( 'WEBGL_depth_texture' );
                extensions.get( 'OES_texture_float' );
                extensions.get( 'OES_texture_half_float' );
                extensions.get( 'OES_texture_half_float_linear' );
                extensions.get( 'OES_standard_derivatives' );
                extensions.get( 'OES_element_index_uint' );
                extensions.get( 'ANGLE_instanced_arrays' );
    
            }
    
            extensions.get( 'OES_texture_float_linear' );
    
            utils = new WebGLUtils( _gl, extensions, capabilities );
    
            state = new WebGLState( _gl, extensions, capabilities );
            state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );
            state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );
    
            info = new WebGLInfo( _gl );
            properties = new WebGLProperties();
            textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
            attributes = new WebGLAttributes( _gl, capabilities );
            geometries = new WebGLGeometries( _gl, attributes, info );
            objects = new WebGLObjects( _gl, geometries, attributes, info );
            morphtargets = new WebGLMorphtargets( _gl );
            programCache = new WebGLPrograms( _this, extensions, capabilities );
            renderLists = new WebGLRenderLists();
            renderStates = new WebGLRenderStates();
    
            background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );
    
            bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
            indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );
    
            info.programs = programCache.programs;
    
            _this.capabilities = capabilities;
            _this.extensions = extensions;
            _this.properties = properties;
            _this.renderLists = renderLists;
            _this.state = state;
            _this.info = info;
    
        }
    
        initGLContext();
    
        // xr
    
        var xr = new WebXRManager( _this, _gl );
    
        this.xr = xr;
    
        // shadow map
    
        var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );
    
        this.shadowMap = shadowMap;
    
        // API
    
        this.getContext = function () {
    
            return _gl;
    
        };
    
        this.getContextAttributes = function () {
    
            return _gl.getContextAttributes();
    
        };
    
        this.forceContextLoss = function () {
    
            var extension = extensions.get( 'WEBGL_lose_context' );
            if ( extension ) extension.loseContext();
    
        };
    
        this.forceContextRestore = function () {
    
            var extension = extensions.get( 'WEBGL_lose_context' );
            if ( extension ) extension.restoreContext();
    
        };
    
        this.getPixelRatio = function () {
    
            return _pixelRatio;
    
        };
    
        this.setPixelRatio = function ( value ) {
    
            if ( value === undefined ) return;
    
            _pixelRatio = value;
    
            this.setSize( _width, _height, false );
    
        };
    
        this.getSize = function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );
    
                target = new Vector2();
    
            }
    
            return target.set( _width, _height );
    
        };
    
        this.setSize = function ( width, height, updateStyle ) {
    
            if ( xr.isPresenting ) {
    
                console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
                return;
    
            }
    
            _width = width;
            _height = height;
    
            _canvas.width = Math.floor( width * _pixelRatio );
            _canvas.height = Math.floor( height * _pixelRatio );
    
            if ( updateStyle !== false ) {
    
                _canvas.style.width = width + 'px';
                _canvas.style.height = height + 'px';
    
            }
    
            this.setViewport( 0, 0, width, height );
    
        };
    
        this.getDrawingBufferSize = function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );
    
                target = new Vector2();
    
            }
    
            return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();
    
        };
    
        this.setDrawingBufferSize = function ( width, height, pixelRatio ) {
    
            _width = width;
            _height = height;
    
            _pixelRatio = pixelRatio;
    
            _canvas.width = Math.floor( width * pixelRatio );
            _canvas.height = Math.floor( height * pixelRatio );
    
            this.setViewport( 0, 0, width, height );
    
        };
    
        this.getCurrentViewport = function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );
    
                target = new Vector4();
    
            }
    
            return target.copy( _currentViewport );
    
        };
    
        this.getViewport = function ( target ) {
    
            return target.copy( _viewport );
    
        };
    
        this.setViewport = function ( x, y, width, height ) {
    
            if ( x.isVector4 ) {
    
                _viewport.set( x.x, x.y, x.z, x.w );
    
            } else {
    
                _viewport.set( x, y, width, height );
    
            }
    
            state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );
    
        };
    
        this.getScissor = function ( target ) {
    
            return target.copy( _scissor );
    
        };
    
        this.setScissor = function ( x, y, width, height ) {
    
            if ( x.isVector4 ) {
    
                _scissor.set( x.x, x.y, x.z, x.w );
    
            } else {
    
                _scissor.set( x, y, width, height );
    
            }
    
            state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );
    
        };
    
        this.getScissorTest = function () {
    
            return _scissorTest;
    
        };
    
        this.setScissorTest = function ( boolean ) {
    
            state.setScissorTest( _scissorTest = boolean );
    
        };
    
        this.setOpaqueSort = function ( method ) {
    
            _opaqueSort = method;
    
        };
    
        this.setTransparentSort = function ( method ) {
    
            _transparentSort = method;
    
        };
    
        // Clearing
    
        this.getClearColor = function () {
    
            return background.getClearColor();
    
        };
    
        this.setClearColor = function () {
    
            background.setClearColor.apply( background, arguments );
    
        };
    
        this.getClearAlpha = function () {
    
            return background.getClearAlpha();
    
        };
    
        this.setClearAlpha = function () {
    
            background.setClearAlpha.apply( background, arguments );
    
        };
    
        this.clear = function ( color, depth, stencil ) {
    
            var bits = 0;
    
            if ( color === undefined || color ) bits |= 16384;
            if ( depth === undefined || depth ) bits |= 256;
            if ( stencil === undefined || stencil ) bits |= 1024;
    
            _gl.clear( bits );
    
        };
    
        this.clearColor = function () {
    
            this.clear( true, false, false );
    
        };
    
        this.clearDepth = function () {
    
            this.clear( false, true, false );
    
        };
    
        this.clearStencil = function () {
    
            this.clear( false, false, true );
    
        };
    
        //
    
        this.dispose = function () {
    
            _canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
            _canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
    
            renderLists.dispose();
            renderStates.dispose();
            properties.dispose();
            objects.dispose();
    
            xr.dispose();
    
            animation.stop();
    
        };
    
        // Events
    
        function onContextLost( event ) {
    
            event.preventDefault();
    
            console.log( 'THREE.WebGLRenderer: Context Lost.' );
    
            _isContextLost = true;
    
        }
    
        function onContextRestore( /* event */ ) {
    
            console.log( 'THREE.WebGLRenderer: Context Restored.' );
    
            _isContextLost = false;
    
            initGLContext();
    
        }
    
        function onMaterialDispose( event ) {
    
            var material = event.target;
    
            material.removeEventListener( 'dispose', onMaterialDispose );
    
            deallocateMaterial( material );
    
        }
    
        // Buffer deallocation
    
        function deallocateMaterial( material ) {
    
            releaseMaterialProgramReference( material );
    
            properties.remove( material );
    
        }
    
    
        function releaseMaterialProgramReference( material ) {
    
            var programInfo = properties.get( material ).program;
    
            material.program = undefined;
    
            if ( programInfo !== undefined ) {
    
                programCache.releaseProgram( programInfo );
    
            }
    
        }
    
        // Buffer rendering
    
        function renderObjectImmediate( object, program ) {
    
            object.render( function ( object ) {
    
                _this.renderBufferImmediate( object, program );
    
            } );
    
        }
    
        this.renderBufferImmediate = function ( object, program ) {
    
            state.initAttributes();
    
            var buffers = properties.get( object );
    
            if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
            if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
            if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
            if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();
    
            var programAttributes = program.getAttributes();
    
            if ( object.hasPositions ) {
    
                _gl.bindBuffer( 34962, buffers.position );
                _gl.bufferData( 34962, object.positionArray, 35048 );
    
                state.enableAttribute( programAttributes.position );
                _gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );
    
            }
    
            if ( object.hasNormals ) {
    
                _gl.bindBuffer( 34962, buffers.normal );
                _gl.bufferData( 34962, object.normalArray, 35048 );
    
                state.enableAttribute( programAttributes.normal );
                _gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );
    
            }
    
            if ( object.hasUvs ) {
    
                _gl.bindBuffer( 34962, buffers.uv );
                _gl.bufferData( 34962, object.uvArray, 35048 );
    
                state.enableAttribute( programAttributes.uv );
                _gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );
    
            }
    
            if ( object.hasColors ) {
    
                _gl.bindBuffer( 34962, buffers.color );
                _gl.bufferData( 34962, object.colorArray, 35048 );
    
                state.enableAttribute( programAttributes.color );
                _gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );
    
            }
    
            state.disableUnusedAttributes();
    
            _gl.drawArrays( 4, 0, object.count );
    
            object.count = 0;
    
        };
    
        var tempScene = new Scene();
    
        this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {
    
            if ( scene === null ) scene = tempScene; // renderBufferDirect second parameter used to be fog (could be null)
    
            var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );
    
            var program = setProgram( camera, scene, material, object );
    
            state.setMaterial( material, frontFaceCW );
    
            var updateBuffers = false;
    
            if ( _currentGeometryProgram.geometry !== geometry.id ||
                _currentGeometryProgram.program !== program.id ||
                _currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {
    
                _currentGeometryProgram.geometry = geometry.id;
                _currentGeometryProgram.program = program.id;
                _currentGeometryProgram.wireframe = material.wireframe === true;
                updateBuffers = true;
    
            }
    
            if ( material.morphTargets || material.morphNormals ) {
    
                morphtargets.update( object, geometry, material, program );
    
                updateBuffers = true;
    
            }
    
            //
    
            var index = geometry.index;
            var position = geometry.attributes.position;
    
            //
    
            if ( index === null ) {
    
                if ( position === undefined || position.count === 0 ) return;
    
            } else if ( index.count === 0 ) {
    
                return;
    
            }
    
            //
    
            var rangeFactor = 1;
    
            if ( material.wireframe === true ) {
    
                index = geometries.getWireframeAttribute( geometry );
                rangeFactor = 2;
    
            }
    
            var attribute;
            var renderer = bufferRenderer;
    
            if ( index !== null ) {
    
                attribute = attributes.get( index );
    
                renderer = indexedBufferRenderer;
                renderer.setIndex( attribute );
    
            }
    
            if ( updateBuffers ) {
    
                setupVertexAttributes( object, geometry, material, program );
    
                if ( index !== null ) {
    
                    _gl.bindBuffer( 34963, attribute.buffer );
    
                }
    
            }
    
            //
    
            var dataCount = ( index !== null ) ? index.count : position.count;
    
            var rangeStart = geometry.drawRange.start * rangeFactor;
            var rangeCount = geometry.drawRange.count * rangeFactor;
    
            var groupStart = group !== null ? group.start * rangeFactor : 0;
            var groupCount = group !== null ? group.count * rangeFactor : Infinity;
    
            var drawStart = Math.max( rangeStart, groupStart );
            var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
    
            var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
    
            if ( drawCount === 0 ) return;
    
            //
    
            if ( object.isMesh ) {
    
                if ( material.wireframe === true ) {
    
                    state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
                    renderer.setMode( 1 );
    
                } else {
    
                    renderer.setMode( 4 );
    
                }
    
            } else if ( object.isLine ) {
    
                var lineWidth = material.linewidth;
    
                if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
    
                state.setLineWidth( lineWidth * getTargetPixelRatio() );
    
                if ( object.isLineSegments ) {
    
                    renderer.setMode( 1 );
    
                } else if ( object.isLineLoop ) {
    
                    renderer.setMode( 2 );
    
                } else {
    
                    renderer.setMode( 3 );
    
                }
    
            } else if ( object.isPoints ) {
    
                renderer.setMode( 0 );
    
            } else if ( object.isSprite ) {
    
                renderer.setMode( 4 );
    
            }
    
            if ( object.isInstancedMesh ) {
    
                renderer.renderInstances( geometry, drawStart, drawCount, object.count );
    
            } else if ( geometry.isInstancedBufferGeometry ) {
    
                renderer.renderInstances( geometry, drawStart, drawCount, geometry.maxInstancedCount );
    
            } else {
    
                renderer.render( drawStart, drawCount );
    
            }
    
        };
    
        function setupVertexAttributes( object, geometry, material, program ) {
    
            if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {
    
                if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;
    
            }
    
            state.initAttributes();
    
            var geometryAttributes = geometry.attributes;
    
            var programAttributes = program.getAttributes();
    
            var materialDefaultAttributeValues = material.defaultAttributeValues;
    
            for ( var name in programAttributes ) {
    
                var programAttribute = programAttributes[ name ];
    
                if ( programAttribute >= 0 ) {
    
                    var geometryAttribute = geometryAttributes[ name ];
    
                    if ( geometryAttribute !== undefined ) {
    
                        var normalized = geometryAttribute.normalized;
                        var size = geometryAttribute.itemSize;
    
                        var attribute = attributes.get( geometryAttribute );
    
                        // TODO Attribute may not be available on context restore
    
                        if ( attribute === undefined ) continue;
    
                        var buffer = attribute.buffer;
                        var type = attribute.type;
                        var bytesPerElement = attribute.bytesPerElement;
    
                        if ( geometryAttribute.isInterleavedBufferAttribute ) {
    
                            var data = geometryAttribute.data;
                            var stride = data.stride;
                            var offset = geometryAttribute.offset;
    
                            if ( data && data.isInstancedInterleavedBuffer ) {
    
                                state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );
    
                                if ( geometry.maxInstancedCount === undefined ) {
    
                                    geometry.maxInstancedCount = data.meshPerAttribute * data.count;
    
                                }
    
                            } else {
    
                                state.enableAttribute( programAttribute );
    
                            }
    
                            _gl.bindBuffer( 34962, buffer );
                            _gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );
    
                        } else {
    
                            if ( geometryAttribute.isInstancedBufferAttribute ) {
    
                                state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );
    
                                if ( geometry.maxInstancedCount === undefined ) {
    
                                    geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
    
                                }
    
                            } else {
    
                                state.enableAttribute( programAttribute );
    
                            }
    
                            _gl.bindBuffer( 34962, buffer );
                            _gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );
    
                        }
    
                    } else if ( name === 'instanceMatrix' ) {
    
                        var attribute = attributes.get( object.instanceMatrix );
    
                        // TODO Attribute may not be available on context restore
    
                        if ( attribute === undefined ) continue;
    
                        var buffer = attribute.buffer;
                        var type = attribute.type;
    
                        state.enableAttributeAndDivisor( programAttribute + 0, 1 );
                        state.enableAttributeAndDivisor( programAttribute + 1, 1 );
                        state.enableAttributeAndDivisor( programAttribute + 2, 1 );
                        state.enableAttributeAndDivisor( programAttribute + 3, 1 );
    
                        _gl.bindBuffer( 34962, buffer );
    
                        _gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
                        _gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
                        _gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
                        _gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );
    
                    } else if ( materialDefaultAttributeValues !== undefined ) {
    
                        var value = materialDefaultAttributeValues[ name ];
    
                        if ( value !== undefined ) {
    
                            switch ( value.length ) {
    
                                case 2:
                                    _gl.vertexAttrib2fv( programAttribute, value );
                                    break;
    
                                case 3:
                                    _gl.vertexAttrib3fv( programAttribute, value );
                                    break;
    
                                case 4:
                                    _gl.vertexAttrib4fv( programAttribute, value );
                                    break;
    
                                default:
                                    _gl.vertexAttrib1fv( programAttribute, value );
    
                            }
    
                        }
    
                    }
    
                }
    
            }
    
            state.disableUnusedAttributes();
    
        }
    
        // Compile
    
        this.compile = function ( scene, camera ) {
    
            currentRenderState = renderStates.get( scene, camera );
            currentRenderState.init();
    
            scene.traverse( function ( object ) {
    
                if ( object.isLight ) {
    
                    currentRenderState.pushLight( object );
    
                    if ( object.castShadow ) {
    
                        currentRenderState.pushShadow( object );
    
                    }
    
                }
    
            } );
    
            currentRenderState.setupLights( camera );
    
            var compiled = {};
    
            scene.traverse( function ( object ) {
    
                if ( object.material ) {
    
                    if ( Array.isArray( object.material ) ) {
    
                        for ( var i = 0; i < object.material.length; i ++ ) {
    
                            if ( object.material[ i ].uuid in compiled === false ) {
    
                                initMaterial( object.material[ i ], scene, object );
                                compiled[ object.material[ i ].uuid ] = true;
    
                            }
    
                        }
    
                    } else if ( object.material.uuid in compiled === false ) {
    
                        initMaterial( object.material, scene, object );
                        compiled[ object.material.uuid ] = true;
    
                    }
    
                }
    
            } );
    
        };
    
        // Animation Loop
    
        var onAnimationFrameCallback = null;
    
        function onAnimationFrame( time ) {
    
            if ( xr.isPresenting ) return;
            if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );
    
        }
    
        var animation = new WebGLAnimation();
        animation.setAnimationLoop( onAnimationFrame );
    
        if ( typeof window !== 'undefined' ) animation.setContext( window );
    
        this.setAnimationLoop = function ( callback ) {
    
            onAnimationFrameCallback = callback;
            xr.setAnimationLoop( callback );
    
            animation.start();
    
        };
    
        // Rendering
    
        this.render = function ( scene, camera ) {
    
            var renderTarget, forceClear;
    
            if ( arguments[ 2 ] !== undefined ) {
    
                console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
                renderTarget = arguments[ 2 ];
    
            }
    
            if ( arguments[ 3 ] !== undefined ) {
    
                console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
                forceClear = arguments[ 3 ];
    
            }
    
            if ( ! ( camera && camera.isCamera ) ) {
    
                console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
                return;
    
            }
    
            if ( _isContextLost ) return;
    
            // reset caching for this frame
    
            _currentGeometryProgram.geometry = null;
            _currentGeometryProgram.program = null;
            _currentGeometryProgram.wireframe = false;
            _currentMaterialId = - 1;
            _currentCamera = null;
    
            // update scene graph
    
            if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
    
            // update camera matrices and frustum
    
            if ( camera.parent === null ) camera.updateMatrixWorld();
    
            if ( xr.enabled && xr.isPresenting ) {
    
                camera = xr.getCamera( camera );
    
            }
    
            //
    
            currentRenderState = renderStates.get( scene, camera );
            currentRenderState.init();
    
            scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );
    
            _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
            _frustum.setFromProjectionMatrix( _projScreenMatrix );
    
            _localClippingEnabled = this.localClippingEnabled;
            _clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );
    
            currentRenderList = renderLists.get( scene, camera );
            currentRenderList.init();
    
            projectObject( scene, camera, 0, _this.sortObjects );
    
            currentRenderList.finish();
    
            if ( _this.sortObjects === true ) {
    
                currentRenderList.sort( _opaqueSort, _transparentSort );
    
            }
    
            //
    
            if ( _clippingEnabled ) _clipping.beginShadows();
    
            var shadowsArray = currentRenderState.state.shadowsArray;
    
            shadowMap.render( shadowsArray, scene, camera );
    
            currentRenderState.setupLights( camera );
    
            if ( _clippingEnabled ) _clipping.endShadows();
    
            //
    
            if ( this.info.autoReset ) this.info.reset();
    
            if ( renderTarget !== undefined ) {
    
                this.setRenderTarget( renderTarget );
    
            }
    
            //
    
            background.render( currentRenderList, scene, camera, forceClear );
    
            // render scene
    
            var opaqueObjects = currentRenderList.opaque;
            var transparentObjects = currentRenderList.transparent;
    
            if ( scene.overrideMaterial ) {
    
                var overrideMaterial = scene.overrideMaterial;
    
                if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
                if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );
    
            } else {
    
                // opaque pass (front-to-back order)
    
                if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );
    
                // transparent pass (back-to-front order)
    
                if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );
    
            }
    
            //
    
            scene.onAfterRender( _this, scene, camera );
    
            //
    
            if ( _currentRenderTarget !== null ) {
    
                // Generate mipmap if we're using any kind of mipmap filtering
    
                textures.updateRenderTargetMipmap( _currentRenderTarget );
    
                // resolve multisample renderbuffers to a single-sample texture if necessary
    
                textures.updateMultisampleRenderTarget( _currentRenderTarget );
    
            }
    
            // Ensure depth buffer writing is enabled so it can be cleared on next render
    
            state.buffers.depth.setTest( true );
            state.buffers.depth.setMask( true );
            state.buffers.color.setMask( true );
    
            state.setPolygonOffset( false );
    
            // _gl.finish();
    
            currentRenderList = null;
            currentRenderState = null;
    
        };
    
        function projectObject( object, camera, groupOrder, sortObjects ) {
    
            if ( object.visible === false ) return;
    
            var visible = object.layers.test( camera.layers );
    
            if ( visible ) {
    
                if ( object.isGroup ) {
    
                    groupOrder = object.renderOrder;
    
                } else if ( object.isLOD ) {
    
                    if ( object.autoUpdate === true ) object.update( camera );
    
                } else if ( object.isLight ) {
    
                    currentRenderState.pushLight( object );
    
                    if ( object.castShadow ) {
    
                        currentRenderState.pushShadow( object );
    
                    }
    
                } else if ( object.isSprite ) {
    
                    if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {
    
                        if ( sortObjects ) {
    
                            _vector3.setFromMatrixPosition( object.matrixWorld )
                                .applyMatrix4( _projScreenMatrix );
    
                        }
    
                        var geometry = objects.update( object );
                        var material = object.material;
    
                        if ( material.visible ) {
    
                            currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );
    
                        }
    
                    }
    
                } else if ( object.isImmediateRenderObject ) {
    
                    if ( sortObjects ) {
    
                        _vector3.setFromMatrixPosition( object.matrixWorld )
                            .applyMatrix4( _projScreenMatrix );
    
                    }
    
                    currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );
    
                } else if ( object.isMesh || object.isLine || object.isPoints ) {
    
                    if ( object.isSkinnedMesh ) {
    
                        // update skeleton only once in a frame
    
                        if ( object.skeleton.frame !== info.render.frame ) {
    
                            object.skeleton.update();
                            object.skeleton.frame = info.render.frame;
    
                        }
    
                    }
    
                    if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {
    
                        if ( sortObjects ) {
    
                            _vector3.setFromMatrixPosition( object.matrixWorld )
                                .applyMatrix4( _projScreenMatrix );
    
                        }
    
                        var geometry = objects.update( object );
                        var material = object.material;
    
                        if ( Array.isArray( material ) ) {
    
                            var groups = geometry.groups;
    
                            for ( var i = 0, l = groups.length; i < l; i ++ ) {
    
                                var group = groups[ i ];
                                var groupMaterial = material[ group.materialIndex ];
    
                                if ( groupMaterial && groupMaterial.visible ) {
    
                                    currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );
    
                                }
    
                            }
    
                        } else if ( material.visible ) {
    
                            currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );
    
                        }
    
                    }
    
                }
    
            }
    
            var children = object.children;
    
            for ( var i = 0, l = children.length; i < l; i ++ ) {
    
                projectObject( children[ i ], camera, groupOrder, sortObjects );
    
            }
    
        }
    
        function renderObjects( renderList, scene, camera, overrideMaterial ) {
    
            for ( var i = 0, l = renderList.length; i < l; i ++ ) {
    
                var renderItem = renderList[ i ];
    
                var object = renderItem.object;
                var geometry = renderItem.geometry;
                var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
                var group = renderItem.group;
    
                if ( camera.isArrayCamera ) {
    
                    _currentArrayCamera = camera;
    
                    var cameras = camera.cameras;
    
                    for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {
    
                        var camera2 = cameras[ j ];
    
                        if ( object.layers.test( camera2.layers ) ) {
    
                            state.viewport( _currentViewport.copy( camera2.viewport ) );
    
                            currentRenderState.setupLights( camera2 );
    
                            renderObject( object, scene, camera2, geometry, material, group );
    
                        }
    
                    }
    
                } else {
    
                    _currentArrayCamera = null;
    
                    renderObject( object, scene, camera, geometry, material, group );
    
                }
    
            }
    
        }
    
        function renderObject( object, scene, camera, geometry, material, group ) {
    
            object.onBeforeRender( _this, scene, camera, geometry, material, group );
            currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );
    
            object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
            object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
    
            if ( object.isImmediateRenderObject ) {
    
                var program = setProgram( camera, scene, material, object );
    
                state.setMaterial( material );
    
                _currentGeometryProgram.geometry = null;
                _currentGeometryProgram.program = null;
                _currentGeometryProgram.wireframe = false;
    
                renderObjectImmediate( object, program );
    
            } else {
    
                _this.renderBufferDirect( camera, scene, geometry, material, object, group );
    
            }
    
            object.onAfterRender( _this, scene, camera, geometry, material, group );
            currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );
    
        }
    
        function initMaterial( material, scene, object ) {
    
            var materialProperties = properties.get( material );
    
            var lights = currentRenderState.state.lights;
            var shadowsArray = currentRenderState.state.shadowsArray;
    
            var lightsStateVersion = lights.state.version;
    
            var parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object );
            var programCacheKey = programCache.getProgramCacheKey( parameters );
    
            var program = materialProperties.program;
            var programChange = true;
    
            if ( program === undefined ) {
    
                // new material
                material.addEventListener( 'dispose', onMaterialDispose );
    
            } else if ( program.cacheKey !== programCacheKey ) {
    
                // changed glsl or parameters
                releaseMaterialProgramReference( material );
    
            } else if ( materialProperties.lightsStateVersion !== lightsStateVersion ) {
    
                materialProperties.lightsStateVersion = lightsStateVersion;
    
                programChange = false;
    
            } else if ( parameters.shaderID !== undefined ) {
    
                // same glsl and uniform list
                return;
    
            } else {
    
                // only rebuild uniform list
                programChange = false;
    
            }
    
            if ( programChange ) {
    
                program = programCache.acquireProgram( parameters, programCacheKey );
    
                materialProperties.program = program;
                materialProperties.uniforms = parameters.uniforms;
                materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
                materialProperties.outputEncoding = _this.outputEncoding;
                material.program = program;
    
            }
    
            var programAttributes = program.getAttributes();
    
            if ( material.morphTargets ) {
    
                material.numSupportedMorphTargets = 0;
    
                for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
    
                    if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {
    
                        material.numSupportedMorphTargets ++;
    
                    }
    
                }
    
            }
    
            if ( material.morphNormals ) {
    
                material.numSupportedMorphNormals = 0;
    
                for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {
    
                    if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {
    
                        material.numSupportedMorphNormals ++;
    
                    }
    
                }
    
            }
    
            var uniforms = materialProperties.uniforms;
    
            if ( ! material.isShaderMaterial &&
                ! material.isRawShaderMaterial ||
                material.clipping === true ) {
    
                materialProperties.numClippingPlanes = _clipping.numPlanes;
                materialProperties.numIntersection = _clipping.numIntersection;
                uniforms.clippingPlanes = _clipping.uniform;
    
            }
    
            materialProperties.fog = scene.fog;
    
            // store the light setup it was created for
    
            materialProperties.needsLights = materialNeedsLights( material );
            materialProperties.lightsStateVersion = lightsStateVersion;
    
            if ( materialProperties.needsLights ) {
    
                // wire up the material to this renderer's lighting state
    
                uniforms.ambientLightColor.value = lights.state.ambient;
                uniforms.lightProbe.value = lights.state.probe;
                uniforms.directionalLights.value = lights.state.directional;
                uniforms.directionalLightShadows.value = lights.state.directionalShadow;
                uniforms.spotLights.value = lights.state.spot;
                uniforms.spotLightShadows.value = lights.state.spotShadow;
                uniforms.rectAreaLights.value = lights.state.rectArea;
                uniforms.pointLights.value = lights.state.point;
                uniforms.pointLightShadows.value = lights.state.pointShadow;
                uniforms.hemisphereLights.value = lights.state.hemi;
    
                uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
                uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
                // TODO (abelnation): add area lights shadow info to uniforms
    
            }
    
            var progUniforms = materialProperties.program.getUniforms(),
                uniformsList =
                    WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );
    
            materialProperties.uniformsList = uniformsList;
    
        }
    
        function setProgram( camera, scene, material, object ) {
    
            textures.resetTextureUnits();
    
            var fog = scene.fog;
            var environment = material.isMeshStandardMaterial ? scene.environment : null;
    
            var materialProperties = properties.get( material );
            var lights = currentRenderState.state.lights;
    
            if ( _clippingEnabled ) {
    
                if ( _localClippingEnabled || camera !== _currentCamera ) {
    
                    var useCache =
                        camera === _currentCamera &&
                        material.id === _currentMaterialId;
    
                    // we might want to call this function with some ClippingGroup
                    // object instead of the material, once it becomes feasible
                    // (#8465, #8379)
                    _clipping.setState(
                        material.clippingPlanes, material.clipIntersection, material.clipShadows,
                        camera, materialProperties, useCache );
    
                }
    
            }
    
            if ( material.version === materialProperties.__version ) {
    
                if ( materialProperties.program === undefined ) {
    
                    initMaterial( material, scene, object );
    
                } else if ( material.fog && materialProperties.fog !== fog ) {
    
                    initMaterial( material, scene, object );
    
                } else if ( materialProperties.environment !== environment ) {
    
                    initMaterial( material, scene, object );
    
                } else if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {
    
                    initMaterial( material, scene, object );
    
                } else if ( materialProperties.numClippingPlanes !== undefined &&
                    ( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
                    materialProperties.numIntersection !== _clipping.numIntersection ) ) {
    
                    initMaterial( material, scene, object );
    
                } else if ( materialProperties.outputEncoding !== _this.outputEncoding ) {
    
                    initMaterial( material, scene, object );
    
                }
    
            } else {
    
                initMaterial( material, scene, object );
                materialProperties.__version = material.version;
    
            }
    
            var refreshProgram = false;
            var refreshMaterial = false;
            var refreshLights = false;
    
            var program = materialProperties.program,
                p_uniforms = program.getUniforms(),
                m_uniforms = materialProperties.uniforms;
    
            if ( state.useProgram( program.program ) ) {
    
                refreshProgram = true;
                refreshMaterial = true;
                refreshLights = true;
    
            }
    
            if ( material.id !== _currentMaterialId ) {
    
                _currentMaterialId = material.id;
    
                refreshMaterial = true;
    
            }
    
            if ( refreshProgram || _currentCamera !== camera ) {
    
                p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );
    
                if ( capabilities.logarithmicDepthBuffer ) {
    
                    p_uniforms.setValue( _gl, 'logDepthBufFC',
                        2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
    
                }
    
                if ( _currentCamera !== camera ) {
    
                    _currentCamera = camera;
    
                    // lighting uniforms depend on the camera so enforce an update
                    // now, in case this material supports lights - or later, when
                    // the next material that does gets activated:
    
                    refreshMaterial = true;		// set to true on material change
                    refreshLights = true;		// remains set until update done
    
                }
    
                // load material specific uniforms
                // (shader material also gets them for the sake of genericity)
    
                if ( material.isShaderMaterial ||
                    material.isMeshPhongMaterial ||
                    material.isMeshToonMaterial ||
                    material.isMeshStandardMaterial ||
                    material.envMap ) {
    
                    var uCamPos = p_uniforms.map.cameraPosition;
    
                    if ( uCamPos !== undefined ) {
    
                        uCamPos.setValue( _gl,
                            _vector3.setFromMatrixPosition( camera.matrixWorld ) );
    
                    }
    
                }
    
                if ( material.isMeshPhongMaterial ||
                    material.isMeshToonMaterial ||
                    material.isMeshLambertMaterial ||
                    material.isMeshBasicMaterial ||
                    material.isMeshStandardMaterial ||
                    material.isShaderMaterial ) {
    
                    p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );
    
                }
    
                if ( material.isMeshPhongMaterial ||
                    material.isMeshToonMaterial ||
                    material.isMeshLambertMaterial ||
                    material.isMeshBasicMaterial ||
                    material.isMeshStandardMaterial ||
                    material.isShaderMaterial ||
                    material.skinning ) {
    
                    p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );
    
                }
    
            }
    
            // skinning uniforms must be set even if material didn't change
            // auto-setting of texture unit for bone texture must go before other textures
            // otherwise textures used for skinning can take over texture units reserved for other material textures
    
            if ( material.skinning ) {
    
                p_uniforms.setOptional( _gl, object, 'bindMatrix' );
                p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );
    
                var skeleton = object.skeleton;
    
                if ( skeleton ) {
    
                    var bones = skeleton.bones;
    
                    if ( capabilities.floatVertexTextures ) {
    
                        if ( skeleton.boneTexture === undefined ) {
    
                            // layout (1 matrix = 4 pixels)
                            //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                            //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                            //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                            //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                            //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
    
    
                            var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
                            size = MathUtils.ceilPowerOfTwo( size );
                            size = Math.max( size, 4 );
    
                            var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
                            boneMatrices.set( skeleton.boneMatrices ); // copy current values
    
                            var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
    
                            skeleton.boneMatrices = boneMatrices;
                            skeleton.boneTexture = boneTexture;
                            skeleton.boneTextureSize = size;
    
                        }
    
                        p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
                        p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );
    
                    } else {
    
                        p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );
    
                    }
    
                }
    
            }
    
            if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {
    
                materialProperties.receiveShadow = object.receiveShadow;
                p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );
    
            }
    
            if ( refreshMaterial ) {
    
                p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
                p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );
    
                if ( materialProperties.needsLights ) {
    
                    // the current material requires lighting info
    
                    // note: all lighting uniforms are always set correctly
                    // they simply reference the renderer's state for their
                    // values
                    //
                    // use the current material's .needsUpdate flags to set
                    // the GL state when required
    
                    markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
    
                }
    
                // refresh uniforms common to several materials
    
                if ( fog && material.fog ) {
    
                    refreshUniformsFog( m_uniforms, fog );
    
                }
    
                if ( material.isMeshBasicMaterial ) {
    
                    refreshUniformsCommon( m_uniforms, material );
    
                } else if ( material.isMeshLambertMaterial ) {
    
                    refreshUniformsCommon( m_uniforms, material );
                    refreshUniformsLambert( m_uniforms, material );
    
                } else if ( material.isMeshToonMaterial ) {
    
                    refreshUniformsCommon( m_uniforms, material );
                    refreshUniformsToon( m_uniforms, material );
    
                } else if ( material.isMeshPhongMaterial ) {
    
                    refreshUniformsCommon( m_uniforms, material );
                    refreshUniformsPhong( m_uniforms, material );
    
                } else if ( material.isMeshStandardMaterial ) {
    
                    refreshUniformsCommon( m_uniforms, material, environment );
    
                    if ( material.isMeshPhysicalMaterial ) {
    
                        refreshUniformsPhysical( m_uniforms, material, environment );
    
                    } else {
    
                        refreshUniformsStandard( m_uniforms, material, environment );
    
                    }
    
                } else if ( material.isMeshMatcapMaterial ) {
    
                    refreshUniformsCommon( m_uniforms, material );
                    refreshUniformsMatcap( m_uniforms, material );
    
                } else if ( material.isMeshDepthMaterial ) {
    
                    refreshUniformsCommon( m_uniforms, material );
                    refreshUniformsDepth( m_uniforms, material );
    
                } else if ( material.isMeshDistanceMaterial ) {
    
                    refreshUniformsCommon( m_uniforms, material );
                    refreshUniformsDistance( m_uniforms, material );
    
                } else if ( material.isMeshNormalMaterial ) {
    
                    refreshUniformsCommon( m_uniforms, material );
                    refreshUniformsNormal( m_uniforms, material );
    
                } else if ( material.isLineBasicMaterial ) {
    
                    refreshUniformsLine( m_uniforms, material );
    
                    if ( material.isLineDashedMaterial ) {
    
                        refreshUniformsDash( m_uniforms, material );
    
                    }
    
                } else if ( material.isPointsMaterial ) {
    
                    refreshUniformsPoints( m_uniforms, material );
    
                } else if ( material.isSpriteMaterial ) {
    
                    refreshUniformsSprites( m_uniforms, material );
    
                } else if ( material.isShadowMaterial ) {
    
                    m_uniforms.color.value.copy( material.color );
                    m_uniforms.opacity.value = material.opacity;
    
                }
    
                // RectAreaLight Texture
                // TODO (mrdoob): Find a nicer implementation
    
                if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
                if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
    
                WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
    
                if ( material.isShaderMaterial ) {
    
                    material.uniformsNeedUpdate = false; // #15581
    
                }
    
            }
    
            if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {
    
                WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
                material.uniformsNeedUpdate = false;
    
            }
    
            if ( material.isSpriteMaterial ) {
    
                p_uniforms.setValue( _gl, 'center', object.center );
    
            }
    
            // common matrices
    
            p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
            p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
            p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );
    
            return program;
    
        }
    
        // Uniforms (refresh uniforms objects)
    
        function refreshUniformsCommon( uniforms, material, environment ) {
    
            uniforms.opacity.value = material.opacity;
    
            if ( material.color ) {
    
                uniforms.diffuse.value.copy( material.color );
    
            }
    
            if ( material.emissive ) {
    
                uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
    
            }
    
            if ( material.map ) {
    
                uniforms.map.value = material.map;
    
            }
    
            if ( material.alphaMap ) {
    
                uniforms.alphaMap.value = material.alphaMap;
    
            }
    
            if ( material.specularMap ) {
    
                uniforms.specularMap.value = material.specularMap;
    
            }
    
            var envMap = material.envMap || environment;
    
            if ( envMap ) {
    
                uniforms.envMap.value = envMap;
    
                uniforms.flipEnvMap.value = envMap.isCubeTexture ? - 1 : 1;
    
                uniforms.reflectivity.value = material.reflectivity;
                uniforms.refractionRatio.value = material.refractionRatio;
    
                uniforms.maxMipLevel.value = properties.get( envMap ).__maxMipLevel;
    
            }
    
            if ( material.lightMap ) {
    
                uniforms.lightMap.value = material.lightMap;
                uniforms.lightMapIntensity.value = material.lightMapIntensity;
    
            }
    
            if ( material.aoMap ) {
    
                uniforms.aoMap.value = material.aoMap;
                uniforms.aoMapIntensity.value = material.aoMapIntensity;
    
            }
    
            // uv repeat and offset setting priorities
            // 1. color map
            // 2. specular map
            // 3. normal map
            // 4. bump map
            // 5. alpha map
            // 6. emissive map
    
            var uvScaleMap;
    
            if ( material.map ) {
    
                uvScaleMap = material.map;
    
            } else if ( material.specularMap ) {
    
                uvScaleMap = material.specularMap;
    
            } else if ( material.displacementMap ) {
    
                uvScaleMap = material.displacementMap;
    
            } else if ( material.normalMap ) {
    
                uvScaleMap = material.normalMap;
    
            } else if ( material.bumpMap ) {
    
                uvScaleMap = material.bumpMap;
    
            } else if ( material.roughnessMap ) {
    
                uvScaleMap = material.roughnessMap;
    
            } else if ( material.metalnessMap ) {
    
                uvScaleMap = material.metalnessMap;
    
            } else if ( material.alphaMap ) {
    
                uvScaleMap = material.alphaMap;
    
            } else if ( material.emissiveMap ) {
    
                uvScaleMap = material.emissiveMap;
    
            }
    
            if ( uvScaleMap !== undefined ) {
    
                // backwards compatibility
                if ( uvScaleMap.isWebGLRenderTarget ) {
    
                    uvScaleMap = uvScaleMap.texture;
    
                }
    
                if ( uvScaleMap.matrixAutoUpdate === true ) {
    
                    uvScaleMap.updateMatrix();
    
                }
    
                uniforms.uvTransform.value.copy( uvScaleMap.matrix );
    
            }
    
            // uv repeat and offset setting priorities for uv2
            // 1. ao map
            // 2. light map
    
            var uv2ScaleMap;
    
            if ( material.aoMap ) {
    
                uv2ScaleMap = material.aoMap;
    
            } else if ( material.lightMap ) {
    
                uv2ScaleMap = material.lightMap;
    
            }
    
            if ( uv2ScaleMap !== undefined ) {
    
                // backwards compatibility
                if ( uv2ScaleMap.isWebGLRenderTarget ) {
    
                    uv2ScaleMap = uv2ScaleMap.texture;
    
                }
    
                if ( uv2ScaleMap.matrixAutoUpdate === true ) {
    
                    uv2ScaleMap.updateMatrix();
    
                }
    
                uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );
    
            }
    
        }
    
        function refreshUniformsLine( uniforms, material ) {
    
            uniforms.diffuse.value.copy( material.color );
            uniforms.opacity.value = material.opacity;
    
        }
    
        function refreshUniformsDash( uniforms, material ) {
    
            uniforms.dashSize.value = material.dashSize;
            uniforms.totalSize.value = material.dashSize + material.gapSize;
            uniforms.scale.value = material.scale;
    
        }
    
        function refreshUniformsPoints( uniforms, material ) {
    
            uniforms.diffuse.value.copy( material.color );
            uniforms.opacity.value = material.opacity;
            uniforms.size.value = material.size * _pixelRatio;
            uniforms.scale.value = _height * 0.5;
    
            if ( material.map ) {
    
                uniforms.map.value = material.map;
    
            }
    
            if ( material.alphaMap ) {
    
                uniforms.alphaMap.value = material.alphaMap;
    
            }
    
            // uv repeat and offset setting priorities
            // 1. color map
            // 2. alpha map
    
            var uvScaleMap;
    
            if ( material.map ) {
    
                uvScaleMap = material.map;
    
            } else if ( material.alphaMap ) {
    
                uvScaleMap = material.alphaMap;
    
            }
    
            if ( uvScaleMap !== undefined ) {
    
                if ( uvScaleMap.matrixAutoUpdate === true ) {
    
                    uvScaleMap.updateMatrix();
    
                }
    
                uniforms.uvTransform.value.copy( uvScaleMap.matrix );
    
            }
    
        }
    
        function refreshUniformsSprites( uniforms, material ) {
    
            uniforms.diffuse.value.copy( material.color );
            uniforms.opacity.value = material.opacity;
            uniforms.rotation.value = material.rotation;
    
            if ( material.map ) {
    
                uniforms.map.value = material.map;
    
            }
    
            if ( material.alphaMap ) {
    
                uniforms.alphaMap.value = material.alphaMap;
    
            }
    
            // uv repeat and offset setting priorities
            // 1. color map
            // 2. alpha map
    
            var uvScaleMap;
    
            if ( material.map ) {
    
                uvScaleMap = material.map;
    
            } else if ( material.alphaMap ) {
    
                uvScaleMap = material.alphaMap;
    
            }
    
            if ( uvScaleMap !== undefined ) {
    
                if ( uvScaleMap.matrixAutoUpdate === true ) {
    
                    uvScaleMap.updateMatrix();
    
                }
    
                uniforms.uvTransform.value.copy( uvScaleMap.matrix );
    
            }
    
        }
    
        function refreshUniformsFog( uniforms, fog ) {
    
            uniforms.fogColor.value.copy( fog.color );
    
            if ( fog.isFog ) {
    
                uniforms.fogNear.value = fog.near;
                uniforms.fogFar.value = fog.far;
    
            } else if ( fog.isFogExp2 ) {
    
                uniforms.fogDensity.value = fog.density;
    
            }
    
        }
    
        function refreshUniformsLambert( uniforms, material ) {
    
            if ( material.emissiveMap ) {
    
                uniforms.emissiveMap.value = material.emissiveMap;
    
            }
    
        }
    
        function refreshUniformsPhong( uniforms, material ) {
    
            uniforms.specular.value.copy( material.specular );
            uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
    
            if ( material.emissiveMap ) {
    
                uniforms.emissiveMap.value = material.emissiveMap;
    
            }
    
            if ( material.bumpMap ) {
    
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
    
            }
    
            if ( material.normalMap ) {
    
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy( material.normalScale );
                if ( material.side === BackSide ) uniforms.normalScale.value.negate();
    
            }
    
            if ( material.displacementMap ) {
    
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
    
            }
    
        }
    
        function refreshUniformsToon( uniforms, material ) {
    
            uniforms.specular.value.copy( material.specular );
            uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
    
            if ( material.gradientMap ) {
    
                uniforms.gradientMap.value = material.gradientMap;
    
            }
    
            if ( material.emissiveMap ) {
    
                uniforms.emissiveMap.value = material.emissiveMap;
    
            }
    
            if ( material.bumpMap ) {
    
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
    
            }
    
            if ( material.normalMap ) {
    
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy( material.normalScale );
                if ( material.side === BackSide ) uniforms.normalScale.value.negate();
    
            }
    
            if ( material.displacementMap ) {
    
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
    
            }
    
        }
    
        function refreshUniformsStandard( uniforms, material, environment ) {
    
            uniforms.roughness.value = material.roughness;
            uniforms.metalness.value = material.metalness;
    
            if ( material.roughnessMap ) {
    
                uniforms.roughnessMap.value = material.roughnessMap;
    
            }
    
            if ( material.metalnessMap ) {
    
                uniforms.metalnessMap.value = material.metalnessMap;
    
            }
    
            if ( material.emissiveMap ) {
    
                uniforms.emissiveMap.value = material.emissiveMap;
    
            }
    
            if ( material.bumpMap ) {
    
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
    
            }
    
            if ( material.normalMap ) {
    
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy( material.normalScale );
                if ( material.side === BackSide ) uniforms.normalScale.value.negate();
    
            }
    
            if ( material.displacementMap ) {
    
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
    
            }
    
            if ( material.envMap || environment ) {
    
                //uniforms.envMap.value = material.envMap; // part of uniforms common
                uniforms.envMapIntensity.value = material.envMapIntensity;
    
            }
    
        }
    
        function refreshUniformsPhysical( uniforms, material, environment ) {
    
            refreshUniformsStandard( uniforms, material, environment );
    
            uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common
    
            uniforms.clearcoat.value = material.clearcoat;
            uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
            if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );
    
            if ( material.clearcoatNormalMap ) {
    
                uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
                uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
    
                if ( material.side === BackSide ) {
    
                    uniforms.clearcoatNormalScale.value.negate();
    
                }
    
            }
    
            uniforms.transparency.value = material.transparency;
    
        }
    
        function refreshUniformsMatcap( uniforms, material ) {
    
            if ( material.matcap ) {
    
                uniforms.matcap.value = material.matcap;
    
            }
    
            if ( material.bumpMap ) {
    
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
    
            }
    
            if ( material.normalMap ) {
    
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy( material.normalScale );
                if ( material.side === BackSide ) uniforms.normalScale.value.negate();
    
            }
    
            if ( material.displacementMap ) {
    
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
    
            }
    
        }
    
        function refreshUniformsDepth( uniforms, material ) {
    
            if ( material.displacementMap ) {
    
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
    
            }
    
        }
    
        function refreshUniformsDistance( uniforms, material ) {
    
            if ( material.displacementMap ) {
    
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
    
            }
    
            uniforms.referencePosition.value.copy( material.referencePosition );
            uniforms.nearDistance.value = material.nearDistance;
            uniforms.farDistance.value = material.farDistance;
    
        }
    
        function refreshUniformsNormal( uniforms, material ) {
    
            if ( material.bumpMap ) {
    
                uniforms.bumpMap.value = material.bumpMap;
                uniforms.bumpScale.value = material.bumpScale;
                if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
    
            }
    
            if ( material.normalMap ) {
    
                uniforms.normalMap.value = material.normalMap;
                uniforms.normalScale.value.copy( material.normalScale );
                if ( material.side === BackSide ) uniforms.normalScale.value.negate();
    
            }
    
            if ( material.displacementMap ) {
    
                uniforms.displacementMap.value = material.displacementMap;
                uniforms.displacementScale.value = material.displacementScale;
                uniforms.displacementBias.value = material.displacementBias;
    
            }
    
        }
    
        // If uniforms are marked as clean, they don't need to be loaded to the GPU.
    
        function markUniformsLightsNeedsUpdate( uniforms, value ) {
    
            uniforms.ambientLightColor.needsUpdate = value;
            uniforms.lightProbe.needsUpdate = value;
    
            uniforms.directionalLights.needsUpdate = value;
            uniforms.directionalLightShadows.needsUpdate = value;
            uniforms.pointLights.needsUpdate = value;
            uniforms.pointLightShadows.needsUpdate = value;
            uniforms.spotLights.needsUpdate = value;
            uniforms.spotLightShadows.needsUpdate = value;
            uniforms.rectAreaLights.needsUpdate = value;
            uniforms.hemisphereLights.needsUpdate = value;
    
        }
    
        function materialNeedsLights( material ) {
    
            return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
                material.isMeshStandardMaterial || material.isShadowMaterial ||
                ( material.isShaderMaterial && material.lights === true );
    
        }
    
        //
        this.setFramebuffer = function ( value ) {
    
            if ( _framebuffer !== value && _currentRenderTarget === null ) _gl.bindFramebuffer( 36160, value );
    
            _framebuffer = value;
    
        };
    
        this.getActiveCubeFace = function () {
    
            return _currentActiveCubeFace;
    
        };
    
        this.getActiveMipmapLevel = function () {
    
            return _currentActiveMipmapLevel;
    
        };
    
        this.getRenderTarget = function () {
    
            return _currentRenderTarget;
    
        };
    
        this.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipmapLevel ) {
    
            _currentRenderTarget = renderTarget;
            _currentActiveCubeFace = activeCubeFace;
            _currentActiveMipmapLevel = activeMipmapLevel;
    
            if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {
    
                textures.setupRenderTarget( renderTarget );
    
            }
    
            var framebuffer = _framebuffer;
            var isCube = false;
    
            if ( renderTarget ) {
    
                var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;
    
                if ( renderTarget.isWebGLCubeRenderTarget ) {
    
                    framebuffer = __webglFramebuffer[ activeCubeFace || 0 ];
                    isCube = true;
    
                } else if ( renderTarget.isWebGLMultisampleRenderTarget ) {
    
                    framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;
    
                } else {
    
                    framebuffer = __webglFramebuffer;
    
                }
    
                _currentViewport.copy( renderTarget.viewport );
                _currentScissor.copy( renderTarget.scissor );
                _currentScissorTest = renderTarget.scissorTest;
    
            } else {
    
                _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
                _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
                _currentScissorTest = _scissorTest;
    
            }
    
            if ( _currentFramebuffer !== framebuffer ) {
    
                _gl.bindFramebuffer( 36160, framebuffer );
                _currentFramebuffer = framebuffer;
    
            }
    
            state.viewport( _currentViewport );
            state.scissor( _currentScissor );
            state.setScissorTest( _currentScissorTest );
    
            if ( isCube ) {
    
                var textureProperties = properties.get( renderTarget.texture );
                _gl.framebufferTexture2D( 36160, 36064, 34069 + ( activeCubeFace || 0 ), textureProperties.__webglTexture, activeMipmapLevel || 0 );
    
            }
    
        };
    
        this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {
    
            if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {
    
                console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
                return;
    
            }
    
            var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
    
            if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {
    
                framebuffer = framebuffer[ activeCubeFaceIndex ];
    
            }
    
            if ( framebuffer ) {
    
                var restore = false;
    
                if ( framebuffer !== _currentFramebuffer ) {
    
                    _gl.bindFramebuffer( 36160, framebuffer );
    
                    restore = true;
    
                }
    
                try {
    
                    var texture = renderTarget.texture;
                    var textureFormat = texture.format;
                    var textureType = texture.type;
    
                    if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {
    
                        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
                        return;
    
                    }
    
                    if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)
                        ! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
                        ! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {
    
                        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
                        return;
    
                    }
    
                    if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {
    
                        // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
    
                        if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {
    
                            _gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );
    
                        }
    
                    } else {
    
                        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
    
                    }
    
                } finally {
    
                    if ( restore ) {
    
                        _gl.bindFramebuffer( 36160, _currentFramebuffer );
    
                    }
    
                }
    
            }
    
        };
    
        this.copyFramebufferToTexture = function ( position, texture, level ) {
    
            if ( level === undefined ) level = 0;
    
            var levelScale = Math.pow( 2, - level );
            var width = Math.floor( texture.image.width * levelScale );
            var height = Math.floor( texture.image.height * levelScale );
            var glFormat = utils.convert( texture.format );
    
            textures.setTexture2D( texture, 0 );
    
            _gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );
    
            state.unbindTexture();
    
        };
    
        this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {
    
            var width = srcTexture.image.width;
            var height = srcTexture.image.height;
            var glFormat = utils.convert( dstTexture.format );
            var glType = utils.convert( dstTexture.type );
    
            textures.setTexture2D( dstTexture, 0 );
    
            if ( srcTexture.isDataTexture ) {
    
                _gl.texSubImage2D( 3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );
    
            } else {
    
                _gl.texSubImage2D( 3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );
    
            }
    
            state.unbindTexture();
    
        };
    
        this.initTexture = function ( texture ) {
    
            textures.setTexture2D( texture, 0 );
    
            state.unbindTexture();
    
        };
    
        if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {
    
            __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef
    
        }
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    
    function FogExp2( color, density ) {
    
        this.name = '';
    
        this.color = new Color( color );
        this.density = ( density !== undefined ) ? density : 0.00025;
    
    }
    
    Object.assign( FogExp2.prototype, {
    
        isFogExp2: true,
    
        clone: function () {
    
            return new FogExp2( this.color, this.density );
    
        },
    
        toJSON: function ( /* meta */ ) {
    
            return {
                type: 'FogExp2',
                color: this.color.getHex(),
                density: this.density
            };
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    
    function Fog( color, near, far ) {
    
        this.name = '';
    
        this.color = new Color( color );
    
        this.near = ( near !== undefined ) ? near : 1;
        this.far = ( far !== undefined ) ? far : 1000;
    
    }
    
    Object.assign( Fog.prototype, {
    
        isFog: true,
    
        clone: function () {
    
            return new Fog( this.color, this.near, this.far );
    
        },
    
        toJSON: function ( /* meta */ ) {
    
            return {
                type: 'Fog',
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            };
    
        }
    
    } );
    
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    
    function InterleavedBuffer( array, stride ) {
    
        this.array = array;
        this.stride = stride;
        this.count = array !== undefined ? array.length / stride : 0;
    
        this.usage = StaticDrawUsage;
        this.updateRange = { offset: 0, count: - 1 };
    
        this.version = 0;
    
    }
    
    Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {
    
        set: function ( value ) {
    
            if ( value === true ) this.version ++;
    
        }
    
    } );
    
    Object.assign( InterleavedBuffer.prototype, {
    
        isInterleavedBuffer: true,
    
        onUploadCallback: function () {},
    
        setUsage: function ( value ) {
    
            this.usage = value;
    
            return this;
    
        },
    
        copy: function ( source ) {
    
            this.array = new source.array.constructor( source.array );
            this.count = source.count;
            this.stride = source.stride;
            this.usage = source.usage;
    
            return this;
    
        },
    
        copyAt: function ( index1, attribute, index2 ) {
    
            index1 *= this.stride;
            index2 *= attribute.stride;
    
            for ( var i = 0, l = this.stride; i < l; i ++ ) {
    
                this.array[ index1 + i ] = attribute.array[ index2 + i ];
    
            }
    
            return this;
    
        },
    
        set: function ( value, offset ) {
    
            if ( offset === undefined ) offset = 0;
    
            this.array.set( value, offset );
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        onUpload: function ( callback ) {
    
            this.onUploadCallback = callback;
    
            return this;
    
        }
    
    } );
    
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    
    var _vector$6 = new Vector3();
    
    function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {
    
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
    
        this.normalized = normalized === true;
    
    }
    
    Object.defineProperties( InterleavedBufferAttribute.prototype, {
    
        count: {
    
            get: function () {
    
                return this.data.count;
    
            }
    
        },
    
        array: {
    
            get: function () {
    
                return this.data.array;
    
            }
    
        }
    
    } );
    
    Object.assign( InterleavedBufferAttribute.prototype, {
    
        isInterleavedBufferAttribute: true,
    
        applyMatrix4: function ( m ) {
    
            for ( var i = 0, l = this.data.count; i < l; i ++ ) {
    
                _vector$6.x = this.getX( i );
                _vector$6.y = this.getY( i );
                _vector$6.z = this.getZ( i );
    
                _vector$6.applyMatrix4( m );
    
                this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );
    
            }
    
            return this;
    
        },
    
        setX: function ( index, x ) {
    
            this.data.array[ index * this.data.stride + this.offset ] = x;
    
            return this;
    
        },
    
        setY: function ( index, y ) {
    
            this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
    
            return this;
    
        },
    
        setZ: function ( index, z ) {
    
            this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
    
            return this;
    
        },
    
        setW: function ( index, w ) {
    
            this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
    
            return this;
    
        },
    
        getX: function ( index ) {
    
            return this.data.array[ index * this.data.stride + this.offset ];
    
        },
    
        getY: function ( index ) {
    
            return this.data.array[ index * this.data.stride + this.offset + 1 ];
    
        },
    
        getZ: function ( index ) {
    
            return this.data.array[ index * this.data.stride + this.offset + 2 ];
    
        },
    
        getW: function ( index ) {
    
            return this.data.array[ index * this.data.stride + this.offset + 3 ];
    
        },
    
        setXY: function ( index, x, y ) {
    
            index = index * this.data.stride + this.offset;
    
            this.data.array[ index + 0 ] = x;
            this.data.array[ index + 1 ] = y;
    
            return this;
    
        },
    
        setXYZ: function ( index, x, y, z ) {
    
            index = index * this.data.stride + this.offset;
    
            this.data.array[ index + 0 ] = x;
            this.data.array[ index + 1 ] = y;
            this.data.array[ index + 2 ] = z;
    
            return this;
    
        },
    
        setXYZW: function ( index, x, y, z, w ) {
    
            index = index * this.data.stride + this.offset;
    
            this.data.array[ index + 0 ] = x;
            this.data.array[ index + 1 ] = y;
            this.data.array[ index + 2 ] = z;
            this.data.array[ index + 3 ] = w;
    
            return this;
    
        }
    
    } );
    
    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  map: new THREE.Texture( <Image> ),
     *  alphaMap: new THREE.Texture( <Image> ),
     *  rotation: <float>,
     *  sizeAttenuation: <bool>
     * }
     */
    
    function SpriteMaterial( parameters ) {
    
        Material.call( this );
    
        this.type = 'SpriteMaterial';
    
        this.color = new Color( 0xffffff );
    
        this.map = null;
    
        this.alphaMap = null;
    
        this.rotation = 0;
    
        this.sizeAttenuation = true;
    
        this.transparent = true;
    
        this.setValues( parameters );
    
    }
    
    SpriteMaterial.prototype = Object.create( Material.prototype );
    SpriteMaterial.prototype.constructor = SpriteMaterial;
    SpriteMaterial.prototype.isSpriteMaterial = true;
    
    SpriteMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.color.copy( source.color );
    
        this.map = source.map;
    
        this.alphaMap = source.alphaMap;
    
        this.rotation = source.rotation;
    
        this.sizeAttenuation = source.sizeAttenuation;
    
        return this;
    
    };
    
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */
    
    var _geometry;
    
    var _intersectPoint = new Vector3();
    var _worldScale = new Vector3();
    var _mvPosition = new Vector3();
    
    var _alignedPosition = new Vector2();
    var _rotatedPosition = new Vector2();
    var _viewWorldMatrix = new Matrix4();
    
    var _vA$1 = new Vector3();
    var _vB$1 = new Vector3();
    var _vC$1 = new Vector3();
    
    var _uvA$1 = new Vector2();
    var _uvB$1 = new Vector2();
    var _uvC$1 = new Vector2();
    
    function Sprite( material ) {
    
        Object3D.call( this );
    
        this.type = 'Sprite';
    
        if ( _geometry === undefined ) {
    
            _geometry = new BufferGeometry();
    
            var float32Array = new Float32Array( [
                - 0.5, - 0.5, 0, 0, 0,
                0.5, - 0.5, 0, 1, 0,
                0.5, 0.5, 0, 1, 1,
                - 0.5, 0.5, 0, 0, 1
            ] );
    
            var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );
    
            _geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
            _geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
            _geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );
    
        }
    
        this.geometry = _geometry;
        this.material = ( material !== undefined ) ? material : new SpriteMaterial();
    
        this.center = new Vector2( 0.5, 0.5 );
    
    }
    
    Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: Sprite,
    
        isSprite: true,
    
        raycast: function ( raycaster, intersects ) {
    
            if ( raycaster.camera === null ) {
    
                console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );
    
            }
    
            _worldScale.setFromMatrixScale( this.matrixWorld );
    
            _viewWorldMatrix.copy( raycaster.camera.matrixWorld );
            this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );
    
            _mvPosition.setFromMatrixPosition( this.modelViewMatrix );
    
            if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {
    
                _worldScale.multiplyScalar( - _mvPosition.z );
    
            }
    
            var rotation = this.material.rotation;
            var sin, cos;
            if ( rotation !== 0 ) {
    
                cos = Math.cos( rotation );
                sin = Math.sin( rotation );
    
            }
    
            var center = this.center;
    
            transformVertex( _vA$1.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
            transformVertex( _vB$1.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
            transformVertex( _vC$1.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
    
            _uvA$1.set( 0, 0 );
            _uvB$1.set( 1, 0 );
            _uvC$1.set( 1, 1 );
    
            // check first triangle
            var intersect = raycaster.ray.intersectTriangle( _vA$1, _vB$1, _vC$1, false, _intersectPoint );
    
            if ( intersect === null ) {
    
                // check second triangle
                transformVertex( _vB$1.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
                _uvB$1.set( 0, 1 );
    
                intersect = raycaster.ray.intersectTriangle( _vA$1, _vC$1, _vB$1, false, _intersectPoint );
                if ( intersect === null ) {
    
                    return;
    
                }
    
            }
    
            var distance = raycaster.ray.origin.distanceTo( _intersectPoint );
    
            if ( distance < raycaster.near || distance > raycaster.far ) return;
    
            intersects.push( {
    
                distance: distance,
                point: _intersectPoint.clone(),
                uv: Triangle.getUV( _intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() ),
                face: null,
                object: this
    
            } );
    
        },
    
        clone: function () {
    
            return new this.constructor( this.material ).copy( this );
    
        },
    
        copy: function ( source ) {
    
            Object3D.prototype.copy.call( this, source );
    
            if ( source.center !== undefined ) this.center.copy( source.center );
    
            return this;
    
        }
    
    
    } );
    
    function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {
    
        // compute position in camera space
        _alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );
    
        // to check if rotation is not zero
        if ( sin !== undefined ) {
    
            _rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
            _rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );
    
        } else {
    
            _rotatedPosition.copy( _alignedPosition );
    
        }
    
    
        vertexPosition.copy( mvPosition );
        vertexPosition.x += _rotatedPosition.x;
        vertexPosition.y += _rotatedPosition.y;
    
        // transform to world space
        vertexPosition.applyMatrix4( _viewWorldMatrix );
    
    }
    
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    
    var _v1$4 = new Vector3();
    var _v2$2 = new Vector3();
    
    function LOD() {
    
        Object3D.call( this );
    
        this._currentLevel = 0;
    
        this.type = 'LOD';
    
        Object.defineProperties( this, {
            levels: {
                enumerable: true,
                value: []
            }
        } );
    
        this.autoUpdate = true;
    
    }
    
    LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: LOD,
    
        isLOD: true,
    
        copy: function ( source ) {
    
            Object3D.prototype.copy.call( this, source, false );
    
            var levels = source.levels;
    
            for ( var i = 0, l = levels.length; i < l; i ++ ) {
    
                var level = levels[ i ];
    
                this.addLevel( level.object.clone(), level.distance );
    
            }
    
            this.autoUpdate = source.autoUpdate;
    
            return this;
    
        },
    
        addLevel: function ( object, distance ) {
    
            if ( distance === undefined ) distance = 0;
    
            distance = Math.abs( distance );
    
            var levels = this.levels;
    
            for ( var l = 0; l < levels.length; l ++ ) {
    
                if ( distance < levels[ l ].distance ) {
    
                    break;
    
                }
    
            }
    
            levels.splice( l, 0, { distance: distance, object: object } );
    
            this.add( object );
    
            return this;
    
        },
    
        getCurrentLevel: function () {
    
            return this._currentLevel;
    
        },
    
        getObjectForDistance: function ( distance ) {
    
            var levels = this.levels;
    
            if ( levels.length > 0 ) {
    
                for ( var i = 1, l = levels.length; i < l; i ++ ) {
    
                    if ( distance < levels[ i ].distance ) {
    
                        break;
    
                    }
    
                }
    
                return levels[ i - 1 ].object;
    
            }
    
            return null;
    
        },
    
        raycast: function ( raycaster, intersects ) {
    
            var levels = this.levels;
    
            if ( levels.length > 0 ) {
    
                _v1$4.setFromMatrixPosition( this.matrixWorld );
    
                var distance = raycaster.ray.origin.distanceTo( _v1$4 );
    
                this.getObjectForDistance( distance ).raycast( raycaster, intersects );
    
            }
    
        },
    
        update: function ( camera ) {
    
            var levels = this.levels;
    
            if ( levels.length > 1 ) {
    
                _v1$4.setFromMatrixPosition( camera.matrixWorld );
                _v2$2.setFromMatrixPosition( this.matrixWorld );
    
                var distance = _v1$4.distanceTo( _v2$2 ) / camera.zoom;
    
                levels[ 0 ].object.visible = true;
    
                for ( var i = 1, l = levels.length; i < l; i ++ ) {
    
                    if ( distance >= levels[ i ].distance ) {
    
                        levels[ i - 1 ].object.visible = false;
                        levels[ i ].object.visible = true;
    
                    } else {
    
                        break;
    
                    }
    
                }
    
                this._currentLevel = i - 1;
    
                for ( ; i < l; i ++ ) {
    
                    levels[ i ].object.visible = false;
    
                }
    
            }
    
        },
    
        toJSON: function ( meta ) {
    
            var data = Object3D.prototype.toJSON.call( this, meta );
    
            if ( this.autoUpdate === false ) data.object.autoUpdate = false;
    
            data.object.levels = [];
    
            var levels = this.levels;
    
            for ( var i = 0, l = levels.length; i < l; i ++ ) {
    
                var level = levels[ i ];
    
                data.object.levels.push( {
                    object: level.object.uuid,
                    distance: level.distance
                } );
    
            }
    
            return data;
    
        }
    
    } );
    
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */
    
    function SkinnedMesh( geometry, material ) {
    
        if ( geometry && geometry.isGeometry ) {
    
            console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
    
        }
    
        Mesh.call( this, geometry, material );
    
        this.type = 'SkinnedMesh';
    
        this.bindMode = 'attached';
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();
    
    }
    
    SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {
    
        constructor: SkinnedMesh,
    
        isSkinnedMesh: true,
    
        bind: function ( skeleton, bindMatrix ) {
    
            this.skeleton = skeleton;
    
            if ( bindMatrix === undefined ) {
    
                this.updateMatrixWorld( true );
    
                this.skeleton.calculateInverses();
    
                bindMatrix = this.matrixWorld;
    
            }
    
            this.bindMatrix.copy( bindMatrix );
            this.bindMatrixInverse.getInverse( bindMatrix );
    
        },
    
        pose: function () {
    
            this.skeleton.pose();
    
        },
    
        normalizeSkinWeights: function () {
    
            var vector = new Vector4();
    
            var skinWeight = this.geometry.attributes.skinWeight;
    
            for ( var i = 0, l = skinWeight.count; i < l; i ++ ) {
    
                vector.x = skinWeight.getX( i );
                vector.y = skinWeight.getY( i );
                vector.z = skinWeight.getZ( i );
                vector.w = skinWeight.getW( i );
    
                var scale = 1.0 / vector.manhattanLength();
    
                if ( scale !== Infinity ) {
    
                    vector.multiplyScalar( scale );
    
                } else {
    
                    vector.set( 1, 0, 0, 0 ); // do something reasonable
    
                }
    
                skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );
    
            }
    
        },
    
        updateMatrixWorld: function ( force ) {
    
            Mesh.prototype.updateMatrixWorld.call( this, force );
    
            if ( this.bindMode === 'attached' ) {
    
                this.bindMatrixInverse.getInverse( this.matrixWorld );
    
            } else if ( this.bindMode === 'detached' ) {
    
                this.bindMatrixInverse.getInverse( this.bindMatrix );
    
            } else {
    
                console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );
    
            }
    
        },
    
        clone: function () {
    
            return new this.constructor( this.geometry, this.material ).copy( this );
    
        }
    
    } );
    
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author michael guerrero / http://realitymeltdown.com
     * @author ikerr / http://verold.com
     */
    
    var _offsetMatrix = new Matrix4();
    var _identityMatrix = new Matrix4();
    
    function Skeleton( bones, boneInverses ) {
    
        // copy the bone array
    
        bones = bones || [];
    
        this.bones = bones.slice( 0 );
        this.boneMatrices = new Float32Array( this.bones.length * 16 );
    
        this.frame = - 1;
    
        // use the supplied bone inverses or calculate the inverses
    
        if ( boneInverses === undefined ) {
    
            this.calculateInverses();
    
        } else {
    
            if ( this.bones.length === boneInverses.length ) {
    
                this.boneInverses = boneInverses.slice( 0 );
    
            } else {
    
                console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );
    
                this.boneInverses = [];
    
                for ( var i = 0, il = this.bones.length; i < il; i ++ ) {
    
                    this.boneInverses.push( new Matrix4() );
    
                }
    
            }
    
        }
    
    }
    
    Object.assign( Skeleton.prototype, {
    
        calculateInverses: function () {
    
            this.boneInverses = [];
    
            for ( var i = 0, il = this.bones.length; i < il; i ++ ) {
    
                var inverse = new Matrix4();
    
                if ( this.bones[ i ] ) {
    
                    inverse.getInverse( this.bones[ i ].matrixWorld );
    
                }
    
                this.boneInverses.push( inverse );
    
            }
    
        },
    
        pose: function () {
    
            var bone, i, il;
    
            // recover the bind-time world matrices
    
            for ( i = 0, il = this.bones.length; i < il; i ++ ) {
    
                bone = this.bones[ i ];
    
                if ( bone ) {
    
                    bone.matrixWorld.getInverse( this.boneInverses[ i ] );
    
                }
    
            }
    
            // compute the local matrices, positions, rotations and scales
    
            for ( i = 0, il = this.bones.length; i < il; i ++ ) {
    
                bone = this.bones[ i ];
    
                if ( bone ) {
    
                    if ( bone.parent && bone.parent.isBone ) {
    
                        bone.matrix.getInverse( bone.parent.matrixWorld );
                        bone.matrix.multiply( bone.matrixWorld );
    
                    } else {
    
                        bone.matrix.copy( bone.matrixWorld );
    
                    }
    
                    bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
    
                }
    
            }
    
        },
    
        update: function () {
    
            var bones = this.bones;
            var boneInverses = this.boneInverses;
            var boneMatrices = this.boneMatrices;
            var boneTexture = this.boneTexture;
    
            // flatten bone matrices to array
    
            for ( var i = 0, il = bones.length; i < il; i ++ ) {
    
                // compute the offset between the current and the original transform
    
                var matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;
    
                _offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
                _offsetMatrix.toArray( boneMatrices, i * 16 );
    
            }
    
            if ( boneTexture !== undefined ) {
    
                boneTexture.needsUpdate = true;
    
            }
    
        },
    
        clone: function () {
    
            return new Skeleton( this.bones, this.boneInverses );
    
        },
    
        getBoneByName: function ( name ) {
    
            for ( var i = 0, il = this.bones.length; i < il; i ++ ) {
    
                var bone = this.bones[ i ];
    
                if ( bone.name === name ) {
    
                    return bone;
    
                }
    
            }
    
            return undefined;
    
        }
    
    } );
    
    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */
    
    function Bone() {
    
        Object3D.call( this );
    
        this.type = 'Bone';
    
    }
    
    Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: Bone,
    
        isBone: true
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    var _instanceLocalMatrix = new Matrix4();
    var _instanceWorldMatrix = new Matrix4();
    
    var _instanceIntersects = [];
    
    var _mesh = new Mesh();
    
    function InstancedMesh( geometry, material, count ) {
    
        Mesh.call( this, geometry, material );
    
        this.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );
    
        this.count = count;
    
        this.frustumCulled = false;
    
    }
    
    InstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {
    
        constructor: InstancedMesh,
    
        isInstancedMesh: true,
    
        getMatrixAt: function ( index, matrix ) {
    
            matrix.fromArray( this.instanceMatrix.array, index * 16 );
    
        },
    
        raycast: function ( raycaster, intersects ) {
    
            var matrixWorld = this.matrixWorld;
            var raycastTimes = this.count;
    
            _mesh.geometry = this.geometry;
            _mesh.material = this.material;
    
            if ( _mesh.material === undefined ) return;
    
            for ( var instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {
    
                // calculate the world matrix for each instance
    
                this.getMatrixAt( instanceId, _instanceLocalMatrix );
    
                _instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );
    
                // the mesh represents this single instance
    
                _mesh.matrixWorld = _instanceWorldMatrix;
    
                _mesh.raycast( raycaster, _instanceIntersects );
    
                // process the result of raycast
    
                if ( _instanceIntersects.length > 0 ) {
    
                    _instanceIntersects[ 0 ].instanceId = instanceId;
                    _instanceIntersects[ 0 ].object = this;
    
                    intersects.push( _instanceIntersects[ 0 ] );
    
                    _instanceIntersects.length = 0;
    
                }
    
            }
    
        },
    
        setMatrixAt: function ( index, matrix ) {
    
            matrix.toArray( this.instanceMatrix.array, index * 16 );
    
        },
    
        updateMorphTargets: function () {
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *  linecap: "round",
     *  linejoin: "round"
     * }
     */
    
    function LineBasicMaterial( parameters ) {
    
        Material.call( this );
    
        this.type = 'LineBasicMaterial';
    
        this.color = new Color( 0xffffff );
    
        this.linewidth = 1;
        this.linecap = 'round';
        this.linejoin = 'round';
    
        this.setValues( parameters );
    
    }
    
    LineBasicMaterial.prototype = Object.create( Material.prototype );
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;
    
    LineBasicMaterial.prototype.isLineBasicMaterial = true;
    
    LineBasicMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.color.copy( source.color );
    
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
    
        return this;
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    var _start = new Vector3();
    var _end = new Vector3();
    var _inverseMatrix$1 = new Matrix4();
    var _ray$1 = new Ray();
    var _sphere$2 = new Sphere();
    
    function Line( geometry, material, mode ) {
    
        if ( mode === 1 ) {
    
            console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );
    
        }
    
        Object3D.call( this );
    
        this.type = 'Line';
    
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new LineBasicMaterial();
    
    }
    
    Line.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: Line,
    
        isLine: true,
    
        computeLineDistances: function () {
    
            var geometry = this.geometry;
    
            if ( geometry.isBufferGeometry ) {
    
                // we assume non-indexed geometry
    
                if ( geometry.index === null ) {
    
                    var positionAttribute = geometry.attributes.position;
                    var lineDistances = [ 0 ];
    
                    for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {
    
                        _start.fromBufferAttribute( positionAttribute, i - 1 );
                        _end.fromBufferAttribute( positionAttribute, i );
    
                        lineDistances[ i ] = lineDistances[ i - 1 ];
                        lineDistances[ i ] += _start.distanceTo( _end );
    
                    }
    
                    geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );
    
                } else {
    
                    console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );
    
                }
    
            } else if ( geometry.isGeometry ) {
    
                var vertices = geometry.vertices;
                var lineDistances = geometry.lineDistances;
    
                lineDistances[ 0 ] = 0;
    
                for ( var i = 1, l = vertices.length; i < l; i ++ ) {
    
                    lineDistances[ i ] = lineDistances[ i - 1 ];
                    lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );
    
                }
    
            }
    
            return this;
    
        },
    
        raycast: function ( raycaster, intersects ) {
    
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            var threshold = raycaster.params.Line.threshold;
    
            // Checking boundingSphere distance to ray
    
            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
    
            _sphere$2.copy( geometry.boundingSphere );
            _sphere$2.applyMatrix4( matrixWorld );
            _sphere$2.radius += threshold;
    
            if ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;
    
            //
    
            _inverseMatrix$1.getInverse( matrixWorld );
            _ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );
    
            var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
            var localThresholdSq = localThreshold * localThreshold;
    
            var vStart = new Vector3();
            var vEnd = new Vector3();
            var interSegment = new Vector3();
            var interRay = new Vector3();
            var step = ( this && this.isLineSegments ) ? 2 : 1;
    
            if ( geometry.isBufferGeometry ) {
    
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
    
                if ( index !== null ) {
    
                    var indices = index.array;
    
                    for ( var i = 0, l = indices.length - 1; i < l; i += step ) {
    
                        var a = indices[ i ];
                        var b = indices[ i + 1 ];
    
                        vStart.fromArray( positions, a * 3 );
                        vEnd.fromArray( positions, b * 3 );
    
                        var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
    
                        if ( distSq > localThresholdSq ) continue;
    
                        interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
    
                        var distance = raycaster.ray.origin.distanceTo( interRay );
    
                        if ( distance < raycaster.near || distance > raycaster.far ) continue;
    
                        intersects.push( {
    
                            distance: distance,
                            // What do we want? intersection point on the ray or on the segment??
                            // point: raycaster.ray.at( distance ),
                            point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
    
                        } );
    
                    }
    
                } else {
    
                    for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {
    
                        vStart.fromArray( positions, 3 * i );
                        vEnd.fromArray( positions, 3 * i + 3 );
    
                        var distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
    
                        if ( distSq > localThresholdSq ) continue;
    
                        interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
    
                        var distance = raycaster.ray.origin.distanceTo( interRay );
    
                        if ( distance < raycaster.near || distance > raycaster.far ) continue;
    
                        intersects.push( {
    
                            distance: distance,
                            // What do we want? intersection point on the ray or on the segment??
                            // point: raycaster.ray.at( distance ),
                            point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                            index: i,
                            face: null,
                            faceIndex: null,
                            object: this
    
                        } );
    
                    }
    
                }
    
            } else if ( geometry.isGeometry ) {
    
                var vertices = geometry.vertices;
                var nbVertices = vertices.length;
    
                for ( var i = 0; i < nbVertices - 1; i += step ) {
    
                    var distSq = _ray$1.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
    
                    if ( distSq > localThresholdSq ) continue;
    
                    interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
    
                    var distance = raycaster.ray.origin.distanceTo( interRay );
    
                    if ( distance < raycaster.near || distance > raycaster.far ) continue;
    
                    intersects.push( {
    
                        distance: distance,
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        point: interSegment.clone().applyMatrix4( this.matrixWorld ),
                        index: i,
                        face: null,
                        faceIndex: null,
                        object: this
    
                    } );
    
                }
    
            }
    
        },
    
        clone: function () {
    
            return new this.constructor( this.geometry, this.material ).copy( this );
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    var _start$1 = new Vector3();
    var _end$1 = new Vector3();
    
    function LineSegments( geometry, material ) {
    
        Line.call( this, geometry, material );
    
        this.type = 'LineSegments';
    
    }
    
    LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {
    
        constructor: LineSegments,
    
        isLineSegments: true,
    
        computeLineDistances: function () {
    
            var geometry = this.geometry;
    
            if ( geometry.isBufferGeometry ) {
    
                // we assume non-indexed geometry
    
                if ( geometry.index === null ) {
    
                    var positionAttribute = geometry.attributes.position;
                    var lineDistances = [];
    
                    for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {
    
                        _start$1.fromBufferAttribute( positionAttribute, i );
                        _end$1.fromBufferAttribute( positionAttribute, i + 1 );
    
                        lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
                        lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );
    
                    }
    
                    geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );
    
                } else {
    
                    console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );
    
                }
    
            } else if ( geometry.isGeometry ) {
    
                var vertices = geometry.vertices;
                var lineDistances = geometry.lineDistances;
    
                for ( var i = 0, l = vertices.length; i < l; i += 2 ) {
    
                    _start$1.copy( vertices[ i ] );
                    _end$1.copy( vertices[ i + 1 ] );
    
                    lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
                    lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );
    
                }
    
            }
    
            return this;
    
        }
    
    } );
    
    /**
     * @author mgreter / http://github.com/mgreter
     */
    
    function LineLoop( geometry, material ) {
    
        Line.call( this, geometry, material );
    
        this.type = 'LineLoop';
    
    }
    
    LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {
    
        constructor: LineLoop,
    
        isLineLoop: true,
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  size: <float>,
     *  sizeAttenuation: <bool>
     *
     *  morphTargets: <bool>
     * }
     */
    
    function PointsMaterial( parameters ) {
    
        Material.call( this );
    
        this.type = 'PointsMaterial';
    
        this.color = new Color( 0xffffff );
    
        this.map = null;
    
        this.alphaMap = null;
    
        this.size = 1;
        this.sizeAttenuation = true;
    
        this.morphTargets = false;
    
        this.setValues( parameters );
    
    }
    
    PointsMaterial.prototype = Object.create( Material.prototype );
    PointsMaterial.prototype.constructor = PointsMaterial;
    
    PointsMaterial.prototype.isPointsMaterial = true;
    
    PointsMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.color.copy( source.color );
    
        this.map = source.map;
    
        this.alphaMap = source.alphaMap;
    
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
    
        this.morphTargets = source.morphTargets;
    
        return this;
    
    };
    
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    
    var _inverseMatrix$2 = new Matrix4();
    var _ray$2 = new Ray();
    var _sphere$3 = new Sphere();
    var _position$1 = new Vector3();
    
    function Points( geometry, material ) {
    
        Object3D.call( this );
    
        this.type = 'Points';
    
        this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
        this.material = material !== undefined ? material : new PointsMaterial();
    
        this.updateMorphTargets();
    
    }
    
    Points.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: Points,
    
        isPoints: true,
    
        raycast: function ( raycaster, intersects ) {
    
            var geometry = this.geometry;
            var matrixWorld = this.matrixWorld;
            var threshold = raycaster.params.Points.threshold;
    
            // Checking boundingSphere distance to ray
    
            if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
    
            _sphere$3.copy( geometry.boundingSphere );
            _sphere$3.applyMatrix4( matrixWorld );
            _sphere$3.radius += threshold;
    
            if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;
    
            //
    
            _inverseMatrix$2.getInverse( matrixWorld );
            _ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );
    
            var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
            var localThresholdSq = localThreshold * localThreshold;
    
            if ( geometry.isBufferGeometry ) {
    
                var index = geometry.index;
                var attributes = geometry.attributes;
                var positions = attributes.position.array;
    
                if ( index !== null ) {
    
                    var indices = index.array;
    
                    for ( var i = 0, il = indices.length; i < il; i ++ ) {
    
                        var a = indices[ i ];
    
                        _position$1.fromArray( positions, a * 3 );
    
                        testPoint( _position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this );
    
                    }
    
                } else {
    
                    for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {
    
                        _position$1.fromArray( positions, i * 3 );
    
                        testPoint( _position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this );
    
                    }
    
                }
    
            } else {
    
                var vertices = geometry.vertices;
    
                for ( var i = 0, l = vertices.length; i < l; i ++ ) {
    
                    testPoint( vertices[ i ], i, localThresholdSq, matrixWorld, raycaster, intersects, this );
    
                }
    
            }
    
        },
    
        updateMorphTargets: function () {
    
            var geometry = this.geometry;
            var m, ml, name;
    
            if ( geometry.isBufferGeometry ) {
    
                var morphAttributes = geometry.morphAttributes;
                var keys = Object.keys( morphAttributes );
    
                if ( keys.length > 0 ) {
    
                    var morphAttribute = morphAttributes[ keys[ 0 ] ];
    
                    if ( morphAttribute !== undefined ) {
    
                        this.morphTargetInfluences = [];
                        this.morphTargetDictionary = {};
    
                        for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {
    
                            name = morphAttribute[ m ].name || String( m );
    
                            this.morphTargetInfluences.push( 0 );
                            this.morphTargetDictionary[ name ] = m;
    
                        }
    
                    }
    
                }
    
            } else {
    
                var morphTargets = geometry.morphTargets;
    
                if ( morphTargets !== undefined && morphTargets.length > 0 ) {
    
                    console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );
    
                }
    
            }
    
        },
    
        clone: function () {
    
            return new this.constructor( this.geometry, this.material ).copy( this );
    
        }
    
    } );
    
    function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {
    
        var rayPointDistanceSq = _ray$2.distanceSqToPoint( point );
    
        if ( rayPointDistanceSq < localThresholdSq ) {
    
            var intersectPoint = new Vector3();
    
            _ray$2.closestPointToPoint( point, intersectPoint );
            intersectPoint.applyMatrix4( matrixWorld );
    
            var distance = raycaster.ray.origin.distanceTo( intersectPoint );
    
            if ( distance < raycaster.near || distance > raycaster.far ) return;
    
            intersects.push( {
    
                distance: distance,
                distanceToRay: Math.sqrt( rayPointDistanceSq ),
                point: intersectPoint,
                index: index,
                face: null,
                object: object
    
            } );
    
        }
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
    
        Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
    
        this.format = format !== undefined ? format : RGBFormat;
    
        this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
        this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    
        this.generateMipmaps = false;
    
    }
    
    VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {
    
        constructor: VideoTexture,
    
        isVideoTexture: true,
    
        update: function () {
    
            var video = this.image;
    
            if ( video.readyState >= video.HAVE_CURRENT_DATA ) {
    
                this.needsUpdate = true;
    
            }
    
        }
    
    } );
    
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    
    function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
    
        Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
    
        this.image = { width: width, height: height };
        this.mipmaps = mipmaps;
    
        // no flipping for cube textures
        // (also flipping doesn't work for compressed textures )
    
        this.flipY = false;
    
        // can't generate mipmaps for compressed textures
        // mips must be embedded in DDS files
    
        this.generateMipmaps = false;
    
    }
    
    CompressedTexture.prototype = Object.create( Texture.prototype );
    CompressedTexture.prototype.constructor = CompressedTexture;
    
    CompressedTexture.prototype.isCompressedTexture = true;
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
    
        Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
    
        this.needsUpdate = true;
    
    }
    
    CanvasTexture.prototype = Object.create( Texture.prototype );
    CanvasTexture.prototype.constructor = CanvasTexture;
    CanvasTexture.prototype.isCanvasTexture = true;
    
    /**
     * @author Matt DesLauriers / @mattdesl
     * @author atix / arthursilber.de
     */
    
    function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {
    
        format = format !== undefined ? format : DepthFormat;
    
        if ( format !== DepthFormat && format !== DepthStencilFormat ) {
    
            throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );
    
        }
    
        if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
        if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;
    
        Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
    
        this.image = { width: width, height: height };
    
        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
    
        this.flipY = false;
        this.generateMipmaps	= false;
    
    }
    
    DepthTexture.prototype = Object.create( Texture.prototype );
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    function WireframeGeometry( geometry ) {
    
        BufferGeometry.call( this );
    
        this.type = 'WireframeGeometry';
    
        // buffer
    
        var vertices = [];
    
        // helper variables
    
        var i, j, l, o, ol;
        var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
        var key, keys = [ 'a', 'b', 'c' ];
        var vertex;
    
        // different logic for Geometry and BufferGeometry
    
        if ( geometry && geometry.isGeometry ) {
    
            // create a data structure that contains all edges without duplicates
    
            var faces = geometry.faces;
    
            for ( i = 0, l = faces.length; i < l; i ++ ) {
    
                var face = faces[ i ];
    
                for ( j = 0; j < 3; j ++ ) {
    
                    edge1 = face[ keys[ j ] ];
                    edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
                    edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
                    edge[ 1 ] = Math.max( edge1, edge2 );
    
                    key = edge[ 0 ] + ',' + edge[ 1 ];
    
                    if ( edges[ key ] === undefined ) {
    
                        edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
    
                    }
    
                }
    
            }
    
            // generate vertices
    
            for ( key in edges ) {
    
                e = edges[ key ];
    
                vertex = geometry.vertices[ e.index1 ];
                vertices.push( vertex.x, vertex.y, vertex.z );
    
                vertex = geometry.vertices[ e.index2 ];
                vertices.push( vertex.x, vertex.y, vertex.z );
    
            }
    
        } else if ( geometry && geometry.isBufferGeometry ) {
    
            var position, indices, groups;
            var group, start, count;
            var index1, index2;
    
            vertex = new Vector3();
    
            if ( geometry.index !== null ) {
    
                // indexed BufferGeometry
    
                position = geometry.attributes.position;
                indices = geometry.index;
                groups = geometry.groups;
    
                if ( groups.length === 0 ) {
    
                    groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];
    
                }
    
                // create a data structure that contains all eges without duplicates
    
                for ( o = 0, ol = groups.length; o < ol; ++ o ) {
    
                    group = groups[ o ];
    
                    start = group.start;
                    count = group.count;
    
                    for ( i = start, l = ( start + count ); i < l; i += 3 ) {
    
                        for ( j = 0; j < 3; j ++ ) {
    
                            edge1 = indices.getX( i + j );
                            edge2 = indices.getX( i + ( j + 1 ) % 3 );
                            edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
                            edge[ 1 ] = Math.max( edge1, edge2 );
    
                            key = edge[ 0 ] + ',' + edge[ 1 ];
    
                            if ( edges[ key ] === undefined ) {
    
                                edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
    
                            }
    
                        }
    
                    }
    
                }
    
                // generate vertices
    
                for ( key in edges ) {
    
                    e = edges[ key ];
    
                    vertex.fromBufferAttribute( position, e.index1 );
                    vertices.push( vertex.x, vertex.y, vertex.z );
    
                    vertex.fromBufferAttribute( position, e.index2 );
                    vertices.push( vertex.x, vertex.y, vertex.z );
    
                }
    
            } else {
    
                // non-indexed BufferGeometry
    
                position = geometry.attributes.position;
    
                for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {
    
                    for ( j = 0; j < 3; j ++ ) {
    
                        // three edges per triangle, an edge is represented as (index1, index2)
                        // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
    
                        index1 = 3 * i + j;
                        vertex.fromBufferAttribute( position, index1 );
                        vertices.push( vertex.x, vertex.y, vertex.z );
    
                        index2 = 3 * i + ( ( j + 1 ) % 3 );
                        vertex.fromBufferAttribute( position, index2 );
                        vertices.push( vertex.x, vertex.y, vertex.z );
    
                    }
    
                }
    
            }
    
        }
    
        // build geometry
    
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    
    }
    
    WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
    WireframeGeometry.prototype.constructor = WireframeGeometry;
    
    /**
     * @author zz85 / https://github.com/zz85
     * @author Mugen87 / https://github.com/Mugen87
     *
     * Parametric Surfaces Geometry
     * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
     */
    
    // ParametricGeometry
    
    function ParametricGeometry( func, slices, stacks ) {
    
        Geometry.call( this );
    
        this.type = 'ParametricGeometry';
    
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
    
        this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
        this.mergeVertices();
    
    }
    
    ParametricGeometry.prototype = Object.create( Geometry.prototype );
    ParametricGeometry.prototype.constructor = ParametricGeometry;
    
    // ParametricBufferGeometry
    
    function ParametricBufferGeometry( func, slices, stacks ) {
    
        BufferGeometry.call( this );
    
        this.type = 'ParametricBufferGeometry';
    
        this.parameters = {
            func: func,
            slices: slices,
            stacks: stacks
        };
    
        // buffers
    
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
    
        var EPS = 0.00001;
    
        var normal = new Vector3();
    
        var p0 = new Vector3(), p1 = new Vector3();
        var pu = new Vector3(), pv = new Vector3();
    
        var i, j;
    
        if ( func.length < 3 ) {
    
            console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );
    
        }
    
        // generate vertices, normals and uvs
    
        var sliceCount = slices + 1;
    
        for ( i = 0; i <= stacks; i ++ ) {
    
            var v = i / stacks;
    
            for ( j = 0; j <= slices; j ++ ) {
    
                var u = j / slices;
    
                // vertex
    
                func( u, v, p0 );
                vertices.push( p0.x, p0.y, p0.z );
    
                // normal
    
                // approximate tangent vectors via finite differences
    
                if ( u - EPS >= 0 ) {
    
                    func( u - EPS, v, p1 );
                    pu.subVectors( p0, p1 );
    
                } else {
    
                    func( u + EPS, v, p1 );
                    pu.subVectors( p1, p0 );
    
                }
    
                if ( v - EPS >= 0 ) {
    
                    func( u, v - EPS, p1 );
                    pv.subVectors( p0, p1 );
    
                } else {
    
                    func( u, v + EPS, p1 );
                    pv.subVectors( p1, p0 );
    
                }
    
                // cross product of tangent vectors returns surface normal
    
                normal.crossVectors( pu, pv ).normalize();
                normals.push( normal.x, normal.y, normal.z );
    
                // uv
    
                uvs.push( u, v );
    
            }
    
        }
    
        // generate indices
    
        for ( i = 0; i < stacks; i ++ ) {
    
            for ( j = 0; j < slices; j ++ ) {
    
                var a = i * sliceCount + j;
                var b = i * sliceCount + j + 1;
                var c = ( i + 1 ) * sliceCount + j + 1;
                var d = ( i + 1 ) * sliceCount + j;
    
                // faces one and two
    
                indices.push( a, b, d );
                indices.push( b, c, d );
    
            }
    
        }
    
        // build geometry
    
        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
    }
    
    ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
    
    /**
     * @author clockworkgeek / https://github.com/clockworkgeek
     * @author timothypratley / https://github.com/timothypratley
     * @author WestLangley / http://github.com/WestLangley
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // PolyhedronGeometry
    
    function PolyhedronGeometry( vertices, indices, radius, detail ) {
    
        Geometry.call( this );
    
        this.type = 'PolyhedronGeometry';
    
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };
    
        this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
        this.mergeVertices();
    
    }
    
    PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
    
    // PolyhedronBufferGeometry
    
    function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {
    
        BufferGeometry.call( this );
    
        this.type = 'PolyhedronBufferGeometry';
    
        this.parameters = {
            vertices: vertices,
            indices: indices,
            radius: radius,
            detail: detail
        };
    
        radius = radius || 1;
        detail = detail || 0;
    
        // default buffer data
    
        var vertexBuffer = [];
        var uvBuffer = [];
    
        // the subdivision creates the vertex buffer data
    
        subdivide( detail );
    
        // all vertices should lie on a conceptual sphere with a given radius
    
        applyRadius( radius );
    
        // finally, create the uv data
    
        generateUVs();
    
        // build non-indexed geometry
    
        this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );
    
        if ( detail === 0 ) {
    
            this.computeVertexNormals(); // flat normals
    
        } else {
    
            this.normalizeNormals(); // smooth normals
    
        }
    
        // helper functions
    
        function subdivide( detail ) {
    
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
    
            // iterate over all faces and apply a subdivison with the given detail value
    
            for ( var i = 0; i < indices.length; i += 3 ) {
    
                // get the vertices of the face
    
                getVertexByIndex( indices[ i + 0 ], a );
                getVertexByIndex( indices[ i + 1 ], b );
                getVertexByIndex( indices[ i + 2 ], c );
    
                // perform subdivision
    
                subdivideFace( a, b, c, detail );
    
            }
    
        }
    
        function subdivideFace( a, b, c, detail ) {
    
            var cols = Math.pow( 2, detail );
    
            // we use this multidimensional array as a data structure for creating the subdivision
    
            var v = [];
    
            var i, j;
    
            // construct all of the vertices for this subdivision
    
            for ( i = 0; i <= cols; i ++ ) {
    
                v[ i ] = [];
    
                var aj = a.clone().lerp( c, i / cols );
                var bj = b.clone().lerp( c, i / cols );
    
                var rows = cols - i;
    
                for ( j = 0; j <= rows; j ++ ) {
    
                    if ( j === 0 && i === cols ) {
    
                        v[ i ][ j ] = aj;
    
                    } else {
    
                        v[ i ][ j ] = aj.clone().lerp( bj, j / rows );
    
                    }
    
                }
    
            }
    
            // construct all of the faces
    
            for ( i = 0; i < cols; i ++ ) {
    
                for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {
    
                    var k = Math.floor( j / 2 );
    
                    if ( j % 2 === 0 ) {
    
                        pushVertex( v[ i ][ k + 1 ] );
                        pushVertex( v[ i + 1 ][ k ] );
                        pushVertex( v[ i ][ k ] );
    
                    } else {
    
                        pushVertex( v[ i ][ k + 1 ] );
                        pushVertex( v[ i + 1 ][ k + 1 ] );
                        pushVertex( v[ i + 1 ][ k ] );
    
                    }
    
                }
    
            }
    
        }
    
        function applyRadius( radius ) {
    
            var vertex = new Vector3();
    
            // iterate over the entire buffer and apply the radius to each vertex
    
            for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
    
                vertex.x = vertexBuffer[ i + 0 ];
                vertex.y = vertexBuffer[ i + 1 ];
                vertex.z = vertexBuffer[ i + 2 ];
    
                vertex.normalize().multiplyScalar( radius );
    
                vertexBuffer[ i + 0 ] = vertex.x;
                vertexBuffer[ i + 1 ] = vertex.y;
                vertexBuffer[ i + 2 ] = vertex.z;
    
            }
    
        }
    
        function generateUVs() {
    
            var vertex = new Vector3();
    
            for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
    
                vertex.x = vertexBuffer[ i + 0 ];
                vertex.y = vertexBuffer[ i + 1 ];
                vertex.z = vertexBuffer[ i + 2 ];
    
                var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
                var v = inclination( vertex ) / Math.PI + 0.5;
                uvBuffer.push( u, 1 - v );
    
            }
    
            correctUVs();
    
            correctSeam();
    
        }
    
        function correctSeam() {
    
            // handle case when face straddles the seam, see #3269
    
            for ( var i = 0; i < uvBuffer.length; i += 6 ) {
    
                // uv data of a single face
    
                var x0 = uvBuffer[ i + 0 ];
                var x1 = uvBuffer[ i + 2 ];
                var x2 = uvBuffer[ i + 4 ];
    
                var max = Math.max( x0, x1, x2 );
                var min = Math.min( x0, x1, x2 );
    
                // 0.9 is somewhat arbitrary
    
                if ( max > 0.9 && min < 0.1 ) {
    
                    if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
                    if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
                    if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;
    
                }
    
            }
    
        }
    
        function pushVertex( vertex ) {
    
            vertexBuffer.push( vertex.x, vertex.y, vertex.z );
    
        }
    
        function getVertexByIndex( index, vertex ) {
    
            var stride = index * 3;
    
            vertex.x = vertices[ stride + 0 ];
            vertex.y = vertices[ stride + 1 ];
            vertex.z = vertices[ stride + 2 ];
    
        }
    
        function correctUVs() {
    
            var a = new Vector3();
            var b = new Vector3();
            var c = new Vector3();
    
            var centroid = new Vector3();
    
            var uvA = new Vector2();
            var uvB = new Vector2();
            var uvC = new Vector2();
    
            for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {
    
                a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
                b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
                c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );
    
                uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
                uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
                uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );
    
                centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );
    
                var azi = azimuth( centroid );
    
                correctUV( uvA, j + 0, a, azi );
                correctUV( uvB, j + 2, b, azi );
                correctUV( uvC, j + 4, c, azi );
    
            }
    
        }
    
        function correctUV( uv, stride, vector, azimuth ) {
    
            if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {
    
                uvBuffer[ stride ] = uv.x - 1;
    
            }
    
            if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {
    
                uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;
    
            }
    
        }
    
        // Angle around the Y axis, counter-clockwise when looking from above.
    
        function azimuth( vector ) {
    
            return Math.atan2( vector.z, - vector.x );
    
        }
    
    
        // Angle above the XZ plane.
    
        function inclination( vector ) {
    
            return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
    
        }
    
    }
    
    PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
    
    /**
     * @author timothypratley / https://github.com/timothypratley
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // TetrahedronGeometry
    
    function TetrahedronGeometry( radius, detail ) {
    
        Geometry.call( this );
    
        this.type = 'TetrahedronGeometry';
    
        this.parameters = {
            radius: radius,
            detail: detail
        };
    
        this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
        this.mergeVertices();
    
    }
    
    TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
    
    // TetrahedronBufferGeometry
    
    function TetrahedronBufferGeometry( radius, detail ) {
    
        var vertices = [
            1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
        ];
    
        var indices = [
            2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
        ];
    
        PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
    
        this.type = 'TetrahedronBufferGeometry';
    
        this.parameters = {
            radius: radius,
            detail: detail
        };
    
    }
    
    TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
    TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
    
    /**
     * @author timothypratley / https://github.com/timothypratley
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // OctahedronGeometry
    
    function OctahedronGeometry( radius, detail ) {
    
        Geometry.call( this );
    
        this.type = 'OctahedronGeometry';
    
        this.parameters = {
            radius: radius,
            detail: detail
        };
    
        this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
        this.mergeVertices();
    
    }
    
    OctahedronGeometry.prototype = Object.create( Geometry.prototype );
    OctahedronGeometry.prototype.constructor = OctahedronGeometry;
    
    // OctahedronBufferGeometry
    
    function OctahedronBufferGeometry( radius, detail ) {
    
        var vertices = [
            1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
            0, - 1, 0, 	0, 0, 1,	0, 0, - 1
        ];
    
        var indices = [
            0, 2, 4,	0, 4, 3,	0, 3, 5,
            0, 5, 2,	1, 2, 5,	1, 5, 3,
            1, 3, 4,	1, 4, 2
        ];
    
        PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
    
        this.type = 'OctahedronBufferGeometry';
    
        this.parameters = {
            radius: radius,
            detail: detail
        };
    
    }
    
    OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
    OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
    
    /**
     * @author timothypratley / https://github.com/timothypratley
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // IcosahedronGeometry
    
    function IcosahedronGeometry( radius, detail ) {
    
        Geometry.call( this );
    
        this.type = 'IcosahedronGeometry';
    
        this.parameters = {
            radius: radius,
            detail: detail
        };
    
        this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
        this.mergeVertices();
    
    }
    
    IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
    
    // IcosahedronBufferGeometry
    
    function IcosahedronBufferGeometry( radius, detail ) {
    
        var t = ( 1 + Math.sqrt( 5 ) ) / 2;
    
        var vertices = [
            - 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
             0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
             t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
        ];
    
        var indices = [
             0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
             1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
             3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
             4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
        ];
    
        PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
    
        this.type = 'IcosahedronBufferGeometry';
    
        this.parameters = {
            radius: radius,
            detail: detail
        };
    
    }
    
    IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
    IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
    
    /**
     * @author Abe Pazos / https://hamoid.com
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // DodecahedronGeometry
    
    function DodecahedronGeometry( radius, detail ) {
    
        Geometry.call( this );
    
        this.type = 'DodecahedronGeometry';
    
        this.parameters = {
            radius: radius,
            detail: detail
        };
    
        this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
        this.mergeVertices();
    
    }
    
    DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
    
    // DodecahedronBufferGeometry
    
    function DodecahedronBufferGeometry( radius, detail ) {
    
        var t = ( 1 + Math.sqrt( 5 ) ) / 2;
        var r = 1 / t;
    
        var vertices = [
    
            // (±1, ±1, ±1)
            - 1, - 1, - 1,	- 1, - 1, 1,
            - 1, 1, - 1, - 1, 1, 1,
            1, - 1, - 1, 1, - 1, 1,
            1, 1, - 1, 1, 1, 1,
    
            // (0, ±1/φ, ±φ)
             0, - r, - t, 0, - r, t,
             0, r, - t, 0, r, t,
    
            // (±1/φ, ±φ, 0)
            - r, - t, 0, - r, t, 0,
             r, - t, 0, r, t, 0,
    
            // (±φ, 0, ±1/φ)
            - t, 0, - r, t, 0, - r,
            - t, 0, r, t, 0, r
        ];
    
        var indices = [
            3, 11, 7, 	3, 7, 15, 	3, 15, 13,
            7, 19, 17, 	7, 17, 6, 	7, 6, 15,
            17, 4, 8, 	17, 8, 10, 	17, 10, 6,
            8, 0, 16, 	8, 16, 2, 	8, 2, 10,
            0, 12, 1, 	0, 1, 18, 	0, 18, 16,
            6, 10, 2, 	6, 2, 13, 	6, 13, 15,
            2, 16, 18, 	2, 18, 3, 	2, 3, 13,
            18, 1, 9, 	18, 9, 11, 	18, 11, 3,
            4, 14, 12, 	4, 12, 0, 	4, 0, 8,
            11, 9, 5, 	11, 5, 19, 	11, 19, 7,
            19, 5, 14, 	19, 14, 4, 	19, 4, 17,
            1, 12, 14, 	1, 14, 5, 	1, 5, 9
        ];
    
        PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
    
        this.type = 'DodecahedronBufferGeometry';
    
        this.parameters = {
            radius: radius,
            detail: detail
        };
    
    }
    
    DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
    DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
    
    /**
     * @author oosmoxiecode / https://github.com/oosmoxiecode
     * @author WestLangley / https://github.com/WestLangley
     * @author zz85 / https://github.com/zz85
     * @author miningold / https://github.com/miningold
     * @author jonobr1 / https://github.com/jonobr1
     * @author Mugen87 / https://github.com/Mugen87
     *
     */
    
    // TubeGeometry
    
    function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {
    
        Geometry.call( this );
    
        this.type = 'TubeGeometry';
    
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
    
        if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );
    
        var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );
    
        // expose internals
    
        this.tangents = bufferGeometry.tangents;
        this.normals = bufferGeometry.normals;
        this.binormals = bufferGeometry.binormals;
    
        // create geometry
    
        this.fromBufferGeometry( bufferGeometry );
        this.mergeVertices();
    
    }
    
    TubeGeometry.prototype = Object.create( Geometry.prototype );
    TubeGeometry.prototype.constructor = TubeGeometry;
    
    // TubeBufferGeometry
    
    function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {
    
        BufferGeometry.call( this );
    
        this.type = 'TubeBufferGeometry';
    
        this.parameters = {
            path: path,
            tubularSegments: tubularSegments,
            radius: radius,
            radialSegments: radialSegments,
            closed: closed
        };
    
        tubularSegments = tubularSegments || 64;
        radius = radius || 1;
        radialSegments = radialSegments || 8;
        closed = closed || false;
    
        var frames = path.computeFrenetFrames( tubularSegments, closed );
    
        // expose internals
    
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
    
        // helper variables
    
        var vertex = new Vector3();
        var normal = new Vector3();
        var uv = new Vector2();
        var P = new Vector3();
    
        var i, j;
    
        // buffer
    
        var vertices = [];
        var normals = [];
        var uvs = [];
        var indices = [];
    
        // create buffer data
    
        generateBufferData();
    
        // build geometry
    
        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
        // functions
    
        function generateBufferData() {
    
            for ( i = 0; i < tubularSegments; i ++ ) {
    
                generateSegment( i );
    
            }
    
            // if the geometry is not closed, generate the last row of vertices and normals
            // at the regular position on the given path
            //
            // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
    
            generateSegment( ( closed === false ) ? tubularSegments : 0 );
    
            // uvs are generated in a separate function.
            // this makes it easy compute correct values for closed geometries
    
            generateUVs();
    
            // finally create faces
    
            generateIndices();
    
        }
    
        function generateSegment( i ) {
    
            // we use getPointAt to sample evenly distributed points from the given path
    
            P = path.getPointAt( i / tubularSegments, P );
    
            // retrieve corresponding normal and binormal
    
            var N = frames.normals[ i ];
            var B = frames.binormals[ i ];
    
            // generate normals and vertices for the current segment
    
            for ( j = 0; j <= radialSegments; j ++ ) {
    
                var v = j / radialSegments * Math.PI * 2;
    
                var sin = Math.sin( v );
                var cos = - Math.cos( v );
    
                // normal
    
                normal.x = ( cos * N.x + sin * B.x );
                normal.y = ( cos * N.y + sin * B.y );
                normal.z = ( cos * N.z + sin * B.z );
                normal.normalize();
    
                normals.push( normal.x, normal.y, normal.z );
    
                // vertex
    
                vertex.x = P.x + radius * normal.x;
                vertex.y = P.y + radius * normal.y;
                vertex.z = P.z + radius * normal.z;
    
                vertices.push( vertex.x, vertex.y, vertex.z );
    
            }
    
        }
    
        function generateIndices() {
    
            for ( j = 1; j <= tubularSegments; j ++ ) {
    
                for ( i = 1; i <= radialSegments; i ++ ) {
    
                    var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
                    var b = ( radialSegments + 1 ) * j + ( i - 1 );
                    var c = ( radialSegments + 1 ) * j + i;
                    var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
    
                    // faces
    
                    indices.push( a, b, d );
                    indices.push( b, c, d );
    
                }
    
            }
    
        }
    
        function generateUVs() {
    
            for ( i = 0; i <= tubularSegments; i ++ ) {
    
                for ( j = 0; j <= radialSegments; j ++ ) {
    
                    uv.x = i / tubularSegments;
                    uv.y = j / radialSegments;
    
                    uvs.push( uv.x, uv.y );
    
                }
    
            }
    
        }
    
    }
    
    TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
    
    TubeBufferGeometry.prototype.toJSON = function () {
    
        var data = BufferGeometry.prototype.toJSON.call( this );
    
        data.path = this.parameters.path.toJSON();
    
        return data;
    
    };
    
    /**
     * @author oosmoxiecode
     * @author Mugen87 / https://github.com/Mugen87
     *
     * based on http://www.blackpawn.com/texts/pqtorus/
     */
    
    // TorusKnotGeometry
    
    function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {
    
        Geometry.call( this );
    
        this.type = 'TorusKnotGeometry';
    
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
    
        if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );
    
        this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
        this.mergeVertices();
    
    }
    
    TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
    
    // TorusKnotBufferGeometry
    
    function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {
    
        BufferGeometry.call( this );
    
        this.type = 'TorusKnotBufferGeometry';
    
        this.parameters = {
            radius: radius,
            tube: tube,
            tubularSegments: tubularSegments,
            radialSegments: radialSegments,
            p: p,
            q: q
        };
    
        radius = radius || 1;
        tube = tube || 0.4;
        tubularSegments = Math.floor( tubularSegments ) || 64;
        radialSegments = Math.floor( radialSegments ) || 8;
        p = p || 2;
        q = q || 3;
    
        // buffers
    
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
    
        // helper variables
    
        var i, j;
    
        var vertex = new Vector3();
        var normal = new Vector3();
    
        var P1 = new Vector3();
        var P2 = new Vector3();
    
        var B = new Vector3();
        var T = new Vector3();
        var N = new Vector3();
    
        // generate vertices, normals and uvs
    
        for ( i = 0; i <= tubularSegments; ++ i ) {
    
            // the radian "u" is used to calculate the position on the torus curve of the current tubular segement
    
            var u = i / tubularSegments * p * Math.PI * 2;
    
            // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
            // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
    
            calculatePositionOnCurve( u, p, q, radius, P1 );
            calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );
    
            // calculate orthonormal basis
    
            T.subVectors( P2, P1 );
            N.addVectors( P2, P1 );
            B.crossVectors( T, N );
            N.crossVectors( B, T );
    
            // normalize B, N. T can be ignored, we don't use it
    
            B.normalize();
            N.normalize();
    
            for ( j = 0; j <= radialSegments; ++ j ) {
    
                // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
    
                var v = j / radialSegments * Math.PI * 2;
                var cx = - tube * Math.cos( v );
                var cy = tube * Math.sin( v );
    
                // now calculate the final vertex position.
                // first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
    
                vertex.x = P1.x + ( cx * N.x + cy * B.x );
                vertex.y = P1.y + ( cx * N.y + cy * B.y );
                vertex.z = P1.z + ( cx * N.z + cy * B.z );
    
                vertices.push( vertex.x, vertex.y, vertex.z );
    
                // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
    
                normal.subVectors( vertex, P1 ).normalize();
    
                normals.push( normal.x, normal.y, normal.z );
    
                // uv
    
                uvs.push( i / tubularSegments );
                uvs.push( j / radialSegments );
    
            }
    
        }
    
        // generate indices
    
        for ( j = 1; j <= tubularSegments; j ++ ) {
    
            for ( i = 1; i <= radialSegments; i ++ ) {
    
                // indices
    
                var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
                var b = ( radialSegments + 1 ) * j + ( i - 1 );
                var c = ( radialSegments + 1 ) * j + i;
                var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
    
                // faces
    
                indices.push( a, b, d );
                indices.push( b, c, d );
    
            }
    
        }
    
        // build geometry
    
        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
        // this function calculates the current position on the torus curve
    
        function calculatePositionOnCurve( u, p, q, radius, position ) {
    
            var cu = Math.cos( u );
            var su = Math.sin( u );
            var quOverP = q / p * u;
            var cs = Math.cos( quOverP );
    
            position.x = radius * ( 2 + cs ) * 0.5 * cu;
            position.y = radius * ( 2 + cs ) * su * 0.5;
            position.z = radius * Math.sin( quOverP ) * 0.5;
    
        }
    
    }
    
    TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
    
    /**
     * @author oosmoxiecode
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // TorusGeometry
    
    function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
    
        Geometry.call( this );
    
        this.type = 'TorusGeometry';
    
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
    
        this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
        this.mergeVertices();
    
    }
    
    TorusGeometry.prototype = Object.create( Geometry.prototype );
    TorusGeometry.prototype.constructor = TorusGeometry;
    
    // TorusBufferGeometry
    
    function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
    
        BufferGeometry.call( this );
    
        this.type = 'TorusBufferGeometry';
    
        this.parameters = {
            radius: radius,
            tube: tube,
            radialSegments: radialSegments,
            tubularSegments: tubularSegments,
            arc: arc
        };
    
        radius = radius || 1;
        tube = tube || 0.4;
        radialSegments = Math.floor( radialSegments ) || 8;
        tubularSegments = Math.floor( tubularSegments ) || 6;
        arc = arc || Math.PI * 2;
    
        // buffers
    
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
    
        // helper variables
    
        var center = new Vector3();
        var vertex = new Vector3();
        var normal = new Vector3();
    
        var j, i;
    
        // generate vertices, normals and uvs
    
        for ( j = 0; j <= radialSegments; j ++ ) {
    
            for ( i = 0; i <= tubularSegments; i ++ ) {
    
                var u = i / tubularSegments * arc;
                var v = j / radialSegments * Math.PI * 2;
    
                // vertex
    
                vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
                vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
                vertex.z = tube * Math.sin( v );
    
                vertices.push( vertex.x, vertex.y, vertex.z );
    
                // normal
    
                center.x = radius * Math.cos( u );
                center.y = radius * Math.sin( u );
                normal.subVectors( vertex, center ).normalize();
    
                normals.push( normal.x, normal.y, normal.z );
    
                // uv
    
                uvs.push( i / tubularSegments );
                uvs.push( j / radialSegments );
    
            }
    
        }
    
        // generate indices
    
        for ( j = 1; j <= radialSegments; j ++ ) {
    
            for ( i = 1; i <= tubularSegments; i ++ ) {
    
                // indices
    
                var a = ( tubularSegments + 1 ) * j + i - 1;
                var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
                var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
                var d = ( tubularSegments + 1 ) * j + i;
    
                // faces
    
                indices.push( a, b, d );
                indices.push( b, c, d );
    
            }
    
        }
    
        // build geometry
    
        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
    }
    
    TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
    
    /**
     * @author Mugen87 / https://github.com/Mugen87
     * Port from https://github.com/mapbox/earcut (v2.1.5)
     */
    
    var Earcut = {
    
        triangulate: function ( data, holeIndices, dim ) {
    
            dim = dim || 2;
    
            var hasHoles = holeIndices && holeIndices.length,
                outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
                outerNode = linkedList( data, 0, outerLen, dim, true ),
                triangles = [];
    
            if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;
    
            var minX, minY, maxX, maxY, x, y, invSize;
    
            if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );
    
            // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
            if ( data.length > 80 * dim ) {
    
                minX = maxX = data[ 0 ];
                minY = maxY = data[ 1 ];
    
                for ( var i = dim; i < outerLen; i += dim ) {
    
                    x = data[ i ];
                    y = data[ i + 1 ];
                    if ( x < minX ) minX = x;
                    if ( y < minY ) minY = y;
                    if ( x > maxX ) maxX = x;
                    if ( y > maxY ) maxY = y;
    
                }
    
                // minX, minY and invSize are later used to transform coords into integers for z-order calculation
                invSize = Math.max( maxX - minX, maxY - minY );
                invSize = invSize !== 0 ? 1 / invSize : 0;
    
            }
    
            earcutLinked( outerNode, triangles, dim, minX, minY, invSize );
    
            return triangles;
    
        }
    
    };
    
    // create a circular doubly linked list from polygon points in the specified winding order
    function linkedList( data, start, end, dim, clockwise ) {
    
        var i, last;
    
        if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {
    
            for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );
    
        } else {
    
            for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );
    
        }
    
        if ( last && equals( last, last.next ) ) {
    
            removeNode( last );
            last = last.next;
    
        }
    
        return last;
    
    }
    
    // eliminate colinear or duplicate points
    function filterPoints( start, end ) {
    
        if ( ! start ) return start;
        if ( ! end ) end = start;
    
        var p = start,
            again;
        do {
    
            again = false;
    
            if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {
    
                removeNode( p );
                p = end = p.prev;
                if ( p === p.next ) break;
                again = true;
    
            } else {
    
                p = p.next;
    
            }
    
        } while ( again || p !== end );
    
        return end;
    
    }
    
    // main ear slicing loop which triangulates a polygon (given as a linked list)
    function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {
    
        if ( ! ear ) return;
    
        // interlink polygon nodes in z-order
        if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );
    
        var stop = ear,
            prev, next;
    
        // iterate through ears, slicing them one by one
        while ( ear.prev !== ear.next ) {
    
            prev = ear.prev;
            next = ear.next;
    
            if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {
    
                // cut off the triangle
                triangles.push( prev.i / dim );
                triangles.push( ear.i / dim );
                triangles.push( next.i / dim );
    
                removeNode( ear );
    
                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;
    
                continue;
    
            }
    
            ear = next;
    
            // if we looped through the whole remaining polygon and can't find any more ears
            if ( ear === stop ) {
    
                // try filtering points and slicing again
                if ( ! pass ) {
    
                    earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );
    
                    // if this didn't work, try curing all small self-intersections locally
    
                } else if ( pass === 1 ) {
    
                    ear = cureLocalIntersections( ear, triangles, dim );
                    earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );
    
                    // as a last resort, try splitting the remaining polygon into two
    
                } else if ( pass === 2 ) {
    
                    splitEarcut( ear, triangles, dim, minX, minY, invSize );
    
                }
    
                break;
    
            }
    
        }
    
    }
    
    // check whether a polygon node forms a valid ear with adjacent nodes
    function isEar( ear ) {
    
        var a = ear.prev,
            b = ear,
            c = ear.next;
    
        if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear
    
        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;
    
        while ( p !== ear.prev ) {
    
            if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
                area( p.prev, p, p.next ) >= 0 ) return false;
            p = p.next;
    
        }
    
        return true;
    
    }
    
    function isEarHashed( ear, minX, minY, invSize ) {
    
        var a = ear.prev,
            b = ear,
            c = ear.next;
    
        if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear
    
        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
            minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
            maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
            maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );
    
        // z-order range for the current triangle bbox;
        var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
            maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );
    
        var p = ear.prevZ,
            n = ear.nextZ;
    
        // look for points inside the triangle in both directions
        while ( p && p.z >= minZ && n && n.z <= maxZ ) {
    
            if ( p !== ear.prev && p !== ear.next &&
                pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
                area( p.prev, p, p.next ) >= 0 ) return false;
            p = p.prevZ;
    
            if ( n !== ear.prev && n !== ear.next &&
                pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
                area( n.prev, n, n.next ) >= 0 ) return false;
            n = n.nextZ;
    
        }
    
        // look for remaining points in decreasing z-order
        while ( p && p.z >= minZ ) {
    
            if ( p !== ear.prev && p !== ear.next &&
                pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
                area( p.prev, p, p.next ) >= 0 ) return false;
            p = p.prevZ;
    
        }
    
        // look for remaining points in increasing z-order
        while ( n && n.z <= maxZ ) {
    
            if ( n !== ear.prev && n !== ear.next &&
                pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
                area( n.prev, n, n.next ) >= 0 ) return false;
            n = n.nextZ;
    
        }
    
        return true;
    
    }
    
    // go through all polygon nodes and cure small local self-intersections
    function cureLocalIntersections( start, triangles, dim ) {
    
        var p = start;
        do {
    
            var a = p.prev,
                b = p.next.next;
    
            if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {
    
                triangles.push( a.i / dim );
                triangles.push( p.i / dim );
                triangles.push( b.i / dim );
    
                // remove two nodes involved
                removeNode( p );
                removeNode( p.next );
    
                p = start = b;
    
            }
    
            p = p.next;
    
        } while ( p !== start );
    
        return p;
    
    }
    
    // try splitting polygon into two and triangulate them independently
    function splitEarcut( start, triangles, dim, minX, minY, invSize ) {
    
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
    
            var b = a.next.next;
            while ( b !== a.prev ) {
    
                if ( a.i !== b.i && isValidDiagonal( a, b ) ) {
    
                    // split the polygon in two by the diagonal
                    var c = splitPolygon( a, b );
    
                    // filter colinear points around the cuts
                    a = filterPoints( a, a.next );
                    c = filterPoints( c, c.next );
    
                    // run earcut on each half
                    earcutLinked( a, triangles, dim, minX, minY, invSize );
                    earcutLinked( c, triangles, dim, minX, minY, invSize );
                    return;
    
                }
    
                b = b.next;
    
            }
    
            a = a.next;
    
        } while ( a !== start );
    
    }
    
    // link every hole into the outer loop, producing a single-ring polygon without holes
    function eliminateHoles( data, holeIndices, outerNode, dim ) {
    
        var queue = [],
            i, len, start, end, list;
    
        for ( i = 0, len = holeIndices.length; i < len; i ++ ) {
    
            start = holeIndices[ i ] * dim;
            end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
            list = linkedList( data, start, end, dim, false );
            if ( list === list.next ) list.steiner = true;
            queue.push( getLeftmost( list ) );
    
        }
    
        queue.sort( compareX );
    
        // process holes from left to right
        for ( i = 0; i < queue.length; i ++ ) {
    
            eliminateHole( queue[ i ], outerNode );
            outerNode = filterPoints( outerNode, outerNode.next );
    
        }
    
        return outerNode;
    
    }
    
    function compareX( a, b ) {
    
        return a.x - b.x;
    
    }
    
    // find a bridge between vertices that connects hole with an outer ring and and link it
    function eliminateHole( hole, outerNode ) {
    
        outerNode = findHoleBridge( hole, outerNode );
        if ( outerNode ) {
    
            var b = splitPolygon( outerNode, hole );
            filterPoints( b, b.next );
    
        }
    
    }
    
    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    function findHoleBridge( hole, outerNode ) {
    
        var p = outerNode,
            hx = hole.x,
            hy = hole.y,
            qx = - Infinity,
            m;
    
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
    
            if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {
    
                var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
                if ( x <= hx && x > qx ) {
    
                    qx = x;
                    if ( x === hx ) {
    
                        if ( hy === p.y ) return p;
                        if ( hy === p.next.y ) return p.next;
    
                    }
    
                    m = p.x < p.next.x ? p : p.next;
    
                }
    
            }
    
            p = p.next;
    
        } while ( p !== outerNode );
    
        if ( ! m ) return null;
    
        if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint
    
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
    
        var stop = m,
            mx = m.x,
            my = m.y,
            tanMin = Infinity,
            tan;
    
        p = m.next;
    
        while ( p !== stop ) {
    
            if ( hx >= p.x && p.x >= mx && hx !== p.x &&
                    pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {
    
                tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential
    
                if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {
    
                    m = p;
                    tanMin = tan;
    
                }
    
            }
    
            p = p.next;
    
        }
    
        return m;
    
    }
    
    // interlink polygon nodes in z-order
    function indexCurve( start, minX, minY, invSize ) {
    
        var p = start;
        do {
    
            if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
    
        } while ( p !== start );
    
        p.prevZ.nextZ = null;
        p.prevZ = null;
    
        sortLinked( p );
    
    }
    
    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    function sortLinked( list ) {
    
        var i, p, q, e, tail, numMerges, pSize, qSize,
            inSize = 1;
    
        do {
    
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
    
            while ( p ) {
    
                numMerges ++;
                q = p;
                pSize = 0;
                for ( i = 0; i < inSize; i ++ ) {
    
                    pSize ++;
                    q = q.nextZ;
                    if ( ! q ) break;
    
                }
    
                qSize = inSize;
    
                while ( pSize > 0 || ( qSize > 0 && q ) ) {
    
                    if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {
    
                        e = p;
                        p = p.nextZ;
                        pSize --;
    
                    } else {
    
                        e = q;
                        q = q.nextZ;
                        qSize --;
    
                    }
    
                    if ( tail ) tail.nextZ = e;
                    else list = e;
    
                    e.prevZ = tail;
                    tail = e;
    
                }
    
                p = q;
    
            }
    
            tail.nextZ = null;
            inSize *= 2;
    
        } while ( numMerges > 1 );
    
        return list;
    
    }
    
    // z-order of a point given coords and inverse of the longer side of data bbox
    function zOrder( x, y, minX, minY, invSize ) {
    
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * ( x - minX ) * invSize;
        y = 32767 * ( y - minY ) * invSize;
    
        x = ( x | ( x << 8 ) ) & 0x00FF00FF;
        x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
        x = ( x | ( x << 2 ) ) & 0x33333333;
        x = ( x | ( x << 1 ) ) & 0x55555555;
    
        y = ( y | ( y << 8 ) ) & 0x00FF00FF;
        y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
        y = ( y | ( y << 2 ) ) & 0x33333333;
        y = ( y | ( y << 1 ) ) & 0x55555555;
    
        return x | ( y << 1 );
    
    }
    
    // find the leftmost node of a polygon ring
    function getLeftmost( start ) {
    
        var p = start,
            leftmost = start;
        do {
    
            if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
            p = p.next;
    
        } while ( p !== start );
    
        return leftmost;
    
    }
    
    // check if a point lies within a convex triangle
    function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {
    
        return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
               ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
               ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;
    
    }
    
    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    function isValidDiagonal( a, b ) {
    
        return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
               locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );
    
    }
    
    // signed area of a triangle
    function area( p, q, r ) {
    
        return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );
    
    }
    
    // check if two points are equal
    function equals( p1, p2 ) {
    
        return p1.x === p2.x && p1.y === p2.y;
    
    }
    
    // check if two segments intersect
    function intersects( p1, q1, p2, q2 ) {
    
        if ( ( equals( p1, p2 ) && equals( q1, q2 ) ) ||
            ( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;
        return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
               area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;
    
    }
    
    // check if a polygon diagonal intersects any polygon segments
    function intersectsPolygon( a, b ) {
    
        var p = a;
        do {
    
            if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    intersects( p, p.next, a, b ) ) return true;
            p = p.next;
    
        } while ( p !== a );
    
        return false;
    
    }
    
    // check if a polygon diagonal is locally inside the polygon
    function locallyInside( a, b ) {
    
        return area( a.prev, a, a.next ) < 0 ?
            area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
            area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;
    
    }
    
    // check if the middle point of a polygon diagonal is inside the polygon
    function middleInside( a, b ) {
    
        var p = a,
            inside = false,
            px = ( a.x + b.x ) / 2,
            py = ( a.y + b.y ) / 2;
        do {
    
            if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
                    ( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
                inside = ! inside;
            p = p.next;
    
        } while ( p !== a );
    
        return inside;
    
    }
    
    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    function splitPolygon( a, b ) {
    
        var a2 = new Node( a.i, a.x, a.y ),
            b2 = new Node( b.i, b.x, b.y ),
            an = a.next,
            bp = b.prev;
    
        a.next = b;
        b.prev = a;
    
        a2.next = an;
        an.prev = a2;
    
        b2.next = a2;
        a2.prev = b2;
    
        bp.next = b2;
        b2.prev = bp;
    
        return b2;
    
    }
    
    // create a node and optionally link it with previous one (in a circular doubly linked list)
    function insertNode( i, x, y, last ) {
    
        var p = new Node( i, x, y );
    
        if ( ! last ) {
    
            p.prev = p;
            p.next = p;
    
        } else {
    
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
    
        }
    
        return p;
    
    }
    
    function removeNode( p ) {
    
        p.next.prev = p.prev;
        p.prev.next = p.next;
    
        if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
        if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;
    
    }
    
    function Node( i, x, y ) {
    
        // vertex index in coordinates array
        this.i = i;
    
        // vertex coordinates
        this.x = x;
        this.y = y;
    
        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;
    
        // z-order curve value
        this.z = null;
    
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
    
        // indicates whether this is a steiner point
        this.steiner = false;
    
    }
    
    function signedArea( data, start, end, dim ) {
    
        var sum = 0;
        for ( var i = start, j = end - dim; i < end; i += dim ) {
    
            sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
            j = i;
    
        }
    
        return sum;
    
    }
    
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */
    
    var ShapeUtils = {
    
        // calculate area of the contour polygon
    
        area: function ( contour ) {
    
            var n = contour.length;
            var a = 0.0;
    
            for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
    
                a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
    
            }
    
            return a * 0.5;
    
        },
    
        isClockWise: function ( pts ) {
    
            return ShapeUtils.area( pts ) < 0;
    
        },
    
        triangulateShape: function ( contour, holes ) {
    
            var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
            var holeIndices = []; // array of hole indices
            var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
    
            removeDupEndPts( contour );
            addContour( vertices, contour );
    
            //
    
            var holeIndex = contour.length;
    
            holes.forEach( removeDupEndPts );
    
            for ( var i = 0; i < holes.length; i ++ ) {
    
                holeIndices.push( holeIndex );
                holeIndex += holes[ i ].length;
                addContour( vertices, holes[ i ] );
    
            }
    
            //
    
            var triangles = Earcut.triangulate( vertices, holeIndices );
    
            //
    
            for ( var i = 0; i < triangles.length; i += 3 ) {
    
                faces.push( triangles.slice( i, i + 3 ) );
    
            }
    
            return faces;
    
        }
    
    };
    
    function removeDupEndPts( points ) {
    
        var l = points.length;
    
        if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {
    
            points.pop();
    
        }
    
    }
    
    function addContour( vertices, contour ) {
    
        for ( var i = 0; i < contour.length; i ++ ) {
    
            vertices.push( contour[ i ].x );
            vertices.push( contour[ i ].y );
    
        }
    
    }
    
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     * Creates extruded geometry from a path shape.
     *
     * parameters = {
     *
     *  curveSegments: <int>, // number of points on the curves
     *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
     *  depth: <float>, // Depth to extrude the shape
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into the original shape bevel goes
     *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
     *  bevelOffset: <float>, // how far from shape outline does bevel start
     *  bevelSegments: <int>, // number of bevel layers
     *
     *  extrudePath: <THREE.Curve> // curve to extrude shape along
     *
     *  UVGenerator: <Object> // object that provides UV generator functions
     *
     * }
     */
    
    // ExtrudeGeometry
    
    function ExtrudeGeometry( shapes, options ) {
    
        Geometry.call( this );
    
        this.type = 'ExtrudeGeometry';
    
        this.parameters = {
            shapes: shapes,
            options: options
        };
    
        this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
        this.mergeVertices();
    
    }
    
    ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
    ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
    
    ExtrudeGeometry.prototype.toJSON = function () {
    
        var data = Geometry.prototype.toJSON.call( this );
    
        var shapes = this.parameters.shapes;
        var options = this.parameters.options;
    
        return toJSON( shapes, options, data );
    
    };
    
    // ExtrudeBufferGeometry
    
    function ExtrudeBufferGeometry( shapes, options ) {
    
        BufferGeometry.call( this );
    
        this.type = 'ExtrudeBufferGeometry';
    
        this.parameters = {
            shapes: shapes,
            options: options
        };
    
        shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
    
        var scope = this;
    
        var verticesArray = [];
        var uvArray = [];
    
        for ( var i = 0, l = shapes.length; i < l; i ++ ) {
    
            var shape = shapes[ i ];
            addShape( shape );
    
        }
    
        // build geometry
    
        this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );
    
        this.computeVertexNormals();
    
        // functions
    
        function addShape( shape ) {
    
            var placeholder = [];
    
            // options
    
            var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
            var steps = options.steps !== undefined ? options.steps : 1;
            var depth = options.depth !== undefined ? options.depth : 100;
    
            var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
            var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
            var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
            var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
            var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
    
            var extrudePath = options.extrudePath;
    
            var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
    
            // deprecated options
    
            if ( options.amount !== undefined ) {
    
                console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
                depth = options.amount;
    
            }
    
            //
    
            var extrudePts, extrudeByPath = false;
            var splineTube, binormal, normal, position2;
    
            if ( extrudePath ) {
    
                extrudePts = extrudePath.getSpacedPoints( steps );
    
                extrudeByPath = true;
                bevelEnabled = false; // bevels not supported for path extrusion
    
                // SETUP TNB variables
    
                // TODO1 - have a .isClosed in spline?
    
                splineTube = extrudePath.computeFrenetFrames( steps, false );
    
                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
    
                binormal = new Vector3();
                normal = new Vector3();
                position2 = new Vector3();
    
            }
    
            // Safeguards if bevels are not enabled
    
            if ( ! bevelEnabled ) {
    
                bevelSegments = 0;
                bevelThickness = 0;
                bevelSize = 0;
                bevelOffset = 0;
    
            }
    
            // Variables initialization
    
            var ahole, h, hl; // looping of holes
    
            var shapePoints = shape.extractPoints( curveSegments );
    
            var vertices = shapePoints.shape;
            var holes = shapePoints.holes;
    
            var reverse = ! ShapeUtils.isClockWise( vertices );
    
            if ( reverse ) {
    
                vertices = vertices.reverse();
    
                // Maybe we should also check if holes are in the opposite direction, just to be safe ...
    
                for ( h = 0, hl = holes.length; h < hl; h ++ ) {
    
                    ahole = holes[ h ];
    
                    if ( ShapeUtils.isClockWise( ahole ) ) {
    
                        holes[ h ] = ahole.reverse();
    
                    }
    
                }
    
            }
    
    
            var faces = ShapeUtils.triangulateShape( vertices, holes );
    
            /* Vertices */
    
            var contour = vertices; // vertices has all points but contour has only points of circumference
    
            for ( h = 0, hl = holes.length; h < hl; h ++ ) {
    
                ahole = holes[ h ];
    
                vertices = vertices.concat( ahole );
    
            }
    
    
            function scalePt2( pt, vec, size ) {
    
                if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );
    
                return vec.clone().multiplyScalar( size ).add( pt );
    
            }
    
            var b, bs, t, z,
                vert, vlen = vertices.length,
                face, flen = faces.length;
    
    
            // Find directions for point movement
    
    
            function getBevelVec( inPt, inPrev, inNext ) {
    
                // computes for inPt the corresponding point inPt' on a new contour
                //   shifted by 1 unit (length of normalized vector) to the left
                // if we walk along contour clockwise, this new contour is outside the old one
                //
                // inPt' is the intersection of the two lines parallel to the two
                //  adjacent edges of inPt at a distance of 1 unit on the left side.
    
                var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
    
                // good reading for geometry algorithms (here: line-line intersection)
                // http://geomalgorithms.com/a05-_intersect-1.html
    
                var v_prev_x = inPt.x - inPrev.x,
                    v_prev_y = inPt.y - inPrev.y;
                var v_next_x = inNext.x - inPt.x,
                    v_next_y = inNext.y - inPt.y;
    
                var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
    
                // check for collinear edges
                var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
    
                if ( Math.abs( collinear0 ) > Number.EPSILON ) {
    
                    // not collinear
    
                    // length of vectors for normalizing
    
                    var v_prev_len = Math.sqrt( v_prev_lensq );
                    var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
    
                    // shift adjacent points by unit vectors to the left
    
                    var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
                    var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
    
                    var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
                    var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
    
                    // scaling factor for v_prev to intersection point
    
                    var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
                            ( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
                        ( v_prev_x * v_next_y - v_prev_y * v_next_x );
    
                    // vector from inPt to intersection point
    
                    v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
                    v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
    
                    // Don't normalize!, otherwise sharp corners become ugly
                    //  but prevent crazy spikes
                    var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
                    if ( v_trans_lensq <= 2 ) {
    
                        return new Vector2( v_trans_x, v_trans_y );
    
                    } else {
    
                        shrink_by = Math.sqrt( v_trans_lensq / 2 );
    
                    }
    
                } else {
    
                    // handle special case of collinear edges
    
                    var direction_eq = false; // assumes: opposite
                    if ( v_prev_x > Number.EPSILON ) {
    
                        if ( v_next_x > Number.EPSILON ) {
    
                            direction_eq = true;
    
                        }
    
                    } else {
    
                        if ( v_prev_x < - Number.EPSILON ) {
    
                            if ( v_next_x < - Number.EPSILON ) {
    
                                direction_eq = true;
    
                            }
    
                        } else {
    
                            if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
    
                                direction_eq = true;
    
                            }
    
                        }
    
                    }
    
                    if ( direction_eq ) {
    
                        // console.log("Warning: lines are a straight sequence");
                        v_trans_x = - v_prev_y;
                        v_trans_y = v_prev_x;
                        shrink_by = Math.sqrt( v_prev_lensq );
    
                    } else {
    
                        // console.log("Warning: lines are a straight spike");
                        v_trans_x = v_prev_x;
                        v_trans_y = v_prev_y;
                        shrink_by = Math.sqrt( v_prev_lensq / 2 );
    
                    }
    
                }
    
                return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
    
            }
    
    
            var contourMovements = [];
    
            for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
    
                if ( j === il ) j = 0;
                if ( k === il ) k = 0;
    
                //  (j)---(i)---(k)
                // console.log('i,j,k', i, j , k)
    
                contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
    
            }
    
            var holesMovements = [],
                oneHoleMovements, verticesMovements = contourMovements.concat();
    
            for ( h = 0, hl = holes.length; h < hl; h ++ ) {
    
                ahole = holes[ h ];
    
                oneHoleMovements = [];
    
                for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
    
                    if ( j === il ) j = 0;
                    if ( k === il ) k = 0;
    
                    //  (j)---(i)---(k)
                    oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
    
                }
    
                holesMovements.push( oneHoleMovements );
                verticesMovements = verticesMovements.concat( oneHoleMovements );
    
            }
    
    
            // Loop bevelSegments, 1 for the front, 1 for the back
    
            for ( b = 0; b < bevelSegments; b ++ ) {
    
                //for ( b = bevelSegments; b > 0; b -- ) {
    
                t = b / bevelSegments;
                z = bevelThickness * Math.cos( t * Math.PI / 2 );
                bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;
    
                // contract shape
    
                for ( i = 0, il = contour.length; i < il; i ++ ) {
    
                    vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
    
                    v( vert.x, vert.y, - z );
    
                }
    
                // expand holes
    
                for ( h = 0, hl = holes.length; h < hl; h ++ ) {
    
                    ahole = holes[ h ];
                    oneHoleMovements = holesMovements[ h ];
    
                    for ( i = 0, il = ahole.length; i < il; i ++ ) {
    
                        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
    
                        v( vert.x, vert.y, - z );
    
                    }
    
                }
    
            }
    
            bs = bevelSize + bevelOffset;
    
            // Back facing vertices
    
            for ( i = 0; i < vlen; i ++ ) {
    
                vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
    
                if ( ! extrudeByPath ) {
    
                    v( vert.x, vert.y, 0 );
    
                } else {
    
                    // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
    
                    normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
                    binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
    
                    position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
    
                    v( position2.x, position2.y, position2.z );
    
                }
    
            }
    
            // Add stepped vertices...
            // Including front facing vertices
    
            var s;
    
            for ( s = 1; s <= steps; s ++ ) {
    
                for ( i = 0; i < vlen; i ++ ) {
    
                    vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
    
                    if ( ! extrudeByPath ) {
    
                        v( vert.x, vert.y, depth / steps * s );
    
                    } else {
    
                        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
    
                        normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
                        binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
    
                        position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
    
                        v( position2.x, position2.y, position2.z );
    
                    }
    
                }
    
            }
    
    
            // Add bevel segments planes
    
            //for ( b = 1; b <= bevelSegments; b ++ ) {
            for ( b = bevelSegments - 1; b >= 0; b -- ) {
    
                t = b / bevelSegments;
                z = bevelThickness * Math.cos( t * Math.PI / 2 );
                bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;
    
                // contract shape
    
                for ( i = 0, il = contour.length; i < il; i ++ ) {
    
                    vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
                    v( vert.x, vert.y, depth + z );
    
                }
    
                // expand holes
    
                for ( h = 0, hl = holes.length; h < hl; h ++ ) {
    
                    ahole = holes[ h ];
                    oneHoleMovements = holesMovements[ h ];
    
                    for ( i = 0, il = ahole.length; i < il; i ++ ) {
    
                        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
    
                        if ( ! extrudeByPath ) {
    
                            v( vert.x, vert.y, depth + z );
    
                        } else {
    
                            v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
    
                        }
    
                    }
    
                }
    
            }
    
            /* Faces */
    
            // Top and bottom faces
    
            buildLidFaces();
    
            // Sides faces
    
            buildSideFaces();
    
    
            /////  Internal functions
    
            function buildLidFaces() {
    
                var start = verticesArray.length / 3;
    
                if ( bevelEnabled ) {
    
                    var layer = 0; // steps + 1
                    var offset = vlen * layer;
    
                    // Bottom faces
    
                    for ( i = 0; i < flen; i ++ ) {
    
                        face = faces[ i ];
                        f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
    
                    }
    
                    layer = steps + bevelSegments * 2;
                    offset = vlen * layer;
    
                    // Top faces
    
                    for ( i = 0; i < flen; i ++ ) {
    
                        face = faces[ i ];
                        f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
    
                    }
    
                } else {
    
                    // Bottom faces
    
                    for ( i = 0; i < flen; i ++ ) {
    
                        face = faces[ i ];
                        f3( face[ 2 ], face[ 1 ], face[ 0 ] );
    
                    }
    
                    // Top faces
    
                    for ( i = 0; i < flen; i ++ ) {
    
                        face = faces[ i ];
                        f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
    
                    }
    
                }
    
                scope.addGroup( start, verticesArray.length / 3 - start, 0 );
    
            }
    
            // Create faces for the z-sides of the shape
    
            function buildSideFaces() {
    
                var start = verticesArray.length / 3;
                var layeroffset = 0;
                sidewalls( contour, layeroffset );
                layeroffset += contour.length;
    
                for ( h = 0, hl = holes.length; h < hl; h ++ ) {
    
                    ahole = holes[ h ];
                    sidewalls( ahole, layeroffset );
    
                    //, true
                    layeroffset += ahole.length;
    
                }
    
    
                scope.addGroup( start, verticesArray.length / 3 - start, 1 );
    
    
            }
    
            function sidewalls( contour, layeroffset ) {
    
                var j, k;
                i = contour.length;
    
                while ( -- i >= 0 ) {
    
                    j = i;
                    k = i - 1;
                    if ( k < 0 ) k = contour.length - 1;
    
                    //console.log('b', i,j, i-1, k,vertices.length);
    
                    var s = 0,
                        sl = steps + bevelSegments * 2;
    
                    for ( s = 0; s < sl; s ++ ) {
    
                        var slen1 = vlen * s;
                        var slen2 = vlen * ( s + 1 );
    
                        var a = layeroffset + j + slen1,
                            b = layeroffset + k + slen1,
                            c = layeroffset + k + slen2,
                            d = layeroffset + j + slen2;
    
                        f4( a, b, c, d );
    
                    }
    
                }
    
            }
    
            function v( x, y, z ) {
    
                placeholder.push( x );
                placeholder.push( y );
                placeholder.push( z );
    
            }
    
    
            function f3( a, b, c ) {
    
                addVertex( a );
                addVertex( b );
                addVertex( c );
    
                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );
    
                addUV( uvs[ 0 ] );
                addUV( uvs[ 1 ] );
                addUV( uvs[ 2 ] );
    
            }
    
            function f4( a, b, c, d ) {
    
                addVertex( a );
                addVertex( b );
                addVertex( d );
    
                addVertex( b );
                addVertex( c );
                addVertex( d );
    
    
                var nextIndex = verticesArray.length / 3;
                var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );
    
                addUV( uvs[ 0 ] );
                addUV( uvs[ 1 ] );
                addUV( uvs[ 3 ] );
    
                addUV( uvs[ 1 ] );
                addUV( uvs[ 2 ] );
                addUV( uvs[ 3 ] );
    
            }
    
            function addVertex( index ) {
    
                verticesArray.push( placeholder[ index * 3 + 0 ] );
                verticesArray.push( placeholder[ index * 3 + 1 ] );
                verticesArray.push( placeholder[ index * 3 + 2 ] );
    
            }
    
    
            function addUV( vector2 ) {
    
                uvArray.push( vector2.x );
                uvArray.push( vector2.y );
    
            }
    
        }
    
    }
    
    ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
    
    ExtrudeBufferGeometry.prototype.toJSON = function () {
    
        var data = BufferGeometry.prototype.toJSON.call( this );
    
        var shapes = this.parameters.shapes;
        var options = this.parameters.options;
    
        return toJSON( shapes, options, data );
    
    };
    
    //
    
    var WorldUVGenerator = {
    
        generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {
    
            var a_x = vertices[ indexA * 3 ];
            var a_y = vertices[ indexA * 3 + 1 ];
            var b_x = vertices[ indexB * 3 ];
            var b_y = vertices[ indexB * 3 + 1 ];
            var c_x = vertices[ indexC * 3 ];
            var c_y = vertices[ indexC * 3 + 1 ];
    
            return [
                new Vector2( a_x, a_y ),
                new Vector2( b_x, b_y ),
                new Vector2( c_x, c_y )
            ];
    
        },
    
        generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {
    
            var a_x = vertices[ indexA * 3 ];
            var a_y = vertices[ indexA * 3 + 1 ];
            var a_z = vertices[ indexA * 3 + 2 ];
            var b_x = vertices[ indexB * 3 ];
            var b_y = vertices[ indexB * 3 + 1 ];
            var b_z = vertices[ indexB * 3 + 2 ];
            var c_x = vertices[ indexC * 3 ];
            var c_y = vertices[ indexC * 3 + 1 ];
            var c_z = vertices[ indexC * 3 + 2 ];
            var d_x = vertices[ indexD * 3 ];
            var d_y = vertices[ indexD * 3 + 1 ];
            var d_z = vertices[ indexD * 3 + 2 ];
    
            if ( Math.abs( a_y - b_y ) < 0.01 ) {
    
                return [
                    new Vector2( a_x, 1 - a_z ),
                    new Vector2( b_x, 1 - b_z ),
                    new Vector2( c_x, 1 - c_z ),
                    new Vector2( d_x, 1 - d_z )
                ];
    
            } else {
    
                return [
                    new Vector2( a_y, 1 - a_z ),
                    new Vector2( b_y, 1 - b_z ),
                    new Vector2( c_y, 1 - c_z ),
                    new Vector2( d_y, 1 - d_z )
                ];
    
            }
    
        }
    };
    
    function toJSON( shapes, options, data ) {
    
        //
    
        data.shapes = [];
    
        if ( Array.isArray( shapes ) ) {
    
            for ( var i = 0, l = shapes.length; i < l; i ++ ) {
    
                var shape = shapes[ i ];
    
                data.shapes.push( shape.uuid );
    
            }
    
        } else {
    
            data.shapes.push( shapes.uuid );
    
        }
    
        //
    
        if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();
    
        return data;
    
    }
    
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author alteredq / http://alteredqualia.com/
     *
     * Text = 3D Text
     *
     * parameters = {
     *  font: <THREE.Font>, // font
     *
     *  size: <float>, // size of the text
     *  height: <float>, // thickness to extrude text
     *  curveSegments: <int>, // number of points on the curves
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into text bevel goes
     *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
     *  bevelOffset: <float> // how far from text outline does bevel start
     * }
     */
    
    // TextGeometry
    
    function TextGeometry( text, parameters ) {
    
        Geometry.call( this );
    
        this.type = 'TextGeometry';
    
        this.parameters = {
            text: text,
            parameters: parameters
        };
    
        this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
        this.mergeVertices();
    
    }
    
    TextGeometry.prototype = Object.create( Geometry.prototype );
    TextGeometry.prototype.constructor = TextGeometry;
    
    // TextBufferGeometry
    
    function TextBufferGeometry( text, parameters ) {
    
        parameters = parameters || {};
    
        var font = parameters.font;
    
        if ( ! ( font && font.isFont ) ) {
    
            console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
            return new Geometry();
    
        }
    
        var shapes = font.generateShapes( text, parameters.size );
    
        // translate parameters to ExtrudeGeometry API
    
        parameters.depth = parameters.height !== undefined ? parameters.height : 50;
    
        // defaults
    
        if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
        if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
        if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
    
        ExtrudeBufferGeometry.call( this, shapes, parameters );
    
        this.type = 'TextBufferGeometry';
    
    }
    
    TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
    TextBufferGeometry.prototype.constructor = TextBufferGeometry;
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author benaadams / https://twitter.com/ben_a_adams
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // SphereGeometry
    
    function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
    
        Geometry.call( this );
    
        this.type = 'SphereGeometry';
    
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    
        this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
        this.mergeVertices();
    
    }
    
    SphereGeometry.prototype = Object.create( Geometry.prototype );
    SphereGeometry.prototype.constructor = SphereGeometry;
    
    // SphereBufferGeometry
    
    function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
    
        BufferGeometry.call( this );
    
        this.type = 'SphereBufferGeometry';
    
        this.parameters = {
            radius: radius,
            widthSegments: widthSegments,
            heightSegments: heightSegments,
            phiStart: phiStart,
            phiLength: phiLength,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    
        radius = radius || 1;
    
        widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
        heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
    
        phiStart = phiStart !== undefined ? phiStart : 0;
        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
    
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
    
        var thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );
    
        var ix, iy;
    
        var index = 0;
        var grid = [];
    
        var vertex = new Vector3();
        var normal = new Vector3();
    
        // buffers
    
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
    
        // generate vertices, normals and uvs
    
        for ( iy = 0; iy <= heightSegments; iy ++ ) {
    
            var verticesRow = [];
    
            var v = iy / heightSegments;
    
            // special case for the poles
    
            var uOffset = 0;
    
            if ( iy == 0 && thetaStart == 0 ) {
    
                uOffset = 0.5 / widthSegments;
    
            } else if ( iy == heightSegments && thetaEnd == Math.PI ) {
    
                uOffset = - 0.5 / widthSegments;
    
            }
    
            for ( ix = 0; ix <= widthSegments; ix ++ ) {
    
                var u = ix / widthSegments;
    
                // vertex
    
                vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
                vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
                vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
    
                vertices.push( vertex.x, vertex.y, vertex.z );
    
                // normal
    
                normal.copy( vertex ).normalize();
                normals.push( normal.x, normal.y, normal.z );
    
                // uv
    
                uvs.push( u + uOffset, 1 - v );
    
                verticesRow.push( index ++ );
    
            }
    
            grid.push( verticesRow );
    
        }
    
        // indices
    
        for ( iy = 0; iy < heightSegments; iy ++ ) {
    
            for ( ix = 0; ix < widthSegments; ix ++ ) {
    
                var a = grid[ iy ][ ix + 1 ];
                var b = grid[ iy ][ ix ];
                var c = grid[ iy + 1 ][ ix ];
                var d = grid[ iy + 1 ][ ix + 1 ];
    
                if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
                if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );
    
            }
    
        }
    
        // build geometry
    
        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
    }
    
    SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
    
    /**
     * @author Kaleb Murphy
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // RingGeometry
    
    function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
    
        Geometry.call( this );
    
        this.type = 'RingGeometry';
    
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    
        this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
        this.mergeVertices();
    
    }
    
    RingGeometry.prototype = Object.create( Geometry.prototype );
    RingGeometry.prototype.constructor = RingGeometry;
    
    // RingBufferGeometry
    
    function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
    
        BufferGeometry.call( this );
    
        this.type = 'RingBufferGeometry';
    
        this.parameters = {
            innerRadius: innerRadius,
            outerRadius: outerRadius,
            thetaSegments: thetaSegments,
            phiSegments: phiSegments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    
        innerRadius = innerRadius || 0.5;
        outerRadius = outerRadius || 1;
    
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    
        thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
        phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;
    
        // buffers
    
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
    
        // some helper variables
    
        var segment;
        var radius = innerRadius;
        var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
        var vertex = new Vector3();
        var uv = new Vector2();
        var j, i;
    
        // generate vertices, normals and uvs
    
        for ( j = 0; j <= phiSegments; j ++ ) {
    
            for ( i = 0; i <= thetaSegments; i ++ ) {
    
                // values are generate from the inside of the ring to the outside
    
                segment = thetaStart + i / thetaSegments * thetaLength;
    
                // vertex
    
                vertex.x = radius * Math.cos( segment );
                vertex.y = radius * Math.sin( segment );
    
                vertices.push( vertex.x, vertex.y, vertex.z );
    
                // normal
    
                normals.push( 0, 0, 1 );
    
                // uv
    
                uv.x = ( vertex.x / outerRadius + 1 ) / 2;
                uv.y = ( vertex.y / outerRadius + 1 ) / 2;
    
                uvs.push( uv.x, uv.y );
    
            }
    
            // increase the radius for next row of vertices
    
            radius += radiusStep;
    
        }
    
        // indices
    
        for ( j = 0; j < phiSegments; j ++ ) {
    
            var thetaSegmentLevel = j * ( thetaSegments + 1 );
    
            for ( i = 0; i < thetaSegments; i ++ ) {
    
                segment = i + thetaSegmentLevel;
    
                var a = segment;
                var b = segment + thetaSegments + 1;
                var c = segment + thetaSegments + 2;
                var d = segment + 1;
    
                // faces
    
                indices.push( a, b, d );
                indices.push( b, c, d );
    
            }
    
        }
    
        // build geometry
    
        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
    }
    
    RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    RingBufferGeometry.prototype.constructor = RingBufferGeometry;
    
    /**
     * @author zz85 / https://github.com/zz85
     * @author bhouston / http://clara.io
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // LatheGeometry
    
    function LatheGeometry( points, segments, phiStart, phiLength ) {
    
        Geometry.call( this );
    
        this.type = 'LatheGeometry';
    
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
    
        this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
        this.mergeVertices();
    
    }
    
    LatheGeometry.prototype = Object.create( Geometry.prototype );
    LatheGeometry.prototype.constructor = LatheGeometry;
    
    // LatheBufferGeometry
    
    function LatheBufferGeometry( points, segments, phiStart, phiLength ) {
    
        BufferGeometry.call( this );
    
        this.type = 'LatheBufferGeometry';
    
        this.parameters = {
            points: points,
            segments: segments,
            phiStart: phiStart,
            phiLength: phiLength
        };
    
        segments = Math.floor( segments ) || 12;
        phiStart = phiStart || 0;
        phiLength = phiLength || Math.PI * 2;
    
        // clamp phiLength so it's in range of [ 0, 2PI ]
    
        phiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );
    
    
        // buffers
    
        var indices = [];
        var vertices = [];
        var uvs = [];
    
        // helper variables
    
        var base;
        var inverseSegments = 1.0 / segments;
        var vertex = new Vector3();
        var uv = new Vector2();
        var i, j;
    
        // generate vertices and uvs
    
        for ( i = 0; i <= segments; i ++ ) {
    
            var phi = phiStart + i * inverseSegments * phiLength;
    
            var sin = Math.sin( phi );
            var cos = Math.cos( phi );
    
            for ( j = 0; j <= ( points.length - 1 ); j ++ ) {
    
                // vertex
    
                vertex.x = points[ j ].x * sin;
                vertex.y = points[ j ].y;
                vertex.z = points[ j ].x * cos;
    
                vertices.push( vertex.x, vertex.y, vertex.z );
    
                // uv
    
                uv.x = i / segments;
                uv.y = j / ( points.length - 1 );
    
                uvs.push( uv.x, uv.y );
    
    
            }
    
        }
    
        // indices
    
        for ( i = 0; i < segments; i ++ ) {
    
            for ( j = 0; j < ( points.length - 1 ); j ++ ) {
    
                base = j + i * points.length;
    
                var a = base;
                var b = base + points.length;
                var c = base + points.length + 1;
                var d = base + 1;
    
                // faces
    
                indices.push( a, b, d );
                indices.push( b, c, d );
    
            }
    
        }
    
        // build geometry
    
        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
        // generate normals
    
        this.computeVertexNormals();
    
        // if the geometry is closed, we need to average the normals along the seam.
        // because the corresponding vertices are identical (but still have different UVs).
    
        if ( phiLength === Math.PI * 2 ) {
    
            var normals = this.attributes.normal.array;
            var n1 = new Vector3();
            var n2 = new Vector3();
            var n = new Vector3();
    
            // this is the buffer offset for the last line of vertices
    
            base = segments * points.length * 3;
    
            for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {
    
                // select the normal of the vertex in the first line
    
                n1.x = normals[ j + 0 ];
                n1.y = normals[ j + 1 ];
                n1.z = normals[ j + 2 ];
    
                // select the normal of the vertex in the last line
    
                n2.x = normals[ base + j + 0 ];
                n2.y = normals[ base + j + 1 ];
                n2.z = normals[ base + j + 2 ];
    
                // average normals
    
                n.addVectors( n1, n2 ).normalize();
    
                // assign the new values to both normals
    
                normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
                normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
                normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;
    
            }
    
        }
    
    }
    
    LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
    
    /**
     * @author jonobr1 / http://jonobr1.com
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // ShapeGeometry
    
    function ShapeGeometry( shapes, curveSegments ) {
    
        Geometry.call( this );
    
        this.type = 'ShapeGeometry';
    
        if ( typeof curveSegments === 'object' ) {
    
            console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );
    
            curveSegments = curveSegments.curveSegments;
    
        }
    
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
    
        this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
        this.mergeVertices();
    
    }
    
    ShapeGeometry.prototype = Object.create( Geometry.prototype );
    ShapeGeometry.prototype.constructor = ShapeGeometry;
    
    ShapeGeometry.prototype.toJSON = function () {
    
        var data = Geometry.prototype.toJSON.call( this );
    
        var shapes = this.parameters.shapes;
    
        return toJSON$1( shapes, data );
    
    };
    
    // ShapeBufferGeometry
    
    function ShapeBufferGeometry( shapes, curveSegments ) {
    
        BufferGeometry.call( this );
    
        this.type = 'ShapeBufferGeometry';
    
        this.parameters = {
            shapes: shapes,
            curveSegments: curveSegments
        };
    
        curveSegments = curveSegments || 12;
    
        // buffers
    
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
    
        // helper variables
    
        var groupStart = 0;
        var groupCount = 0;
    
        // allow single and array values for "shapes" parameter
    
        if ( Array.isArray( shapes ) === false ) {
    
            addShape( shapes );
    
        } else {
    
            for ( var i = 0; i < shapes.length; i ++ ) {
    
                addShape( shapes[ i ] );
    
                this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support
    
                groupStart += groupCount;
                groupCount = 0;
    
            }
    
        }
    
        // build geometry
    
        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
    
        // helper functions
    
        function addShape( shape ) {
    
            var i, l, shapeHole;
    
            var indexOffset = vertices.length / 3;
            var points = shape.extractPoints( curveSegments );
    
            var shapeVertices = points.shape;
            var shapeHoles = points.holes;
    
            // check direction of vertices
    
            if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {
    
                shapeVertices = shapeVertices.reverse();
    
            }
    
            for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
    
                shapeHole = shapeHoles[ i ];
    
                if ( ShapeUtils.isClockWise( shapeHole ) === true ) {
    
                    shapeHoles[ i ] = shapeHole.reverse();
    
                }
    
            }
    
            var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );
    
            // join vertices of inner and outer paths to a single array
    
            for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
    
                shapeHole = shapeHoles[ i ];
                shapeVertices = shapeVertices.concat( shapeHole );
    
            }
    
            // vertices, normals, uvs
    
            for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {
    
                var vertex = shapeVertices[ i ];
    
                vertices.push( vertex.x, vertex.y, 0 );
                normals.push( 0, 0, 1 );
                uvs.push( vertex.x, vertex.y ); // world uvs
    
            }
    
            // incides
    
            for ( i = 0, l = faces.length; i < l; i ++ ) {
    
                var face = faces[ i ];
    
                var a = face[ 0 ] + indexOffset;
                var b = face[ 1 ] + indexOffset;
                var c = face[ 2 ] + indexOffset;
    
                indices.push( a, b, c );
                groupCount += 3;
    
            }
    
        }
    
    }
    
    ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
    
    ShapeBufferGeometry.prototype.toJSON = function () {
    
        var data = BufferGeometry.prototype.toJSON.call( this );
    
        var shapes = this.parameters.shapes;
    
        return toJSON$1( shapes, data );
    
    };
    
    //
    
    function toJSON$1( shapes, data ) {
    
        data.shapes = [];
    
        if ( Array.isArray( shapes ) ) {
    
            for ( var i = 0, l = shapes.length; i < l; i ++ ) {
    
                var shape = shapes[ i ];
    
                data.shapes.push( shape.uuid );
    
            }
    
        } else {
    
            data.shapes.push( shapes.uuid );
    
        }
    
        return data;
    
    }
    
    /**
     * @author WestLangley / http://github.com/WestLangley
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    function EdgesGeometry( geometry, thresholdAngle ) {
    
        BufferGeometry.call( this );
    
        this.type = 'EdgesGeometry';
    
        this.parameters = {
            thresholdAngle: thresholdAngle
        };
    
        thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
    
        // buffer
    
        var vertices = [];
    
        // helper variables
    
        var thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );
        var edge = [ 0, 0 ], edges = {}, edge1, edge2;
        var key, keys = [ 'a', 'b', 'c' ];
    
        // prepare source geometry
    
        var geometry2;
    
        if ( geometry.isBufferGeometry ) {
    
            geometry2 = new Geometry();
            geometry2.fromBufferGeometry( geometry );
    
        } else {
    
            geometry2 = geometry.clone();
    
        }
    
        geometry2.mergeVertices();
        geometry2.computeFaceNormals();
    
        var sourceVertices = geometry2.vertices;
        var faces = geometry2.faces;
    
        // now create a data structure where each entry represents an edge with its adjoining faces
    
        for ( var i = 0, l = faces.length; i < l; i ++ ) {
    
            var face = faces[ i ];
    
            for ( var j = 0; j < 3; j ++ ) {
    
                edge1 = face[ keys[ j ] ];
                edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
                edge[ 0 ] = Math.min( edge1, edge2 );
                edge[ 1 ] = Math.max( edge1, edge2 );
    
                key = edge[ 0 ] + ',' + edge[ 1 ];
    
                if ( edges[ key ] === undefined ) {
    
                    edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };
    
                } else {
    
                    edges[ key ].face2 = i;
    
                }
    
            }
    
        }
    
        // generate vertices
    
        for ( key in edges ) {
    
            var e = edges[ key ];
    
            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
    
            if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {
    
                var vertex = sourceVertices[ e.index1 ];
                vertices.push( vertex.x, vertex.y, vertex.z );
    
                vertex = sourceVertices[ e.index2 ];
                vertices.push( vertex.x, vertex.y, vertex.z );
    
            }
    
        }
    
        // build geometry
    
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
    
    }
    
    EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
    EdgesGeometry.prototype.constructor = EdgesGeometry;
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    // CylinderGeometry
    
    function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
    
        Geometry.call( this );
    
        this.type = 'CylinderGeometry';
    
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    
        this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
        this.mergeVertices();
    
    }
    
    CylinderGeometry.prototype = Object.create( Geometry.prototype );
    CylinderGeometry.prototype.constructor = CylinderGeometry;
    
    // CylinderBufferGeometry
    
    function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
    
        BufferGeometry.call( this );
    
        this.type = 'CylinderBufferGeometry';
    
        this.parameters = {
            radiusTop: radiusTop,
            radiusBottom: radiusBottom,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    
        var scope = this;
    
        radiusTop = radiusTop !== undefined ? radiusTop : 1;
        radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
        height = height || 1;
    
        radialSegments = Math.floor( radialSegments ) || 8;
        heightSegments = Math.floor( heightSegments ) || 1;
    
        openEnded = openEnded !== undefined ? openEnded : false;
        thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    
        // buffers
    
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
    
        // helper variables
    
        var index = 0;
        var indexArray = [];
        var halfHeight = height / 2;
        var groupStart = 0;
    
        // generate geometry
    
        generateTorso();
    
        if ( openEnded === false ) {
    
            if ( radiusTop > 0 ) generateCap( true );
            if ( radiusBottom > 0 ) generateCap( false );
    
        }
    
        // build geometry
    
        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
        function generateTorso() {
    
            var x, y;
            var normal = new Vector3();
            var vertex = new Vector3();
    
            var groupCount = 0;
    
            // this will be used to calculate the normal
            var slope = ( radiusBottom - radiusTop ) / height;
    
            // generate vertices, normals and uvs
    
            for ( y = 0; y <= heightSegments; y ++ ) {
    
                var indexRow = [];
    
                var v = y / heightSegments;
    
                // calculate the radius of the current row
    
                var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
    
                for ( x = 0; x <= radialSegments; x ++ ) {
    
                    var u = x / radialSegments;
    
                    var theta = u * thetaLength + thetaStart;
    
                    var sinTheta = Math.sin( theta );
                    var cosTheta = Math.cos( theta );
    
                    // vertex
    
                    vertex.x = radius * sinTheta;
                    vertex.y = - v * height + halfHeight;
                    vertex.z = radius * cosTheta;
                    vertices.push( vertex.x, vertex.y, vertex.z );
    
                    // normal
    
                    normal.set( sinTheta, slope, cosTheta ).normalize();
                    normals.push( normal.x, normal.y, normal.z );
    
                    // uv
    
                    uvs.push( u, 1 - v );
    
                    // save index of vertex in respective row
    
                    indexRow.push( index ++ );
    
                }
    
                // now save vertices of the row in our index array
    
                indexArray.push( indexRow );
    
            }
    
            // generate indices
    
            for ( x = 0; x < radialSegments; x ++ ) {
    
                for ( y = 0; y < heightSegments; y ++ ) {
    
                    // we use the index array to access the correct indices
    
                    var a = indexArray[ y ][ x ];
                    var b = indexArray[ y + 1 ][ x ];
                    var c = indexArray[ y + 1 ][ x + 1 ];
                    var d = indexArray[ y ][ x + 1 ];
    
                    // faces
    
                    indices.push( a, b, d );
                    indices.push( b, c, d );
    
                    // update group counter
    
                    groupCount += 6;
    
                }
    
            }
    
            // add a group to the geometry. this will ensure multi material support
    
            scope.addGroup( groupStart, groupCount, 0 );
    
            // calculate new start value for groups
    
            groupStart += groupCount;
    
        }
    
        function generateCap( top ) {
    
            var x, centerIndexStart, centerIndexEnd;
    
            var uv = new Vector2();
            var vertex = new Vector3();
    
            var groupCount = 0;
    
            var radius = ( top === true ) ? radiusTop : radiusBottom;
            var sign = ( top === true ) ? 1 : - 1;
    
            // save the index of the first center vertex
            centerIndexStart = index;
    
            // first we generate the center vertex data of the cap.
            // because the geometry needs one set of uvs per face,
            // we must generate a center vertex per face/segment
    
            for ( x = 1; x <= radialSegments; x ++ ) {
    
                // vertex
    
                vertices.push( 0, halfHeight * sign, 0 );
    
                // normal
    
                normals.push( 0, sign, 0 );
    
                // uv
    
                uvs.push( 0.5, 0.5 );
    
                // increase index
    
                index ++;
    
            }
    
            // save the index of the last center vertex
    
            centerIndexEnd = index;
    
            // now we generate the surrounding vertices, normals and uvs
    
            for ( x = 0; x <= radialSegments; x ++ ) {
    
                var u = x / radialSegments;
                var theta = u * thetaLength + thetaStart;
    
                var cosTheta = Math.cos( theta );
                var sinTheta = Math.sin( theta );
    
                // vertex
    
                vertex.x = radius * sinTheta;
                vertex.y = halfHeight * sign;
                vertex.z = radius * cosTheta;
                vertices.push( vertex.x, vertex.y, vertex.z );
    
                // normal
    
                normals.push( 0, sign, 0 );
    
                // uv
    
                uv.x = ( cosTheta * 0.5 ) + 0.5;
                uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
                uvs.push( uv.x, uv.y );
    
                // increase index
    
                index ++;
    
            }
    
            // generate indices
    
            for ( x = 0; x < radialSegments; x ++ ) {
    
                var c = centerIndexStart + x;
                var i = centerIndexEnd + x;
    
                if ( top === true ) {
    
                    // face top
    
                    indices.push( i, i + 1, c );
    
                } else {
    
                    // face bottom
    
                    indices.push( i + 1, i, c );
    
                }
    
                groupCount += 3;
    
            }
    
            // add a group to the geometry. this will ensure multi material support
    
            scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );
    
            // calculate new start value for groups
    
            groupStart += groupCount;
    
        }
    
    }
    
    CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
    
    /**
     * @author abelnation / http://github.com/abelnation
     */
    
    // ConeGeometry
    
    function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
    
        CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
    
        this.type = 'ConeGeometry';
    
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    
    }
    
    ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
    ConeGeometry.prototype.constructor = ConeGeometry;
    
    // ConeBufferGeometry
    
    function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
    
        CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
    
        this.type = 'ConeBufferGeometry';
    
        this.parameters = {
            radius: radius,
            height: height,
            radialSegments: radialSegments,
            heightSegments: heightSegments,
            openEnded: openEnded,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    
    }
    
    ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
    
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     * @author Mugen87 / https://github.com/Mugen87
     * @author hughes
     */
    
    // CircleGeometry
    
    function CircleGeometry( radius, segments, thetaStart, thetaLength ) {
    
        Geometry.call( this );
    
        this.type = 'CircleGeometry';
    
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    
        this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
        this.mergeVertices();
    
    }
    
    CircleGeometry.prototype = Object.create( Geometry.prototype );
    CircleGeometry.prototype.constructor = CircleGeometry;
    
    // CircleBufferGeometry
    
    function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {
    
        BufferGeometry.call( this );
    
        this.type = 'CircleBufferGeometry';
    
        this.parameters = {
            radius: radius,
            segments: segments,
            thetaStart: thetaStart,
            thetaLength: thetaLength
        };
    
        radius = radius || 1;
        segments = segments !== undefined ? Math.max( 3, segments ) : 8;
    
        thetaStart = thetaStart !== undefined ? thetaStart : 0;
        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    
        // buffers
    
        var indices = [];
        var vertices = [];
        var normals = [];
        var uvs = [];
    
        // helper variables
    
        var i, s;
        var vertex = new Vector3();
        var uv = new Vector2();
    
        // center point
    
        vertices.push( 0, 0, 0 );
        normals.push( 0, 0, 1 );
        uvs.push( 0.5, 0.5 );
    
        for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {
    
            var segment = thetaStart + s / segments * thetaLength;
    
            // vertex
    
            vertex.x = radius * Math.cos( segment );
            vertex.y = radius * Math.sin( segment );
    
            vertices.push( vertex.x, vertex.y, vertex.z );
    
            // normal
    
            normals.push( 0, 0, 1 );
    
            // uvs
    
            uv.x = ( vertices[ i ] / radius + 1 ) / 2;
            uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;
    
            uvs.push( uv.x, uv.y );
    
        }
    
        // indices
    
        for ( i = 1; i <= segments; i ++ ) {
    
            indices.push( i, i + 1, 0 );
    
        }
    
        // build geometry
    
        this.setIndex( indices );
        this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
        this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
    
    }
    
    CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
    
    
    
    var Geometries = /*#__PURE__*/Object.freeze({
        __proto__: null,
        WireframeGeometry: WireframeGeometry,
        ParametricGeometry: ParametricGeometry,
        ParametricBufferGeometry: ParametricBufferGeometry,
        TetrahedronGeometry: TetrahedronGeometry,
        TetrahedronBufferGeometry: TetrahedronBufferGeometry,
        OctahedronGeometry: OctahedronGeometry,
        OctahedronBufferGeometry: OctahedronBufferGeometry,
        IcosahedronGeometry: IcosahedronGeometry,
        IcosahedronBufferGeometry: IcosahedronBufferGeometry,
        DodecahedronGeometry: DodecahedronGeometry,
        DodecahedronBufferGeometry: DodecahedronBufferGeometry,
        PolyhedronGeometry: PolyhedronGeometry,
        PolyhedronBufferGeometry: PolyhedronBufferGeometry,
        TubeGeometry: TubeGeometry,
        TubeBufferGeometry: TubeBufferGeometry,
        TorusKnotGeometry: TorusKnotGeometry,
        TorusKnotBufferGeometry: TorusKnotBufferGeometry,
        TorusGeometry: TorusGeometry,
        TorusBufferGeometry: TorusBufferGeometry,
        TextGeometry: TextGeometry,
        TextBufferGeometry: TextBufferGeometry,
        SphereGeometry: SphereGeometry,
        SphereBufferGeometry: SphereBufferGeometry,
        RingGeometry: RingGeometry,
        RingBufferGeometry: RingBufferGeometry,
        PlaneGeometry: PlaneGeometry,
        PlaneBufferGeometry: PlaneBufferGeometry,
        LatheGeometry: LatheGeometry,
        LatheBufferGeometry: LatheBufferGeometry,
        ShapeGeometry: ShapeGeometry,
        ShapeBufferGeometry: ShapeBufferGeometry,
        ExtrudeGeometry: ExtrudeGeometry,
        ExtrudeBufferGeometry: ExtrudeBufferGeometry,
        EdgesGeometry: EdgesGeometry,
        ConeGeometry: ConeGeometry,
        ConeBufferGeometry: ConeBufferGeometry,
        CylinderGeometry: CylinderGeometry,
        CylinderBufferGeometry: CylinderBufferGeometry,
        CircleGeometry: CircleGeometry,
        CircleBufferGeometry: CircleBufferGeometry,
        BoxGeometry: BoxGeometry,
        BoxBufferGeometry: BoxBufferGeometry
    });
    
    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * parameters = {
     *  color: <THREE.Color>
     * }
     */
    
    function ShadowMaterial( parameters ) {
    
        Material.call( this );
    
        this.type = 'ShadowMaterial';
    
        this.color = new Color( 0x000000 );
        this.transparent = true;
    
        this.setValues( parameters );
    
    }
    
    ShadowMaterial.prototype = Object.create( Material.prototype );
    ShadowMaterial.prototype.constructor = ShadowMaterial;
    
    ShadowMaterial.prototype.isShadowMaterial = true;
    
    ShadowMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.color.copy( source.color );
    
        return this;
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function RawShaderMaterial( parameters ) {
    
        ShaderMaterial.call( this, parameters );
    
        this.type = 'RawShaderMaterial';
    
    }
    
    RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;
    
    RawShaderMaterial.prototype.isRawShaderMaterial = true;
    
    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  color: <hex>,
     *  roughness: <float>,
     *  metalness: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalMapType: THREE.TangentSpaceNormalMap,
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  roughnessMap: new THREE.Texture( <Image> ),
     *
     *  metalnessMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  envMapIntensity: <float>
     *
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    
    function MeshStandardMaterial( parameters ) {
    
        Material.call( this );
    
        this.defines = { 'STANDARD': '' };
    
        this.type = 'MeshStandardMaterial';
    
        this.color = new Color( 0xffffff ); // diffuse
        this.roughness = 1.0;
        this.metalness = 0.0;
    
        this.map = null;
    
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
    
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
    
        this.emissive = new Color( 0x000000 );
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
    
        this.bumpMap = null;
        this.bumpScale = 1;
    
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2( 1, 1 );
    
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
    
        this.roughnessMap = null;
    
        this.metalnessMap = null;
    
        this.alphaMap = null;
    
        this.envMap = null;
        this.envMapIntensity = 1.0;
    
        this.refractionRatio = 0.98;
    
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
    
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
    
        this.vertexTangents = false;
    
        this.setValues( parameters );
    
    }
    
    MeshStandardMaterial.prototype = Object.create( Material.prototype );
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
    
    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
    
    MeshStandardMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.defines = { 'STANDARD': '' };
    
        this.color.copy( source.color );
        this.roughness = source.roughness;
        this.metalness = source.metalness;
    
        this.map = source.map;
    
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
    
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
    
        this.emissive.copy( source.emissive );
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
    
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
    
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy( source.normalScale );
    
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
    
        this.roughnessMap = source.roughnessMap;
    
        this.metalnessMap = source.metalnessMap;
    
        this.alphaMap = source.alphaMap;
    
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
    
        this.refractionRatio = source.refractionRatio;
    
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
    
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
    
        this.vertexTangents = source.vertexTangents;
    
        return this;
    
    };
    
    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  reflectivity: <float>
     *  clearcoat: <float>
     *  clearcoatRoughness: <float>
     *
     *  sheen: <Color>
     *
     *  clearcoatNormalScale: <Vector2>,
     *  clearcoatNormalMap: new THREE.Texture( <Image> ),
     * }
     */
    
    function MeshPhysicalMaterial( parameters ) {
    
        MeshStandardMaterial.call( this );
    
        this.defines = {
    
            'STANDARD': '',
            'PHYSICAL': ''
    
        };
    
        this.type = 'MeshPhysicalMaterial';
    
        this.reflectivity = 0.5; // maps to F0 = 0.04
    
        this.clearcoat = 0.0;
        this.clearcoatRoughness = 0.0;
    
        this.sheen = null; // null will disable sheen bsdf
    
        this.clearcoatNormalScale = new Vector2( 1, 1 );
        this.clearcoatNormalMap = null;
    
        this.transparency = 0.0;
    
        this.setValues( parameters );
    
    }
    
    MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
    
    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
    
    MeshPhysicalMaterial.prototype.copy = function ( source ) {
    
        MeshStandardMaterial.prototype.copy.call( this, source );
    
        this.defines = {
    
            'STANDARD': '',
            'PHYSICAL': ''
    
        };
    
        this.reflectivity = source.reflectivity;
    
        this.clearcoat = source.clearcoat;
        this.clearcoatRoughness = source.clearcoatRoughness;
    
        if ( source.sheen ) this.sheen = ( this.sheen || new Color() ).copy( source.sheen );
        else this.sheen = null;
    
        this.clearcoatNormalMap = source.clearcoatNormalMap;
        this.clearcoatNormalScale.copy( source.clearcoatNormalScale );
    
        this.transparency = source.transparency;
    
        return this;
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  specular: <hex>,
     *  shininess: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalMapType: THREE.TangentSpaceNormalMap,
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.MultiplyOperation,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    
    function MeshPhongMaterial( parameters ) {
    
        Material.call( this );
    
        this.type = 'MeshPhongMaterial';
    
        this.color = new Color( 0xffffff ); // diffuse
        this.specular = new Color( 0x111111 );
        this.shininess = 30;
    
        this.map = null;
    
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
    
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
    
        this.emissive = new Color( 0x000000 );
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
    
        this.bumpMap = null;
        this.bumpScale = 1;
    
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2( 1, 1 );
    
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
    
        this.specularMap = null;
    
        this.alphaMap = null;
    
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
    
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
    
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
    
        this.setValues( parameters );
    
    }
    
    MeshPhongMaterial.prototype = Object.create( Material.prototype );
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
    
    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
    
    MeshPhongMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.color.copy( source.color );
        this.specular.copy( source.specular );
        this.shininess = source.shininess;
    
        this.map = source.map;
    
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
    
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
    
        this.emissive.copy( source.emissive );
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
    
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
    
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy( source.normalScale );
    
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
    
        this.specularMap = source.specularMap;
    
        this.alphaMap = source.alphaMap;
    
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
    
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
    
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
    
        return this;
    
    };
    
    /**
     * @author takahirox / http://github.com/takahirox
     *
     * parameters = {
     *  color: <hex>,
     *  specular: <hex>,
     *  shininess: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *  gradientMap: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalMapType: THREE.TangentSpaceNormalMap,
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    
    function MeshToonMaterial( parameters ) {
    
        Material.call( this );
    
        this.defines = { 'TOON': '' };
    
        this.type = 'MeshToonMaterial';
    
        this.color = new Color( 0xffffff );
        this.specular = new Color( 0x111111 );
        this.shininess = 30;
    
        this.map = null;
        this.gradientMap = null;
    
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
    
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
    
        this.emissive = new Color( 0x000000 );
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
    
        this.bumpMap = null;
        this.bumpScale = 1;
    
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2( 1, 1 );
    
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
    
        this.specularMap = null;
    
        this.alphaMap = null;
    
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
    
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
    
        this.setValues( parameters );
    
    }
    
    MeshToonMaterial.prototype = Object.create( Material.prototype );
    MeshToonMaterial.prototype.constructor = MeshToonMaterial;
    
    MeshToonMaterial.prototype.isMeshToonMaterial = true;
    
    MeshToonMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.color.copy( source.color );
        this.specular.copy( source.specular );
        this.shininess = source.shininess;
    
        this.map = source.map;
        this.gradientMap = source.gradientMap;
    
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
    
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
    
        this.emissive.copy( source.emissive );
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
    
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
    
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy( source.normalScale );
    
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
    
        this.specularMap = source.specularMap;
    
        this.alphaMap = source.alphaMap;
    
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
    
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
    
        return this;
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  opacity: <float>,
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalMapType: THREE.TangentSpaceNormalMap,
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    
    function MeshNormalMaterial( parameters ) {
    
        Material.call( this );
    
        this.type = 'MeshNormalMaterial';
    
        this.bumpMap = null;
        this.bumpScale = 1;
    
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2( 1, 1 );
    
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
    
        this.wireframe = false;
        this.wireframeLinewidth = 1;
    
        this.fog = false;
    
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
    
        this.setValues( parameters );
    
    }
    
    MeshNormalMaterial.prototype = Object.create( Material.prototype );
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
    
    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
    
    MeshNormalMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
    
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy( source.normalScale );
    
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
    
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
    
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
    
        return this;
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    
    function MeshLambertMaterial( parameters ) {
    
        Material.call( this );
    
        this.type = 'MeshLambertMaterial';
    
        this.color = new Color( 0xffffff ); // diffuse
    
        this.map = null;
    
        this.lightMap = null;
        this.lightMapIntensity = 1.0;
    
        this.aoMap = null;
        this.aoMapIntensity = 1.0;
    
        this.emissive = new Color( 0x000000 );
        this.emissiveIntensity = 1.0;
        this.emissiveMap = null;
    
        this.specularMap = null;
    
        this.alphaMap = null;
    
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
    
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = 'round';
        this.wireframeLinejoin = 'round';
    
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
    
        this.setValues( parameters );
    
    }
    
    MeshLambertMaterial.prototype = Object.create( Material.prototype );
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
    
    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
    
    MeshLambertMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.color.copy( source.color );
    
        this.map = source.map;
    
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
    
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
    
        this.emissive.copy( source.emissive );
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
    
        this.specularMap = source.specularMap;
    
        this.alphaMap = source.alphaMap;
    
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
    
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
    
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
    
        return this;
    
    };
    
    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  matcap: new THREE.Texture( <Image> ),
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalMapType: THREE.TangentSpaceNormalMap,
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */
    
    function MeshMatcapMaterial( parameters ) {
    
        Material.call( this );
    
        this.defines = { 'MATCAP': '' };
    
        this.type = 'MeshMatcapMaterial';
    
        this.color = new Color( 0xffffff ); // diffuse
    
        this.matcap = null;
    
        this.map = null;
    
        this.bumpMap = null;
        this.bumpScale = 1;
    
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2( 1, 1 );
    
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
    
        this.alphaMap = null;
    
        this.skinning = false;
        this.morphTargets = false;
        this.morphNormals = false;
    
        this.setValues( parameters );
    
    }
    
    MeshMatcapMaterial.prototype = Object.create( Material.prototype );
    MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
    
    MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
    
    MeshMatcapMaterial.prototype.copy = function ( source ) {
    
        Material.prototype.copy.call( this, source );
    
        this.defines = { 'MATCAP': '' };
    
        this.color.copy( source.color );
    
        this.matcap = source.matcap;
    
        this.map = source.map;
    
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
    
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy( source.normalScale );
    
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
    
        this.alphaMap = source.alphaMap;
    
        this.skinning = source.skinning;
        this.morphTargets = source.morphTargets;
        this.morphNormals = source.morphNormals;
    
        return this;
    
    };
    
    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *
     *  scale: <float>,
     *  dashSize: <float>,
     *  gapSize: <float>
     * }
     */
    
    function LineDashedMaterial( parameters ) {
    
        LineBasicMaterial.call( this );
    
        this.type = 'LineDashedMaterial';
    
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
    
        this.setValues( parameters );
    
    }
    
    LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;
    
    LineDashedMaterial.prototype.isLineDashedMaterial = true;
    
    LineDashedMaterial.prototype.copy = function ( source ) {
    
        LineBasicMaterial.prototype.copy.call( this, source );
    
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
    
        return this;
    
    };
    
    
    
    var Materials = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ShadowMaterial: ShadowMaterial,
        SpriteMaterial: SpriteMaterial,
        RawShaderMaterial: RawShaderMaterial,
        ShaderMaterial: ShaderMaterial,
        PointsMaterial: PointsMaterial,
        MeshPhysicalMaterial: MeshPhysicalMaterial,
        MeshStandardMaterial: MeshStandardMaterial,
        MeshPhongMaterial: MeshPhongMaterial,
        MeshToonMaterial: MeshToonMaterial,
        MeshNormalMaterial: MeshNormalMaterial,
        MeshLambertMaterial: MeshLambertMaterial,
        MeshDepthMaterial: MeshDepthMaterial,
        MeshDistanceMaterial: MeshDistanceMaterial,
        MeshBasicMaterial: MeshBasicMaterial,
        MeshMatcapMaterial: MeshMatcapMaterial,
        LineDashedMaterial: LineDashedMaterial,
        LineBasicMaterial: LineBasicMaterial,
        Material: Material
    });
    
    /**
     * @author tschw
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */
    
    var AnimationUtils = {
    
        // same as Array.prototype.slice, but also works on typed arrays
        arraySlice: function ( array, from, to ) {
    
            if ( AnimationUtils.isTypedArray( array ) ) {
    
                // in ios9 array.subarray(from, undefined) will return empty array
                // but array.subarray(from) or array.subarray(from, len) is correct
                return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );
    
            }
    
            return array.slice( from, to );
    
        },
    
        // converts an array to a specific type
        convertArray: function ( array, type, forceClone ) {
    
            if ( ! array || // let 'undefined' and 'null' pass
                ! forceClone && array.constructor === type ) return array;
    
            if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
    
                return new type( array ); // create typed array
    
            }
    
            return Array.prototype.slice.call( array ); // create Array
    
        },
    
        isTypedArray: function ( object ) {
    
            return ArrayBuffer.isView( object ) &&
                ! ( object instanceof DataView );
    
        },
    
        // returns an array by which times and values can be sorted
        getKeyframeOrder: function ( times ) {
    
            function compareTime( i, j ) {
    
                return times[ i ] - times[ j ];
    
            }
    
            var n = times.length;
            var result = new Array( n );
            for ( var i = 0; i !== n; ++ i ) result[ i ] = i;
    
            result.sort( compareTime );
    
            return result;
    
        },
    
        // uses the array previously returned by 'getKeyframeOrder' to sort data
        sortedArray: function ( values, stride, order ) {
    
            var nValues = values.length;
            var result = new values.constructor( nValues );
    
            for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {
    
                var srcOffset = order[ i ] * stride;
    
                for ( var j = 0; j !== stride; ++ j ) {
    
                    result[ dstOffset ++ ] = values[ srcOffset + j ];
    
                }
    
            }
    
            return result;
    
        },
    
        // function for parsing AOS keyframe formats
        flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {
    
            var i = 1, key = jsonKeys[ 0 ];
    
            while ( key !== undefined && key[ valuePropertyName ] === undefined ) {
    
                key = jsonKeys[ i ++ ];
    
            }
    
            if ( key === undefined ) return; // no data
    
            var value = key[ valuePropertyName ];
            if ( value === undefined ) return; // no data
    
            if ( Array.isArray( value ) ) {
    
                do {
    
                    value = key[ valuePropertyName ];
    
                    if ( value !== undefined ) {
    
                        times.push( key.time );
                        values.push.apply( values, value ); // push all elements
    
                    }
    
                    key = jsonKeys[ i ++ ];
    
                } while ( key !== undefined );
    
            } else if ( value.toArray !== undefined ) {
    
                // ...assume THREE.Math-ish
    
                do {
    
                    value = key[ valuePropertyName ];
    
                    if ( value !== undefined ) {
    
                        times.push( key.time );
                        value.toArray( values, values.length );
    
                    }
    
                    key = jsonKeys[ i ++ ];
    
                } while ( key !== undefined );
    
            } else {
    
                // otherwise push as-is
    
                do {
    
                    value = key[ valuePropertyName ];
    
                    if ( value !== undefined ) {
    
                        times.push( key.time );
                        values.push( value );
    
                    }
    
                    key = jsonKeys[ i ++ ];
    
                } while ( key !== undefined );
    
            }
    
        },
    
        subclip: function ( sourceClip, name, startFrame, endFrame, fps ) {
    
            fps = fps || 30;
    
            var clip = sourceClip.clone();
    
            clip.name = name;
    
            var tracks = [];
    
            for ( var i = 0; i < clip.tracks.length; ++ i ) {
    
                var track = clip.tracks[ i ];
                var valueSize = track.getValueSize();
    
                var times = [];
                var values = [];
    
                for ( var j = 0; j < track.times.length; ++ j ) {
    
                    var frame = track.times[ j ] * fps;
    
                    if ( frame < startFrame || frame >= endFrame ) continue;
    
                    times.push( track.times[ j ] );
    
                    for ( var k = 0; k < valueSize; ++ k ) {
    
                        values.push( track.values[ j * valueSize + k ] );
    
                    }
    
                }
    
                if ( times.length === 0 ) continue;
    
                track.times = AnimationUtils.convertArray( times, track.times.constructor );
                track.values = AnimationUtils.convertArray( values, track.values.constructor );
    
                tracks.push( track );
    
            }
    
            clip.tracks = tracks;
    
            // find minimum .times value across all tracks in the trimmed clip
    
            var minStartTime = Infinity;
    
            for ( var i = 0; i < clip.tracks.length; ++ i ) {
    
                if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {
    
                    minStartTime = clip.tracks[ i ].times[ 0 ];
    
                }
    
            }
    
            // shift all tracks such that clip begins at t=0
    
            for ( var i = 0; i < clip.tracks.length; ++ i ) {
    
                clip.tracks[ i ].shift( - 1 * minStartTime );
    
            }
    
            clip.resetDuration();
    
            return clip;
    
        }
    
    };
    
    /**
     * Abstract base class of interpolants over parametric samples.
     *
     * The parameter domain is one dimensional, typically the time or a path
     * along a curve defined by the data.
     *
     * The sample values can have any dimensionality and derived classes may
     * apply special interpretations to the data.
     *
     * This class provides the interval seek in a Template Method, deferring
     * the actual interpolation to derived classes.
     *
     * Time complexity is O(1) for linear access crossing at most two points
     * and O(log N) for random access, where N is the number of positions.
     *
     * References:
     *
     * 		http://www.oodesign.com/template-method-pattern.html
     *
     * @author tschw
     */
    
    function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
    
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
    
        this.resultBuffer = resultBuffer !== undefined ?
            resultBuffer : new sampleValues.constructor( sampleSize );
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
    
    }
    
    Object.assign( Interpolant.prototype, {
    
        evaluate: function ( t ) {
    
            var pp = this.parameterPositions,
                i1 = this._cachedIndex,
    
                t1 = pp[ i1 ],
                t0 = pp[ i1 - 1 ];
    
            validate_interval: {
    
                seek: {
    
                    var right;
    
                    linear_scan: {
    
                        //- See http://jsperf.com/comparison-to-undefined/3
                        //- slower code:
                        //-
                        //- 				if ( t >= t1 || t1 === undefined ) {
                        forward_scan: if ( ! ( t < t1 ) ) {
    
                            for ( var giveUpAt = i1 + 2; ; ) {
    
                                if ( t1 === undefined ) {
    
                                    if ( t < t0 ) break forward_scan;
    
                                    // after end
    
                                    i1 = pp.length;
                                    this._cachedIndex = i1;
                                    return this.afterEnd_( i1 - 1, t, t0 );
    
                                }
    
                                if ( i1 === giveUpAt ) break; // this loop
    
                                t0 = t1;
                                t1 = pp[ ++ i1 ];
    
                                if ( t < t1 ) {
    
                                    // we have arrived at the sought interval
                                    break seek;
    
                                }
    
                            }
    
                            // prepare binary search on the right side of the index
                            right = pp.length;
                            break linear_scan;
    
                        }
    
                        //- slower code:
                        //-					if ( t < t0 || t0 === undefined ) {
                        if ( ! ( t >= t0 ) ) {
    
                            // looping?
    
                            var t1global = pp[ 1 ];
    
                            if ( t < t1global ) {
    
                                i1 = 2; // + 1, using the scan for the details
                                t0 = t1global;
    
                            }
    
                            // linear reverse scan
    
                            for ( var giveUpAt = i1 - 2; ; ) {
    
                                if ( t0 === undefined ) {
    
                                    // before start
    
                                    this._cachedIndex = 0;
                                    return this.beforeStart_( 0, t, t1 );
    
                                }
    
                                if ( i1 === giveUpAt ) break; // this loop
    
                                t1 = t0;
                                t0 = pp[ -- i1 - 1 ];
    
                                if ( t >= t0 ) {
    
                                    // we have arrived at the sought interval
                                    break seek;
    
                                }
    
                            }
    
                            // prepare binary search on the left side of the index
                            right = i1;
                            i1 = 0;
                            break linear_scan;
    
                        }
    
                        // the interval is valid
    
                        break validate_interval;
    
                    } // linear scan
    
                    // binary search
    
                    while ( i1 < right ) {
    
                        var mid = ( i1 + right ) >>> 1;
    
                        if ( t < pp[ mid ] ) {
    
                            right = mid;
    
                        } else {
    
                            i1 = mid + 1;
    
                        }
    
                    }
    
                    t1 = pp[ i1 ];
                    t0 = pp[ i1 - 1 ];
    
                    // check boundary cases, again
    
                    if ( t0 === undefined ) {
    
                        this._cachedIndex = 0;
                        return this.beforeStart_( 0, t, t1 );
    
                    }
    
                    if ( t1 === undefined ) {
    
                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_( i1 - 1, t0, t );
    
                    }
    
                } // seek
    
                this._cachedIndex = i1;
    
                this.intervalChanged_( i1, t0, t1 );
    
            } // validate_interval
    
            return this.interpolate_( i1, t0, t, t1 );
    
        },
    
        settings: null, // optional, subclass-specific settings structure
        // Note: The indirection allows central control of many interpolants.
    
        // --- Protected interface
    
        DefaultSettings_: {},
    
        getSettings_: function () {
    
            return this.settings || this.DefaultSettings_;
    
        },
    
        copySampleValue_: function ( index ) {
    
            // copies a sample value to the result buffer
    
            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset = index * stride;
    
            for ( var i = 0; i !== stride; ++ i ) {
    
                result[ i ] = values[ offset + i ];
    
            }
    
            return result;
    
        },
    
        // Template methods for derived classes:
    
        interpolate_: function ( /* i1, t0, t, t1 */ ) {
    
            throw new Error( 'call to abstract method' );
            // implementations shall return this.resultBuffer
    
        },
    
        intervalChanged_: function ( /* i1, t0, t1 */ ) {
    
            // empty
    
        }
    
    } );
    
    //!\ DECLARE ALIAS AFTER assign prototype !
    Object.assign( Interpolant.prototype, {
    
        //( 0, t, t0 ), returns this.resultBuffer
        beforeStart_: Interpolant.prototype.copySampleValue_,
    
        //( N-1, tN-1, t ), returns this.resultBuffer
        afterEnd_: Interpolant.prototype.copySampleValue_,
    
    } );
    
    /**
     * Fast and simple cubic spline interpolant.
     *
     * It was derived from a Hermitian construction setting the first derivative
     * at each sample position to the linear slope between neighboring positions
     * over their parameter interval.
     *
     * @author tschw
     */
    
    function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
    
        Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
    
        this._weightPrev = - 0;
        this._offsetPrev = - 0;
        this._weightNext = - 0;
        this._offsetNext = - 0;
    
    }
    
    CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
    
        constructor: CubicInterpolant,
    
        DefaultSettings_: {
    
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
    
        },
    
        intervalChanged_: function ( i1, t0, t1 ) {
    
            var pp = this.parameterPositions,
                iPrev = i1 - 2,
                iNext = i1 + 1,
    
                tPrev = pp[ iPrev ],
                tNext = pp[ iNext ];
    
            if ( tPrev === undefined ) {
    
                switch ( this.getSettings_().endingStart ) {
    
                    case ZeroSlopeEnding:
    
                        // f'(t0) = 0
                        iPrev = i1;
                        tPrev = 2 * t0 - t1;
    
                        break;
    
                    case WrapAroundEnding:
    
                        // use the other end of the curve
                        iPrev = pp.length - 2;
                        tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
    
                        break;
    
                    default: // ZeroCurvatureEnding
    
                        // f''(t0) = 0 a.k.a. Natural Spline
                        iPrev = i1;
                        tPrev = t1;
    
                }
    
            }
    
            if ( tNext === undefined ) {
    
                switch ( this.getSettings_().endingEnd ) {
    
                    case ZeroSlopeEnding:
    
                        // f'(tN) = 0
                        iNext = i1;
                        tNext = 2 * t1 - t0;
    
                        break;
    
                    case WrapAroundEnding:
    
                        // use the other end of the curve
                        iNext = 1;
                        tNext = t1 + pp[ 1 ] - pp[ 0 ];
    
                        break;
    
                    default: // ZeroCurvatureEnding
    
                        // f''(tN) = 0, a.k.a. Natural Spline
                        iNext = i1 - 1;
                        tNext = t0;
    
                }
    
            }
    
            var halfDt = ( t1 - t0 ) * 0.5,
                stride = this.valueSize;
    
            this._weightPrev = halfDt / ( t0 - tPrev );
            this._weightNext = halfDt / ( tNext - t1 );
            this._offsetPrev = iPrev * stride;
            this._offsetNext = iNext * stride;
    
        },
    
        interpolate_: function ( i1, t0, t, t1 ) {
    
            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
    
                o1 = i1 * stride,		o0 = o1 - stride,
                oP = this._offsetPrev, 	oN = this._offsetNext,
                wP = this._weightPrev,	wN = this._weightNext,
    
                p = ( t - t0 ) / ( t1 - t0 ),
                pp = p * p,
                ppp = pp * p;
    
            // evaluate polynomials
    
            var sP = - wP * ppp + 2 * wP * pp - wP * p;
            var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
            var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
            var sN = wN * ppp - wN * pp;
    
            // combine data linearly
    
            for ( var i = 0; i !== stride; ++ i ) {
    
                result[ i ] =
                        sP * values[ oP + i ] +
                        s0 * values[ o0 + i ] +
                        s1 * values[ o1 + i ] +
                        sN * values[ oN + i ];
    
            }
    
            return result;
    
        }
    
    } );
    
    /**
     * @author tschw
     */
    
    function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
    
        Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
    
    }
    
    LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
    
        constructor: LinearInterpolant,
    
        interpolate_: function ( i1, t0, t, t1 ) {
    
            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
    
                offset1 = i1 * stride,
                offset0 = offset1 - stride,
    
                weight1 = ( t - t0 ) / ( t1 - t0 ),
                weight0 = 1 - weight1;
    
            for ( var i = 0; i !== stride; ++ i ) {
    
                result[ i ] =
                        values[ offset0 + i ] * weight0 +
                        values[ offset1 + i ] * weight1;
    
            }
    
            return result;
    
        }
    
    } );
    
    /**
     *
     * Interpolant that evaluates to the sample value at the position preceeding
     * the parameter.
     *
     * @author tschw
     */
    
    function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
    
        Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
    
    }
    
    DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
    
        constructor: DiscreteInterpolant,
    
        interpolate_: function ( i1 /*, t0, t, t1 */ ) {
    
            return this.copySampleValue_( i1 - 1 );
    
        }
    
    } );
    
    /**
     *
     * A timed sequence of keyframes for a specific property.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    
    function KeyframeTrack( name, times, values, interpolation ) {
    
        if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
        if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );
    
        this.name = name;
    
        this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
        this.values = AnimationUtils.convertArray( values, this.ValueBufferType );
    
        this.setInterpolation( interpolation || this.DefaultInterpolation );
    
    }
    
    // Static methods
    
    Object.assign( KeyframeTrack, {
    
        // Serialization (in static context, because of constructor invocation
        // and automatic invocation of .toJSON):
    
        toJSON: function ( track ) {
    
            var trackType = track.constructor;
    
            var json;
    
            // derived classes can define a static toJSON method
            if ( trackType.toJSON !== undefined ) {
    
                json = trackType.toJSON( track );
    
            } else {
    
                // by default, we assume the data can be serialized as-is
                json = {
    
                    'name': track.name,
                    'times': AnimationUtils.convertArray( track.times, Array ),
                    'values': AnimationUtils.convertArray( track.values, Array )
    
                };
    
                var interpolation = track.getInterpolation();
    
                if ( interpolation !== track.DefaultInterpolation ) {
    
                    json.interpolation = interpolation;
    
                }
    
            }
    
            json.type = track.ValueTypeName; // mandatory
    
            return json;
    
        }
    
    } );
    
    Object.assign( KeyframeTrack.prototype, {
    
        constructor: KeyframeTrack,
    
        TimeBufferType: Float32Array,
    
        ValueBufferType: Float32Array,
    
        DefaultInterpolation: InterpolateLinear,
    
        InterpolantFactoryMethodDiscrete: function ( result ) {
    
            return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );
    
        },
    
        InterpolantFactoryMethodLinear: function ( result ) {
    
            return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );
    
        },
    
        InterpolantFactoryMethodSmooth: function ( result ) {
    
            return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );
    
        },
    
        setInterpolation: function ( interpolation ) {
    
            var factoryMethod;
    
            switch ( interpolation ) {
    
                case InterpolateDiscrete:
    
                    factoryMethod = this.InterpolantFactoryMethodDiscrete;
    
                    break;
    
                case InterpolateLinear:
    
                    factoryMethod = this.InterpolantFactoryMethodLinear;
    
                    break;
    
                case InterpolateSmooth:
    
                    factoryMethod = this.InterpolantFactoryMethodSmooth;
    
                    break;
    
            }
    
            if ( factoryMethod === undefined ) {
    
                var message = "unsupported interpolation for " +
                    this.ValueTypeName + " keyframe track named " + this.name;
    
                if ( this.createInterpolant === undefined ) {
    
                    // fall back to default, unless the default itself is messed up
                    if ( interpolation !== this.DefaultInterpolation ) {
    
                        this.setInterpolation( this.DefaultInterpolation );
    
                    } else {
    
                        throw new Error( message ); // fatal, in this case
    
                    }
    
                }
    
                console.warn( 'THREE.KeyframeTrack:', message );
                return this;
    
            }
    
            this.createInterpolant = factoryMethod;
    
            return this;
    
        },
    
        getInterpolation: function () {
    
            switch ( this.createInterpolant ) {
    
                case this.InterpolantFactoryMethodDiscrete:
    
                    return InterpolateDiscrete;
    
                case this.InterpolantFactoryMethodLinear:
    
                    return InterpolateLinear;
    
                case this.InterpolantFactoryMethodSmooth:
    
                    return InterpolateSmooth;
    
            }
    
        },
    
        getValueSize: function () {
    
            return this.values.length / this.times.length;
    
        },
    
        // move all keyframes either forwards or backwards in time
        shift: function ( timeOffset ) {
    
            if ( timeOffset !== 0.0 ) {
    
                var times = this.times;
    
                for ( var i = 0, n = times.length; i !== n; ++ i ) {
    
                    times[ i ] += timeOffset;
    
                }
    
            }
    
            return this;
    
        },
    
        // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
        scale: function ( timeScale ) {
    
            if ( timeScale !== 1.0 ) {
    
                var times = this.times;
    
                for ( var i = 0, n = times.length; i !== n; ++ i ) {
    
                    times[ i ] *= timeScale;
    
                }
    
            }
    
            return this;
    
        },
    
        // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
        // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
        trim: function ( startTime, endTime ) {
    
            var times = this.times,
                nKeys = times.length,
                from = 0,
                to = nKeys - 1;
    
            while ( from !== nKeys && times[ from ] < startTime ) {
    
                ++ from;
    
            }
    
            while ( to !== - 1 && times[ to ] > endTime ) {
    
                -- to;
    
            }
    
            ++ to; // inclusive -> exclusive bound
    
            if ( from !== 0 || to !== nKeys ) {
    
                // empty tracks are forbidden, so keep at least one keyframe
                if ( from >= to ) {
    
                    to = Math.max( to, 1 );
                    from = to - 1;
    
                }
    
                var stride = this.getValueSize();
                this.times = AnimationUtils.arraySlice( times, from, to );
                this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );
    
            }
    
            return this;
    
        },
    
        // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
        validate: function () {
    
            var valid = true;
    
            var valueSize = this.getValueSize();
            if ( valueSize - Math.floor( valueSize ) !== 0 ) {
    
                console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
                valid = false;
    
            }
    
            var times = this.times,
                values = this.values,
    
                nKeys = times.length;
    
            if ( nKeys === 0 ) {
    
                console.error( 'THREE.KeyframeTrack: Track is empty.', this );
                valid = false;
    
            }
    
            var prevTime = null;
    
            for ( var i = 0; i !== nKeys; i ++ ) {
    
                var currTime = times[ i ];
    
                if ( typeof currTime === 'number' && isNaN( currTime ) ) {
    
                    console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
                    valid = false;
                    break;
    
                }
    
                if ( prevTime !== null && prevTime > currTime ) {
    
                    console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
                    valid = false;
                    break;
    
                }
    
                prevTime = currTime;
    
            }
    
            if ( values !== undefined ) {
    
                if ( AnimationUtils.isTypedArray( values ) ) {
    
                    for ( var i = 0, n = values.length; i !== n; ++ i ) {
    
                        var value = values[ i ];
    
                        if ( isNaN( value ) ) {
    
                            console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
                            valid = false;
                            break;
    
                        }
    
                    }
    
                }
    
            }
    
            return valid;
    
        },
    
        // removes equivalent sequential keys as common in morph target sequences
        // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
        optimize: function () {
    
            // times or values may be shared with other tracks, so overwriting is unsafe
            var times = AnimationUtils.arraySlice( this.times ),
                values = AnimationUtils.arraySlice( this.values ),
                stride = this.getValueSize(),
    
                smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
    
                writeIndex = 1,
                lastIndex = times.length - 1;
    
            for ( var i = 1; i < lastIndex; ++ i ) {
    
                var keep = false;
    
                var time = times[ i ];
                var timeNext = times[ i + 1 ];
    
                // remove adjacent keyframes scheduled at the same time
    
                if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {
    
                    if ( ! smoothInterpolation ) {
    
                        // remove unnecessary keyframes same as their neighbors
    
                        var offset = i * stride,
                            offsetP = offset - stride,
                            offsetN = offset + stride;
    
                        for ( var j = 0; j !== stride; ++ j ) {
    
                            var value = values[ offset + j ];
    
                            if ( value !== values[ offsetP + j ] ||
                                value !== values[ offsetN + j ] ) {
    
                                keep = true;
                                break;
    
                            }
    
                        }
    
                    } else {
    
                        keep = true;
    
                    }
    
                }
    
                // in-place compaction
    
                if ( keep ) {
    
                    if ( i !== writeIndex ) {
    
                        times[ writeIndex ] = times[ i ];
    
                        var readOffset = i * stride,
                            writeOffset = writeIndex * stride;
    
                        for ( var j = 0; j !== stride; ++ j ) {
    
                            values[ writeOffset + j ] = values[ readOffset + j ];
    
                        }
    
                    }
    
                    ++ writeIndex;
    
                }
    
            }
    
            // flush last keyframe (compaction looks ahead)
    
            if ( lastIndex > 0 ) {
    
                times[ writeIndex ] = times[ lastIndex ];
    
                for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {
    
                    values[ writeOffset + j ] = values[ readOffset + j ];
    
                }
    
                ++ writeIndex;
    
            }
    
            if ( writeIndex !== times.length ) {
    
                this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
                this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );
    
            } else {
    
                this.times = times;
                this.values = values;
    
            }
    
            return this;
    
        },
    
        clone: function () {
    
            var times = AnimationUtils.arraySlice( this.times, 0 );
            var values = AnimationUtils.arraySlice( this.values, 0 );
    
            var TypedKeyframeTrack = this.constructor;
            var track = new TypedKeyframeTrack( this.name, times, values );
    
            // Interpolant argument to constructor is not saved, so copy the factory method directly.
            track.createInterpolant = this.createInterpolant;
    
            return track;
    
        }
    
    } );
    
    /**
     *
     * A Track of Boolean keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    
    function BooleanKeyframeTrack( name, times, values ) {
    
        KeyframeTrack.call( this, name, times, values );
    
    }
    
    BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
    
        constructor: BooleanKeyframeTrack,
    
        ValueTypeName: 'bool',
        ValueBufferType: Array,
    
        DefaultInterpolation: InterpolateDiscrete,
    
        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined
    
        // Note: Actually this track could have a optimized / compressed
        // representation of a single value and a custom interpolant that
        // computes "firstValue ^ isOdd( index )".
    
    } );
    
    /**
     *
     * A Track of keyframe values that represent color.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    
    function ColorKeyframeTrack( name, times, values, interpolation ) {
    
        KeyframeTrack.call( this, name, times, values, interpolation );
    
    }
    
    ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
    
        constructor: ColorKeyframeTrack,
    
        ValueTypeName: 'color'
    
        // ValueBufferType is inherited
    
        // DefaultInterpolation is inherited
    
        // Note: Very basic implementation and nothing special yet.
        // However, this is the place for color space parameterization.
    
    } );
    
    /**
     *
     * A Track of numeric keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    
    function NumberKeyframeTrack( name, times, values, interpolation ) {
    
        KeyframeTrack.call( this, name, times, values, interpolation );
    
    }
    
    NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
    
        constructor: NumberKeyframeTrack,
    
        ValueTypeName: 'number'
    
        // ValueBufferType is inherited
    
        // DefaultInterpolation is inherited
    
    } );
    
    /**
     * Spherical linear unit quaternion interpolant.
     *
     * @author tschw
     */
    
    function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
    
        Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
    
    }
    
    QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
    
        constructor: QuaternionLinearInterpolant,
    
        interpolate_: function ( i1, t0, t, t1 ) {
    
            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
    
                offset = i1 * stride,
    
                alpha = ( t - t0 ) / ( t1 - t0 );
    
            for ( var end = offset + stride; offset !== end; offset += 4 ) {
    
                Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );
    
            }
    
            return result;
    
        }
    
    } );
    
    /**
     *
     * A Track of quaternion keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    
    function QuaternionKeyframeTrack( name, times, values, interpolation ) {
    
        KeyframeTrack.call( this, name, times, values, interpolation );
    
    }
    
    QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
    
        constructor: QuaternionKeyframeTrack,
    
        ValueTypeName: 'quaternion',
    
        // ValueBufferType is inherited
    
        DefaultInterpolation: InterpolateLinear,
    
        InterpolantFactoryMethodLinear: function ( result ) {
    
            return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );
    
        },
    
        InterpolantFactoryMethodSmooth: undefined // not yet implemented
    
    } );
    
    /**
     *
     * A Track that interpolates Strings
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    
    function StringKeyframeTrack( name, times, values, interpolation ) {
    
        KeyframeTrack.call( this, name, times, values, interpolation );
    
    }
    
    StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
    
        constructor: StringKeyframeTrack,
    
        ValueTypeName: 'string',
        ValueBufferType: Array,
    
        DefaultInterpolation: InterpolateDiscrete,
    
        InterpolantFactoryMethodLinear: undefined,
    
        InterpolantFactoryMethodSmooth: undefined
    
    } );
    
    /**
     *
     * A Track of vectored keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    
    function VectorKeyframeTrack( name, times, values, interpolation ) {
    
        KeyframeTrack.call( this, name, times, values, interpolation );
    
    }
    
    VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
    
        constructor: VectorKeyframeTrack,
    
        ValueTypeName: 'vector'
    
        // ValueBufferType is inherited
    
        // DefaultInterpolation is inherited
    
    } );
    
    /**
     *
     * Reusable set of Tracks that represent an animation.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */
    
    function AnimationClip( name, duration, tracks ) {
    
        this.name = name;
        this.tracks = tracks;
        this.duration = ( duration !== undefined ) ? duration : - 1;
    
        this.uuid = MathUtils.generateUUID();
    
        // this means it should figure out its duration by scanning the tracks
        if ( this.duration < 0 ) {
    
            this.resetDuration();
    
        }
    
    }
    
    function getTrackTypeForValueTypeName( typeName ) {
    
        switch ( typeName.toLowerCase() ) {
    
            case 'scalar':
            case 'double':
            case 'float':
            case 'number':
            case 'integer':
    
                return NumberKeyframeTrack;
    
            case 'vector':
            case 'vector2':
            case 'vector3':
            case 'vector4':
    
                return VectorKeyframeTrack;
    
            case 'color':
    
                return ColorKeyframeTrack;
    
            case 'quaternion':
    
                return QuaternionKeyframeTrack;
    
            case 'bool':
            case 'boolean':
    
                return BooleanKeyframeTrack;
    
            case 'string':
    
                return StringKeyframeTrack;
    
        }
    
        throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );
    
    }
    
    function parseKeyframeTrack( json ) {
    
        if ( json.type === undefined ) {
    
            throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );
    
        }
    
        var trackType = getTrackTypeForValueTypeName( json.type );
    
        if ( json.times === undefined ) {
    
            var times = [], values = [];
    
            AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
    
            json.times = times;
            json.values = values;
    
        }
    
        // derived classes can define a static parse method
        if ( trackType.parse !== undefined ) {
    
            return trackType.parse( json );
    
        } else {
    
            // by default, we assume a constructor compatible with the base
            return new trackType( json.name, json.times, json.values, json.interpolation );
    
        }
    
    }
    
    Object.assign( AnimationClip, {
    
        parse: function ( json ) {
    
            var tracks = [],
                jsonTracks = json.tracks,
                frameTime = 1.0 / ( json.fps || 1.0 );
    
            for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {
    
                tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );
    
            }
    
            return new AnimationClip( json.name, json.duration, tracks );
    
        },
    
        toJSON: function ( clip ) {
    
            var tracks = [],
                clipTracks = clip.tracks;
    
            var json = {
    
                'name': clip.name,
                'duration': clip.duration,
                'tracks': tracks,
                'uuid': clip.uuid
    
            };
    
            for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {
    
                tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );
    
            }
    
            return json;
    
        },
    
        CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {
    
            var numMorphTargets = morphTargetSequence.length;
            var tracks = [];
    
            for ( var i = 0; i < numMorphTargets; i ++ ) {
    
                var times = [];
                var values = [];
    
                times.push(
                    ( i + numMorphTargets - 1 ) % numMorphTargets,
                    i,
                    ( i + 1 ) % numMorphTargets );
    
                values.push( 0, 1, 0 );
    
                var order = AnimationUtils.getKeyframeOrder( times );
                times = AnimationUtils.sortedArray( times, 1, order );
                values = AnimationUtils.sortedArray( values, 1, order );
    
                // if there is a key at the first frame, duplicate it as the
                // last frame as well for perfect loop.
                if ( ! noLoop && times[ 0 ] === 0 ) {
    
                    times.push( numMorphTargets );
                    values.push( values[ 0 ] );
    
                }
    
                tracks.push(
                    new NumberKeyframeTrack(
                        '.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
                        times, values
                    ).scale( 1.0 / fps ) );
    
            }
    
            return new AnimationClip( name, - 1, tracks );
    
        },
    
        findByName: function ( objectOrClipArray, name ) {
    
            var clipArray = objectOrClipArray;
    
            if ( ! Array.isArray( objectOrClipArray ) ) {
    
                var o = objectOrClipArray;
                clipArray = o.geometry && o.geometry.animations || o.animations;
    
            }
    
            for ( var i = 0; i < clipArray.length; i ++ ) {
    
                if ( clipArray[ i ].name === name ) {
    
                    return clipArray[ i ];
    
                }
    
            }
    
            return null;
    
        },
    
        CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {
    
            var animationToMorphTargets = {};
    
            // tested with https://regex101.com/ on trick sequences
            // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
            var pattern = /^([\w-]*?)([\d]+)$/;
    
            // sort morph target names into animation groups based
            // patterns like Walk_001, Walk_002, Run_001, Run_002
            for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {
    
                var morphTarget = morphTargets[ i ];
                var parts = morphTarget.name.match( pattern );
    
                if ( parts && parts.length > 1 ) {
    
                    var name = parts[ 1 ];
    
                    var animationMorphTargets = animationToMorphTargets[ name ];
                    if ( ! animationMorphTargets ) {
    
                        animationToMorphTargets[ name ] = animationMorphTargets = [];
    
                    }
    
                    animationMorphTargets.push( morphTarget );
    
                }
    
            }
    
            var clips = [];
    
            for ( var name in animationToMorphTargets ) {
    
                clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );
    
            }
    
            return clips;
    
        },
    
        // parse the animation.hierarchy format
        parseAnimation: function ( animation, bones ) {
    
            if ( ! animation ) {
    
                console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
                return null;
    
            }
    
            var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {
    
                // only return track if there are actually keys.
                if ( animationKeys.length !== 0 ) {
    
                    var times = [];
                    var values = [];
    
                    AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );
    
                    // empty keys are filtered out, so check again
                    if ( times.length !== 0 ) {
    
                        destTracks.push( new trackType( trackName, times, values ) );
    
                    }
    
                }
    
            };
    
            var tracks = [];
    
            var clipName = animation.name || 'default';
            // automatic length determination in AnimationClip.
            var duration = animation.length || - 1;
            var fps = animation.fps || 30;
    
            var hierarchyTracks = animation.hierarchy || [];
    
            for ( var h = 0; h < hierarchyTracks.length; h ++ ) {
    
                var animationKeys = hierarchyTracks[ h ].keys;
    
                // skip empty tracks
                if ( ! animationKeys || animationKeys.length === 0 ) continue;
    
                // process morph targets
                if ( animationKeys[ 0 ].morphTargets ) {
    
                    // figure out all morph targets used in this track
                    var morphTargetNames = {};
    
                    for ( var k = 0; k < animationKeys.length; k ++ ) {
    
                        if ( animationKeys[ k ].morphTargets ) {
    
                            for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {
    
                                morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;
    
                            }
    
                        }
    
                    }
    
                    // create a track for each morph target with all zero
                    // morphTargetInfluences except for the keys in which
                    // the morphTarget is named.
                    for ( var morphTargetName in morphTargetNames ) {
    
                        var times = [];
                        var values = [];
    
                        for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {
    
                            var animationKey = animationKeys[ k ];
    
                            times.push( animationKey.time );
                            values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );
    
                        }
    
                        tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
    
                    }
    
                    duration = morphTargetNames.length * ( fps || 1.0 );
    
                } else {
    
                    // ...assume skeletal animation
    
                    var boneName = '.bones[' + bones[ h ].name + ']';
    
                    addNonemptyTrack(
                        VectorKeyframeTrack, boneName + '.position',
                        animationKeys, 'pos', tracks );
    
                    addNonemptyTrack(
                        QuaternionKeyframeTrack, boneName + '.quaternion',
                        animationKeys, 'rot', tracks );
    
                    addNonemptyTrack(
                        VectorKeyframeTrack, boneName + '.scale',
                        animationKeys, 'scl', tracks );
    
                }
    
            }
    
            if ( tracks.length === 0 ) {
    
                return null;
    
            }
    
            var clip = new AnimationClip( clipName, duration, tracks );
    
            return clip;
    
        }
    
    } );
    
    Object.assign( AnimationClip.prototype, {
    
        resetDuration: function () {
    
            var tracks = this.tracks, duration = 0;
    
            for ( var i = 0, n = tracks.length; i !== n; ++ i ) {
    
                var track = this.tracks[ i ];
    
                duration = Math.max( duration, track.times[ track.times.length - 1 ] );
    
            }
    
            this.duration = duration;
    
            return this;
    
        },
    
        trim: function () {
    
            for ( var i = 0; i < this.tracks.length; i ++ ) {
    
                this.tracks[ i ].trim( 0, this.duration );
    
            }
    
            return this;
    
        },
    
        validate: function () {
    
            var valid = true;
    
            for ( var i = 0; i < this.tracks.length; i ++ ) {
    
                valid = valid && this.tracks[ i ].validate();
    
            }
    
            return valid;
    
        },
    
        optimize: function () {
    
            for ( var i = 0; i < this.tracks.length; i ++ ) {
    
                this.tracks[ i ].optimize();
    
            }
    
            return this;
    
        },
    
        clone: function () {
    
            var tracks = [];
    
            for ( var i = 0; i < this.tracks.length; i ++ ) {
    
                tracks.push( this.tracks[ i ].clone() );
    
            }
    
            return new AnimationClip( this.name, this.duration, tracks );
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    var Cache = {
    
        enabled: false,
    
        files: {},
    
        add: function ( key, file ) {
    
            if ( this.enabled === false ) return;
    
            // console.log( 'THREE.Cache', 'Adding key:', key );
    
            this.files[ key ] = file;
    
        },
    
        get: function ( key ) {
    
            if ( this.enabled === false ) return;
    
            // console.log( 'THREE.Cache', 'Checking key:', key );
    
            return this.files[ key ];
    
        },
    
        remove: function ( key ) {
    
            delete this.files[ key ];
    
        },
    
        clear: function () {
    
            this.files = {};
    
        }
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function LoadingManager( onLoad, onProgress, onError ) {
    
        var scope = this;
    
        var isLoading = false;
        var itemsLoaded = 0;
        var itemsTotal = 0;
        var urlModifier = undefined;
        var handlers = [];
    
        // Refer to #5689 for the reason why we don't set .onStart
        // in the constructor
    
        this.onStart = undefined;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
    
        this.itemStart = function ( url ) {
    
            itemsTotal ++;
    
            if ( isLoading === false ) {
    
                if ( scope.onStart !== undefined ) {
    
                    scope.onStart( url, itemsLoaded, itemsTotal );
    
                }
    
            }
    
            isLoading = true;
    
        };
    
        this.itemEnd = function ( url ) {
    
            itemsLoaded ++;
    
            if ( scope.onProgress !== undefined ) {
    
                scope.onProgress( url, itemsLoaded, itemsTotal );
    
            }
    
            if ( itemsLoaded === itemsTotal ) {
    
                isLoading = false;
    
                if ( scope.onLoad !== undefined ) {
    
                    scope.onLoad();
    
                }
    
            }
    
        };
    
        this.itemError = function ( url ) {
    
            if ( scope.onError !== undefined ) {
    
                scope.onError( url );
    
            }
    
        };
    
        this.resolveURL = function ( url ) {
    
            if ( urlModifier ) {
    
                return urlModifier( url );
    
            }
    
            return url;
    
        };
    
        this.setURLModifier = function ( transform ) {
    
            urlModifier = transform;
    
            return this;
    
        };
    
        this.addHandler = function ( regex, loader ) {
    
            handlers.push( regex, loader );
    
            return this;
    
        };
    
        this.removeHandler = function ( regex ) {
    
            var index = handlers.indexOf( regex );
    
            if ( index !== - 1 ) {
    
                handlers.splice( index, 2 );
    
            }
    
            return this;
    
        };
    
        this.getHandler = function ( file ) {
    
            for ( var i = 0, l = handlers.length; i < l; i += 2 ) {
    
                var regex = handlers[ i ];
                var loader = handlers[ i + 1 ];
    
                if ( regex.global ) regex.lastIndex = 0; // see #17920
    
                if ( regex.test( file ) ) {
    
                    return loader;
    
                }
    
            }
    
            return null;
    
        };
    
    }
    
    var DefaultLoadingManager = new LoadingManager();
    
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    
    function Loader( manager ) {
    
        this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
    
        this.crossOrigin = 'anonymous';
        this.path = '';
        this.resourcePath = '';
    
    }
    
    Object.assign( Loader.prototype, {
    
        load: function ( /* url, onLoad, onProgress, onError */ ) {},
    
        parse: function ( /* data */ ) {},
    
        setCrossOrigin: function ( crossOrigin ) {
    
            this.crossOrigin = crossOrigin;
            return this;
    
        },
    
        setPath: function ( path ) {
    
            this.path = path;
            return this;
    
        },
    
        setResourcePath: function ( resourcePath ) {
    
            this.resourcePath = resourcePath;
            return this;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    var loading = {};
    
    function FileLoader( manager ) {
    
        Loader.call( this, manager );
    
    }
    
    FileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: FileLoader,
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            if ( url === undefined ) url = '';
    
            if ( this.path !== undefined ) url = this.path + url;
    
            url = this.manager.resolveURL( url );
    
            var scope = this;
    
            var cached = Cache.get( url );
    
            if ( cached !== undefined ) {
    
                scope.manager.itemStart( url );
    
                setTimeout( function () {
    
                    if ( onLoad ) onLoad( cached );
    
                    scope.manager.itemEnd( url );
    
                }, 0 );
    
                return cached;
    
            }
    
            // Check if request is duplicate
    
            if ( loading[ url ] !== undefined ) {
    
                loading[ url ].push( {
    
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
    
                } );
    
                return;
    
            }
    
            // Check for data: URI
            var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
            var dataUriRegexResult = url.match( dataUriRegex );
    
            // Safari can not handle Data URIs through XMLHttpRequest so process manually
            if ( dataUriRegexResult ) {
    
                var mimeType = dataUriRegexResult[ 1 ];
                var isBase64 = !! dataUriRegexResult[ 2 ];
                var data = dataUriRegexResult[ 3 ];
    
                data = decodeURIComponent( data );
    
                if ( isBase64 ) data = atob( data );
    
                try {
    
                    var response;
                    var responseType = ( this.responseType || '' ).toLowerCase();
    
                    switch ( responseType ) {
    
                        case 'arraybuffer':
                        case 'blob':
    
                            var view = new Uint8Array( data.length );
    
                            for ( var i = 0; i < data.length; i ++ ) {
    
                                view[ i ] = data.charCodeAt( i );
    
                            }
    
                            if ( responseType === 'blob' ) {
    
                                response = new Blob( [ view.buffer ], { type: mimeType } );
    
                            } else {
    
                                response = view.buffer;
    
                            }
    
                            break;
    
                        case 'document':
    
                            var parser = new DOMParser();
                            response = parser.parseFromString( data, mimeType );
    
                            break;
    
                        case 'json':
    
                            response = JSON.parse( data );
    
                            break;
    
                        default: // 'text' or other
    
                            response = data;
    
                            break;
    
                    }
    
                    // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                    setTimeout( function () {
    
                        if ( onLoad ) onLoad( response );
    
                        scope.manager.itemEnd( url );
    
                    }, 0 );
    
                } catch ( error ) {
    
                    // Wait for next browser tick like standard XMLHttpRequest event dispatching does
                    setTimeout( function () {
    
                        if ( onError ) onError( error );
    
                        scope.manager.itemError( url );
                        scope.manager.itemEnd( url );
    
                    }, 0 );
    
                }
    
            } else {
    
                // Initialise array for duplicate requests
    
                loading[ url ] = [];
    
                loading[ url ].push( {
    
                    onLoad: onLoad,
                    onProgress: onProgress,
                    onError: onError
    
                } );
    
                var request = new XMLHttpRequest();
    
                request.open( 'GET', url, true );
    
                request.addEventListener( 'load', function ( event ) {
    
                    var response = this.response;
    
                    var callbacks = loading[ url ];
    
                    delete loading[ url ];
    
                    if ( this.status === 200 || this.status === 0 ) {
    
                        // Some browsers return HTTP Status 0 when using non-http protocol
                        // e.g. 'file://' or 'data://'. Handle as success.
    
                        if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );
    
                        // Add to cache only on HTTP success, so that we do not cache
                        // error response bodies as proper responses to requests.
                        Cache.add( url, response );
    
                        for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
    
                            var callback = callbacks[ i ];
                            if ( callback.onLoad ) callback.onLoad( response );
    
                        }
    
                        scope.manager.itemEnd( url );
    
                    } else {
    
                        for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
    
                            var callback = callbacks[ i ];
                            if ( callback.onError ) callback.onError( event );
    
                        }
    
                        scope.manager.itemError( url );
                        scope.manager.itemEnd( url );
    
                    }
    
                }, false );
    
                request.addEventListener( 'progress', function ( event ) {
    
                    var callbacks = loading[ url ];
    
                    for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
    
                        var callback = callbacks[ i ];
                        if ( callback.onProgress ) callback.onProgress( event );
    
                    }
    
                }, false );
    
                request.addEventListener( 'error', function ( event ) {
    
                    var callbacks = loading[ url ];
    
                    delete loading[ url ];
    
                    for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
    
                        var callback = callbacks[ i ];
                        if ( callback.onError ) callback.onError( event );
    
                    }
    
                    scope.manager.itemError( url );
                    scope.manager.itemEnd( url );
    
                }, false );
    
                request.addEventListener( 'abort', function ( event ) {
    
                    var callbacks = loading[ url ];
    
                    delete loading[ url ];
    
                    for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
    
                        var callback = callbacks[ i ];
                        if ( callback.onError ) callback.onError( event );
    
                    }
    
                    scope.manager.itemError( url );
                    scope.manager.itemEnd( url );
    
                }, false );
    
                if ( this.responseType !== undefined ) request.responseType = this.responseType;
                if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
    
                if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );
    
                for ( var header in this.requestHeader ) {
    
                    request.setRequestHeader( header, this.requestHeader[ header ] );
    
                }
    
                request.send( null );
    
            }
    
            scope.manager.itemStart( url );
    
            return request;
    
        },
    
        setResponseType: function ( value ) {
    
            this.responseType = value;
            return this;
    
        },
    
        setWithCredentials: function ( value ) {
    
            this.withCredentials = value;
            return this;
    
        },
    
        setMimeType: function ( value ) {
    
            this.mimeType = value;
            return this;
    
        },
    
        setRequestHeader: function ( value ) {
    
            this.requestHeader = value;
            return this;
    
        }
    
    } );
    
    /**
     * @author bhouston / http://clara.io/
     */
    
    function AnimationLoader( manager ) {
    
        Loader.call( this, manager );
    
    }
    
    AnimationLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: AnimationLoader,
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            var scope = this;
    
            var loader = new FileLoader( scope.manager );
            loader.setPath( scope.path );
            loader.load( url, function ( text ) {
    
                onLoad( scope.parse( JSON.parse( text ) ) );
    
            }, onProgress, onError );
    
        },
    
        parse: function ( json ) {
    
            var animations = [];
    
            for ( var i = 0; i < json.length; i ++ ) {
    
                var clip = AnimationClip.parse( json[ i ] );
    
                animations.push( clip );
    
            }
    
            return animations;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * Abstract Base class to block based textures loader (dds, pvr, ...)
     *
     * Sub classes have to implement the parse() method which will be used in load().
     */
    
    function CompressedTextureLoader( manager ) {
    
        Loader.call( this, manager );
    
    }
    
    CompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: CompressedTextureLoader,
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            var scope = this;
    
            var images = [];
    
            var texture = new CompressedTexture();
            texture.image = images;
    
            var loader = new FileLoader( this.manager );
            loader.setPath( this.path );
            loader.setResponseType( 'arraybuffer' );
    
            function loadTexture( i ) {
    
                loader.load( url[ i ], function ( buffer ) {
    
                    var texDatas = scope.parse( buffer, true );
    
                    images[ i ] = {
                        width: texDatas.width,
                        height: texDatas.height,
                        format: texDatas.format,
                        mipmaps: texDatas.mipmaps
                    };
    
                    loaded += 1;
    
                    if ( loaded === 6 ) {
    
                        if ( texDatas.mipmapCount === 1 )
                            texture.minFilter = LinearFilter;
    
                        texture.format = texDatas.format;
                        texture.needsUpdate = true;
    
                        if ( onLoad ) onLoad( texture );
    
                    }
    
                }, onProgress, onError );
    
            }
    
            if ( Array.isArray( url ) ) {
    
                var loaded = 0;
    
                for ( var i = 0, il = url.length; i < il; ++ i ) {
    
                    loadTexture( i );
    
                }
    
            } else {
    
                // compressed cubemap texture stored in a single DDS file
    
                loader.load( url, function ( buffer ) {
    
                    var texDatas = scope.parse( buffer, true );
    
                    if ( texDatas.isCubemap ) {
    
                        var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
    
                        for ( var f = 0; f < faces; f ++ ) {
    
                            images[ f ] = { mipmaps: [] };
    
                            for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
    
                                images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
                                images[ f ].format = texDatas.format;
                                images[ f ].width = texDatas.width;
                                images[ f ].height = texDatas.height;
    
                            }
    
                        }
    
                    } else {
    
                        texture.image.width = texDatas.width;
                        texture.image.height = texDatas.height;
                        texture.mipmaps = texDatas.mipmaps;
    
                    }
    
                    if ( texDatas.mipmapCount === 1 ) {
    
                        texture.minFilter = LinearFilter;
    
                    }
    
                    texture.format = texDatas.format;
                    texture.needsUpdate = true;
    
                    if ( onLoad ) onLoad( texture );
    
                }, onProgress, onError );
    
            }
    
            return texture;
    
        }
    
    } );
    
    /**
     * @author Nikos M. / https://github.com/foo123/
     *
     * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
     *
     * Sub classes have to implement the parse() method which will be used in load().
     */
    
    function DataTextureLoader( manager ) {
    
        Loader.call( this, manager );
    
    }
    
    DataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: DataTextureLoader,
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            var scope = this;
    
            var texture = new DataTexture();
    
            var loader = new FileLoader( this.manager );
            loader.setResponseType( 'arraybuffer' );
            loader.setPath( this.path );
            loader.load( url, function ( buffer ) {
    
                var texData = scope.parse( buffer );
    
                if ( ! texData ) return;
    
                if ( texData.image !== undefined ) {
    
                    texture.image = texData.image;
    
                } else if ( texData.data !== undefined ) {
    
                    texture.image.width = texData.width;
                    texture.image.height = texData.height;
                    texture.image.data = texData.data;
    
                }
    
                texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
                texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
    
                texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
                texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
    
                texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
    
                if ( texData.format !== undefined ) {
    
                    texture.format = texData.format;
    
                }
                if ( texData.type !== undefined ) {
    
                    texture.type = texData.type;
    
                }
    
                if ( texData.mipmaps !== undefined ) {
    
                    texture.mipmaps = texData.mipmaps;
                    texture.minFilter = LinearMipmapLinearFilter; // presumably...
    
                }
    
                if ( texData.mipmapCount === 1 ) {
    
                    texture.minFilter = LinearFilter;
    
                }
    
                texture.needsUpdate = true;
    
                if ( onLoad ) onLoad( texture, texData );
    
            }, onProgress, onError );
    
    
            return texture;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function ImageLoader( manager ) {
    
        Loader.call( this, manager );
    
    }
    
    ImageLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: ImageLoader,
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            if ( this.path !== undefined ) url = this.path + url;
    
            url = this.manager.resolveURL( url );
    
            var scope = this;
    
            var cached = Cache.get( url );
    
            if ( cached !== undefined ) {
    
                scope.manager.itemStart( url );
    
                setTimeout( function () {
    
                    if ( onLoad ) onLoad( cached );
    
                    scope.manager.itemEnd( url );
    
                }, 0 );
    
                return cached;
    
            }
    
            var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
    
            function onImageLoad() {
    
                image.removeEventListener( 'load', onImageLoad, false );
                image.removeEventListener( 'error', onImageError, false );
    
                Cache.add( url, this );
    
                if ( onLoad ) onLoad( this );
    
                scope.manager.itemEnd( url );
    
            }
    
            function onImageError( event ) {
    
                image.removeEventListener( 'load', onImageLoad, false );
                image.removeEventListener( 'error', onImageError, false );
    
                if ( onError ) onError( event );
    
                scope.manager.itemError( url );
                scope.manager.itemEnd( url );
    
            }
    
            image.addEventListener( 'load', onImageLoad, false );
            image.addEventListener( 'error', onImageError, false );
    
            if ( url.substr( 0, 5 ) !== 'data:' ) {
    
                if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
    
            }
    
            scope.manager.itemStart( url );
    
            image.src = url;
    
            return image;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    
    function CubeTextureLoader( manager ) {
    
        Loader.call( this, manager );
    
    }
    
    CubeTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: CubeTextureLoader,
    
        load: function ( urls, onLoad, onProgress, onError ) {
    
            var texture = new CubeTexture();
    
            var loader = new ImageLoader( this.manager );
            loader.setCrossOrigin( this.crossOrigin );
            loader.setPath( this.path );
    
            var loaded = 0;
    
            function loadTexture( i ) {
    
                loader.load( urls[ i ], function ( image ) {
    
                    texture.images[ i ] = image;
    
                    loaded ++;
    
                    if ( loaded === 6 ) {
    
                        texture.needsUpdate = true;
    
                        if ( onLoad ) onLoad( texture );
    
                    }
    
                }, undefined, onError );
    
            }
    
            for ( var i = 0; i < urls.length; ++ i ) {
    
                loadTexture( i );
    
            }
    
            return texture;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function TextureLoader( manager ) {
    
        Loader.call( this, manager );
    
    }
    
    TextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: TextureLoader,
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            var texture = new Texture();
    
            var loader = new ImageLoader( this.manager );
            loader.setCrossOrigin( this.crossOrigin );
            loader.setPath( this.path );
    
            loader.load( url, function ( image ) {
    
                texture.image = image;
    
                // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
                var isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;
    
                texture.format = isJPEG ? RGBFormat : RGBAFormat;
                texture.needsUpdate = true;
    
                if ( onLoad !== undefined ) {
    
                    onLoad( texture );
    
                }
    
            }, onProgress, onError );
    
            return texture;
    
        }
    
    } );
    
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Extensible curve object
     *
     * Some common of curve methods:
     * .getPoint( t, optionalTarget ), .getTangent( t )
     * .getPointAt( u, optionalTarget ), .getTangentAt( u )
     * .getPoints(), .getSpacedPoints()
     * .getLength()
     * .updateArcLengths()
     *
     * This following curves inherit from THREE.Curve:
     *
     * -- 2D curves --
     * THREE.ArcCurve
     * THREE.CubicBezierCurve
     * THREE.EllipseCurve
     * THREE.LineCurve
     * THREE.QuadraticBezierCurve
     * THREE.SplineCurve
     *
     * -- 3D curves --
     * THREE.CatmullRomCurve3
     * THREE.CubicBezierCurve3
     * THREE.LineCurve3
     * THREE.QuadraticBezierCurve3
     *
     * A series of curves can be represented as a THREE.CurvePath.
     *
     **/
    
    /**************************************************************
     *	Abstract Curve base class
     **************************************************************/
    
    function Curve() {
    
        this.type = 'Curve';
    
        this.arcLengthDivisions = 200;
    
    }
    
    Object.assign( Curve.prototype, {
    
        // Virtual base class method to overwrite and implement in subclasses
        //	- t [0 .. 1]
    
        getPoint: function ( /* t, optionalTarget */ ) {
    
            console.warn( 'THREE.Curve: .getPoint() not implemented.' );
            return null;
    
        },
    
        // Get point at relative position in curve according to arc length
        // - u [0 .. 1]
    
        getPointAt: function ( u, optionalTarget ) {
    
            var t = this.getUtoTmapping( u );
            return this.getPoint( t, optionalTarget );
    
        },
    
        // Get sequence of points using getPoint( t )
    
        getPoints: function ( divisions ) {
    
            if ( divisions === undefined ) divisions = 5;
    
            var points = [];
    
            for ( var d = 0; d <= divisions; d ++ ) {
    
                points.push( this.getPoint( d / divisions ) );
    
            }
    
            return points;
    
        },
    
        // Get sequence of points using getPointAt( u )
    
        getSpacedPoints: function ( divisions ) {
    
            if ( divisions === undefined ) divisions = 5;
    
            var points = [];
    
            for ( var d = 0; d <= divisions; d ++ ) {
    
                points.push( this.getPointAt( d / divisions ) );
    
            }
    
            return points;
    
        },
    
        // Get total curve arc length
    
        getLength: function () {
    
            var lengths = this.getLengths();
            return lengths[ lengths.length - 1 ];
    
        },
    
        // Get list of cumulative segment lengths
    
        getLengths: function ( divisions ) {
    
            if ( divisions === undefined ) divisions = this.arcLengthDivisions;
    
            if ( this.cacheArcLengths &&
                ( this.cacheArcLengths.length === divisions + 1 ) &&
                ! this.needsUpdate ) {
    
                return this.cacheArcLengths;
    
            }
    
            this.needsUpdate = false;
    
            var cache = [];
            var current, last = this.getPoint( 0 );
            var p, sum = 0;
    
            cache.push( 0 );
    
            for ( p = 1; p <= divisions; p ++ ) {
    
                current = this.getPoint( p / divisions );
                sum += current.distanceTo( last );
                cache.push( sum );
                last = current;
    
            }
    
            this.cacheArcLengths = cache;
    
            return cache; // { sums: cache, sum: sum }; Sum is in the last element.
    
        },
    
        updateArcLengths: function () {
    
            this.needsUpdate = true;
            this.getLengths();
    
        },
    
        // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
    
        getUtoTmapping: function ( u, distance ) {
    
            var arcLengths = this.getLengths();
    
            var i = 0, il = arcLengths.length;
    
            var targetArcLength; // The targeted u distance value to get
    
            if ( distance ) {
    
                targetArcLength = distance;
    
            } else {
    
                targetArcLength = u * arcLengths[ il - 1 ];
    
            }
    
            // binary search for the index with largest value smaller than target u distance
    
            var low = 0, high = il - 1, comparison;
    
            while ( low <= high ) {
    
                i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
    
                comparison = arcLengths[ i ] - targetArcLength;
    
                if ( comparison < 0 ) {
    
                    low = i + 1;
    
                } else if ( comparison > 0 ) {
    
                    high = i - 1;
    
                } else {
    
                    high = i;
                    break;
    
                    // DONE
    
                }
    
            }
    
            i = high;
    
            if ( arcLengths[ i ] === targetArcLength ) {
    
                return i / ( il - 1 );
    
            }
    
            // we could get finer grain at lengths, or use simple interpolation between two points
    
            var lengthBefore = arcLengths[ i ];
            var lengthAfter = arcLengths[ i + 1 ];
    
            var segmentLength = lengthAfter - lengthBefore;
    
            // determine where we are between the 'before' and 'after' points
    
            var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
    
            // add that fractional amount to t
    
            var t = ( i + segmentFraction ) / ( il - 1 );
    
            return t;
    
        },
    
        // Returns a unit vector tangent at t
        // In case any sub curve does not implement its tangent derivation,
        // 2 points a small delta apart will be used to find its gradient
        // which seems to give a reasonable approximation
    
        getTangent: function ( t ) {
    
            var delta = 0.0001;
            var t1 = t - delta;
            var t2 = t + delta;
    
            // Capping in case of danger
    
            if ( t1 < 0 ) t1 = 0;
            if ( t2 > 1 ) t2 = 1;
    
            var pt1 = this.getPoint( t1 );
            var pt2 = this.getPoint( t2 );
    
            var vec = pt2.clone().sub( pt1 );
            return vec.normalize();
    
        },
    
        getTangentAt: function ( u ) {
    
            var t = this.getUtoTmapping( u );
            return this.getTangent( t );
    
        },
    
        computeFrenetFrames: function ( segments, closed ) {
    
            // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
    
            var normal = new Vector3();
    
            var tangents = [];
            var normals = [];
            var binormals = [];
    
            var vec = new Vector3();
            var mat = new Matrix4();
    
            var i, u, theta;
    
            // compute the tangent vectors for each segment on the curve
    
            for ( i = 0; i <= segments; i ++ ) {
    
                u = i / segments;
    
                tangents[ i ] = this.getTangentAt( u );
                tangents[ i ].normalize();
    
            }
    
            // select an initial normal vector perpendicular to the first tangent vector,
            // and in the direction of the minimum tangent xyz component
    
            normals[ 0 ] = new Vector3();
            binormals[ 0 ] = new Vector3();
            var min = Number.MAX_VALUE;
            var tx = Math.abs( tangents[ 0 ].x );
            var ty = Math.abs( tangents[ 0 ].y );
            var tz = Math.abs( tangents[ 0 ].z );
    
            if ( tx <= min ) {
    
                min = tx;
                normal.set( 1, 0, 0 );
    
            }
    
            if ( ty <= min ) {
    
                min = ty;
                normal.set( 0, 1, 0 );
    
            }
    
            if ( tz <= min ) {
    
                normal.set( 0, 0, 1 );
    
            }
    
            vec.crossVectors( tangents[ 0 ], normal ).normalize();
    
            normals[ 0 ].crossVectors( tangents[ 0 ], vec );
            binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
    
    
            // compute the slowly-varying normal and binormal vectors for each segment on the curve
    
            for ( i = 1; i <= segments; i ++ ) {
    
                normals[ i ] = normals[ i - 1 ].clone();
    
                binormals[ i ] = binormals[ i - 1 ].clone();
    
                vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
    
                if ( vec.length() > Number.EPSILON ) {
    
                    vec.normalize();
    
                    theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
    
                    normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
    
                }
    
                binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
    
            }
    
            // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
    
            if ( closed === true ) {
    
                theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
                theta /= segments;
    
                if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {
    
                    theta = - theta;
    
                }
    
                for ( i = 1; i <= segments; i ++ ) {
    
                    // twist a little...
                    normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
                    binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
    
                }
    
            }
    
            return {
                tangents: tangents,
                normals: normals,
                binormals: binormals
            };
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( source ) {
    
            this.arcLengthDivisions = source.arcLengthDivisions;
    
            return this;
    
        },
    
        toJSON: function () {
    
            var data = {
                metadata: {
                    version: 4.5,
                    type: 'Curve',
                    generator: 'Curve.toJSON'
                }
            };
    
            data.arcLengthDivisions = this.arcLengthDivisions;
            data.type = this.type;
    
            return data;
    
        },
    
        fromJSON: function ( json ) {
    
            this.arcLengthDivisions = json.arcLengthDivisions;
    
            return this;
    
        }
    
    } );
    
    function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
    
        Curve.call( this );
    
        this.type = 'EllipseCurve';
    
        this.aX = aX || 0;
        this.aY = aY || 0;
    
        this.xRadius = xRadius || 1;
        this.yRadius = yRadius || 1;
    
        this.aStartAngle = aStartAngle || 0;
        this.aEndAngle = aEndAngle || 2 * Math.PI;
    
        this.aClockwise = aClockwise || false;
    
        this.aRotation = aRotation || 0;
    
    }
    
    EllipseCurve.prototype = Object.create( Curve.prototype );
    EllipseCurve.prototype.constructor = EllipseCurve;
    
    EllipseCurve.prototype.isEllipseCurve = true;
    
    EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {
    
        var point = optionalTarget || new Vector2();
    
        var twoPi = Math.PI * 2;
        var deltaAngle = this.aEndAngle - this.aStartAngle;
        var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;
    
        // ensures that deltaAngle is 0 .. 2 PI
        while ( deltaAngle < 0 ) deltaAngle += twoPi;
        while ( deltaAngle > twoPi ) deltaAngle -= twoPi;
    
        if ( deltaAngle < Number.EPSILON ) {
    
            if ( samePoints ) {
    
                deltaAngle = 0;
    
            } else {
    
                deltaAngle = twoPi;
    
            }
    
        }
    
        if ( this.aClockwise === true && ! samePoints ) {
    
            if ( deltaAngle === twoPi ) {
    
                deltaAngle = - twoPi;
    
            } else {
    
                deltaAngle = deltaAngle - twoPi;
    
            }
    
        }
    
        var angle = this.aStartAngle + t * deltaAngle;
        var x = this.aX + this.xRadius * Math.cos( angle );
        var y = this.aY + this.yRadius * Math.sin( angle );
    
        if ( this.aRotation !== 0 ) {
    
            var cos = Math.cos( this.aRotation );
            var sin = Math.sin( this.aRotation );
    
            var tx = x - this.aX;
            var ty = y - this.aY;
    
            // Rotate the point about the center of the ellipse.
            x = tx * cos - ty * sin + this.aX;
            y = tx * sin + ty * cos + this.aY;
    
        }
    
        return point.set( x, y );
    
    };
    
    EllipseCurve.prototype.copy = function ( source ) {
    
        Curve.prototype.copy.call( this, source );
    
        this.aX = source.aX;
        this.aY = source.aY;
    
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
    
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
    
        this.aClockwise = source.aClockwise;
    
        this.aRotation = source.aRotation;
    
        return this;
    
    };
    
    
    EllipseCurve.prototype.toJSON = function () {
    
        var data = Curve.prototype.toJSON.call( this );
    
        data.aX = this.aX;
        data.aY = this.aY;
    
        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;
    
        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;
    
        data.aClockwise = this.aClockwise;
    
        data.aRotation = this.aRotation;
    
        return data;
    
    };
    
    EllipseCurve.prototype.fromJSON = function ( json ) {
    
        Curve.prototype.fromJSON.call( this, json );
    
        this.aX = json.aX;
        this.aY = json.aY;
    
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
    
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
    
        this.aClockwise = json.aClockwise;
    
        this.aRotation = json.aRotation;
    
        return this;
    
    };
    
    function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
    
        EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
    
        this.type = 'ArcCurve';
    
    }
    
    ArcCurve.prototype = Object.create( EllipseCurve.prototype );
    ArcCurve.prototype.constructor = ArcCurve;
    
    ArcCurve.prototype.isArcCurve = true;
    
    /**
     * @author zz85 https://github.com/zz85
     *
     * Centripetal CatmullRom Curve - which is useful for avoiding
     * cusps and self-intersections in non-uniform catmull rom curves.
     * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
     *
     * curve.type accepts centripetal(default), chordal and catmullrom
     * curve.tension is used for catmullrom which defaults to 0.5
     */
    
    
    /*
    Based on an optimized c++ solution in
     - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
     - http://ideone.com/NoEbVM
    
    This CubicPoly class could be used for reusing some variables and calculations,
    but for three.js curve use, it could be possible inlined and flatten into a single function call
    which can be placed in CurveUtils.
    */
    
    function CubicPoly() {
    
        var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    
        /*
         * Compute coefficients for a cubic polynomial
         *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
         * such that
         *   p(0) = x0, p(1) = x1
         *  and
         *   p'(0) = t0, p'(1) = t1.
         */
        function init( x0, x1, t0, t1 ) {
    
            c0 = x0;
            c1 = t0;
            c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
            c3 = 2 * x0 - 2 * x1 + t0 + t1;
    
        }
    
        return {
    
            initCatmullRom: function ( x0, x1, x2, x3, tension ) {
    
                init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
    
            },
    
            initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {
    
                // compute tangents when parameterized in [t1,t2]
                var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
                var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
    
                // rescale tangents for parametrization in [0,1]
                t1 *= dt1;
                t2 *= dt1;
    
                init( x1, x2, t1, t2 );
    
            },
    
            calc: function ( t ) {
    
                var t2 = t * t;
                var t3 = t2 * t;
                return c0 + c1 * t + c2 * t2 + c3 * t3;
    
            }
    
        };
    
    }
    
    //
    
    var tmp = new Vector3();
    var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
    
    function CatmullRomCurve3( points, closed, curveType, tension ) {
    
        Curve.call( this );
    
        this.type = 'CatmullRomCurve3';
    
        this.points = points || [];
        this.closed = closed || false;
        this.curveType = curveType || 'centripetal';
        this.tension = tension || 0.5;
    
    }
    
    CatmullRomCurve3.prototype = Object.create( Curve.prototype );
    CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
    
    CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
    
    CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {
    
        var point = optionalTarget || new Vector3();
    
        var points = this.points;
        var l = points.length;
    
        var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
        var intPoint = Math.floor( p );
        var weight = p - intPoint;
    
        if ( this.closed ) {
    
            intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;
    
        } else if ( weight === 0 && intPoint === l - 1 ) {
    
            intPoint = l - 2;
            weight = 1;
    
        }
    
        var p0, p1, p2, p3; // 4 points
    
        if ( this.closed || intPoint > 0 ) {
    
            p0 = points[ ( intPoint - 1 ) % l ];
    
        } else {
    
            // extrapolate first point
            tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
            p0 = tmp;
    
        }
    
        p1 = points[ intPoint % l ];
        p2 = points[ ( intPoint + 1 ) % l ];
    
        if ( this.closed || intPoint + 2 < l ) {
    
            p3 = points[ ( intPoint + 2 ) % l ];
    
        } else {
    
            // extrapolate last point
            tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
            p3 = tmp;
    
        }
    
        if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {
    
            // init Centripetal / Chordal Catmull-Rom
            var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
            var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
            var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
            var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
    
            // safety check for repeated points
            if ( dt1 < 1e-4 ) dt1 = 1.0;
            if ( dt0 < 1e-4 ) dt0 = dt1;
            if ( dt2 < 1e-4 ) dt2 = dt1;
    
            px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
            py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
            pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
    
        } else if ( this.curveType === 'catmullrom' ) {
    
            px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
            py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
            pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );
    
        }
    
        point.set(
            px.calc( weight ),
            py.calc( weight ),
            pz.calc( weight )
        );
    
        return point;
    
    };
    
    CatmullRomCurve3.prototype.copy = function ( source ) {
    
        Curve.prototype.copy.call( this, source );
    
        this.points = [];
    
        for ( var i = 0, l = source.points.length; i < l; i ++ ) {
    
            var point = source.points[ i ];
    
            this.points.push( point.clone() );
    
        }
    
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
    
        return this;
    
    };
    
    CatmullRomCurve3.prototype.toJSON = function () {
    
        var data = Curve.prototype.toJSON.call( this );
    
        data.points = [];
    
        for ( var i = 0, l = this.points.length; i < l; i ++ ) {
    
            var point = this.points[ i ];
            data.points.push( point.toArray() );
    
        }
    
        data.closed = this.closed;
        data.curveType = this.curveType;
        data.tension = this.tension;
    
        return data;
    
    };
    
    CatmullRomCurve3.prototype.fromJSON = function ( json ) {
    
        Curve.prototype.fromJSON.call( this, json );
    
        this.points = [];
    
        for ( var i = 0, l = json.points.length; i < l; i ++ ) {
    
            var point = json.points[ i ];
            this.points.push( new Vector3().fromArray( point ) );
    
        }
    
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
    
        return this;
    
    };
    
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     * Bezier Curves formulas obtained from
     * http://en.wikipedia.org/wiki/Bézier_curve
     */
    
    function CatmullRom( t, p0, p1, p2, p3 ) {
    
        var v0 = ( p2 - p0 ) * 0.5;
        var v1 = ( p3 - p1 ) * 0.5;
        var t2 = t * t;
        var t3 = t * t2;
        return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
    
    }
    
    //
    
    function QuadraticBezierP0( t, p ) {
    
        var k = 1 - t;
        return k * k * p;
    
    }
    
    function QuadraticBezierP1( t, p ) {
    
        return 2 * ( 1 - t ) * t * p;
    
    }
    
    function QuadraticBezierP2( t, p ) {
    
        return t * t * p;
    
    }
    
    function QuadraticBezier( t, p0, p1, p2 ) {
    
        return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
            QuadraticBezierP2( t, p2 );
    
    }
    
    //
    
    function CubicBezierP0( t, p ) {
    
        var k = 1 - t;
        return k * k * k * p;
    
    }
    
    function CubicBezierP1( t, p ) {
    
        var k = 1 - t;
        return 3 * k * k * t * p;
    
    }
    
    function CubicBezierP2( t, p ) {
    
        return 3 * ( 1 - t ) * t * t * p;
    
    }
    
    function CubicBezierP3( t, p ) {
    
        return t * t * t * p;
    
    }
    
    function CubicBezier( t, p0, p1, p2, p3 ) {
    
        return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
            CubicBezierP3( t, p3 );
    
    }
    
    function CubicBezierCurve( v0, v1, v2, v3 ) {
    
        Curve.call( this );
    
        this.type = 'CubicBezierCurve';
    
        this.v0 = v0 || new Vector2();
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
        this.v3 = v3 || new Vector2();
    
    }
    
    CubicBezierCurve.prototype = Object.create( Curve.prototype );
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;
    
    CubicBezierCurve.prototype.isCubicBezierCurve = true;
    
    CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {
    
        var point = optionalTarget || new Vector2();
    
        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    
        point.set(
            CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
            CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
        );
    
        return point;
    
    };
    
    CubicBezierCurve.prototype.copy = function ( source ) {
    
        Curve.prototype.copy.call( this, source );
    
        this.v0.copy( source.v0 );
        this.v1.copy( source.v1 );
        this.v2.copy( source.v2 );
        this.v3.copy( source.v3 );
    
        return this;
    
    };
    
    CubicBezierCurve.prototype.toJSON = function () {
    
        var data = Curve.prototype.toJSON.call( this );
    
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
    
        return data;
    
    };
    
    CubicBezierCurve.prototype.fromJSON = function ( json ) {
    
        Curve.prototype.fromJSON.call( this, json );
    
        this.v0.fromArray( json.v0 );
        this.v1.fromArray( json.v1 );
        this.v2.fromArray( json.v2 );
        this.v3.fromArray( json.v3 );
    
        return this;
    
    };
    
    function CubicBezierCurve3( v0, v1, v2, v3 ) {
    
        Curve.call( this );
    
        this.type = 'CubicBezierCurve3';
    
        this.v0 = v0 || new Vector3();
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
        this.v3 = v3 || new Vector3();
    
    }
    
    CubicBezierCurve3.prototype = Object.create( Curve.prototype );
    CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
    
    CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
    
    CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {
    
        var point = optionalTarget || new Vector3();
    
        var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    
        point.set(
            CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
            CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
            CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
        );
    
        return point;
    
    };
    
    CubicBezierCurve3.prototype.copy = function ( source ) {
    
        Curve.prototype.copy.call( this, source );
    
        this.v0.copy( source.v0 );
        this.v1.copy( source.v1 );
        this.v2.copy( source.v2 );
        this.v3.copy( source.v3 );
    
        return this;
    
    };
    
    CubicBezierCurve3.prototype.toJSON = function () {
    
        var data = Curve.prototype.toJSON.call( this );
    
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
    
        return data;
    
    };
    
    CubicBezierCurve3.prototype.fromJSON = function ( json ) {
    
        Curve.prototype.fromJSON.call( this, json );
    
        this.v0.fromArray( json.v0 );
        this.v1.fromArray( json.v1 );
        this.v2.fromArray( json.v2 );
        this.v3.fromArray( json.v3 );
    
        return this;
    
    };
    
    function LineCurve( v1, v2 ) {
    
        Curve.call( this );
    
        this.type = 'LineCurve';
    
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
    
    }
    
    LineCurve.prototype = Object.create( Curve.prototype );
    LineCurve.prototype.constructor = LineCurve;
    
    LineCurve.prototype.isLineCurve = true;
    
    LineCurve.prototype.getPoint = function ( t, optionalTarget ) {
    
        var point = optionalTarget || new Vector2();
    
        if ( t === 1 ) {
    
            point.copy( this.v2 );
    
        } else {
    
            point.copy( this.v2 ).sub( this.v1 );
            point.multiplyScalar( t ).add( this.v1 );
    
        }
    
        return point;
    
    };
    
    // Line curve is linear, so we can overwrite default getPointAt
    
    LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {
    
        return this.getPoint( u, optionalTarget );
    
    };
    
    LineCurve.prototype.getTangent = function ( /* t */ ) {
    
        var tangent = this.v2.clone().sub( this.v1 );
    
        return tangent.normalize();
    
    };
    
    LineCurve.prototype.copy = function ( source ) {
    
        Curve.prototype.copy.call( this, source );
    
        this.v1.copy( source.v1 );
        this.v2.copy( source.v2 );
    
        return this;
    
    };
    
    LineCurve.prototype.toJSON = function () {
    
        var data = Curve.prototype.toJSON.call( this );
    
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
    
        return data;
    
    };
    
    LineCurve.prototype.fromJSON = function ( json ) {
    
        Curve.prototype.fromJSON.call( this, json );
    
        this.v1.fromArray( json.v1 );
        this.v2.fromArray( json.v2 );
    
        return this;
    
    };
    
    function LineCurve3( v1, v2 ) {
    
        Curve.call( this );
    
        this.type = 'LineCurve3';
    
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
    
    }
    
    LineCurve3.prototype = Object.create( Curve.prototype );
    LineCurve3.prototype.constructor = LineCurve3;
    
    LineCurve3.prototype.isLineCurve3 = true;
    
    LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {
    
        var point = optionalTarget || new Vector3();
    
        if ( t === 1 ) {
    
            point.copy( this.v2 );
    
        } else {
    
            point.copy( this.v2 ).sub( this.v1 );
            point.multiplyScalar( t ).add( this.v1 );
    
        }
    
        return point;
    
    };
    
    // Line curve is linear, so we can overwrite default getPointAt
    
    LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {
    
        return this.getPoint( u, optionalTarget );
    
    };
    
    LineCurve3.prototype.copy = function ( source ) {
    
        Curve.prototype.copy.call( this, source );
    
        this.v1.copy( source.v1 );
        this.v2.copy( source.v2 );
    
        return this;
    
    };
    
    LineCurve3.prototype.toJSON = function () {
    
        var data = Curve.prototype.toJSON.call( this );
    
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
    
        return data;
    
    };
    
    LineCurve3.prototype.fromJSON = function ( json ) {
    
        Curve.prototype.fromJSON.call( this, json );
    
        this.v1.fromArray( json.v1 );
        this.v2.fromArray( json.v2 );
    
        return this;
    
    };
    
    function QuadraticBezierCurve( v0, v1, v2 ) {
    
        Curve.call( this );
    
        this.type = 'QuadraticBezierCurve';
    
        this.v0 = v0 || new Vector2();
        this.v1 = v1 || new Vector2();
        this.v2 = v2 || new Vector2();
    
    }
    
    QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
    
    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
    
    QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {
    
        var point = optionalTarget || new Vector2();
    
        var v0 = this.v0, v1 = this.v1, v2 = this.v2;
    
        point.set(
            QuadraticBezier( t, v0.x, v1.x, v2.x ),
            QuadraticBezier( t, v0.y, v1.y, v2.y )
        );
    
        return point;
    
    };
    
    QuadraticBezierCurve.prototype.copy = function ( source ) {
    
        Curve.prototype.copy.call( this, source );
    
        this.v0.copy( source.v0 );
        this.v1.copy( source.v1 );
        this.v2.copy( source.v2 );
    
        return this;
    
    };
    
    QuadraticBezierCurve.prototype.toJSON = function () {
    
        var data = Curve.prototype.toJSON.call( this );
    
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
    
        return data;
    
    };
    
    QuadraticBezierCurve.prototype.fromJSON = function ( json ) {
    
        Curve.prototype.fromJSON.call( this, json );
    
        this.v0.fromArray( json.v0 );
        this.v1.fromArray( json.v1 );
        this.v2.fromArray( json.v2 );
    
        return this;
    
    };
    
    function QuadraticBezierCurve3( v0, v1, v2 ) {
    
        Curve.call( this );
    
        this.type = 'QuadraticBezierCurve3';
    
        this.v0 = v0 || new Vector3();
        this.v1 = v1 || new Vector3();
        this.v2 = v2 || new Vector3();
    
    }
    
    QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
    QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
    
    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
    
    QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {
    
        var point = optionalTarget || new Vector3();
    
        var v0 = this.v0, v1 = this.v1, v2 = this.v2;
    
        point.set(
            QuadraticBezier( t, v0.x, v1.x, v2.x ),
            QuadraticBezier( t, v0.y, v1.y, v2.y ),
            QuadraticBezier( t, v0.z, v1.z, v2.z )
        );
    
        return point;
    
    };
    
    QuadraticBezierCurve3.prototype.copy = function ( source ) {
    
        Curve.prototype.copy.call( this, source );
    
        this.v0.copy( source.v0 );
        this.v1.copy( source.v1 );
        this.v2.copy( source.v2 );
    
        return this;
    
    };
    
    QuadraticBezierCurve3.prototype.toJSON = function () {
    
        var data = Curve.prototype.toJSON.call( this );
    
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
    
        return data;
    
    };
    
    QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {
    
        Curve.prototype.fromJSON.call( this, json );
    
        this.v0.fromArray( json.v0 );
        this.v1.fromArray( json.v1 );
        this.v2.fromArray( json.v2 );
    
        return this;
    
    };
    
    function SplineCurve( points /* array of Vector2 */ ) {
    
        Curve.call( this );
    
        this.type = 'SplineCurve';
    
        this.points = points || [];
    
    }
    
    SplineCurve.prototype = Object.create( Curve.prototype );
    SplineCurve.prototype.constructor = SplineCurve;
    
    SplineCurve.prototype.isSplineCurve = true;
    
    SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {
    
        var point = optionalTarget || new Vector2();
    
        var points = this.points;
        var p = ( points.length - 1 ) * t;
    
        var intPoint = Math.floor( p );
        var weight = p - intPoint;
    
        var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
        var p1 = points[ intPoint ];
        var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
        var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
    
        point.set(
            CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
            CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
        );
    
        return point;
    
    };
    
    SplineCurve.prototype.copy = function ( source ) {
    
        Curve.prototype.copy.call( this, source );
    
        this.points = [];
    
        for ( var i = 0, l = source.points.length; i < l; i ++ ) {
    
            var point = source.points[ i ];
    
            this.points.push( point.clone() );
    
        }
    
        return this;
    
    };
    
    SplineCurve.prototype.toJSON = function () {
    
        var data = Curve.prototype.toJSON.call( this );
    
        data.points = [];
    
        for ( var i = 0, l = this.points.length; i < l; i ++ ) {
    
            var point = this.points[ i ];
            data.points.push( point.toArray() );
    
        }
    
        return data;
    
    };
    
    SplineCurve.prototype.fromJSON = function ( json ) {
    
        Curve.prototype.fromJSON.call( this, json );
    
        this.points = [];
    
        for ( var i = 0, l = json.points.length; i < l; i ++ ) {
    
            var point = json.points[ i ];
            this.points.push( new Vector2().fromArray( point ) );
    
        }
    
        return this;
    
    };
    
    
    
    var Curves = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ArcCurve: ArcCurve,
        CatmullRomCurve3: CatmullRomCurve3,
        CubicBezierCurve: CubicBezierCurve,
        CubicBezierCurve3: CubicBezierCurve3,
        EllipseCurve: EllipseCurve,
        LineCurve: LineCurve,
        LineCurve3: LineCurve3,
        QuadraticBezierCurve: QuadraticBezierCurve,
        QuadraticBezierCurve3: QuadraticBezierCurve3,
        SplineCurve: SplineCurve
    });
    
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     **/
    
    /**************************************************************
     *	Curved Path - a curve path is simply a array of connected
     *  curves, but retains the api of a curve
     **************************************************************/
    
    function CurvePath() {
    
        Curve.call( this );
    
        this.type = 'CurvePath';
    
        this.curves = [];
        this.autoClose = false; // Automatically closes the path
    
    }
    
    CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {
    
        constructor: CurvePath,
    
        add: function ( curve ) {
    
            this.curves.push( curve );
    
        },
    
        closePath: function () {
    
            // Add a line curve if start and end of lines are not connected
            var startPoint = this.curves[ 0 ].getPoint( 0 );
            var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
    
            if ( ! startPoint.equals( endPoint ) ) {
    
                this.curves.push( new LineCurve( endPoint, startPoint ) );
    
            }
    
        },
    
        // To get accurate point with reference to
        // entire path distance at time t,
        // following has to be done:
    
        // 1. Length of each sub path have to be known
        // 2. Locate and identify type of curve
        // 3. Get t for the curve
        // 4. Return curve.getPointAt(t')
    
        getPoint: function ( t ) {
    
            var d = t * this.getLength();
            var curveLengths = this.getCurveLengths();
            var i = 0;
    
            // To think about boundaries points.
    
            while ( i < curveLengths.length ) {
    
                if ( curveLengths[ i ] >= d ) {
    
                    var diff = curveLengths[ i ] - d;
                    var curve = this.curves[ i ];
    
                    var segmentLength = curve.getLength();
                    var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
    
                    return curve.getPointAt( u );
    
                }
    
                i ++;
    
            }
    
            return null;
    
            // loop where sum != 0, sum > d , sum+1 <d
    
        },
    
        // We cannot use the default THREE.Curve getPoint() with getLength() because in
        // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
        // getPoint() depends on getLength
    
        getLength: function () {
    
            var lens = this.getCurveLengths();
            return lens[ lens.length - 1 ];
    
        },
    
        // cacheLengths must be recalculated.
        updateArcLengths: function () {
    
            this.needsUpdate = true;
            this.cacheLengths = null;
            this.getCurveLengths();
    
        },
    
        // Compute lengths and cache them
        // We cannot overwrite getLengths() because UtoT mapping uses it.
    
        getCurveLengths: function () {
    
            // We use cache values if curves and cache array are same length
    
            if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
    
                return this.cacheLengths;
    
            }
    
            // Get length of sub-curve
            // Push sums into cached array
    
            var lengths = [], sums = 0;
    
            for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
    
                sums += this.curves[ i ].getLength();
                lengths.push( sums );
    
            }
    
            this.cacheLengths = lengths;
    
            return lengths;
    
        },
    
        getSpacedPoints: function ( divisions ) {
    
            if ( divisions === undefined ) divisions = 40;
    
            var points = [];
    
            for ( var i = 0; i <= divisions; i ++ ) {
    
                points.push( this.getPoint( i / divisions ) );
    
            }
    
            if ( this.autoClose ) {
    
                points.push( points[ 0 ] );
    
            }
    
            return points;
    
        },
    
        getPoints: function ( divisions ) {
    
            divisions = divisions || 12;
    
            var points = [], last;
    
            for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {
    
                var curve = curves[ i ];
                var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
                    : ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
                        : ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
                            : divisions;
    
                var pts = curve.getPoints( resolution );
    
                for ( var j = 0; j < pts.length; j ++ ) {
    
                    var point = pts[ j ];
    
                    if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates
    
                    points.push( point );
                    last = point;
    
                }
    
            }
    
            if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {
    
                points.push( points[ 0 ] );
    
            }
    
            return points;
    
        },
    
        copy: function ( source ) {
    
            Curve.prototype.copy.call( this, source );
    
            this.curves = [];
    
            for ( var i = 0, l = source.curves.length; i < l; i ++ ) {
    
                var curve = source.curves[ i ];
    
                this.curves.push( curve.clone() );
    
            }
    
            this.autoClose = source.autoClose;
    
            return this;
    
        },
    
        toJSON: function () {
    
            var data = Curve.prototype.toJSON.call( this );
    
            data.autoClose = this.autoClose;
            data.curves = [];
    
            for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
    
                var curve = this.curves[ i ];
                data.curves.push( curve.toJSON() );
    
            }
    
            return data;
    
        },
    
        fromJSON: function ( json ) {
    
            Curve.prototype.fromJSON.call( this, json );
    
            this.autoClose = json.autoClose;
            this.curves = [];
    
            for ( var i = 0, l = json.curves.length; i < l; i ++ ) {
    
                var curve = json.curves[ i ];
                this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );
    
            }
    
            return this;
    
        }
    
    } );
    
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Creates free form 2d path using series of points, lines or curves.
     **/
    
    function Path( points ) {
    
        CurvePath.call( this );
    
        this.type = 'Path';
    
        this.currentPoint = new Vector2();
    
        if ( points ) {
    
            this.setFromPoints( points );
    
        }
    
    }
    
    Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {
    
        constructor: Path,
    
        setFromPoints: function ( points ) {
    
            this.moveTo( points[ 0 ].x, points[ 0 ].y );
    
            for ( var i = 1, l = points.length; i < l; i ++ ) {
    
                this.lineTo( points[ i ].x, points[ i ].y );
    
            }
    
            return this;
    
        },
    
        moveTo: function ( x, y ) {
    
            this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?
    
            return this;
    
        },
    
        lineTo: function ( x, y ) {
    
            var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
            this.curves.push( curve );
    
            this.currentPoint.set( x, y );
    
            return this;
    
        },
    
        quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
    
            var curve = new QuadraticBezierCurve(
                this.currentPoint.clone(),
                new Vector2( aCPx, aCPy ),
                new Vector2( aX, aY )
            );
    
            this.curves.push( curve );
    
            this.currentPoint.set( aX, aY );
    
            return this;
    
        },
    
        bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
    
            var curve = new CubicBezierCurve(
                this.currentPoint.clone(),
                new Vector2( aCP1x, aCP1y ),
                new Vector2( aCP2x, aCP2y ),
                new Vector2( aX, aY )
            );
    
            this.curves.push( curve );
    
            this.currentPoint.set( aX, aY );
    
            return this;
    
        },
    
        splineThru: function ( pts /*Array of Vector*/ ) {
    
            var npts = [ this.currentPoint.clone() ].concat( pts );
    
            var curve = new SplineCurve( npts );
            this.curves.push( curve );
    
            this.currentPoint.copy( pts[ pts.length - 1 ] );
    
            return this;
    
        },
    
        arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
    
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
    
            this.absarc( aX + x0, aY + y0, aRadius,
                aStartAngle, aEndAngle, aClockwise );
    
            return this;
    
        },
    
        absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
    
            this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
    
            return this;
    
        },
    
        ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
    
            var x0 = this.currentPoint.x;
            var y0 = this.currentPoint.y;
    
            this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
    
            return this;
    
        },
    
        absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
    
            var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
    
            if ( this.curves.length > 0 ) {
    
                // if a previous curve is present, attempt to join
                var firstPoint = curve.getPoint( 0 );
    
                if ( ! firstPoint.equals( this.currentPoint ) ) {
    
                    this.lineTo( firstPoint.x, firstPoint.y );
    
                }
    
            }
    
            this.curves.push( curve );
    
            var lastPoint = curve.getPoint( 1 );
            this.currentPoint.copy( lastPoint );
    
            return this;
    
        },
    
        copy: function ( source ) {
    
            CurvePath.prototype.copy.call( this, source );
    
            this.currentPoint.copy( source.currentPoint );
    
            return this;
    
        },
    
        toJSON: function () {
    
            var data = CurvePath.prototype.toJSON.call( this );
    
            data.currentPoint = this.currentPoint.toArray();
    
            return data;
    
        },
    
        fromJSON: function ( json ) {
    
            CurvePath.prototype.fromJSON.call( this, json );
    
            this.currentPoint.fromArray( json.currentPoint );
    
            return this;
    
        }
    
    } );
    
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Defines a 2d shape plane using paths.
     **/
    
    // STEP 1 Create a path.
    // STEP 2 Turn path into shape.
    // STEP 3 ExtrudeGeometry takes in Shape/Shapes
    // STEP 3a - Extract points from each shape, turn to vertices
    // STEP 3b - Triangulate each shape, add faces.
    
    function Shape( points ) {
    
        Path.call( this, points );
    
        this.uuid = MathUtils.generateUUID();
    
        this.type = 'Shape';
    
        this.holes = [];
    
    }
    
    Shape.prototype = Object.assign( Object.create( Path.prototype ), {
    
        constructor: Shape,
    
        getPointsHoles: function ( divisions ) {
    
            var holesPts = [];
    
            for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
    
                holesPts[ i ] = this.holes[ i ].getPoints( divisions );
    
            }
    
            return holesPts;
    
        },
    
        // get points of shape and holes (keypoints based on segments parameter)
    
        extractPoints: function ( divisions ) {
    
            return {
    
                shape: this.getPoints( divisions ),
                holes: this.getPointsHoles( divisions )
    
            };
    
        },
    
        copy: function ( source ) {
    
            Path.prototype.copy.call( this, source );
    
            this.holes = [];
    
            for ( var i = 0, l = source.holes.length; i < l; i ++ ) {
    
                var hole = source.holes[ i ];
    
                this.holes.push( hole.clone() );
    
            }
    
            return this;
    
        },
    
        toJSON: function () {
    
            var data = Path.prototype.toJSON.call( this );
    
            data.uuid = this.uuid;
            data.holes = [];
    
            for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
    
                var hole = this.holes[ i ];
                data.holes.push( hole.toJSON() );
    
            }
    
            return data;
    
        },
    
        fromJSON: function ( json ) {
    
            Path.prototype.fromJSON.call( this, json );
    
            this.uuid = json.uuid;
            this.holes = [];
    
            for ( var i = 0, l = json.holes.length; i < l; i ++ ) {
    
                var hole = json.holes[ i ];
                this.holes.push( new Path().fromJSON( hole ) );
    
            }
    
            return this;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    
    function Light( color, intensity ) {
    
        Object3D.call( this );
    
        this.type = 'Light';
    
        this.color = new Color( color );
        this.intensity = intensity !== undefined ? intensity : 1;
    
        this.receiveShadow = undefined;
    
    }
    
    Light.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: Light,
    
        isLight: true,
    
        copy: function ( source ) {
    
            Object3D.prototype.copy.call( this, source );
    
            this.color.copy( source.color );
            this.intensity = source.intensity;
    
            return this;
    
        },
    
        toJSON: function ( meta ) {
    
            var data = Object3D.prototype.toJSON.call( this, meta );
    
            data.object.color = this.color.getHex();
            data.object.intensity = this.intensity;
    
            if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
    
            if ( this.distance !== undefined ) data.object.distance = this.distance;
            if ( this.angle !== undefined ) data.object.angle = this.angle;
            if ( this.decay !== undefined ) data.object.decay = this.decay;
            if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;
    
            if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
    
            return data;
    
        }
    
    } );
    
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    
    function HemisphereLight( skyColor, groundColor, intensity ) {
    
        Light.call( this, skyColor, intensity );
    
        this.type = 'HemisphereLight';
    
        this.castShadow = undefined;
    
        this.position.copy( Object3D.DefaultUp );
        this.updateMatrix();
    
        this.groundColor = new Color( groundColor );
    
    }
    
    HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {
    
        constructor: HemisphereLight,
    
        isHemisphereLight: true,
    
        copy: function ( source ) {
    
            Light.prototype.copy.call( this, source );
    
            this.groundColor.copy( source.groundColor );
    
            return this;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function LightShadow( camera ) {
    
        this.camera = camera;
    
        this.bias = 0;
        this.radius = 1;
    
        this.mapSize = new Vector2( 512, 512 );
    
        this.map = null;
        this.mapPass = null;
        this.matrix = new Matrix4();
    
        this._frustum = new Frustum();
        this._frameExtents = new Vector2( 1, 1 );
    
        this._viewportCount = 1;
    
        this._viewports = [
    
            new Vector4( 0, 0, 1, 1 )
    
        ];
    
    }
    
    Object.assign( LightShadow.prototype, {
    
        _projScreenMatrix: new Matrix4(),
    
        _lightPositionWorld: new Vector3(),
    
        _lookTarget: new Vector3(),
    
        getViewportCount: function () {
    
            return this._viewportCount;
    
        },
    
        getFrustum: function () {
    
            return this._frustum;
    
        },
    
        updateMatrices: function ( light ) {
    
            var shadowCamera = this.camera,
                shadowMatrix = this.matrix,
                projScreenMatrix = this._projScreenMatrix,
                lookTarget = this._lookTarget,
                lightPositionWorld = this._lightPositionWorld;
    
            lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
            shadowCamera.position.copy( lightPositionWorld );
    
            lookTarget.setFromMatrixPosition( light.target.matrixWorld );
            shadowCamera.lookAt( lookTarget );
            shadowCamera.updateMatrixWorld();
    
            projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
            this._frustum.setFromProjectionMatrix( projScreenMatrix );
    
            shadowMatrix.set(
                0.5, 0.0, 0.0, 0.5,
                0.0, 0.5, 0.0, 0.5,
                0.0, 0.0, 0.5, 0.5,
                0.0, 0.0, 0.0, 1.0
            );
    
            shadowMatrix.multiply( shadowCamera.projectionMatrix );
            shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
    
        },
    
        getViewport: function ( viewportIndex ) {
    
            return this._viewports[ viewportIndex ];
    
        },
    
        getFrameExtents: function () {
    
            return this._frameExtents;
    
        },
    
        copy: function ( source ) {
    
            this.camera = source.camera.clone();
    
            this.bias = source.bias;
            this.radius = source.radius;
    
            this.mapSize.copy( source.mapSize );
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        toJSON: function () {
    
            var object = {};
    
            if ( this.bias !== 0 ) object.bias = this.bias;
            if ( this.radius !== 1 ) object.radius = this.radius;
            if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();
    
            object.camera = this.camera.toJSON( false ).object;
            delete object.camera.matrix;
    
            return object;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function SpotLightShadow() {
    
        LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );
    
    }
    
    SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
    
        constructor: SpotLightShadow,
    
        isSpotLightShadow: true,
    
        updateMatrices: function ( light ) {
    
            var camera = this.camera;
    
            var fov = MathUtils.RAD2DEG * 2 * light.angle;
            var aspect = this.mapSize.width / this.mapSize.height;
            var far = light.distance || camera.far;
    
            if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {
    
                camera.fov = fov;
                camera.aspect = aspect;
                camera.far = far;
                camera.updateProjectionMatrix();
    
            }
    
            LightShadow.prototype.updateMatrices.call( this, light );
    
        }
    
    } );
    
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    
    function SpotLight( color, intensity, distance, angle, penumbra, decay ) {
    
        Light.call( this, color, intensity );
    
        this.type = 'SpotLight';
    
        this.position.copy( Object3D.DefaultUp );
        this.updateMatrix();
    
        this.target = new Object3D();
    
        Object.defineProperty( this, 'power', {
            get: function () {
    
                // intensity = power per solid angle.
                // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                return this.intensity * Math.PI;
    
            },
            set: function ( power ) {
    
                // intensity = power per solid angle.
                // ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                this.intensity = power / Math.PI;
    
            }
        } );
    
        this.distance = ( distance !== undefined ) ? distance : 0;
        this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
        this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
        this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
    
        this.shadow = new SpotLightShadow();
    
    }
    
    SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {
    
        constructor: SpotLight,
    
        isSpotLight: true,
    
        copy: function ( source ) {
    
            Light.prototype.copy.call( this, source );
    
            this.distance = source.distance;
            this.angle = source.angle;
            this.penumbra = source.penumbra;
            this.decay = source.decay;
    
            this.target = source.target.clone();
    
            this.shadow = source.shadow.clone();
    
            return this;
    
        }
    
    } );
    
    function PointLightShadow() {
    
        LightShadow.call( this, new PerspectiveCamera( 90, 1, 0.5, 500 ) );
    
        this._frameExtents = new Vector2( 4, 2 );
    
        this._viewportCount = 6;
    
        this._viewports = [
            // These viewports map a cube-map onto a 2D texture with the
            // following orientation:
            //
            //  xzXZ
            //   y Y
            //
            // X - Positive x direction
            // x - Negative x direction
            // Y - Positive y direction
            // y - Negative y direction
            // Z - Positive z direction
            // z - Negative z direction
    
            // positive X
            new Vector4( 2, 1, 1, 1 ),
            // negative X
            new Vector4( 0, 1, 1, 1 ),
            // positive Z
            new Vector4( 3, 1, 1, 1 ),
            // negative Z
            new Vector4( 1, 1, 1, 1 ),
            // positive Y
            new Vector4( 3, 0, 1, 1 ),
            // negative Y
            new Vector4( 1, 0, 1, 1 )
        ];
    
        this._cubeDirections = [
            new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
            new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
        ];
    
        this._cubeUps = [
            new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
            new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
        ];
    
    }
    
    PointLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
    
        constructor: PointLightShadow,
    
        isPointLightShadow: true,
    
        updateMatrices: function ( light, viewportIndex ) {
    
            if ( viewportIndex === undefined ) viewportIndex = 0;
    
            var camera = this.camera,
                shadowMatrix = this.matrix,
                lightPositionWorld = this._lightPositionWorld,
                lookTarget = this._lookTarget,
                projScreenMatrix = this._projScreenMatrix;
    
            lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
            camera.position.copy( lightPositionWorld );
    
            lookTarget.copy( camera.position );
            lookTarget.add( this._cubeDirections[ viewportIndex ] );
            camera.up.copy( this._cubeUps[ viewportIndex ] );
            camera.lookAt( lookTarget );
            camera.updateMatrixWorld();
    
            shadowMatrix.makeTranslation( - lightPositionWorld.x, - lightPositionWorld.y, - lightPositionWorld.z );
    
            projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
            this._frustum.setFromProjectionMatrix( projScreenMatrix );
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    
    function PointLight( color, intensity, distance, decay ) {
    
        Light.call( this, color, intensity );
    
        this.type = 'PointLight';
    
        Object.defineProperty( this, 'power', {
            get: function () {
    
                // intensity = power per solid angle.
                // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                return this.intensity * 4 * Math.PI;
    
            },
            set: function ( power ) {
    
                // intensity = power per solid angle.
                // ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
                this.intensity = power / ( 4 * Math.PI );
    
            }
        } );
    
        this.distance = ( distance !== undefined ) ? distance : 0;
        this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
    
        this.shadow = new PointLightShadow();
    
    }
    
    PointLight.prototype = Object.assign( Object.create( Light.prototype ), {
    
        constructor: PointLight,
    
        isPointLight: true,
    
        copy: function ( source ) {
    
            Light.prototype.copy.call( this, source );
    
            this.distance = source.distance;
            this.decay = source.decay;
    
            this.shadow = source.shadow.clone();
    
            return this;
    
        }
    
    } );
    
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author arose / http://github.com/arose
     */
    
    function OrthographicCamera( left, right, top, bottom, near, far ) {
    
        Camera.call( this );
    
        this.type = 'OrthographicCamera';
    
        this.zoom = 1;
        this.view = null;
    
        this.left = ( left !== undefined ) ? left : - 1;
        this.right = ( right !== undefined ) ? right : 1;
        this.top = ( top !== undefined ) ? top : 1;
        this.bottom = ( bottom !== undefined ) ? bottom : - 1;
    
        this.near = ( near !== undefined ) ? near : 0.1;
        this.far = ( far !== undefined ) ? far : 2000;
    
        this.updateProjectionMatrix();
    
    }
    
    OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
    
        constructor: OrthographicCamera,
    
        isOrthographicCamera: true,
    
        copy: function ( source, recursive ) {
    
            Camera.prototype.copy.call( this, source, recursive );
    
            this.left = source.left;
            this.right = source.right;
            this.top = source.top;
            this.bottom = source.bottom;
            this.near = source.near;
            this.far = source.far;
    
            this.zoom = source.zoom;
            this.view = source.view === null ? null : Object.assign( {}, source.view );
    
            return this;
    
        },
    
        setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
    
            if ( this.view === null ) {
    
                this.view = {
                    enabled: true,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                };
    
            }
    
            this.view.enabled = true;
            this.view.fullWidth = fullWidth;
            this.view.fullHeight = fullHeight;
            this.view.offsetX = x;
            this.view.offsetY = y;
            this.view.width = width;
            this.view.height = height;
    
            this.updateProjectionMatrix();
    
        },
    
        clearViewOffset: function () {
    
            if ( this.view !== null ) {
    
                this.view.enabled = false;
    
            }
    
            this.updateProjectionMatrix();
    
        },
    
        updateProjectionMatrix: function () {
    
            var dx = ( this.right - this.left ) / ( 2 * this.zoom );
            var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
            var cx = ( this.right + this.left ) / 2;
            var cy = ( this.top + this.bottom ) / 2;
    
            var left = cx - dx;
            var right = cx + dx;
            var top = cy + dy;
            var bottom = cy - dy;
    
            if ( this.view !== null && this.view.enabled ) {
    
                var scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
                var scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;
    
                left += scaleW * this.view.offsetX;
                right = left + scaleW * this.view.width;
                top -= scaleH * this.view.offsetY;
                bottom = top - scaleH * this.view.height;
    
            }
    
            this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );
    
            this.projectionMatrixInverse.getInverse( this.projectionMatrix );
    
        },
    
        toJSON: function ( meta ) {
    
            var data = Object3D.prototype.toJSON.call( this, meta );
    
            data.object.zoom = this.zoom;
            data.object.left = this.left;
            data.object.right = this.right;
            data.object.top = this.top;
            data.object.bottom = this.bottom;
            data.object.near = this.near;
            data.object.far = this.far;
    
            if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
    
            return data;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function DirectionalLightShadow() {
    
        LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );
    
    }
    
    DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
    
        constructor: DirectionalLightShadow,
    
        isDirectionalLightShadow: true,
    
        updateMatrices: function ( light ) {
    
            LightShadow.prototype.updateMatrices.call( this, light );
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */
    
    function DirectionalLight( color, intensity ) {
    
        Light.call( this, color, intensity );
    
        this.type = 'DirectionalLight';
    
        this.position.copy( Object3D.DefaultUp );
        this.updateMatrix();
    
        this.target = new Object3D();
    
        this.shadow = new DirectionalLightShadow();
    
    }
    
    DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {
    
        constructor: DirectionalLight,
    
        isDirectionalLight: true,
    
        copy: function ( source ) {
    
            Light.prototype.copy.call( this, source );
    
            this.target = source.target.clone();
    
            this.shadow = source.shadow.clone();
    
            return this;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function AmbientLight( color, intensity ) {
    
        Light.call( this, color, intensity );
    
        this.type = 'AmbientLight';
    
        this.castShadow = undefined;
    
    }
    
    AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {
    
        constructor: AmbientLight,
    
        isAmbientLight: true
    
    } );
    
    /**
     * @author abelnation / http://github.com/abelnation
     */
    
    function RectAreaLight( color, intensity, width, height ) {
    
        Light.call( this, color, intensity );
    
        this.type = 'RectAreaLight';
    
        this.width = ( width !== undefined ) ? width : 10;
        this.height = ( height !== undefined ) ? height : 10;
    
    }
    
    RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {
    
        constructor: RectAreaLight,
    
        isRectAreaLight: true,
    
        copy: function ( source ) {
    
            Light.prototype.copy.call( this, source );
    
            this.width = source.width;
            this.height = source.height;
    
            return this;
    
        },
    
        toJSON: function ( meta ) {
    
            var data = Light.prototype.toJSON.call( this, meta );
    
            data.object.width = this.width;
            data.object.height = this.height;
    
            return data;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function MaterialLoader( manager ) {
    
        Loader.call( this, manager );
    
        this.textures = {};
    
    }
    
    MaterialLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: MaterialLoader,
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            var scope = this;
    
            var loader = new FileLoader( scope.manager );
            loader.setPath( scope.path );
            loader.load( url, function ( text ) {
    
                onLoad( scope.parse( JSON.parse( text ) ) );
    
            }, onProgress, onError );
    
        },
    
        parse: function ( json ) {
    
            var textures = this.textures;
    
            function getTexture( name ) {
    
                if ( textures[ name ] === undefined ) {
    
                    console.warn( 'THREE.MaterialLoader: Undefined texture', name );
    
                }
    
                return textures[ name ];
    
            }
    
            var material = new Materials[ json.type ]();
    
            if ( json.uuid !== undefined ) material.uuid = json.uuid;
            if ( json.name !== undefined ) material.name = json.name;
            if ( json.color !== undefined ) material.color.setHex( json.color );
            if ( json.roughness !== undefined ) material.roughness = json.roughness;
            if ( json.metalness !== undefined ) material.metalness = json.metalness;
            if ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );
            if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
            if ( json.specular !== undefined ) material.specular.setHex( json.specular );
            if ( json.shininess !== undefined ) material.shininess = json.shininess;
            if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
            if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
            if ( json.fog !== undefined ) material.fog = json.fog;
            if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
            if ( json.blending !== undefined ) material.blending = json.blending;
            if ( json.combine !== undefined ) material.combine = json.combine;
            if ( json.side !== undefined ) material.side = json.side;
            if ( json.opacity !== undefined ) material.opacity = json.opacity;
            if ( json.transparent !== undefined ) material.transparent = json.transparent;
            if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
            if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
            if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
            if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
    
            if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
            if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
            if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
            if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
            if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
            if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
            if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
            if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;
    
            if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
            if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
            if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
            if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
    
            if ( json.rotation !== undefined ) material.rotation = json.rotation;
    
            if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
            if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
            if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
            if ( json.scale !== undefined ) material.scale = json.scale;
    
            if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
            if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
            if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;
    
            if ( json.skinning !== undefined ) material.skinning = json.skinning;
            if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
            if ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;
            if ( json.dithering !== undefined ) material.dithering = json.dithering;
    
            if ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;
    
            if ( json.visible !== undefined ) material.visible = json.visible;
    
            if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;
    
            if ( json.userData !== undefined ) material.userData = json.userData;
    
            if ( json.vertexColors !== undefined ) {
    
                if ( typeof json.vertexColors === 'number' ) {
    
                    material.vertexColors = ( json.vertexColors > 0 ) ? true : false;
    
                } else {
    
                    material.vertexColors = json.vertexColors;
    
                }
    
            }
    
            // Shader Material
    
            if ( json.uniforms !== undefined ) {
    
                for ( var name in json.uniforms ) {
    
                    var uniform = json.uniforms[ name ];
    
                    material.uniforms[ name ] = {};
    
                    switch ( uniform.type ) {
    
                        case 't':
                            material.uniforms[ name ].value = getTexture( uniform.value );
                            break;
    
                        case 'c':
                            material.uniforms[ name ].value = new Color().setHex( uniform.value );
                            break;
    
                        case 'v2':
                            material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
                            break;
    
                        case 'v3':
                            material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
                            break;
    
                        case 'v4':
                            material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
                            break;
    
                        case 'm3':
                            material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
    
                        case 'm4':
                            material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
                            break;
    
                        default:
                            material.uniforms[ name ].value = uniform.value;
    
                    }
    
                }
    
            }
    
            if ( json.defines !== undefined ) material.defines = json.defines;
            if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
            if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
    
            if ( json.extensions !== undefined ) {
    
                for ( var key in json.extensions ) {
    
                    material.extensions[ key ] = json.extensions[ key ];
    
                }
    
            }
    
            // Deprecated
    
            if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading
    
            // for PointsMaterial
    
            if ( json.size !== undefined ) material.size = json.size;
            if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
    
            // maps
    
            if ( json.map !== undefined ) material.map = getTexture( json.map );
            if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );
    
            if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );
    
            if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
            if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
    
            if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
            if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
            if ( json.normalScale !== undefined ) {
    
                var normalScale = json.normalScale;
    
                if ( Array.isArray( normalScale ) === false ) {
    
                    // Blender exporter used to export a scalar. See #7459
    
                    normalScale = [ normalScale, normalScale ];
    
                }
    
                material.normalScale = new Vector2().fromArray( normalScale );
    
            }
    
            if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
            if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
            if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
    
            if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
            if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );
    
            if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
            if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;
    
            if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
    
            if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
            if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;
    
            if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
            if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;
    
            if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
            if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
    
            if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
            if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
    
            if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );
    
            if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
            if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );
    
            return material;
    
        },
    
        setTextures: function ( value ) {
    
            this.textures = value;
            return this;
    
        }
    
    } );
    
    /**
     * @author Don McCurdy / https://www.donmccurdy.com
     */
    
    var LoaderUtils = {
    
        decodeText: function ( array ) {
    
            if ( typeof TextDecoder !== 'undefined' ) {
    
                return new TextDecoder().decode( array );
    
            }
    
            // Avoid the String.fromCharCode.apply(null, array) shortcut, which
            // throws a "maximum call stack size exceeded" error for large arrays.
    
            var s = '';
    
            for ( var i = 0, il = array.length; i < il; i ++ ) {
    
                // Implicitly assumes little-endian.
                s += String.fromCharCode( array[ i ] );
    
            }
    
            try {
    
                // merges multi-byte utf-8 characters.
    
                return decodeURIComponent( escape( s ) );
    
            } catch ( e ) { // see #16358
    
                return s;
    
            }
    
        },
    
        extractUrlBase: function ( url ) {
    
            var index = url.lastIndexOf( '/' );
    
            if ( index === - 1 ) return './';
    
            return url.substr( 0, index + 1 );
    
        }
    
    };
    
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    
    function InstancedBufferGeometry() {
    
        BufferGeometry.call( this );
    
        this.type = 'InstancedBufferGeometry';
        this.maxInstancedCount = undefined;
    
    }
    
    InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {
    
        constructor: InstancedBufferGeometry,
    
        isInstancedBufferGeometry: true,
    
        copy: function ( source ) {
    
            BufferGeometry.prototype.copy.call( this, source );
    
            this.maxInstancedCount = source.maxInstancedCount;
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        toJSON: function () {
    
            var data = BufferGeometry.prototype.toJSON.call( this );
    
            data.maxInstancedCount = this.maxInstancedCount;
    
            data.isInstancedBufferGeometry = true;
    
            return data;
    
        }
    
    } );
    
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    
    function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {
    
        if ( typeof ( normalized ) === 'number' ) {
    
            meshPerAttribute = normalized;
    
            normalized = false;
    
            console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );
    
        }
    
        BufferAttribute.call( this, array, itemSize, normalized );
    
        this.meshPerAttribute = meshPerAttribute || 1;
    
    }
    
    InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {
    
        constructor: InstancedBufferAttribute,
    
        isInstancedBufferAttribute: true,
    
        copy: function ( source ) {
    
            BufferAttribute.prototype.copy.call( this, source );
    
            this.meshPerAttribute = source.meshPerAttribute;
    
            return this;
    
        },
    
        toJSON: function ()	{
    
            var data = BufferAttribute.prototype.toJSON.call( this );
    
            data.meshPerAttribute = this.meshPerAttribute;
    
            data.isInstancedBufferAttribute = true;
    
            return data;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function BufferGeometryLoader( manager ) {
    
        Loader.call( this, manager );
    
    }
    
    BufferGeometryLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: BufferGeometryLoader,
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            var scope = this;
    
            var loader = new FileLoader( scope.manager );
            loader.setPath( scope.path );
            loader.load( url, function ( text ) {
    
                onLoad( scope.parse( JSON.parse( text ) ) );
    
            }, onProgress, onError );
    
        },
    
        parse: function ( json ) {
    
            var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    
            var index = json.data.index;
    
            if ( index !== undefined ) {
    
                var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
                geometry.setIndex( new BufferAttribute( typedArray, 1 ) );
    
            }
    
            var attributes = json.data.attributes;
    
            for ( var key in attributes ) {
    
                var attribute = attributes[ key ];
                var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
                var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                var bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );
                if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
                geometry.setAttribute( key, bufferAttribute );
    
            }
    
            var morphAttributes = json.data.morphAttributes;
    
            if ( morphAttributes ) {
    
                for ( var key in morphAttributes ) {
    
                    var attributeArray = morphAttributes[ key ];
    
                    var array = [];
    
                    for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {
    
                        var attribute = attributeArray[ i ];
                        var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
    
                        var bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );
                        if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
                        array.push( bufferAttribute );
    
                    }
    
                    geometry.morphAttributes[ key ] = array;
    
                }
    
            }
    
            var morphTargetsRelative = json.data.morphTargetsRelative;
    
            if ( morphTargetsRelative ) {
    
                geometry.morphTargetsRelative = true;
    
            }
    
            var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
    
            if ( groups !== undefined ) {
    
                for ( var i = 0, n = groups.length; i !== n; ++ i ) {
    
                    var group = groups[ i ];
    
                    geometry.addGroup( group.start, group.count, group.materialIndex );
    
                }
    
            }
    
            var boundingSphere = json.data.boundingSphere;
    
            if ( boundingSphere !== undefined ) {
    
                var center = new Vector3();
    
                if ( boundingSphere.center !== undefined ) {
    
                    center.fromArray( boundingSphere.center );
    
                }
    
                geometry.boundingSphere = new Sphere( center, boundingSphere.radius );
    
            }
    
            if ( json.name ) geometry.name = json.name;
            if ( json.userData ) geometry.userData = json.userData;
    
            return geometry;
    
        }
    
    } );
    
    var TYPED_ARRAYS = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        // Workaround for IE11 pre KB2929437. See #11440
        Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function ObjectLoader( manager ) {
    
        Loader.call( this, manager );
    
    }
    
    ObjectLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: ObjectLoader,
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            var scope = this;
    
            var path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
            this.resourcePath = this.resourcePath || path;
    
            var loader = new FileLoader( scope.manager );
            loader.setPath( this.path );
            loader.load( url, function ( text ) {
    
                var json = null;
    
                try {
    
                    json = JSON.parse( text );
    
                } catch ( error ) {
    
                    if ( onError !== undefined ) onError( error );
    
                    console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );
    
                    return;
    
                }
    
                var metadata = json.metadata;
    
                if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {
    
                    console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
                    return;
    
                }
    
                scope.parse( json, onLoad );
    
            }, onProgress, onError );
    
        },
    
        parse: function ( json, onLoad ) {
    
            var shapes = this.parseShape( json.shapes );
            var geometries = this.parseGeometries( json.geometries, shapes );
    
            var images = this.parseImages( json.images, function () {
    
                if ( onLoad !== undefined ) onLoad( object );
    
            } );
    
            var textures = this.parseTextures( json.textures, images );
            var materials = this.parseMaterials( json.materials, textures );
    
            var object = this.parseObject( json.object, geometries, materials );
    
            if ( json.animations ) {
    
                object.animations = this.parseAnimations( json.animations );
    
            }
    
            if ( json.images === undefined || json.images.length === 0 ) {
    
                if ( onLoad !== undefined ) onLoad( object );
    
            }
    
            return object;
    
        },
    
        parseShape: function ( json ) {
    
            var shapes = {};
    
            if ( json !== undefined ) {
    
                for ( var i = 0, l = json.length; i < l; i ++ ) {
    
                    var shape = new Shape().fromJSON( json[ i ] );
    
                    shapes[ shape.uuid ] = shape;
    
                }
    
            }
    
            return shapes;
    
        },
    
        parseGeometries: function ( json, shapes ) {
    
            var geometries = {};
    
            if ( json !== undefined ) {
    
                var bufferGeometryLoader = new BufferGeometryLoader();
    
                for ( var i = 0, l = json.length; i < l; i ++ ) {
    
                    var geometry;
                    var data = json[ i ];
    
                    switch ( data.type ) {
    
                        case 'PlaneGeometry':
                        case 'PlaneBufferGeometry':
    
                            geometry = new Geometries[ data.type ](
                                data.width,
                                data.height,
                                data.widthSegments,
                                data.heightSegments
                            );
    
                            break;
    
                        case 'BoxGeometry':
                        case 'BoxBufferGeometry':
                        case 'CubeGeometry': // backwards compatible
    
                            geometry = new Geometries[ data.type ](
                                data.width,
                                data.height,
                                data.depth,
                                data.widthSegments,
                                data.heightSegments,
                                data.depthSegments
                            );
    
                            break;
    
                        case 'CircleGeometry':
                        case 'CircleBufferGeometry':
    
                            geometry = new Geometries[ data.type ](
                                data.radius,
                                data.segments,
                                data.thetaStart,
                                data.thetaLength
                            );
    
                            break;
    
                        case 'CylinderGeometry':
                        case 'CylinderBufferGeometry':
    
                            geometry = new Geometries[ data.type ](
                                data.radiusTop,
                                data.radiusBottom,
                                data.height,
                                data.radialSegments,
                                data.heightSegments,
                                data.openEnded,
                                data.thetaStart,
                                data.thetaLength
                            );
    
                            break;
    
                        case 'ConeGeometry':
                        case 'ConeBufferGeometry':
    
                            geometry = new Geometries[ data.type ](
                                data.radius,
                                data.height,
                                data.radialSegments,
                                data.heightSegments,
                                data.openEnded,
                                data.thetaStart,
                                data.thetaLength
                            );
    
                            break;
    
                        case 'SphereGeometry':
                        case 'SphereBufferGeometry':
    
                            geometry = new Geometries[ data.type ](
                                data.radius,
                                data.widthSegments,
                                data.heightSegments,
                                data.phiStart,
                                data.phiLength,
                                data.thetaStart,
                                data.thetaLength
                            );
    
                            break;
    
                        case 'DodecahedronGeometry':
                        case 'DodecahedronBufferGeometry':
                        case 'IcosahedronGeometry':
                        case 'IcosahedronBufferGeometry':
                        case 'OctahedronGeometry':
                        case 'OctahedronBufferGeometry':
                        case 'TetrahedronGeometry':
                        case 'TetrahedronBufferGeometry':
    
                            geometry = new Geometries[ data.type ](
                                data.radius,
                                data.detail
                            );
    
                            break;
    
                        case 'RingGeometry':
                        case 'RingBufferGeometry':
    
                            geometry = new Geometries[ data.type ](
                                data.innerRadius,
                                data.outerRadius,
                                data.thetaSegments,
                                data.phiSegments,
                                data.thetaStart,
                                data.thetaLength
                            );
    
                            break;
    
                        case 'TorusGeometry':
                        case 'TorusBufferGeometry':
    
                            geometry = new Geometries[ data.type ](
                                data.radius,
                                data.tube,
                                data.radialSegments,
                                data.tubularSegments,
                                data.arc
                            );
    
                            break;
    
                        case 'TorusKnotGeometry':
                        case 'TorusKnotBufferGeometry':
    
                            geometry = new Geometries[ data.type ](
                                data.radius,
                                data.tube,
                                data.tubularSegments,
                                data.radialSegments,
                                data.p,
                                data.q
                            );
    
                            break;
    
                        case 'TubeGeometry':
                        case 'TubeBufferGeometry':
    
                            // This only works for built-in curves (e.g. CatmullRomCurve3).
                            // User defined curves or instances of CurvePath will not be deserialized.
                            geometry = new Geometries[ data.type ](
                                new Curves[ data.path.type ]().fromJSON( data.path ),
                                data.tubularSegments,
                                data.radius,
                                data.radialSegments,
                                data.closed
                            );
    
                            break;
    
                        case 'LatheGeometry':
                        case 'LatheBufferGeometry':
    
                            geometry = new Geometries[ data.type ](
                                data.points,
                                data.segments,
                                data.phiStart,
                                data.phiLength
                            );
    
                            break;
    
                        case 'PolyhedronGeometry':
                        case 'PolyhedronBufferGeometry':
    
                            geometry = new Geometries[ data.type ](
                                data.vertices,
                                data.indices,
                                data.radius,
                                data.details
                            );
    
                            break;
    
                        case 'ShapeGeometry':
                        case 'ShapeBufferGeometry':
    
                            var geometryShapes = [];
    
                            for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {
    
                                var shape = shapes[ data.shapes[ j ] ];
    
                                geometryShapes.push( shape );
    
                            }
    
                            geometry = new Geometries[ data.type ](
                                geometryShapes,
                                data.curveSegments
                            );
    
                            break;
    
    
                        case 'ExtrudeGeometry':
                        case 'ExtrudeBufferGeometry':
    
                            var geometryShapes = [];
    
                            for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {
    
                                var shape = shapes[ data.shapes[ j ] ];
    
                                geometryShapes.push( shape );
    
                            }
    
                            var extrudePath = data.options.extrudePath;
    
                            if ( extrudePath !== undefined ) {
    
                                data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );
    
                            }
    
                            geometry = new Geometries[ data.type ](
                                geometryShapes,
                                data.options
                            );
    
                            break;
    
                        case 'BufferGeometry':
                        case 'InstancedBufferGeometry':
    
                            geometry = bufferGeometryLoader.parse( data );
    
                            break;
    
                        case 'Geometry':
    
                            console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );
    
                            break;
    
                        default:
    
                            console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );
    
                            continue;
    
                    }
    
                    geometry.uuid = data.uuid;
    
                    if ( data.name !== undefined ) geometry.name = data.name;
                    if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;
    
                    geometries[ data.uuid ] = geometry;
    
                }
    
            }
    
            return geometries;
    
        },
    
        parseMaterials: function ( json, textures ) {
    
            var cache = {}; // MultiMaterial
            var materials = {};
    
            if ( json !== undefined ) {
    
                var loader = new MaterialLoader();
                loader.setTextures( textures );
    
                for ( var i = 0, l = json.length; i < l; i ++ ) {
    
                    var data = json[ i ];
    
                    if ( data.type === 'MultiMaterial' ) {
    
                        // Deprecated
    
                        var array = [];
    
                        for ( var j = 0; j < data.materials.length; j ++ ) {
    
                            var material = data.materials[ j ];
    
                            if ( cache[ material.uuid ] === undefined ) {
    
                                cache[ material.uuid ] = loader.parse( material );
    
                            }
    
                            array.push( cache[ material.uuid ] );
    
                        }
    
                        materials[ data.uuid ] = array;
    
                    } else {
    
                        if ( cache[ data.uuid ] === undefined ) {
    
                            cache[ data.uuid ] = loader.parse( data );
    
                        }
    
                        materials[ data.uuid ] = cache[ data.uuid ];
    
                    }
    
                }
    
            }
    
            return materials;
    
        },
    
        parseAnimations: function ( json ) {
    
            var animations = [];
    
            for ( var i = 0; i < json.length; i ++ ) {
    
                var data = json[ i ];
    
                var clip = AnimationClip.parse( data );
    
                if ( data.uuid !== undefined ) clip.uuid = data.uuid;
    
                animations.push( clip );
    
            }
    
            return animations;
    
        },
    
        parseImages: function ( json, onLoad ) {
    
            var scope = this;
            var images = {};
    
            function loadImage( url ) {
    
                scope.manager.itemStart( url );
    
                return loader.load( url, function () {
    
                    scope.manager.itemEnd( url );
    
                }, undefined, function () {
    
                    scope.manager.itemError( url );
                    scope.manager.itemEnd( url );
    
                } );
    
            }
    
            if ( json !== undefined && json.length > 0 ) {
    
                var manager = new LoadingManager( onLoad );
    
                var loader = new ImageLoader( manager );
                loader.setCrossOrigin( this.crossOrigin );
    
                for ( var i = 0, il = json.length; i < il; i ++ ) {
    
                    var image = json[ i ];
                    var url = image.url;
    
                    if ( Array.isArray( url ) ) {
    
                        // load array of images e.g CubeTexture
    
                        images[ image.uuid ] = [];
    
                        for ( var j = 0, jl = url.length; j < jl; j ++ ) {
    
                            var currentUrl = url[ j ];
    
                            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;
    
                            images[ image.uuid ].push( loadImage( path ) );
    
                        }
    
                    } else {
    
                        // load single image
    
                        var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;
    
                        images[ image.uuid ] = loadImage( path );
    
                    }
    
                }
    
            }
    
            return images;
    
        },
    
        parseTextures: function ( json, images ) {
    
            function parseConstant( value, type ) {
    
                if ( typeof value === 'number' ) return value;
    
                console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
    
                return type[ value ];
    
            }
    
            var textures = {};
    
            if ( json !== undefined ) {
    
                for ( var i = 0, l = json.length; i < l; i ++ ) {
    
                    var data = json[ i ];
    
                    if ( data.image === undefined ) {
    
                        console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );
    
                    }
    
                    if ( images[ data.image ] === undefined ) {
    
                        console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
    
                    }
    
                    var texture;
    
                    if ( Array.isArray( images[ data.image ] ) ) {
    
                        texture = new CubeTexture( images[ data.image ] );
    
                    } else {
    
                        texture = new Texture( images[ data.image ] );
    
                    }
    
                    texture.needsUpdate = true;
    
                    texture.uuid = data.uuid;
    
                    if ( data.name !== undefined ) texture.name = data.name;
    
                    if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );
    
                    if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
                    if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
                    if ( data.center !== undefined ) texture.center.fromArray( data.center );
                    if ( data.rotation !== undefined ) texture.rotation = data.rotation;
    
                    if ( data.wrap !== undefined ) {
    
                        texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
                        texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );
    
                    }
    
                    if ( data.format !== undefined ) texture.format = data.format;
                    if ( data.type !== undefined ) texture.type = data.type;
                    if ( data.encoding !== undefined ) texture.encoding = data.encoding;
    
                    if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
                    if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
                    if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
    
                    if ( data.flipY !== undefined ) texture.flipY = data.flipY;
    
                    if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
                    if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;
    
                    textures[ data.uuid ] = texture;
    
                }
    
            }
    
            return textures;
    
        },
    
        parseObject: function ( data, geometries, materials ) {
    
            var object;
    
            function getGeometry( name ) {
    
                if ( geometries[ name ] === undefined ) {
    
                    console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
    
                }
    
                return geometries[ name ];
    
            }
    
            function getMaterial( name ) {
    
                if ( name === undefined ) return undefined;
    
                if ( Array.isArray( name ) ) {
    
                    var array = [];
    
                    for ( var i = 0, l = name.length; i < l; i ++ ) {
    
                        var uuid = name[ i ];
    
                        if ( materials[ uuid ] === undefined ) {
    
                            console.warn( 'THREE.ObjectLoader: Undefined material', uuid );
    
                        }
    
                        array.push( materials[ uuid ] );
    
                    }
    
                    return array;
    
                }
    
                if ( materials[ name ] === undefined ) {
    
                    console.warn( 'THREE.ObjectLoader: Undefined material', name );
    
                }
    
                return materials[ name ];
    
            }
    
            switch ( data.type ) {
    
                case 'Scene':
    
                    object = new Scene();
    
                    if ( data.background !== undefined ) {
    
                        if ( Number.isInteger( data.background ) ) {
    
                            object.background = new Color( data.background );
    
                        }
    
                    }
    
                    if ( data.fog !== undefined ) {
    
                        if ( data.fog.type === 'Fog' ) {
    
                            object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );
    
                        } else if ( data.fog.type === 'FogExp2' ) {
    
                            object.fog = new FogExp2( data.fog.color, data.fog.density );
    
                        }
    
                    }
    
                    break;
    
                case 'PerspectiveCamera':
    
                    object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
    
                    if ( data.focus !== undefined ) object.focus = data.focus;
                    if ( data.zoom !== undefined ) object.zoom = data.zoom;
                    if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
                    if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
                    if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
    
                    break;
    
                case 'OrthographicCamera':
    
                    object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
    
                    if ( data.zoom !== undefined ) object.zoom = data.zoom;
                    if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
    
                    break;
    
                case 'AmbientLight':
    
                    object = new AmbientLight( data.color, data.intensity );
    
                    break;
    
                case 'DirectionalLight':
    
                    object = new DirectionalLight( data.color, data.intensity );
    
                    break;
    
                case 'PointLight':
    
                    object = new PointLight( data.color, data.intensity, data.distance, data.decay );
    
                    break;
    
                case 'RectAreaLight':
    
                    object = new RectAreaLight( data.color, data.intensity, data.width, data.height );
    
                    break;
    
                case 'SpotLight':
    
                    object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );
    
                    break;
    
                case 'HemisphereLight':
    
                    object = new HemisphereLight( data.color, data.groundColor, data.intensity );
    
                    break;
    
                case 'SkinnedMesh':
    
                    console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );
    
                case 'Mesh':
    
                    var geometry = getGeometry( data.geometry );
                    var material = getMaterial( data.material );
    
                    if ( geometry.bones && geometry.bones.length > 0 ) {
    
                        object = new SkinnedMesh( geometry, material );
    
                    } else {
    
                        object = new Mesh( geometry, material );
    
                    }
    
                    break;
    
                case 'InstancedMesh':
    
                    var geometry = getGeometry( data.geometry );
                    var material = getMaterial( data.material );
                    var count = data.count;
                    var instanceMatrix = data.instanceMatrix;
    
                    object = new InstancedMesh( geometry, material, count );
                    object.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );
    
                    break;
    
                case 'LOD':
    
                    object = new LOD();
    
                    break;
    
                case 'Line':
    
                    object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
    
                    break;
    
                case 'LineLoop':
    
                    object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );
    
                    break;
    
                case 'LineSegments':
    
                    object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );
    
                    break;
    
                case 'PointCloud':
                case 'Points':
    
                    object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );
    
                    break;
    
                case 'Sprite':
    
                    object = new Sprite( getMaterial( data.material ) );
    
                    break;
    
                case 'Group':
    
                    object = new Group();
    
                    break;
    
                default:
    
                    object = new Object3D();
    
            }
    
            object.uuid = data.uuid;
    
            if ( data.name !== undefined ) object.name = data.name;
    
            if ( data.matrix !== undefined ) {
    
                object.matrix.fromArray( data.matrix );
    
                if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
                if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );
    
            } else {
    
                if ( data.position !== undefined ) object.position.fromArray( data.position );
                if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
                if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
                if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
    
            }
    
            if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
            if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
    
            if ( data.shadow ) {
    
                if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
                if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
                if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
                if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );
    
            }
    
            if ( data.visible !== undefined ) object.visible = data.visible;
            if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
            if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
            if ( data.userData !== undefined ) object.userData = data.userData;
            if ( data.layers !== undefined ) object.layers.mask = data.layers;
    
            if ( data.children !== undefined ) {
    
                var children = data.children;
    
                for ( var i = 0; i < children.length; i ++ ) {
    
                    object.add( this.parseObject( children[ i ], geometries, materials ) );
    
                }
    
            }
    
            if ( data.type === 'LOD' ) {
    
                if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;
    
                var levels = data.levels;
    
                for ( var l = 0; l < levels.length; l ++ ) {
    
                    var level = levels[ l ];
                    var child = object.getObjectByProperty( 'uuid', level.object );
    
                    if ( child !== undefined ) {
    
                        object.addLevel( child, level.distance );
    
                    }
    
                }
    
            }
    
            return object;
    
        }
    
    } );
    
    var TEXTURE_MAPPING = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        SphericalReflectionMapping: SphericalReflectionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    };
    
    var TEXTURE_WRAPPING = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    };
    
    var TEXTURE_FILTER = {
        NearestFilter: NearestFilter,
        NearestMipmapNearestFilter: NearestMipmapNearestFilter,
        NearestMipmapLinearFilter: NearestMipmapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipmapNearestFilter: LinearMipmapNearestFilter,
        LinearMipmapLinearFilter: LinearMipmapLinearFilter
    };
    
    /**
     * @author thespite / http://clicktorelease.com/
     */
    
    
    function ImageBitmapLoader( manager ) {
    
        if ( typeof createImageBitmap === 'undefined' ) {
    
            console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );
    
        }
    
        if ( typeof fetch === 'undefined' ) {
    
            console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );
    
        }
    
        Loader.call( this, manager );
    
        this.options = undefined;
    
    }
    
    ImageBitmapLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: ImageBitmapLoader,
    
        setOptions: function setOptions( options ) {
    
            this.options = options;
    
            return this;
    
        },
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            if ( url === undefined ) url = '';
    
            if ( this.path !== undefined ) url = this.path + url;
    
            url = this.manager.resolveURL( url );
    
            var scope = this;
    
            var cached = Cache.get( url );
    
            if ( cached !== undefined ) {
    
                scope.manager.itemStart( url );
    
                setTimeout( function () {
    
                    if ( onLoad ) onLoad( cached );
    
                    scope.manager.itemEnd( url );
    
                }, 0 );
    
                return cached;
    
            }
    
            fetch( url ).then( function ( res ) {
    
                return res.blob();
    
            } ).then( function ( blob ) {
    
                if ( scope.options === undefined ) {
    
                    // Workaround for FireFox. It causes an error if you pass options.
                    return createImageBitmap( blob );
    
                } else {
    
                    return createImageBitmap( blob, scope.options );
    
                }
    
            } ).then( function ( imageBitmap ) {
    
                Cache.add( url, imageBitmap );
    
                if ( onLoad ) onLoad( imageBitmap );
    
                scope.manager.itemEnd( url );
    
            } ).catch( function ( e ) {
    
                if ( onError ) onError( e );
    
                scope.manager.itemError( url );
                scope.manager.itemEnd( url );
    
            } );
    
            scope.manager.itemStart( url );
    
        }
    
    } );
    
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
     **/
    
    function ShapePath() {
    
        this.type = 'ShapePath';
    
        this.color = new Color();
    
        this.subPaths = [];
        this.currentPath = null;
    
    }
    
    Object.assign( ShapePath.prototype, {
    
        moveTo: function ( x, y ) {
    
            this.currentPath = new Path();
            this.subPaths.push( this.currentPath );
            this.currentPath.moveTo( x, y );
    
            return this;
    
        },
    
        lineTo: function ( x, y ) {
    
            this.currentPath.lineTo( x, y );
    
            return this;
    
        },
    
        quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
    
            this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
    
            return this;
    
        },
    
        bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
    
            this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
    
            return this;
    
        },
    
        splineThru: function ( pts ) {
    
            this.currentPath.splineThru( pts );
    
            return this;
    
        },
    
        toShapes: function ( isCCW, noHoles ) {
    
            function toShapesNoHoles( inSubpaths ) {
    
                var shapes = [];
    
                for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {
    
                    var tmpPath = inSubpaths[ i ];
    
                    var tmpShape = new Shape();
                    tmpShape.curves = tmpPath.curves;
    
                    shapes.push( tmpShape );
    
                }
    
                return shapes;
    
            }
    
            function isPointInsidePolygon( inPt, inPolygon ) {
    
                var polyLen = inPolygon.length;
    
                // inPt on polygon contour => immediate success    or
                // toggling of inside/outside at every single! intersection point of an edge
                //  with the horizontal line through inPt, left of inPt
                //  not counting lowerY endpoints of edges and whole edges on that line
                var inside = false;
                for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
    
                    var edgeLowPt = inPolygon[ p ];
                    var edgeHighPt = inPolygon[ q ];
    
                    var edgeDx = edgeHighPt.x - edgeLowPt.x;
                    var edgeDy = edgeHighPt.y - edgeLowPt.y;
    
                    if ( Math.abs( edgeDy ) > Number.EPSILON ) {
    
                        // not parallel
                        if ( edgeDy < 0 ) {
    
                            edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
                            edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
    
                        }
                        if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
    
                        if ( inPt.y === edgeLowPt.y ) {
    
                            if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
                            // continue;				// no intersection or edgeLowPt => doesn't count !!!
    
                        } else {
    
                            var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
                            if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
                            if ( perpEdge < 0 ) 				continue;
                            inside = ! inside;		// true intersection left of inPt
    
                        }
    
                    } else {
    
                        // parallel or collinear
                        if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
                        // edge lies on the same horizontal line as inPt
                        if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
                             ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
                        // continue;
    
                    }
    
                }
    
                return	inside;
    
            }
    
            var isClockWise = ShapeUtils.isClockWise;
    
            var subPaths = this.subPaths;
            if ( subPaths.length === 0 ) return [];
    
            if ( noHoles === true )	return	toShapesNoHoles( subPaths );
    
    
            var solid, tmpPath, tmpShape, shapes = [];
    
            if ( subPaths.length === 1 ) {
    
                tmpPath = subPaths[ 0 ];
                tmpShape = new Shape();
                tmpShape.curves = tmpPath.curves;
                shapes.push( tmpShape );
                return shapes;
    
            }
    
            var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
            holesFirst = isCCW ? ! holesFirst : holesFirst;
    
            // console.log("Holes first", holesFirst);
    
            var betterShapeHoles = [];
            var newShapes = [];
            var newShapeHoles = [];
            var mainIdx = 0;
            var tmpPoints;
    
            newShapes[ mainIdx ] = undefined;
            newShapeHoles[ mainIdx ] = [];
    
            for ( var i = 0, l = subPaths.length; i < l; i ++ ) {
    
                tmpPath = subPaths[ i ];
                tmpPoints = tmpPath.getPoints();
                solid = isClockWise( tmpPoints );
                solid = isCCW ? ! solid : solid;
    
                if ( solid ) {
    
                    if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;
    
                    newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
                    newShapes[ mainIdx ].s.curves = tmpPath.curves;
    
                    if ( holesFirst )	mainIdx ++;
                    newShapeHoles[ mainIdx ] = [];
    
                    //console.log('cw', i);
    
                } else {
    
                    newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
    
                    //console.log('ccw', i);
    
                }
    
            }
    
            // only Holes? -> probably all Shapes with wrong orientation
            if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
    
    
            if ( newShapes.length > 1 ) {
    
                var ambiguous = false;
                var toChange = [];
    
                for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
    
                    betterShapeHoles[ sIdx ] = [];
    
                }
    
                for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
    
                    var sho = newShapeHoles[ sIdx ];
    
                    for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
    
                        var ho = sho[ hIdx ];
                        var hole_unassigned = true;
    
                        for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
    
                            if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
    
                                if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
                                if ( hole_unassigned ) {
    
                                    hole_unassigned = false;
                                    betterShapeHoles[ s2Idx ].push( ho );
    
                                } else {
    
                                    ambiguous = true;
    
                                }
    
                            }
    
                        }
                        if ( hole_unassigned ) {
    
                            betterShapeHoles[ sIdx ].push( ho );
    
                        }
    
                    }
    
                }
                // console.log("ambiguous: ", ambiguous);
                if ( toChange.length > 0 ) {
    
                    // console.log("to change: ", toChange);
                    if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
    
                }
    
            }
    
            var tmpHoles;
    
            for ( var i = 0, il = newShapes.length; i < il; i ++ ) {
    
                tmpShape = newShapes[ i ].s;
                shapes.push( tmpShape );
                tmpHoles = newShapeHoles[ i ];
    
                for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
    
                    tmpShape.holes.push( tmpHoles[ j ].h );
    
                }
    
            }
    
            //console.log("shape", shapes);
    
            return shapes;
    
        }
    
    } );
    
    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author mrdoob / http://mrdoob.com/
     */
    
    
    function Font( data ) {
    
        this.type = 'Font';
    
        this.data = data;
    
    }
    
    Object.assign( Font.prototype, {
    
        isFont: true,
    
        generateShapes: function ( text, size ) {
    
            if ( size === undefined ) size = 100;
    
            var shapes = [];
            var paths = createPaths( text, size, this.data );
    
            for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
    
                Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
    
            }
    
            return shapes;
    
        }
    
    } );
    
    function createPaths( text, size, data ) {
    
        var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // workaround for IE11, see #13988
        var scale = size / data.resolution;
        var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;
    
        var paths = [];
    
        var offsetX = 0, offsetY = 0;
    
        for ( var i = 0; i < chars.length; i ++ ) {
    
            var char = chars[ i ];
    
            if ( char === '\n' ) {
    
                offsetX = 0;
                offsetY -= line_height;
    
            } else {
    
                var ret = createPath( char, scale, offsetX, offsetY, data );
                offsetX += ret.offsetX;
                paths.push( ret.path );
    
            }
    
        }
    
        return paths;
    
    }
    
    function createPath( char, scale, offsetX, offsetY, data ) {
    
        var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];
    
        if ( ! glyph ) {
    
            console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );
    
            return;
    
        }
    
        var path = new ShapePath();
    
        var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    
        if ( glyph.o ) {
    
            var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
    
            for ( var i = 0, l = outline.length; i < l; ) {
    
                var action = outline[ i ++ ];
    
                switch ( action ) {
    
                    case 'm': // moveTo
    
                        x = outline[ i ++ ] * scale + offsetX;
                        y = outline[ i ++ ] * scale + offsetY;
    
                        path.moveTo( x, y );
    
                        break;
    
                    case 'l': // lineTo
    
                        x = outline[ i ++ ] * scale + offsetX;
                        y = outline[ i ++ ] * scale + offsetY;
    
                        path.lineTo( x, y );
    
                        break;
    
                    case 'q': // quadraticCurveTo
    
                        cpx = outline[ i ++ ] * scale + offsetX;
                        cpy = outline[ i ++ ] * scale + offsetY;
                        cpx1 = outline[ i ++ ] * scale + offsetX;
                        cpy1 = outline[ i ++ ] * scale + offsetY;
    
                        path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
    
                        break;
    
                    case 'b': // bezierCurveTo
    
                        cpx = outline[ i ++ ] * scale + offsetX;
                        cpy = outline[ i ++ ] * scale + offsetY;
                        cpx1 = outline[ i ++ ] * scale + offsetX;
                        cpy1 = outline[ i ++ ] * scale + offsetY;
                        cpx2 = outline[ i ++ ] * scale + offsetX;
                        cpy2 = outline[ i ++ ] * scale + offsetY;
    
                        path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
    
                        break;
    
                }
    
            }
    
        }
    
        return { offsetX: glyph.ha * scale, path: path };
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function FontLoader( manager ) {
    
        Loader.call( this, manager );
    
    }
    
    FontLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: FontLoader,
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            var scope = this;
    
            var loader = new FileLoader( this.manager );
            loader.setPath( this.path );
            loader.load( url, function ( text ) {
    
                var json;
    
                try {
    
                    json = JSON.parse( text );
    
                } catch ( e ) {
    
                    console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
                    json = JSON.parse( text.substring( 65, text.length - 2 ) );
    
                }
    
                var font = scope.parse( json );
    
                if ( onLoad ) onLoad( font );
    
            }, onProgress, onError );
    
        },
    
        parse: function ( json ) {
    
            return new Font( json );
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    var _context;
    
    var AudioContext = {
    
        getContext: function () {
    
            if ( _context === undefined ) {
    
                _context = new ( window.AudioContext || window.webkitAudioContext )();
    
            }
    
            return _context;
    
        },
    
        setContext: function ( value ) {
    
            _context = value;
    
        }
    
    };
    
    /**
     * @author Reece Aaron Lecrivain / http://reecenotes.com/
     */
    
    function AudioLoader( manager ) {
    
        Loader.call( this, manager );
    
    }
    
    AudioLoader.prototype = Object.assign( Object.create( Loader.prototype ), {
    
        constructor: AudioLoader,
    
        load: function ( url, onLoad, onProgress, onError ) {
    
            var loader = new FileLoader( this.manager );
            loader.setResponseType( 'arraybuffer' );
            loader.setPath( this.path );
            loader.load( url, function ( buffer ) {
    
                // Create a copy of the buffer. The `decodeAudioData` method
                // detaches the buffer when complete, preventing reuse.
                var bufferCopy = buffer.slice( 0 );
    
                var context = AudioContext.getContext();
                context.decodeAudioData( bufferCopy, function ( audioBuffer ) {
    
                    onLoad( audioBuffer );
    
                } );
    
            }, onProgress, onError );
    
        }
    
    } );
    
    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * Primary reference:
     *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
     *
     * Secondary reference:
     *   https://www.ppsloan.org/publications/StupidSH36.pdf
     */
    
    // 3-band SH defined by 9 coefficients
    
    function SphericalHarmonics3() {
    
        this.coefficients = [];
    
        for ( var i = 0; i < 9; i ++ ) {
    
            this.coefficients.push( new Vector3() );
    
        }
    
    }
    
    Object.assign( SphericalHarmonics3.prototype, {
    
        isSphericalHarmonics3: true,
    
        set: function ( coefficients ) {
    
            for ( var i = 0; i < 9; i ++ ) {
    
                this.coefficients[ i ].copy( coefficients[ i ] );
    
            }
    
            return this;
    
        },
    
        zero: function () {
    
            for ( var i = 0; i < 9; i ++ ) {
    
                this.coefficients[ i ].set( 0, 0, 0 );
    
            }
    
            return this;
    
        },
    
        // get the radiance in the direction of the normal
        // target is a Vector3
        getAt: function ( normal, target ) {
    
            // normal is assumed to be unit length
    
            var x = normal.x, y = normal.y, z = normal.z;
    
            var coeff = this.coefficients;
    
            // band 0
            target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );
    
            // band 1
            target.addScale( coeff[ 1 ], 0.488603 * y );
            target.addScale( coeff[ 2 ], 0.488603 * z );
            target.addScale( coeff[ 3 ], 0.488603 * x );
    
            // band 2
            target.addScale( coeff[ 4 ], 1.092548 * ( x * y ) );
            target.addScale( coeff[ 5 ], 1.092548 * ( y * z ) );
            target.addScale( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
            target.addScale( coeff[ 7 ], 1.092548 * ( x * z ) );
            target.addScale( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );
    
            return target;
    
        },
    
        // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
        // target is a Vector3
        // https://graphics.stanford.edu/papers/envmap/envmap.pdf
        getIrradianceAt: function ( normal, target ) {
    
            // normal is assumed to be unit length
    
            var x = normal.x, y = normal.y, z = normal.z;
    
            var coeff = this.coefficients;
    
            // band 0
            target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095
    
            // band 1
            target.addScale( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
            target.addScale( coeff[ 2 ], 2.0 * 0.511664 * z );
            target.addScale( coeff[ 3 ], 2.0 * 0.511664 * x );
    
            // band 2
            target.addScale( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
            target.addScale( coeff[ 5 ], 2.0 * 0.429043 * y * z );
            target.addScale( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
            target.addScale( coeff[ 7 ], 2.0 * 0.429043 * x * z );
            target.addScale( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274
    
            return target;
    
        },
    
        add: function ( sh ) {
    
            for ( var i = 0; i < 9; i ++ ) {
    
                this.coefficients[ i ].add( sh.coefficients[ i ] );
    
            }
    
            return this;
    
        },
    
    
        scale: function ( s ) {
    
            for ( var i = 0; i < 9; i ++ ) {
    
                this.coefficients[ i ].multiplyScalar( s );
    
            }
    
            return this;
    
        },
    
        lerp: function ( sh, alpha ) {
    
            for ( var i = 0; i < 9; i ++ ) {
    
                this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );
    
            }
    
            return this;
    
        },
    
        equals: function ( sh ) {
    
            for ( var i = 0; i < 9; i ++ ) {
    
                if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {
    
                    return false;
    
                }
    
            }
    
            return true;
    
        },
    
        copy: function ( sh ) {
    
            return this.set( sh.coefficients );
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        fromArray: function ( array, offset ) {
    
            if ( offset === undefined ) offset = 0;
    
            var coefficients = this.coefficients;
    
            for ( var i = 0; i < 9; i ++ ) {
    
                coefficients[ i ].fromArray( array, offset + ( i * 3 ) );
    
            }
    
            return this;
    
        },
    
        toArray: function ( array, offset ) {
    
            if ( array === undefined ) array = [];
            if ( offset === undefined ) offset = 0;
    
            var coefficients = this.coefficients;
    
            for ( var i = 0; i < 9; i ++ ) {
    
                coefficients[ i ].toArray( array, offset + ( i * 3 ) );
    
            }
    
            return array;
    
        }
    
    } );
    
    Object.assign( SphericalHarmonics3, {
    
        // evaluate the basis functions
        // shBasis is an Array[ 9 ]
        getBasisAt: function ( normal, shBasis ) {
    
            // normal is assumed to be unit length
    
            var x = normal.x, y = normal.y, z = normal.z;
    
            // band 0
            shBasis[ 0 ] = 0.282095;
    
            // band 1
            shBasis[ 1 ] = 0.488603 * y;
            shBasis[ 2 ] = 0.488603 * z;
            shBasis[ 3 ] = 0.488603 * x;
    
            // band 2
            shBasis[ 4 ] = 1.092548 * x * y;
            shBasis[ 5 ] = 1.092548 * y * z;
            shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
            shBasis[ 7 ] = 1.092548 * x * z;
            shBasis[ 8 ] = 0.546274 * ( x * x - y * y );
    
        }
    
    } );
    
    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * A LightProbe is a source of indirect-diffuse light
     */
    
    function LightProbe( sh, intensity ) {
    
        Light.call( this, undefined, intensity );
    
        this.sh = ( sh !== undefined ) ? sh : new SphericalHarmonics3();
    
    }
    
    LightProbe.prototype = Object.assign( Object.create( Light.prototype ), {
    
        constructor: LightProbe,
    
        isLightProbe: true,
    
        copy: function ( source ) {
    
            Light.prototype.copy.call( this, source );
    
            this.sh.copy( source.sh );
            this.intensity = source.intensity;
    
            return this;
    
        },
    
        toJSON: function ( meta ) {
    
            var data = Light.prototype.toJSON.call( this, meta );
    
            // data.sh = this.sh.toArray(); // todo
    
            return data;
    
        }
    
    } );
    
    /**
     * @author WestLangley / http://github.com/WestLangley
     */
    
    function HemisphereLightProbe( skyColor, groundColor, intensity ) {
    
        LightProbe.call( this, undefined, intensity );
    
        var color1 = new Color().set( skyColor );
        var color2 = new Color().set( groundColor );
    
        var sky = new Vector3( color1.r, color1.g, color1.b );
        var ground = new Vector3( color2.r, color2.g, color2.b );
    
        // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
        var c0 = Math.sqrt( Math.PI );
        var c1 = c0 * Math.sqrt( 0.75 );
    
        this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
        this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );
    
    }
    
    HemisphereLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {
    
        constructor: HemisphereLightProbe,
    
        isHemisphereLightProbe: true,
    
        copy: function ( source ) { // modifying colors not currently supported
    
            LightProbe.prototype.copy.call( this, source );
    
            return this;
    
        },
    
        toJSON: function ( meta ) {
    
            var data = LightProbe.prototype.toJSON.call( this, meta );
    
            // data.sh = this.sh.toArray(); // todo
    
            return data;
    
        }
    
    } );
    
    /**
     * @author WestLangley / http://github.com/WestLangley
     */
    
    function AmbientLightProbe( color, intensity ) {
    
        LightProbe.call( this, undefined, intensity );
    
        var color1 = new Color().set( color );
    
        // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
        this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );
    
    }
    
    AmbientLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {
    
        constructor: AmbientLightProbe,
    
        isAmbientLightProbe: true,
    
        copy: function ( source ) { // modifying color not currently supported
    
            LightProbe.prototype.copy.call( this, source );
    
            return this;
    
        },
    
        toJSON: function ( meta ) {
    
            var data = LightProbe.prototype.toJSON.call( this, meta );
    
            // data.sh = this.sh.toArray(); // todo
    
            return data;
    
        }
    
    } );
    
    var _eyeRight = new Matrix4();
    var _eyeLeft = new Matrix4();
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function StereoCamera() {
    
        this.type = 'StereoCamera';
    
        this.aspect = 1;
    
        this.eyeSep = 0.064;
    
        this.cameraL = new PerspectiveCamera();
        this.cameraL.layers.enable( 1 );
        this.cameraL.matrixAutoUpdate = false;
    
        this.cameraR = new PerspectiveCamera();
        this.cameraR.layers.enable( 2 );
        this.cameraR.matrixAutoUpdate = false;
    
        this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        };
    
    }
    
    Object.assign( StereoCamera.prototype, {
    
        update: function ( camera ) {
    
            var cache = this._cache;
    
            var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
                cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
                cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
    
            if ( needsUpdate ) {
    
                cache.focus = camera.focus;
                cache.fov = camera.fov;
                cache.aspect = camera.aspect * this.aspect;
                cache.near = camera.near;
                cache.far = camera.far;
                cache.zoom = camera.zoom;
                cache.eyeSep = this.eyeSep;
    
                // Off-axis stereoscopic effect based on
                // http://paulbourke.net/stereographics/stereorender/
    
                var projectionMatrix = camera.projectionMatrix.clone();
                var eyeSepHalf = cache.eyeSep / 2;
                var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
                var ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
                var xmin, xmax;
    
                // translate xOffset
    
                _eyeLeft.elements[ 12 ] = - eyeSepHalf;
                _eyeRight.elements[ 12 ] = eyeSepHalf;
    
                // for left eye
    
                xmin = - ymax * cache.aspect + eyeSepOnProjection;
                xmax = ymax * cache.aspect + eyeSepOnProjection;
    
                projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
                projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
    
                this.cameraL.projectionMatrix.copy( projectionMatrix );
    
                // for right eye
    
                xmin = - ymax * cache.aspect - eyeSepOnProjection;
                xmax = ymax * cache.aspect - eyeSepOnProjection;
    
                projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
                projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
    
                this.cameraR.projectionMatrix.copy( projectionMatrix );
    
            }
    
            this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
            this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );
    
        }
    
    } );
    
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    
    function Clock( autoStart ) {
    
        this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
    
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
    
        this.running = false;
    
    }
    
    Object.assign( Clock.prototype, {
    
        start: function () {
    
            this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732
    
            this.oldTime = this.startTime;
            this.elapsedTime = 0;
            this.running = true;
    
        },
    
        stop: function () {
    
            this.getElapsedTime();
            this.running = false;
            this.autoStart = false;
    
        },
    
        getElapsedTime: function () {
    
            this.getDelta();
            return this.elapsedTime;
    
        },
    
        getDelta: function () {
    
            var diff = 0;
    
            if ( this.autoStart && ! this.running ) {
    
                this.start();
                return 0;
    
            }
    
            if ( this.running ) {
    
                var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();
    
                diff = ( newTime - this.oldTime ) / 1000;
                this.oldTime = newTime;
    
                this.elapsedTime += diff;
    
            }
    
            return diff;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    var _position$2 = new Vector3();
    var _quaternion$3 = new Quaternion();
    var _scale$1 = new Vector3();
    var _orientation = new Vector3();
    
    function AudioListener() {
    
        Object3D.call( this );
    
        this.type = 'AudioListener';
    
        this.context = AudioContext.getContext();
    
        this.gain = this.context.createGain();
        this.gain.connect( this.context.destination );
    
        this.filter = null;
    
        this.timeDelta = 0;
    
        // private
    
        this._clock = new Clock();
    
    }
    
    AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: AudioListener,
    
        getInput: function () {
    
            return this.gain;
    
        },
    
        removeFilter: function ( ) {
    
            if ( this.filter !== null ) {
    
                this.gain.disconnect( this.filter );
                this.filter.disconnect( this.context.destination );
                this.gain.connect( this.context.destination );
                this.filter = null;
    
            }
    
            return this;
    
        },
    
        getFilter: function () {
    
            return this.filter;
    
        },
    
        setFilter: function ( value ) {
    
            if ( this.filter !== null ) {
    
                this.gain.disconnect( this.filter );
                this.filter.disconnect( this.context.destination );
    
            } else {
    
                this.gain.disconnect( this.context.destination );
    
            }
    
            this.filter = value;
            this.gain.connect( this.filter );
            this.filter.connect( this.context.destination );
    
            return this;
    
        },
    
        getMasterVolume: function () {
    
            return this.gain.gain.value;
    
        },
    
        setMasterVolume: function ( value ) {
    
            this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );
    
            return this;
    
        },
    
        updateMatrixWorld: function ( force ) {
    
            Object3D.prototype.updateMatrixWorld.call( this, force );
    
            var listener = this.context.listener;
            var up = this.up;
    
            this.timeDelta = this._clock.getDelta();
    
            this.matrixWorld.decompose( _position$2, _quaternion$3, _scale$1 );
    
            _orientation.set( 0, 0, - 1 ).applyQuaternion( _quaternion$3 );
    
            if ( listener.positionX ) {
    
                // code path for Chrome (see #14393)
    
                var endTime = this.context.currentTime + this.timeDelta;
    
                listener.positionX.linearRampToValueAtTime( _position$2.x, endTime );
                listener.positionY.linearRampToValueAtTime( _position$2.y, endTime );
                listener.positionZ.linearRampToValueAtTime( _position$2.z, endTime );
                listener.forwardX.linearRampToValueAtTime( _orientation.x, endTime );
                listener.forwardY.linearRampToValueAtTime( _orientation.y, endTime );
                listener.forwardZ.linearRampToValueAtTime( _orientation.z, endTime );
                listener.upX.linearRampToValueAtTime( up.x, endTime );
                listener.upY.linearRampToValueAtTime( up.y, endTime );
                listener.upZ.linearRampToValueAtTime( up.z, endTime );
    
            } else {
    
                listener.setPosition( _position$2.x, _position$2.y, _position$2.z );
                listener.setOrientation( _orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z );
    
            }
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Reece Aaron Lecrivain / http://reecenotes.com/
     */
    
    function Audio( listener ) {
    
        Object3D.call( this );
    
        this.type = 'Audio';
    
        this.listener = listener;
        this.context = listener.context;
    
        this.gain = this.context.createGain();
        this.gain.connect( listener.getInput() );
    
        this.autoplay = false;
    
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = undefined;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.sourceType = 'empty';
    
        this._startedAt = 0;
        this._pausedAt = 0;
    
        this.filters = [];
    
    }
    
    Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {
    
        constructor: Audio,
    
        getOutput: function () {
    
            return this.gain;
    
        },
    
        setNodeSource: function ( audioNode ) {
    
            this.hasPlaybackControl = false;
            this.sourceType = 'audioNode';
            this.source = audioNode;
            this.connect();
    
            return this;
    
        },
    
        setMediaElementSource: function ( mediaElement ) {
    
            this.hasPlaybackControl = false;
            this.sourceType = 'mediaNode';
            this.source = this.context.createMediaElementSource( mediaElement );
            this.connect();
    
            return this;
    
        },
    
        setMediaStreamSource: function ( mediaStream ) {
    
            this.hasPlaybackControl = false;
            this.sourceType = 'mediaStreamNode';
            this.source = this.context.createMediaStreamSource( mediaStream );
            this.connect();
    
            return this;
    
        },
    
        setBuffer: function ( audioBuffer ) {
    
            this.buffer = audioBuffer;
            this.sourceType = 'buffer';
    
            if ( this.autoplay ) this.play();
    
            return this;
    
        },
    
        play: function ( delay ) {
    
            if ( delay === undefined ) delay = 0;
    
            if ( this.isPlaying === true ) {
    
                console.warn( 'THREE.Audio: Audio is already playing.' );
                return;
    
            }
    
            if ( this.hasPlaybackControl === false ) {
    
                console.warn( 'THREE.Audio: this Audio has no playback control.' );
                return;
    
            }
    
            this._startedAt = this.context.currentTime + delay;
    
            var source = this.context.createBufferSource();
            source.buffer = this.buffer;
            source.loop = this.loop;
            source.loopStart = this.loopStart;
            source.loopEnd = this.loopEnd;
            source.onended = this.onEnded.bind( this );
            source.start( this._startedAt, this._pausedAt + this.offset, this.duration );
    
            this.isPlaying = true;
    
            this.source = source;
    
            this.setDetune( this.detune );
            this.setPlaybackRate( this.playbackRate );
    
            return this.connect();
    
        },
    
        pause: function () {
    
            if ( this.hasPlaybackControl === false ) {
    
                console.warn( 'THREE.Audio: this Audio has no playback control.' );
                return;
    
            }
    
            if ( this.isPlaying === true ) {
    
                this._pausedAt += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;
    
                this.source.stop();
                this.source.onended = null;
    
                this.isPlaying = false;
    
            }
    
            return this;
    
        },
    
        stop: function () {
    
            if ( this.hasPlaybackControl === false ) {
    
                console.warn( 'THREE.Audio: this Audio has no playback control.' );
                return;
    
            }
    
            this._pausedAt = 0;
    
            this.source.stop();
            this.source.onended = null;
            this.isPlaying = false;
    
            return this;
    
        },
    
        connect: function () {
    
            if ( this.filters.length > 0 ) {
    
                this.source.connect( this.filters[ 0 ] );
    
                for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
    
                    this.filters[ i - 1 ].connect( this.filters[ i ] );
    
                }
    
                this.filters[ this.filters.length - 1 ].connect( this.getOutput() );
    
            } else {
    
                this.source.connect( this.getOutput() );
    
            }
    
            return this;
    
        },
    
        disconnect: function () {
    
            if ( this.filters.length > 0 ) {
    
                this.source.disconnect( this.filters[ 0 ] );
    
                for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
    
                    this.filters[ i - 1 ].disconnect( this.filters[ i ] );
    
                }
    
                this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );
    
            } else {
    
                this.source.disconnect( this.getOutput() );
    
            }
    
            return this;
    
        },
    
        getFilters: function () {
    
            return this.filters;
    
        },
    
        setFilters: function ( value ) {
    
            if ( ! value ) value = [];
    
            if ( this.isPlaying === true ) {
    
                this.disconnect();
                this.filters = value;
                this.connect();
    
            } else {
    
                this.filters = value;
    
            }
    
            return this;
    
        },
    
        setDetune: function ( value ) {
    
            this.detune = value;
    
            if ( this.source.detune === undefined ) return; // only set detune when available
    
            if ( this.isPlaying === true ) {
    
                this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );
    
            }
    
            return this;
    
        },
    
        getDetune: function () {
    
            return this.detune;
    
        },
    
        getFilter: function () {
    
            return this.getFilters()[ 0 ];
    
        },
    
        setFilter: function ( filter ) {
    
            return this.setFilters( filter ? [ filter ] : [] );
    
        },
    
        setPlaybackRate: function ( value ) {
    
            if ( this.hasPlaybackControl === false ) {
    
                console.warn( 'THREE.Audio: this Audio has no playback control.' );
                return;
    
            }
    
            this.playbackRate = value;
    
            if ( this.isPlaying === true ) {
    
                this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );
    
            }
    
            return this;
    
        },
    
        getPlaybackRate: function () {
    
            return this.playbackRate;
    
        },
    
        onEnded: function () {
    
            this.isPlaying = false;
    
        },
    
        getLoop: function () {
    
            if ( this.hasPlaybackControl === false ) {
    
                console.warn( 'THREE.Audio: this Audio has no playback control.' );
                return false;
    
            }
    
            return this.loop;
    
        },
    
        setLoop: function ( value ) {
    
            if ( this.hasPlaybackControl === false ) {
    
                console.warn( 'THREE.Audio: this Audio has no playback control.' );
                return;
    
            }
    
            this.loop = value;
    
            if ( this.isPlaying === true ) {
    
                this.source.loop = this.loop;
    
            }
    
            return this;
    
        },
    
        setLoopStart: function ( value ) {
    
            this.loopStart = value;
    
            return this;
    
        },
    
        setLoopEnd: function ( value ) {
    
            this.loopEnd = value;
    
            return this;
    
        },
    
        getVolume: function () {
    
            return this.gain.gain.value;
    
        },
    
        setVolume: function ( value ) {
    
            this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );
    
            return this;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    var _position$3 = new Vector3();
    var _quaternion$4 = new Quaternion();
    var _scale$2 = new Vector3();
    var _orientation$1 = new Vector3();
    
    function PositionalAudio( listener ) {
    
        Audio.call( this, listener );
    
        this.panner = this.context.createPanner();
        this.panner.panningModel = 'HRTF';
        this.panner.connect( this.gain );
    
    }
    
    PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {
    
        constructor: PositionalAudio,
    
        getOutput: function () {
    
            return this.panner;
    
        },
    
        getRefDistance: function () {
    
            return this.panner.refDistance;
    
        },
    
        setRefDistance: function ( value ) {
    
            this.panner.refDistance = value;
    
            return this;
    
        },
    
        getRolloffFactor: function () {
    
            return this.panner.rolloffFactor;
    
        },
    
        setRolloffFactor: function ( value ) {
    
            this.panner.rolloffFactor = value;
    
            return this;
    
        },
    
        getDistanceModel: function () {
    
            return this.panner.distanceModel;
    
        },
    
        setDistanceModel: function ( value ) {
    
            this.panner.distanceModel = value;
    
            return this;
    
        },
    
        getMaxDistance: function () {
    
            return this.panner.maxDistance;
    
        },
    
        setMaxDistance: function ( value ) {
    
            this.panner.maxDistance = value;
    
            return this;
    
        },
    
        setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {
    
            this.panner.coneInnerAngle = coneInnerAngle;
            this.panner.coneOuterAngle = coneOuterAngle;
            this.panner.coneOuterGain = coneOuterGain;
    
            return this;
    
        },
    
        updateMatrixWorld: function ( force ) {
    
            Object3D.prototype.updateMatrixWorld.call( this, force );
    
            if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;
    
            this.matrixWorld.decompose( _position$3, _quaternion$4, _scale$2 );
    
            _orientation$1.set( 0, 0, 1 ).applyQuaternion( _quaternion$4 );
    
            var panner = this.panner;
    
            if ( panner.positionX ) {
    
                // code path for Chrome and Firefox (see #14393)
    
                var endTime = this.context.currentTime + this.listener.timeDelta;
    
                panner.positionX.linearRampToValueAtTime( _position$3.x, endTime );
                panner.positionY.linearRampToValueAtTime( _position$3.y, endTime );
                panner.positionZ.linearRampToValueAtTime( _position$3.z, endTime );
                panner.orientationX.linearRampToValueAtTime( _orientation$1.x, endTime );
                panner.orientationY.linearRampToValueAtTime( _orientation$1.y, endTime );
                panner.orientationZ.linearRampToValueAtTime( _orientation$1.z, endTime );
    
            } else {
    
                panner.setPosition( _position$3.x, _position$3.y, _position$3.z );
                panner.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z );
    
            }
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function AudioAnalyser( audio, fftSize ) {
    
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
    
        this.data = new Uint8Array( this.analyser.frequencyBinCount );
    
        audio.getOutput().connect( this.analyser );
    
    }
    
    Object.assign( AudioAnalyser.prototype, {
    
        getFrequencyData: function () {
    
            this.analyser.getByteFrequencyData( this.data );
    
            return this.data;
    
        },
    
        getAverageFrequency: function () {
    
            var value = 0, data = this.getFrequencyData();
    
            for ( var i = 0; i < data.length; i ++ ) {
    
                value += data[ i ];
    
            }
    
            return value / data.length;
    
        }
    
    } );
    
    /**
     *
     * Buffered scene graph property that allows weighted accumulation.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    
    function PropertyMixer( binding, typeName, valueSize ) {
    
        this.binding = binding;
        this.valueSize = valueSize;
    
        var bufferType = Float64Array,
            mixFunction;
    
        switch ( typeName ) {
    
            case 'quaternion':
                mixFunction = this._slerp;
                break;
    
            case 'string':
            case 'bool':
                bufferType = Array;
                mixFunction = this._select;
                break;
    
            default:
                mixFunction = this._lerp;
    
        }
    
        this.buffer = new bufferType( valueSize * 4 );
        // layout: [ incoming | accu0 | accu1 | orig ]
        //
        // interpolators can use .buffer as their .result
        // the data then goes to 'incoming'
        //
        // 'accu0' and 'accu1' are used frame-interleaved for
        // the cumulative result and are compared to detect
        // changes
        //
        // 'orig' stores the original state of the property
    
        this._mixBufferRegion = mixFunction;
    
        this.cumulativeWeight = 0;
    
        this.useCount = 0;
        this.referenceCount = 0;
    
    }
    
    Object.assign( PropertyMixer.prototype, {
    
        // accumulate data in the 'incoming' region into 'accu<i>'
        accumulate: function ( accuIndex, weight ) {
    
            // note: happily accumulating nothing when weight = 0, the caller knows
            // the weight and shouldn't have made the call in the first place
    
            var buffer = this.buffer,
                stride = this.valueSize,
                offset = accuIndex * stride + stride,
    
                currentWeight = this.cumulativeWeight;
    
            if ( currentWeight === 0 ) {
    
                // accuN := incoming * weight
    
                for ( var i = 0; i !== stride; ++ i ) {
    
                    buffer[ offset + i ] = buffer[ i ];
    
                }
    
                currentWeight = weight;
    
            } else {
    
                // accuN := accuN + incoming * weight
    
                currentWeight += weight;
                var mix = weight / currentWeight;
                this._mixBufferRegion( buffer, offset, 0, mix, stride );
    
            }
    
            this.cumulativeWeight = currentWeight;
    
        },
    
        // apply the state of 'accu<i>' to the binding when accus differ
        apply: function ( accuIndex ) {
    
            var stride = this.valueSize,
                buffer = this.buffer,
                offset = accuIndex * stride + stride,
    
                weight = this.cumulativeWeight,
    
                binding = this.binding;
    
            this.cumulativeWeight = 0;
    
            if ( weight < 1 ) {
    
                // accuN := accuN + original * ( 1 - cumulativeWeight )
    
                var originalValueOffset = stride * 3;
    
                this._mixBufferRegion(
                    buffer, offset, originalValueOffset, 1 - weight, stride );
    
            }
    
            for ( var i = stride, e = stride + stride; i !== e; ++ i ) {
    
                if ( buffer[ i ] !== buffer[ i + stride ] ) {
    
                    // value has changed -> update scene graph
    
                    binding.setValue( buffer, offset );
                    break;
    
                }
    
            }
    
        },
    
        // remember the state of the bound property and copy it to both accus
        saveOriginalState: function () {
    
            var binding = this.binding;
    
            var buffer = this.buffer,
                stride = this.valueSize,
    
                originalValueOffset = stride * 3;
    
            binding.getValue( buffer, originalValueOffset );
    
            // accu[0..1] := orig -- initially detect changes against the original
            for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {
    
                buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];
    
            }
    
            this.cumulativeWeight = 0;
    
        },
    
        // apply the state previously taken via 'saveOriginalState' to the binding
        restoreOriginalState: function () {
    
            var originalValueOffset = this.valueSize * 3;
            this.binding.setValue( this.buffer, originalValueOffset );
    
        },
    
    
        // mix functions
    
        _select: function ( buffer, dstOffset, srcOffset, t, stride ) {
    
            if ( t >= 0.5 ) {
    
                for ( var i = 0; i !== stride; ++ i ) {
    
                    buffer[ dstOffset + i ] = buffer[ srcOffset + i ];
    
                }
    
            }
    
        },
    
        _slerp: function ( buffer, dstOffset, srcOffset, t ) {
    
            Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );
    
        },
    
        _lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {
    
            var s = 1 - t;
    
            for ( var i = 0; i !== stride; ++ i ) {
    
                var j = dstOffset + i;
    
                buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;
    
            }
    
        }
    
    } );
    
    /**
     *
     * A reference to a real property in the scene graph.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    
    // Characters [].:/ are reserved for track binding syntax.
    var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
    var _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );
    
    // Attempts to allow node names from any language. ES5's `\w` regexp matches
    // only latin characters, and the unicode \p{L} is not yet supported. So
    // instead, we exclude reserved characters and match everything else.
    var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
    var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';
    
    // Parent directories, delimited by '/' or ':'. Currently unused, but must
    // be matched to parse the rest of the track name.
    var _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );
    
    // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
    var _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );
    
    // Object on target node, and accessor. May not contain reserved
    // characters. Accessor may contain any character except closing bracket.
    var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );
    
    // Property and accessor. May not contain reserved characters. Accessor may
    // contain any non-bracket characters.
    var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );
    
    var _trackRe = new RegExp( ''
        + '^'
        + _directoryRe
        + _nodeRe
        + _objectRe
        + _propertyRe
        + '$'
    );
    
    var _supportedObjectNames = [ 'material', 'materials', 'bones' ];
    
    function Composite( targetGroup, path, optionalParsedPath ) {
    
        var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );
    
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_( path, parsedPath );
    
    }
    
    Object.assign( Composite.prototype, {
    
        getValue: function ( array, offset ) {
    
            this.bind(); // bind all binding
    
            var firstValidIndex = this._targetGroup.nCachedObjects_,
                binding = this._bindings[ firstValidIndex ];
    
            // and only call .getValue on the first
            if ( binding !== undefined ) binding.getValue( array, offset );
    
        },
    
        setValue: function ( array, offset ) {
    
            var bindings = this._bindings;
    
            for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {
    
                bindings[ i ].setValue( array, offset );
    
            }
    
        },
    
        bind: function () {
    
            var bindings = this._bindings;
    
            for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {
    
                bindings[ i ].bind();
    
            }
    
        },
    
        unbind: function () {
    
            var bindings = this._bindings;
    
            for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {
    
                bindings[ i ].unbind();
    
            }
    
        }
    
    } );
    
    
    function PropertyBinding( rootNode, path, parsedPath ) {
    
        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );
    
        this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;
    
        this.rootNode = rootNode;
    
    }
    
    Object.assign( PropertyBinding, {
    
        Composite: Composite,
    
        create: function ( root, path, parsedPath ) {
    
            if ( ! ( root && root.isAnimationObjectGroup ) ) {
    
                return new PropertyBinding( root, path, parsedPath );
    
            } else {
    
                return new PropertyBinding.Composite( root, path, parsedPath );
    
            }
    
        },
    
        /**
         * Replaces spaces with underscores and removes unsupported characters from
         * node names, to ensure compatibility with parseTrackName().
         *
         * @param {string} name Node name to be sanitized.
         * @return {string}
         */
        sanitizeNodeName: function ( name ) {
    
            return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );
    
        },
    
        parseTrackName: function ( trackName ) {
    
            var matches = _trackRe.exec( trackName );
    
            if ( ! matches ) {
    
                throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );
    
            }
    
            var results = {
                // directoryName: matches[ 1 ], // (tschw) currently unused
                nodeName: matches[ 2 ],
                objectName: matches[ 3 ],
                objectIndex: matches[ 4 ],
                propertyName: matches[ 5 ], // required
                propertyIndex: matches[ 6 ]
            };
    
            var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );
    
            if ( lastDot !== undefined && lastDot !== - 1 ) {
    
                var objectName = results.nodeName.substring( lastDot + 1 );
    
                // Object names must be checked against a whitelist. Otherwise, there
                // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
                // 'bar' could be the objectName, or part of a nodeName (which can
                // include '.' characters).
                if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {
    
                    results.nodeName = results.nodeName.substring( 0, lastDot );
                    results.objectName = objectName;
    
                }
    
            }
    
            if ( results.propertyName === null || results.propertyName.length === 0 ) {
    
                throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );
    
            }
    
            return results;
    
        },
    
        findNode: function ( root, nodeName ) {
    
            if ( ! nodeName || nodeName === "" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {
    
                return root;
    
            }
    
            // search into skeleton bones.
            if ( root.skeleton ) {
    
                var bone = root.skeleton.getBoneByName( nodeName );
    
                if ( bone !== undefined ) {
    
                    return bone;
    
                }
    
            }
    
            // search into node subtree.
            if ( root.children ) {
    
                var searchNodeSubtree = function ( children ) {
    
                    for ( var i = 0; i < children.length; i ++ ) {
    
                        var childNode = children[ i ];
    
                        if ( childNode.name === nodeName || childNode.uuid === nodeName ) {
    
                            return childNode;
    
                        }
    
                        var result = searchNodeSubtree( childNode.children );
    
                        if ( result ) return result;
    
                    }
    
                    return null;
    
                };
    
                var subTreeNode = searchNodeSubtree( root.children );
    
                if ( subTreeNode ) {
    
                    return subTreeNode;
    
                }
    
            }
    
            return null;
    
        }
    
    } );
    
    Object.assign( PropertyBinding.prototype, { // prototype, continued
    
        // these are used to "bind" a nonexistent property
        _getValue_unavailable: function () {},
        _setValue_unavailable: function () {},
    
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
    
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
    
        GetterByBindingType: [
    
            function getValue_direct( buffer, offset ) {
    
                buffer[ offset ] = this.node[ this.propertyName ];
    
            },
    
            function getValue_array( buffer, offset ) {
    
                var source = this.resolvedProperty;
    
                for ( var i = 0, n = source.length; i !== n; ++ i ) {
    
                    buffer[ offset ++ ] = source[ i ];
    
                }
    
            },
    
            function getValue_arrayElement( buffer, offset ) {
    
                buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
    
            },
    
            function getValue_toArray( buffer, offset ) {
    
                this.resolvedProperty.toArray( buffer, offset );
    
            }
    
        ],
    
        SetterByBindingTypeAndVersioning: [
    
            [
                // Direct
    
                function setValue_direct( buffer, offset ) {
    
                    this.targetObject[ this.propertyName ] = buffer[ offset ];
    
                },
    
                function setValue_direct_setNeedsUpdate( buffer, offset ) {
    
                    this.targetObject[ this.propertyName ] = buffer[ offset ];
                    this.targetObject.needsUpdate = true;
    
                },
    
                function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
    
                    this.targetObject[ this.propertyName ] = buffer[ offset ];
                    this.targetObject.matrixWorldNeedsUpdate = true;
    
                }
    
            ], [
    
                // EntireArray
    
                function setValue_array( buffer, offset ) {
    
                    var dest = this.resolvedProperty;
    
                    for ( var i = 0, n = dest.length; i !== n; ++ i ) {
    
                        dest[ i ] = buffer[ offset ++ ];
    
                    }
    
                },
    
                function setValue_array_setNeedsUpdate( buffer, offset ) {
    
                    var dest = this.resolvedProperty;
    
                    for ( var i = 0, n = dest.length; i !== n; ++ i ) {
    
                        dest[ i ] = buffer[ offset ++ ];
    
                    }
    
                    this.targetObject.needsUpdate = true;
    
                },
    
                function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
    
                    var dest = this.resolvedProperty;
    
                    for ( var i = 0, n = dest.length; i !== n; ++ i ) {
    
                        dest[ i ] = buffer[ offset ++ ];
    
                    }
    
                    this.targetObject.matrixWorldNeedsUpdate = true;
    
                }
    
            ], [
    
                // ArrayElement
    
                function setValue_arrayElement( buffer, offset ) {
    
                    this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
    
                },
    
                function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
    
                    this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
                    this.targetObject.needsUpdate = true;
    
                },
    
                function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
    
                    this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
                    this.targetObject.matrixWorldNeedsUpdate = true;
    
                }
    
            ], [
    
                // HasToFromArray
    
                function setValue_fromArray( buffer, offset ) {
    
                    this.resolvedProperty.fromArray( buffer, offset );
    
                },
    
                function setValue_fromArray_setNeedsUpdate( buffer, offset ) {
    
                    this.resolvedProperty.fromArray( buffer, offset );
                    this.targetObject.needsUpdate = true;
    
                },
    
                function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
    
                    this.resolvedProperty.fromArray( buffer, offset );
                    this.targetObject.matrixWorldNeedsUpdate = true;
    
                }
    
            ]
    
        ],
    
        getValue: function getValue_unbound( targetArray, offset ) {
    
            this.bind();
            this.getValue( targetArray, offset );
    
            // Note: This class uses a State pattern on a per-method basis:
            // 'bind' sets 'this.getValue' / 'setValue' and shadows the
            // prototype version of these methods with one that represents
            // the bound state. When the property is not found, the methods
            // become no-ops.
    
        },
    
        setValue: function getValue_unbound( sourceArray, offset ) {
    
            this.bind();
            this.setValue( sourceArray, offset );
    
        },
    
        // create getter / setter pair for a property in the scene graph
        bind: function () {
    
            var targetObject = this.node,
                parsedPath = this.parsedPath,
    
                objectName = parsedPath.objectName,
                propertyName = parsedPath.propertyName,
                propertyIndex = parsedPath.propertyIndex;
    
            if ( ! targetObject ) {
    
                targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;
    
                this.node = targetObject;
    
            }
    
            // set fail state so we can just 'return' on error
            this.getValue = this._getValue_unavailable;
            this.setValue = this._setValue_unavailable;
    
            // ensure there is a value node
            if ( ! targetObject ) {
    
                console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
                return;
    
            }
    
            if ( objectName ) {
    
                var objectIndex = parsedPath.objectIndex;
    
                // special cases were we need to reach deeper into the hierarchy to get the face materials....
                switch ( objectName ) {
    
                    case 'materials':
    
                        if ( ! targetObject.material ) {
    
                            console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
                            return;
    
                        }
    
                        if ( ! targetObject.material.materials ) {
    
                            console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
                            return;
    
                        }
    
                        targetObject = targetObject.material.materials;
    
                        break;
    
                    case 'bones':
    
                        if ( ! targetObject.skeleton ) {
    
                            console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
                            return;
    
                        }
    
                        // potential future optimization: skip this if propertyIndex is already an integer
                        // and convert the integer string to a true integer.
    
                        targetObject = targetObject.skeleton.bones;
    
                        // support resolving morphTarget names into indices.
                        for ( var i = 0; i < targetObject.length; i ++ ) {
    
                            if ( targetObject[ i ].name === objectIndex ) {
    
                                objectIndex = i;
                                break;
    
                            }
    
                        }
    
                        break;
    
                    default:
    
                        if ( targetObject[ objectName ] === undefined ) {
    
                            console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
                            return;
    
                        }
    
                        targetObject = targetObject[ objectName ];
    
                }
    
    
                if ( objectIndex !== undefined ) {
    
                    if ( targetObject[ objectIndex ] === undefined ) {
    
                        console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
                        return;
    
                    }
    
                    targetObject = targetObject[ objectIndex ];
    
                }
    
            }
    
            // resolve property
            var nodeProperty = targetObject[ propertyName ];
    
            if ( nodeProperty === undefined ) {
    
                var nodeName = parsedPath.nodeName;
    
                console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
                    '.' + propertyName + ' but it wasn\'t found.', targetObject );
                return;
    
            }
    
            // determine versioning scheme
            var versioning = this.Versioning.None;
    
            this.targetObject = targetObject;
    
            if ( targetObject.needsUpdate !== undefined ) { // material
    
                versioning = this.Versioning.NeedsUpdate;
    
            } else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
    
                versioning = this.Versioning.MatrixWorldNeedsUpdate;
    
            }
    
            // determine how the property gets bound
            var bindingType = this.BindingType.Direct;
    
            if ( propertyIndex !== undefined ) {
    
                // access a sub element of the property array (only primitives are supported right now)
    
                if ( propertyName === "morphTargetInfluences" ) {
    
                    // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
    
                    // support resolving morphTarget names into indices.
                    if ( ! targetObject.geometry ) {
    
                        console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
                        return;
    
                    }
    
                    if ( targetObject.geometry.isBufferGeometry ) {
    
                        if ( ! targetObject.geometry.morphAttributes ) {
    
                            console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
                            return;
    
                        }
    
                        for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {
    
                            if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {
    
                                propertyIndex = i;
                                break;
    
                            }
    
                        }
    
    
                    } else {
    
                        if ( ! targetObject.geometry.morphTargets ) {
    
                            console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
                            return;
    
                        }
    
                        for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
    
                            if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {
    
                                propertyIndex = i;
                                break;
    
                            }
    
                        }
    
                    }
    
                }
    
                bindingType = this.BindingType.ArrayElement;
    
                this.resolvedProperty = nodeProperty;
                this.propertyIndex = propertyIndex;
    
            } else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
    
                // must use copy for Object3D.Euler/Quaternion
    
                bindingType = this.BindingType.HasFromToArray;
    
                this.resolvedProperty = nodeProperty;
    
            } else if ( Array.isArray( nodeProperty ) ) {
    
                bindingType = this.BindingType.EntireArray;
    
                this.resolvedProperty = nodeProperty;
    
            } else {
    
                this.propertyName = propertyName;
    
            }
    
            // select getter / setter
            this.getValue = this.GetterByBindingType[ bindingType ];
            this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
    
        },
    
        unbind: function () {
    
            this.node = null;
    
            // back to the prototype version of getValue / setValue
            // note: avoiding to mutate the shape of 'this' via 'delete'
            this.getValue = this._getValue_unbound;
            this.setValue = this._setValue_unbound;
    
        }
    
    } );
    
    //!\ DECLARE ALIAS AFTER assign prototype !
    Object.assign( PropertyBinding.prototype, {
    
        // initial state of these methods that calls 'bind'
        _getValue_unbound: PropertyBinding.prototype.getValue,
        _setValue_unbound: PropertyBinding.prototype.setValue,
    
    } );
    
    /**
     *
     * A group of objects that receives a shared animation state.
     *
     * Usage:
     *
     *  - Add objects you would otherwise pass as 'root' to the
     *    constructor or the .clipAction method of AnimationMixer.
     *
     *  - Instead pass this object as 'root'.
     *
     *  - You can also add and remove objects later when the mixer
     *    is running.
     *
     * Note:
     *
     *    Objects of this class appear as one object to the mixer,
     *    so cache control of the individual objects must be done
     *    on the group.
     *
     * Limitation:
     *
     *  - The animated properties must be compatible among the
     *    all objects in the group.
     *
     *  - A single property can either be controlled through a
     *    target group or directly, but not both.
     *
     * @author tschw
     */
    
    function AnimationObjectGroup() {
    
        this.uuid = MathUtils.generateUUID();
    
        // cached objects followed by the active ones
        this._objects = Array.prototype.slice.call( arguments );
    
        this.nCachedObjects_ = 0; // threshold
        // note: read by PropertyBinding.Composite
    
        var indices = {};
        this._indicesByUUID = indices; // for bookkeeping
    
        for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
    
            indices[ arguments[ i ].uuid ] = i;
    
        }
    
        this._paths = []; // inside: string
        this._parsedPaths = []; // inside: { we don't care, here }
        this._bindings = []; // inside: Array< PropertyBinding >
        this._bindingsIndicesByPath = {}; // inside: indices in these arrays
    
        var scope = this;
    
        this.stats = {
    
            objects: {
                get total() {
    
                    return scope._objects.length;
    
                },
                get inUse() {
    
                    return this.total - scope.nCachedObjects_;
    
                }
            },
            get bindingsPerObject() {
    
                return scope._bindings.length;
    
            }
    
        };
    
    }
    
    Object.assign( AnimationObjectGroup.prototype, {
    
        isAnimationObjectGroup: true,
    
        add: function () {
    
            var objects = this._objects,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_,
                indicesByUUID = this._indicesByUUID,
                paths = this._paths,
                parsedPaths = this._parsedPaths,
                bindings = this._bindings,
                nBindings = bindings.length,
                knownObject = undefined;
    
            for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
    
                var object = arguments[ i ],
                    uuid = object.uuid,
                    index = indicesByUUID[ uuid ];
    
                if ( index === undefined ) {
    
                    // unknown object -> add it to the ACTIVE region
    
                    index = nObjects ++;
                    indicesByUUID[ uuid ] = index;
                    objects.push( object );
    
                    // accounting is done, now do the same for all bindings
    
                    for ( var j = 0, m = nBindings; j !== m; ++ j ) {
    
                        bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );
    
                    }
    
                } else if ( index < nCachedObjects ) {
    
                    knownObject = objects[ index ];
    
                    // move existing object to the ACTIVE region
    
                    var firstActiveIndex = -- nCachedObjects,
                        lastCachedObject = objects[ firstActiveIndex ];
    
                    indicesByUUID[ lastCachedObject.uuid ] = index;
                    objects[ index ] = lastCachedObject;
    
                    indicesByUUID[ uuid ] = firstActiveIndex;
                    objects[ firstActiveIndex ] = object;
    
                    // accounting is done, now do the same for all bindings
    
                    for ( var j = 0, m = nBindings; j !== m; ++ j ) {
    
                        var bindingsForPath = bindings[ j ],
                            lastCached = bindingsForPath[ firstActiveIndex ],
                            binding = bindingsForPath[ index ];
    
                        bindingsForPath[ index ] = lastCached;
    
                        if ( binding === undefined ) {
    
                            // since we do not bother to create new bindings
                            // for objects that are cached, the binding may
                            // or may not exist
    
                            binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );
    
                        }
    
                        bindingsForPath[ firstActiveIndex ] = binding;
    
                    }
    
                } else if ( objects[ index ] !== knownObject ) {
    
                    console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
                        'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );
    
                } // else the object is already where we want it to be
    
            } // for arguments
    
            this.nCachedObjects_ = nCachedObjects;
    
        },
    
        remove: function () {
    
            var objects = this._objects,
                nCachedObjects = this.nCachedObjects_,
                indicesByUUID = this._indicesByUUID,
                bindings = this._bindings,
                nBindings = bindings.length;
    
            for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
    
                var object = arguments[ i ],
                    uuid = object.uuid,
                    index = indicesByUUID[ uuid ];
    
                if ( index !== undefined && index >= nCachedObjects ) {
    
                    // move existing object into the CACHED region
    
                    var lastCachedIndex = nCachedObjects ++,
                        firstActiveObject = objects[ lastCachedIndex ];
    
                    indicesByUUID[ firstActiveObject.uuid ] = index;
                    objects[ index ] = firstActiveObject;
    
                    indicesByUUID[ uuid ] = lastCachedIndex;
                    objects[ lastCachedIndex ] = object;
    
                    // accounting is done, now do the same for all bindings
    
                    for ( var j = 0, m = nBindings; j !== m; ++ j ) {
    
                        var bindingsForPath = bindings[ j ],
                            firstActive = bindingsForPath[ lastCachedIndex ],
                            binding = bindingsForPath[ index ];
    
                        bindingsForPath[ index ] = firstActive;
                        bindingsForPath[ lastCachedIndex ] = binding;
    
                    }
    
                }
    
            } // for arguments
    
            this.nCachedObjects_ = nCachedObjects;
    
        },
    
        // remove & forget
        uncache: function () {
    
            var objects = this._objects,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_,
                indicesByUUID = this._indicesByUUID,
                bindings = this._bindings,
                nBindings = bindings.length;
    
            for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
    
                var object = arguments[ i ],
                    uuid = object.uuid,
                    index = indicesByUUID[ uuid ];
    
                if ( index !== undefined ) {
    
                    delete indicesByUUID[ uuid ];
    
                    if ( index < nCachedObjects ) {
    
                        // object is cached, shrink the CACHED region
    
                        var firstActiveIndex = -- nCachedObjects,
                            lastCachedObject = objects[ firstActiveIndex ],
                            lastIndex = -- nObjects,
                            lastObject = objects[ lastIndex ];
    
                        // last cached object takes this object's place
                        indicesByUUID[ lastCachedObject.uuid ] = index;
                        objects[ index ] = lastCachedObject;
    
                        // last object goes to the activated slot and pop
                        indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
                        objects[ firstActiveIndex ] = lastObject;
                        objects.pop();
    
                        // accounting is done, now do the same for all bindings
    
                        for ( var j = 0, m = nBindings; j !== m; ++ j ) {
    
                            var bindingsForPath = bindings[ j ],
                                lastCached = bindingsForPath[ firstActiveIndex ],
                                last = bindingsForPath[ lastIndex ];
    
                            bindingsForPath[ index ] = lastCached;
                            bindingsForPath[ firstActiveIndex ] = last;
                            bindingsForPath.pop();
    
                        }
    
                    } else {
    
                        // object is active, just swap with the last and pop
    
                        var lastIndex = -- nObjects,
                            lastObject = objects[ lastIndex ];
    
                        indicesByUUID[ lastObject.uuid ] = index;
                        objects[ index ] = lastObject;
                        objects.pop();
    
                        // accounting is done, now do the same for all bindings
    
                        for ( var j = 0, m = nBindings; j !== m; ++ j ) {
    
                            var bindingsForPath = bindings[ j ];
    
                            bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
                            bindingsForPath.pop();
    
                        }
    
                    } // cached or active
    
                } // if object is known
    
            } // for arguments
    
            this.nCachedObjects_ = nCachedObjects;
    
        },
    
        // Internal interface used by befriended PropertyBinding.Composite:
    
        subscribe_: function ( path, parsedPath ) {
    
            // returns an array of bindings for the given path that is changed
            // according to the contained objects in the group
    
            var indicesByPath = this._bindingsIndicesByPath,
                index = indicesByPath[ path ],
                bindings = this._bindings;
    
            if ( index !== undefined ) return bindings[ index ];
    
            var paths = this._paths,
                parsedPaths = this._parsedPaths,
                objects = this._objects,
                nObjects = objects.length,
                nCachedObjects = this.nCachedObjects_,
                bindingsForPath = new Array( nObjects );
    
            index = bindings.length;
    
            indicesByPath[ path ] = index;
    
            paths.push( path );
            parsedPaths.push( parsedPath );
            bindings.push( bindingsForPath );
    
            for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {
    
                var object = objects[ i ];
                bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );
    
            }
    
            return bindingsForPath;
    
        },
    
        unsubscribe_: function ( path ) {
    
            // tells the group to forget about a property path and no longer
            // update the array previously obtained with 'subscribe_'
    
            var indicesByPath = this._bindingsIndicesByPath,
                index = indicesByPath[ path ];
    
            if ( index !== undefined ) {
    
                var paths = this._paths,
                    parsedPaths = this._parsedPaths,
                    bindings = this._bindings,
                    lastBindingsIndex = bindings.length - 1,
                    lastBindings = bindings[ lastBindingsIndex ],
                    lastBindingsPath = path[ lastBindingsIndex ];
    
                indicesByPath[ lastBindingsPath ] = index;
    
                bindings[ index ] = lastBindings;
                bindings.pop();
    
                parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
                parsedPaths.pop();
    
                paths[ index ] = paths[ lastBindingsIndex ];
                paths.pop();
    
            }
    
        }
    
    } );
    
    /**
     *
     * Action provided by AnimationMixer for scheduling clip playback on specific
     * objects.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     *
     */
    
    function AnimationAction( mixer, clip, localRoot ) {
    
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot || null;
    
        var tracks = clip.tracks,
            nTracks = tracks.length,
            interpolants = new Array( nTracks );
    
        var interpolantSettings = {
            endingStart: ZeroCurvatureEnding,
            endingEnd: ZeroCurvatureEnding
        };
    
        for ( var i = 0; i !== nTracks; ++ i ) {
    
            var interpolant = tracks[ i ].createInterpolant( null );
            interpolants[ i ] = interpolant;
            interpolant.settings = interpolantSettings;
    
        }
    
        this._interpolantSettings = interpolantSettings;
    
        this._interpolants = interpolants; // bound by the mixer
    
        // inside: PropertyMixer (managed by the mixer)
        this._propertyBindings = new Array( nTracks );
    
        this._cacheIndex = null; // for the memory manager
        this._byClipCacheIndex = null; // for the memory manager
    
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
    
        this.loop = LoopRepeat;
        this._loopCount = - 1;
    
        // global mixer time when the action is to be started
        // it's set back to 'null' upon start of the action
        this._startTime = null;
    
        // scaled local time of the action
        // gets clamped or wrapped to 0..clip.duration according to loop
        this.time = 0;
    
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
    
        this.weight = 1;
        this._effectiveWeight = 1;
    
        this.repetitions = Infinity; // no. of repetitions when looping
    
        this.paused = false; // true -> zero effective time scale
        this.enabled = true; // false -> zero effective weight
    
        this.clampWhenFinished = false;// keep feeding the last frame?
    
        this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
        this.zeroSlopeAtEnd = true;// clips for start, loop and end
    
    }
    
    Object.assign( AnimationAction.prototype, {
    
        // State & Scheduling
    
        play: function () {
    
            this._mixer._activateAction( this );
    
            return this;
    
        },
    
        stop: function () {
    
            this._mixer._deactivateAction( this );
    
            return this.reset();
    
        },
    
        reset: function () {
    
            this.paused = false;
            this.enabled = true;
    
            this.time = 0; // restart clip
            this._loopCount = - 1;// forget previous loops
            this._startTime = null;// forget scheduling
    
            return this.stopFading().stopWarping();
    
        },
    
        isRunning: function () {
    
            return this.enabled && ! this.paused && this.timeScale !== 0 &&
                this._startTime === null && this._mixer._isActiveAction( this );
    
        },
    
        // return true when play has been called
        isScheduled: function () {
    
            return this._mixer._isActiveAction( this );
    
        },
    
        startAt: function ( time ) {
    
            this._startTime = time;
    
            return this;
    
        },
    
        setLoop: function ( mode, repetitions ) {
    
            this.loop = mode;
            this.repetitions = repetitions;
    
            return this;
    
        },
    
        // Weight
    
        // set the weight stopping any scheduled fading
        // although .enabled = false yields an effective weight of zero, this
        // method does *not* change .enabled, because it would be confusing
        setEffectiveWeight: function ( weight ) {
    
            this.weight = weight;
    
            // note: same logic as when updated at runtime
            this._effectiveWeight = this.enabled ? weight : 0;
    
            return this.stopFading();
    
        },
    
        // return the weight considering fading and .enabled
        getEffectiveWeight: function () {
    
            return this._effectiveWeight;
    
        },
    
        fadeIn: function ( duration ) {
    
            return this._scheduleFading( duration, 0, 1 );
    
        },
    
        fadeOut: function ( duration ) {
    
            return this._scheduleFading( duration, 1, 0 );
    
        },
    
        crossFadeFrom: function ( fadeOutAction, duration, warp ) {
    
            fadeOutAction.fadeOut( duration );
            this.fadeIn( duration );
    
            if ( warp ) {
    
                var fadeInDuration = this._clip.duration,
                    fadeOutDuration = fadeOutAction._clip.duration,
    
                    startEndRatio = fadeOutDuration / fadeInDuration,
                    endStartRatio = fadeInDuration / fadeOutDuration;
    
                fadeOutAction.warp( 1.0, startEndRatio, duration );
                this.warp( endStartRatio, 1.0, duration );
    
            }
    
            return this;
    
        },
    
        crossFadeTo: function ( fadeInAction, duration, warp ) {
    
            return fadeInAction.crossFadeFrom( this, duration, warp );
    
        },
    
        stopFading: function () {
    
            var weightInterpolant = this._weightInterpolant;
    
            if ( weightInterpolant !== null ) {
    
                this._weightInterpolant = null;
                this._mixer._takeBackControlInterpolant( weightInterpolant );
    
            }
    
            return this;
    
        },
    
        // Time Scale Control
    
        // set the time scale stopping any scheduled warping
        // although .paused = true yields an effective time scale of zero, this
        // method does *not* change .paused, because it would be confusing
        setEffectiveTimeScale: function ( timeScale ) {
    
            this.timeScale = timeScale;
            this._effectiveTimeScale = this.paused ? 0 : timeScale;
    
            return this.stopWarping();
    
        },
    
        // return the time scale considering warping and .paused
        getEffectiveTimeScale: function () {
    
            return this._effectiveTimeScale;
    
        },
    
        setDuration: function ( duration ) {
    
            this.timeScale = this._clip.duration / duration;
    
            return this.stopWarping();
    
        },
    
        syncWith: function ( action ) {
    
            this.time = action.time;
            this.timeScale = action.timeScale;
    
            return this.stopWarping();
    
        },
    
        halt: function ( duration ) {
    
            return this.warp( this._effectiveTimeScale, 0, duration );
    
        },
    
        warp: function ( startTimeScale, endTimeScale, duration ) {
    
            var mixer = this._mixer, now = mixer.time,
                interpolant = this._timeScaleInterpolant,
    
                timeScale = this.timeScale;
    
            if ( interpolant === null ) {
    
                interpolant = mixer._lendControlInterpolant();
                this._timeScaleInterpolant = interpolant;
    
            }
    
            var times = interpolant.parameterPositions,
                values = interpolant.sampleValues;
    
            times[ 0 ] = now;
            times[ 1 ] = now + duration;
    
            values[ 0 ] = startTimeScale / timeScale;
            values[ 1 ] = endTimeScale / timeScale;
    
            return this;
    
        },
    
        stopWarping: function () {
    
            var timeScaleInterpolant = this._timeScaleInterpolant;
    
            if ( timeScaleInterpolant !== null ) {
    
                this._timeScaleInterpolant = null;
                this._mixer._takeBackControlInterpolant( timeScaleInterpolant );
    
            }
    
            return this;
    
        },
    
        // Object Accessors
    
        getMixer: function () {
    
            return this._mixer;
    
        },
    
        getClip: function () {
    
            return this._clip;
    
        },
    
        getRoot: function () {
    
            return this._localRoot || this._mixer._root;
    
        },
    
        // Interna
    
        _update: function ( time, deltaTime, timeDirection, accuIndex ) {
    
            // called by the mixer
    
            if ( ! this.enabled ) {
    
                // call ._updateWeight() to update ._effectiveWeight
    
                this._updateWeight( time );
                return;
    
            }
    
            var startTime = this._startTime;
    
            if ( startTime !== null ) {
    
                // check for scheduled start of action
    
                var timeRunning = ( time - startTime ) * timeDirection;
                if ( timeRunning < 0 || timeDirection === 0 ) {
    
                    return; // yet to come / don't decide when delta = 0
    
                }
    
                // start
    
                this._startTime = null; // unschedule
                deltaTime = timeDirection * timeRunning;
    
            }
    
            // apply time scale and advance time
    
            deltaTime *= this._updateTimeScale( time );
            var clipTime = this._updateTime( deltaTime );
    
            // note: _updateTime may disable the action resulting in
            // an effective weight of 0
    
            var weight = this._updateWeight( time );
    
            if ( weight > 0 ) {
    
                var interpolants = this._interpolants;
                var propertyMixers = this._propertyBindings;
    
                for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {
    
                    interpolants[ j ].evaluate( clipTime );
                    propertyMixers[ j ].accumulate( accuIndex, weight );
    
                }
    
            }
    
        },
    
        _updateWeight: function ( time ) {
    
            var weight = 0;
    
            if ( this.enabled ) {
    
                weight = this.weight;
                var interpolant = this._weightInterpolant;
    
                if ( interpolant !== null ) {
    
                    var interpolantValue = interpolant.evaluate( time )[ 0 ];
    
                    weight *= interpolantValue;
    
                    if ( time > interpolant.parameterPositions[ 1 ] ) {
    
                        this.stopFading();
    
                        if ( interpolantValue === 0 ) {
    
                            // faded out, disable
                            this.enabled = false;
    
                        }
    
                    }
    
                }
    
            }
    
            this._effectiveWeight = weight;
            return weight;
    
        },
    
        _updateTimeScale: function ( time ) {
    
            var timeScale = 0;
    
            if ( ! this.paused ) {
    
                timeScale = this.timeScale;
    
                var interpolant = this._timeScaleInterpolant;
    
                if ( interpolant !== null ) {
    
                    var interpolantValue = interpolant.evaluate( time )[ 0 ];
    
                    timeScale *= interpolantValue;
    
                    if ( time > interpolant.parameterPositions[ 1 ] ) {
    
                        this.stopWarping();
    
                        if ( timeScale === 0 ) {
    
                            // motion has halted, pause
                            this.paused = true;
    
                        } else {
    
                            // warp done - apply final time scale
                            this.timeScale = timeScale;
    
                        }
    
                    }
    
                }
    
            }
    
            this._effectiveTimeScale = timeScale;
            return timeScale;
    
        },
    
        _updateTime: function ( deltaTime ) {
    
            var time = this.time + deltaTime;
            var duration = this._clip.duration;
            var loop = this.loop;
            var loopCount = this._loopCount;
    
            var pingPong = ( loop === LoopPingPong );
    
            if ( deltaTime === 0 ) {
    
                if ( loopCount === - 1 ) return time;
    
                return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;
    
            }
    
            if ( loop === LoopOnce ) {
    
                if ( loopCount === - 1 ) {
    
                    // just started
    
                    this._loopCount = 0;
                    this._setEndings( true, true, false );
    
                }
    
                handle_stop: {
    
                    if ( time >= duration ) {
    
                        time = duration;
    
                    } else if ( time < 0 ) {
    
                        time = 0;
    
                    } else {
    
                        this.time = time;
    
                        break handle_stop;
    
                    }
    
                    if ( this.clampWhenFinished ) this.paused = true;
                    else this.enabled = false;
    
                    this.time = time;
    
                    this._mixer.dispatchEvent( {
                        type: 'finished', action: this,
                        direction: deltaTime < 0 ? - 1 : 1
                    } );
    
                }
    
            } else { // repetitive Repeat or PingPong
    
                if ( loopCount === - 1 ) {
    
                    // just started
    
                    if ( deltaTime >= 0 ) {
    
                        loopCount = 0;
    
                        this._setEndings( true, this.repetitions === 0, pingPong );
    
                    } else {
    
                        // when looping in reverse direction, the initial
                        // transition through zero counts as a repetition,
                        // so leave loopCount at -1
    
                        this._setEndings( this.repetitions === 0, true, pingPong );
    
                    }
    
                }
    
                if ( time >= duration || time < 0 ) {
    
                    // wrap around
    
                    var loopDelta = Math.floor( time / duration ); // signed
                    time -= duration * loopDelta;
    
                    loopCount += Math.abs( loopDelta );
    
                    var pending = this.repetitions - loopCount;
    
                    if ( pending <= 0 ) {
    
                        // have to stop (switch state, clamp time, fire event)
    
                        if ( this.clampWhenFinished ) this.paused = true;
                        else this.enabled = false;
    
                        time = deltaTime > 0 ? duration : 0;
    
                        this.time = time;
    
                        this._mixer.dispatchEvent( {
                            type: 'finished', action: this,
                            direction: deltaTime > 0 ? 1 : - 1
                        } );
    
                    } else {
    
                        // keep running
    
                        if ( pending === 1 ) {
    
                            // entering the last round
    
                            var atStart = deltaTime < 0;
                            this._setEndings( atStart, ! atStart, pingPong );
    
                        } else {
    
                            this._setEndings( false, false, pingPong );
    
                        }
    
                        this._loopCount = loopCount;
    
                        this.time = time;
    
                        this._mixer.dispatchEvent( {
                            type: 'loop', action: this, loopDelta: loopDelta
                        } );
    
                    }
    
                } else {
    
                    this.time = time;
    
                }
    
                if ( pingPong && ( loopCount & 1 ) === 1 ) {
    
                    // invert time for the "pong round"
    
                    return duration - time;
    
                }
    
            }
    
            return time;
    
        },
    
        _setEndings: function ( atStart, atEnd, pingPong ) {
    
            var settings = this._interpolantSettings;
    
            if ( pingPong ) {
    
                settings.endingStart = ZeroSlopeEnding;
                settings.endingEnd = ZeroSlopeEnding;
    
            } else {
    
                // assuming for LoopOnce atStart == atEnd == true
    
                if ( atStart ) {
    
                    settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
    
                } else {
    
                    settings.endingStart = WrapAroundEnding;
    
                }
    
                if ( atEnd ) {
    
                    settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
    
                } else {
    
                    settings.endingEnd 	 = WrapAroundEnding;
    
                }
    
            }
    
        },
    
        _scheduleFading: function ( duration, weightNow, weightThen ) {
    
            var mixer = this._mixer, now = mixer.time,
                interpolant = this._weightInterpolant;
    
            if ( interpolant === null ) {
    
                interpolant = mixer._lendControlInterpolant();
                this._weightInterpolant = interpolant;
    
            }
    
            var times = interpolant.parameterPositions,
                values = interpolant.sampleValues;
    
            times[ 0 ] = now;
            values[ 0 ] = weightNow;
            times[ 1 ] = now + duration;
            values[ 1 ] = weightThen;
    
            return this;
    
        }
    
    } );
    
    /**
     *
     * Player for AnimationClips.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */
    
    function AnimationMixer( root ) {
    
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
    
        this.time = 0;
    
        this.timeScale = 1.0;
    
    }
    
    AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
    
        constructor: AnimationMixer,
    
        _bindAction: function ( action, prototypeAction ) {
    
            var root = action._localRoot || this._root,
                tracks = action._clip.tracks,
                nTracks = tracks.length,
                bindings = action._propertyBindings,
                interpolants = action._interpolants,
                rootUuid = root.uuid,
                bindingsByRoot = this._bindingsByRootAndName,
                bindingsByName = bindingsByRoot[ rootUuid ];
    
            if ( bindingsByName === undefined ) {
    
                bindingsByName = {};
                bindingsByRoot[ rootUuid ] = bindingsByName;
    
            }
    
            for ( var i = 0; i !== nTracks; ++ i ) {
    
                var track = tracks[ i ],
                    trackName = track.name,
                    binding = bindingsByName[ trackName ];
    
                if ( binding !== undefined ) {
    
                    bindings[ i ] = binding;
    
                } else {
    
                    binding = bindings[ i ];
    
                    if ( binding !== undefined ) {
    
                        // existing binding, make sure the cache knows
    
                        if ( binding._cacheIndex === null ) {
    
                            ++ binding.referenceCount;
                            this._addInactiveBinding( binding, rootUuid, trackName );
    
                        }
    
                        continue;
    
                    }
    
                    var path = prototypeAction && prototypeAction.
                        _propertyBindings[ i ].binding.parsedPath;
    
                    binding = new PropertyMixer(
                        PropertyBinding.create( root, trackName, path ),
                        track.ValueTypeName, track.getValueSize() );
    
                    ++ binding.referenceCount;
                    this._addInactiveBinding( binding, rootUuid, trackName );
    
                    bindings[ i ] = binding;
    
                }
    
                interpolants[ i ].resultBuffer = binding.buffer;
    
            }
    
        },
    
        _activateAction: function ( action ) {
    
            if ( ! this._isActiveAction( action ) ) {
    
                if ( action._cacheIndex === null ) {
    
                    // this action has been forgotten by the cache, but the user
                    // appears to be still using it -> rebind
    
                    var rootUuid = ( action._localRoot || this._root ).uuid,
                        clipUuid = action._clip.uuid,
                        actionsForClip = this._actionsByClip[ clipUuid ];
    
                    this._bindAction( action,
                        actionsForClip && actionsForClip.knownActions[ 0 ] );
    
                    this._addInactiveAction( action, clipUuid, rootUuid );
    
                }
    
                var bindings = action._propertyBindings;
    
                // increment reference counts / sort out state
                for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
    
                    var binding = bindings[ i ];
    
                    if ( binding.useCount ++ === 0 ) {
    
                        this._lendBinding( binding );
                        binding.saveOriginalState();
    
                    }
    
                }
    
                this._lendAction( action );
    
            }
    
        },
    
        _deactivateAction: function ( action ) {
    
            if ( this._isActiveAction( action ) ) {
    
                var bindings = action._propertyBindings;
    
                // decrement reference counts / sort out state
                for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
    
                    var binding = bindings[ i ];
    
                    if ( -- binding.useCount === 0 ) {
    
                        binding.restoreOriginalState();
                        this._takeBackBinding( binding );
    
                    }
    
                }
    
                this._takeBackAction( action );
    
            }
    
        },
    
        // Memory manager
    
        _initMemoryManager: function () {
    
            this._actions = []; // 'nActiveActions' followed by inactive ones
            this._nActiveActions = 0;
    
            this._actionsByClip = {};
            // inside:
            // {
            // 	knownActions: Array< AnimationAction > - used as prototypes
            // 	actionByRoot: AnimationAction - lookup
            // }
    
    
            this._bindings = []; // 'nActiveBindings' followed by inactive ones
            this._nActiveBindings = 0;
    
            this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
    
    
            this._controlInterpolants = []; // same game as above
            this._nActiveControlInterpolants = 0;
    
            var scope = this;
    
            this.stats = {
    
                actions: {
                    get total() {
    
                        return scope._actions.length;
    
                    },
                    get inUse() {
    
                        return scope._nActiveActions;
    
                    }
                },
                bindings: {
                    get total() {
    
                        return scope._bindings.length;
    
                    },
                    get inUse() {
    
                        return scope._nActiveBindings;
    
                    }
                },
                controlInterpolants: {
                    get total() {
    
                        return scope._controlInterpolants.length;
    
                    },
                    get inUse() {
    
                        return scope._nActiveControlInterpolants;
    
                    }
                }
    
            };
    
        },
    
        // Memory management for AnimationAction objects
    
        _isActiveAction: function ( action ) {
    
            var index = action._cacheIndex;
            return index !== null && index < this._nActiveActions;
    
        },
    
        _addInactiveAction: function ( action, clipUuid, rootUuid ) {
    
            var actions = this._actions,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[ clipUuid ];
    
            if ( actionsForClip === undefined ) {
    
                actionsForClip = {
    
                    knownActions: [ action ],
                    actionByRoot: {}
    
                };
    
                action._byClipCacheIndex = 0;
    
                actionsByClip[ clipUuid ] = actionsForClip;
    
            } else {
    
                var knownActions = actionsForClip.knownActions;
    
                action._byClipCacheIndex = knownActions.length;
                knownActions.push( action );
    
            }
    
            action._cacheIndex = actions.length;
            actions.push( action );
    
            actionsForClip.actionByRoot[ rootUuid ] = action;
    
        },
    
        _removeInactiveAction: function ( action ) {
    
            var actions = this._actions,
                lastInactiveAction = actions[ actions.length - 1 ],
                cacheIndex = action._cacheIndex;
    
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[ cacheIndex ] = lastInactiveAction;
            actions.pop();
    
            action._cacheIndex = null;
    
    
            var clipUuid = action._clip.uuid,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[ clipUuid ],
                knownActionsForClip = actionsForClip.knownActions,
    
                lastKnownAction =
                    knownActionsForClip[ knownActionsForClip.length - 1 ],
    
                byClipCacheIndex = action._byClipCacheIndex;
    
            lastKnownAction._byClipCacheIndex = byClipCacheIndex;
            knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
            knownActionsForClip.pop();
    
            action._byClipCacheIndex = null;
    
    
            var actionByRoot = actionsForClip.actionByRoot,
                rootUuid = ( action._localRoot || this._root ).uuid;
    
            delete actionByRoot[ rootUuid ];
    
            if ( knownActionsForClip.length === 0 ) {
    
                delete actionsByClip[ clipUuid ];
    
            }
    
            this._removeInactiveBindingsForAction( action );
    
        },
    
        _removeInactiveBindingsForAction: function ( action ) {
    
            var bindings = action._propertyBindings;
            for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
    
                var binding = bindings[ i ];
    
                if ( -- binding.referenceCount === 0 ) {
    
                    this._removeInactiveBinding( binding );
    
                }
    
            }
    
        },
    
        _lendAction: function ( action ) {
    
            // [ active actions |  inactive actions  ]
            // [  active actions >| inactive actions ]
            //                 s        a
            //                  <-swap->
            //                 a        s
    
            var actions = this._actions,
                prevIndex = action._cacheIndex,
    
                lastActiveIndex = this._nActiveActions ++,
    
                firstInactiveAction = actions[ lastActiveIndex ];
    
            action._cacheIndex = lastActiveIndex;
            actions[ lastActiveIndex ] = action;
    
            firstInactiveAction._cacheIndex = prevIndex;
            actions[ prevIndex ] = firstInactiveAction;
    
        },
    
        _takeBackAction: function ( action ) {
    
            // [  active actions  | inactive actions ]
            // [ active actions |< inactive actions  ]
            //        a        s
            //         <-swap->
            //        s        a
    
            var actions = this._actions,
                prevIndex = action._cacheIndex,
    
                firstInactiveIndex = -- this._nActiveActions,
    
                lastActiveAction = actions[ firstInactiveIndex ];
    
            action._cacheIndex = firstInactiveIndex;
            actions[ firstInactiveIndex ] = action;
    
            lastActiveAction._cacheIndex = prevIndex;
            actions[ prevIndex ] = lastActiveAction;
    
        },
    
        // Memory management for PropertyMixer objects
    
        _addInactiveBinding: function ( binding, rootUuid, trackName ) {
    
            var bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[ rootUuid ],
    
                bindings = this._bindings;
    
            if ( bindingByName === undefined ) {
    
                bindingByName = {};
                bindingsByRoot[ rootUuid ] = bindingByName;
    
            }
    
            bindingByName[ trackName ] = binding;
    
            binding._cacheIndex = bindings.length;
            bindings.push( binding );
    
        },
    
        _removeInactiveBinding: function ( binding ) {
    
            var bindings = this._bindings,
                propBinding = binding.binding,
                rootUuid = propBinding.rootNode.uuid,
                trackName = propBinding.path,
                bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[ rootUuid ],
    
                lastInactiveBinding = bindings[ bindings.length - 1 ],
                cacheIndex = binding._cacheIndex;
    
            lastInactiveBinding._cacheIndex = cacheIndex;
            bindings[ cacheIndex ] = lastInactiveBinding;
            bindings.pop();
    
            delete bindingByName[ trackName ];
    
            if ( Object.keys( bindingByName ).length === 0 ) {
    
                delete bindingsByRoot[ rootUuid ];
    
            }
    
        },
    
        _lendBinding: function ( binding ) {
    
            var bindings = this._bindings,
                prevIndex = binding._cacheIndex,
    
                lastActiveIndex = this._nActiveBindings ++,
    
                firstInactiveBinding = bindings[ lastActiveIndex ];
    
            binding._cacheIndex = lastActiveIndex;
            bindings[ lastActiveIndex ] = binding;
    
            firstInactiveBinding._cacheIndex = prevIndex;
            bindings[ prevIndex ] = firstInactiveBinding;
    
        },
    
        _takeBackBinding: function ( binding ) {
    
            var bindings = this._bindings,
                prevIndex = binding._cacheIndex,
    
                firstInactiveIndex = -- this._nActiveBindings,
    
                lastActiveBinding = bindings[ firstInactiveIndex ];
    
            binding._cacheIndex = firstInactiveIndex;
            bindings[ firstInactiveIndex ] = binding;
    
            lastActiveBinding._cacheIndex = prevIndex;
            bindings[ prevIndex ] = lastActiveBinding;
    
        },
    
    
        // Memory management of Interpolants for weight and time scale
    
        _lendControlInterpolant: function () {
    
            var interpolants = this._controlInterpolants,
                lastActiveIndex = this._nActiveControlInterpolants ++,
                interpolant = interpolants[ lastActiveIndex ];
    
            if ( interpolant === undefined ) {
    
                interpolant = new LinearInterpolant(
                    new Float32Array( 2 ), new Float32Array( 2 ),
                    1, this._controlInterpolantsResultBuffer );
    
                interpolant.__cacheIndex = lastActiveIndex;
                interpolants[ lastActiveIndex ] = interpolant;
    
            }
    
            return interpolant;
    
        },
    
        _takeBackControlInterpolant: function ( interpolant ) {
    
            var interpolants = this._controlInterpolants,
                prevIndex = interpolant.__cacheIndex,
    
                firstInactiveIndex = -- this._nActiveControlInterpolants,
    
                lastActiveInterpolant = interpolants[ firstInactiveIndex ];
    
            interpolant.__cacheIndex = firstInactiveIndex;
            interpolants[ firstInactiveIndex ] = interpolant;
    
            lastActiveInterpolant.__cacheIndex = prevIndex;
            interpolants[ prevIndex ] = lastActiveInterpolant;
    
        },
    
        _controlInterpolantsResultBuffer: new Float32Array( 1 ),
    
        // return an action for a clip optionally using a custom root target
        // object (this method allocates a lot of dynamic memory in case a
        // previously unknown clip/root combination is specified)
        clipAction: function ( clip, optionalRoot ) {
    
            var root = optionalRoot || this._root,
                rootUuid = root.uuid,
    
                clipObject = typeof clip === 'string' ?
                    AnimationClip.findByName( root, clip ) : clip,
    
                clipUuid = clipObject !== null ? clipObject.uuid : clip,
    
                actionsForClip = this._actionsByClip[ clipUuid ],
                prototypeAction = null;
    
            if ( actionsForClip !== undefined ) {
    
                var existingAction =
                        actionsForClip.actionByRoot[ rootUuid ];
    
                if ( existingAction !== undefined ) {
    
                    return existingAction;
    
                }
    
                // we know the clip, so we don't have to parse all
                // the bindings again but can just copy
                prototypeAction = actionsForClip.knownActions[ 0 ];
    
                // also, take the clip from the prototype action
                if ( clipObject === null )
                    clipObject = prototypeAction._clip;
    
            }
    
            // clip must be known when specified via string
            if ( clipObject === null ) return null;
    
            // allocate all resources required to run it
            var newAction = new AnimationAction( this, clipObject, optionalRoot );
    
            this._bindAction( newAction, prototypeAction );
    
            // and make the action known to the memory manager
            this._addInactiveAction( newAction, clipUuid, rootUuid );
    
            return newAction;
    
        },
    
        // get an existing action
        existingAction: function ( clip, optionalRoot ) {
    
            var root = optionalRoot || this._root,
                rootUuid = root.uuid,
    
                clipObject = typeof clip === 'string' ?
                    AnimationClip.findByName( root, clip ) : clip,
    
                clipUuid = clipObject ? clipObject.uuid : clip,
    
                actionsForClip = this._actionsByClip[ clipUuid ];
    
            if ( actionsForClip !== undefined ) {
    
                return actionsForClip.actionByRoot[ rootUuid ] || null;
    
            }
    
            return null;
    
        },
    
        // deactivates all previously scheduled actions
        stopAllAction: function () {
    
            var actions = this._actions,
                nActions = this._nActiveActions,
                bindings = this._bindings,
                nBindings = this._nActiveBindings;
    
            this._nActiveActions = 0;
            this._nActiveBindings = 0;
    
            for ( var i = 0; i !== nActions; ++ i ) {
    
                actions[ i ].reset();
    
            }
    
            for ( var i = 0; i !== nBindings; ++ i ) {
    
                bindings[ i ].useCount = 0;
    
            }
    
            return this;
    
        },
    
        // advance the time and update apply the animation
        update: function ( deltaTime ) {
    
            deltaTime *= this.timeScale;
    
            var actions = this._actions,
                nActions = this._nActiveActions,
    
                time = this.time += deltaTime,
                timeDirection = Math.sign( deltaTime ),
    
                accuIndex = this._accuIndex ^= 1;
    
            // run active actions
    
            for ( var i = 0; i !== nActions; ++ i ) {
    
                var action = actions[ i ];
    
                action._update( time, deltaTime, timeDirection, accuIndex );
    
            }
    
            // update scene graph
    
            var bindings = this._bindings,
                nBindings = this._nActiveBindings;
    
            for ( var i = 0; i !== nBindings; ++ i ) {
    
                bindings[ i ].apply( accuIndex );
    
            }
    
            return this;
    
        },
    
        // Allows you to seek to a specific time in an animation.
        setTime: function ( timeInSeconds ) {
    
            this.time = 0; // Zero out time attribute for AnimationMixer object;
            for ( var i = 0; i < this._actions.length; i ++ ) {
    
                this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.
    
            }
    
            return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.
    
        },
    
        // return this mixer's root target object
        getRoot: function () {
    
            return this._root;
    
        },
    
        // free all resources specific to a particular clip
        uncacheClip: function ( clip ) {
    
            var actions = this._actions,
                clipUuid = clip.uuid,
                actionsByClip = this._actionsByClip,
                actionsForClip = actionsByClip[ clipUuid ];
    
            if ( actionsForClip !== undefined ) {
    
                // note: just calling _removeInactiveAction would mess up the
                // iteration state and also require updating the state we can
                // just throw away
    
                var actionsToRemove = actionsForClip.knownActions;
    
                for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {
    
                    var action = actionsToRemove[ i ];
    
                    this._deactivateAction( action );
    
                    var cacheIndex = action._cacheIndex,
                        lastInactiveAction = actions[ actions.length - 1 ];
    
                    action._cacheIndex = null;
                    action._byClipCacheIndex = null;
    
                    lastInactiveAction._cacheIndex = cacheIndex;
                    actions[ cacheIndex ] = lastInactiveAction;
                    actions.pop();
    
                    this._removeInactiveBindingsForAction( action );
    
                }
    
                delete actionsByClip[ clipUuid ];
    
            }
    
        },
    
        // free all resources specific to a particular root target object
        uncacheRoot: function ( root ) {
    
            var rootUuid = root.uuid,
                actionsByClip = this._actionsByClip;
    
            for ( var clipUuid in actionsByClip ) {
    
                var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
                    action = actionByRoot[ rootUuid ];
    
                if ( action !== undefined ) {
    
                    this._deactivateAction( action );
                    this._removeInactiveAction( action );
    
                }
    
            }
    
            var bindingsByRoot = this._bindingsByRootAndName,
                bindingByName = bindingsByRoot[ rootUuid ];
    
            if ( bindingByName !== undefined ) {
    
                for ( var trackName in bindingByName ) {
    
                    var binding = bindingByName[ trackName ];
                    binding.restoreOriginalState();
                    this._removeInactiveBinding( binding );
    
                }
    
            }
    
        },
    
        // remove a targeted clip from the cache
        uncacheAction: function ( clip, optionalRoot ) {
    
            var action = this.existingAction( clip, optionalRoot );
    
            if ( action !== null ) {
    
                this._deactivateAction( action );
                this._removeInactiveAction( action );
    
            }
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function Uniform( value ) {
    
        if ( typeof value === 'string' ) {
    
            console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
            value = arguments[ 1 ];
    
        }
    
        this.value = value;
    
    }
    
    Uniform.prototype.clone = function () {
    
        return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );
    
    };
    
    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */
    
    function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {
    
        InterleavedBuffer.call( this, array, stride );
    
        this.meshPerAttribute = meshPerAttribute || 1;
    
    }
    
    InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {
    
        constructor: InstancedInterleavedBuffer,
    
        isInstancedInterleavedBuffer: true,
    
        copy: function ( source ) {
    
            InterleavedBuffer.prototype.copy.call( this, source );
    
            this.meshPerAttribute = source.meshPerAttribute;
    
            return this;
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author bhouston / http://clara.io/
     * @author stephomi / http://stephaneginier.com/
     */
    
    function Raycaster( origin, direction, near, far ) {
    
        this.ray = new Ray( origin, direction );
        // direction is assumed to be normalized (for accurate distance calculations)
    
        this.near = near || 0;
        this.far = far || Infinity;
        this.camera = null;
        this.layers = new Layers();
    
        this.params = {
            Mesh: {},
            Line: { threshold: 1 },
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {}
        };
    
        Object.defineProperties( this.params, {
            PointCloud: {
                get: function () {
    
                    console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
                    return this.Points;
    
                }
            }
        } );
    
    }
    
    function ascSort( a, b ) {
    
        return a.distance - b.distance;
    
    }
    
    function intersectObject( object, raycaster, intersects, recursive ) {
    
        if ( object.layers.test( raycaster.layers ) ) {
    
            object.raycast( raycaster, intersects );
    
        }
    
        if ( recursive === true ) {
    
            var children = object.children;
    
            for ( var i = 0, l = children.length; i < l; i ++ ) {
    
                intersectObject( children[ i ], raycaster, intersects, true );
    
            }
    
        }
    
    }
    
    Object.assign( Raycaster.prototype, {
    
        set: function ( origin, direction ) {
    
            // direction is assumed to be normalized (for accurate distance calculations)
    
            this.ray.set( origin, direction );
    
        },
    
        setFromCamera: function ( coords, camera ) {
    
            if ( ( camera && camera.isPerspectiveCamera ) ) {
    
                this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
                this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
                this.camera = camera;
    
            } else if ( ( camera && camera.isOrthographicCamera ) ) {
    
                this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
                this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
                this.camera = camera;
    
            } else {
    
                console.error( 'THREE.Raycaster: Unsupported camera type.' );
    
            }
    
        },
    
        intersectObject: function ( object, recursive, optionalTarget ) {
    
            var intersects = optionalTarget || [];
    
            intersectObject( object, this, intersects, recursive );
    
            intersects.sort( ascSort );
    
            return intersects;
    
        },
    
        intersectObjects: function ( objects, recursive, optionalTarget ) {
    
            var intersects = optionalTarget || [];
    
            if ( Array.isArray( objects ) === false ) {
    
                console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
                return intersects;
    
            }
    
            for ( var i = 0, l = objects.length; i < l; i ++ ) {
    
                intersectObject( objects[ i ], this, intersects, recursive );
    
            }
    
            intersects.sort( ascSort );
    
            return intersects;
    
        }
    
    } );
    
    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
     *
     * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
     * The azimuthal angle (theta) is measured from the positive z-axis.
     */
    
    function Spherical( radius, phi, theta ) {
    
        this.radius = ( radius !== undefined ) ? radius : 1.0;
        this.phi = ( phi !== undefined ) ? phi : 0; // polar angle
        this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle
    
        return this;
    
    }
    
    Object.assign( Spherical.prototype, {
    
        set: function ( radius, phi, theta ) {
    
            this.radius = radius;
            this.phi = phi;
            this.theta = theta;
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( other ) {
    
            this.radius = other.radius;
            this.phi = other.phi;
            this.theta = other.theta;
    
            return this;
    
        },
    
        // restrict phi to be betwee EPS and PI-EPS
        makeSafe: function () {
    
            var EPS = 0.000001;
            this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );
    
            return this;
    
        },
    
        setFromVector3: function ( v ) {
    
            return this.setFromCartesianCoords( v.x, v.y, v.z );
    
        },
    
        setFromCartesianCoords: function ( x, y, z ) {
    
            this.radius = Math.sqrt( x * x + y * y + z * z );
    
            if ( this.radius === 0 ) {
    
                this.theta = 0;
                this.phi = 0;
    
            } else {
    
                this.theta = Math.atan2( x, z );
                this.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );
    
            }
    
            return this;
    
        }
    
    } );
    
    /**
     * @author Mugen87 / https://github.com/Mugen87
     *
     * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
     *
     */
    
    function Cylindrical( radius, theta, y ) {
    
        this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
        this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
        this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane
    
        return this;
    
    }
    
    Object.assign( Cylindrical.prototype, {
    
        set: function ( radius, theta, y ) {
    
            this.radius = radius;
            this.theta = theta;
            this.y = y;
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( other ) {
    
            this.radius = other.radius;
            this.theta = other.theta;
            this.y = other.y;
    
            return this;
    
        },
    
        setFromVector3: function ( v ) {
    
            return this.setFromCartesianCoords( v.x, v.y, v.z );
    
        },
    
        setFromCartesianCoords: function ( x, y, z ) {
    
            this.radius = Math.sqrt( x * x + z * z );
            this.theta = Math.atan2( x, z );
            this.y = y;
    
            return this;
    
        }
    
    } );
    
    /**
     * @author bhouston / http://clara.io
     */
    
    var _vector$7 = new Vector2();
    
    function Box2( min, max ) {
    
        this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
        this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );
    
    }
    
    Object.assign( Box2.prototype, {
    
        set: function ( min, max ) {
    
            this.min.copy( min );
            this.max.copy( max );
    
            return this;
    
        },
    
        setFromPoints: function ( points ) {
    
            this.makeEmpty();
    
            for ( var i = 0, il = points.length; i < il; i ++ ) {
    
                this.expandByPoint( points[ i ] );
    
            }
    
            return this;
    
        },
    
        setFromCenterAndSize: function ( center, size ) {
    
            var halfSize = _vector$7.copy( size ).multiplyScalar( 0.5 );
            this.min.copy( center ).sub( halfSize );
            this.max.copy( center ).add( halfSize );
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( box ) {
    
            this.min.copy( box.min );
            this.max.copy( box.max );
    
            return this;
    
        },
    
        makeEmpty: function () {
    
            this.min.x = this.min.y = + Infinity;
            this.max.x = this.max.y = - Infinity;
    
            return this;
    
        },
    
        isEmpty: function () {
    
            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
    
            return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
    
        },
    
        getCenter: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Box2: .getCenter() target is now required' );
                target = new Vector2();
    
            }
    
            return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
    
        },
    
        getSize: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Box2: .getSize() target is now required' );
                target = new Vector2();
    
            }
    
            return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );
    
        },
    
        expandByPoint: function ( point ) {
    
            this.min.min( point );
            this.max.max( point );
    
            return this;
    
        },
    
        expandByVector: function ( vector ) {
    
            this.min.sub( vector );
            this.max.add( vector );
    
            return this;
    
        },
    
        expandByScalar: function ( scalar ) {
    
            this.min.addScalar( - scalar );
            this.max.addScalar( scalar );
    
            return this;
    
        },
    
        containsPoint: function ( point ) {
    
            return point.x < this.min.x || point.x > this.max.x ||
                point.y < this.min.y || point.y > this.max.y ? false : true;
    
        },
    
        containsBox: function ( box ) {
    
            return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                this.min.y <= box.min.y && box.max.y <= this.max.y;
    
        },
    
        getParameter: function ( point, target ) {
    
            // This can potentially have a divide by zero if the box
            // has a size dimension of 0.
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Box2: .getParameter() target is now required' );
                target = new Vector2();
    
            }
    
            return target.set(
                ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
                ( point.y - this.min.y ) / ( this.max.y - this.min.y )
            );
    
        },
    
        intersectsBox: function ( box ) {
    
            // using 4 splitting planes to rule out intersections
    
            return box.max.x < this.min.x || box.min.x > this.max.x ||
                box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    
        },
    
        clampPoint: function ( point, target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Box2: .clampPoint() target is now required' );
                target = new Vector2();
    
            }
    
            return target.copy( point ).clamp( this.min, this.max );
    
        },
    
        distanceToPoint: function ( point ) {
    
            var clampedPoint = _vector$7.copy( point ).clamp( this.min, this.max );
            return clampedPoint.sub( point ).length();
    
        },
    
        intersect: function ( box ) {
    
            this.min.max( box.min );
            this.max.min( box.max );
    
            return this;
    
        },
    
        union: function ( box ) {
    
            this.min.min( box.min );
            this.max.max( box.max );
    
            return this;
    
        },
    
        translate: function ( offset ) {
    
            this.min.add( offset );
            this.max.add( offset );
    
            return this;
    
        },
    
        equals: function ( box ) {
    
            return box.min.equals( this.min ) && box.max.equals( this.max );
    
        }
    
    } );
    
    /**
     * @author bhouston / http://clara.io
     */
    
    var _startP = new Vector3();
    var _startEnd = new Vector3();
    
    function Line3( start, end ) {
    
        this.start = ( start !== undefined ) ? start : new Vector3();
        this.end = ( end !== undefined ) ? end : new Vector3();
    
    }
    
    Object.assign( Line3.prototype, {
    
        set: function ( start, end ) {
    
            this.start.copy( start );
            this.end.copy( end );
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        },
    
        copy: function ( line ) {
    
            this.start.copy( line.start );
            this.end.copy( line.end );
    
            return this;
    
        },
    
        getCenter: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Line3: .getCenter() target is now required' );
                target = new Vector3();
    
            }
    
            return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
    
        },
    
        delta: function ( target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Line3: .delta() target is now required' );
                target = new Vector3();
    
            }
    
            return target.subVectors( this.end, this.start );
    
        },
    
        distanceSq: function () {
    
            return this.start.distanceToSquared( this.end );
    
        },
    
        distance: function () {
    
            return this.start.distanceTo( this.end );
    
        },
    
        at: function ( t, target ) {
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Line3: .at() target is now required' );
                target = new Vector3();
    
            }
    
            return this.delta( target ).multiplyScalar( t ).add( this.start );
    
        },
    
        closestPointToPointParameter: function ( point, clampToLine ) {
    
            _startP.subVectors( point, this.start );
            _startEnd.subVectors( this.end, this.start );
    
            var startEnd2 = _startEnd.dot( _startEnd );
            var startEnd_startP = _startEnd.dot( _startP );
    
            var t = startEnd_startP / startEnd2;
    
            if ( clampToLine ) {
    
                t = MathUtils.clamp( t, 0, 1 );
    
            }
    
            return t;
    
        },
    
        closestPointToPoint: function ( point, clampToLine, target ) {
    
            var t = this.closestPointToPointParameter( point, clampToLine );
    
            if ( target === undefined ) {
    
                console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
                target = new Vector3();
    
            }
    
            return this.delta( target ).multiplyScalar( t ).add( this.start );
    
        },
    
        applyMatrix4: function ( matrix ) {
    
            this.start.applyMatrix4( matrix );
            this.end.applyMatrix4( matrix );
    
            return this;
    
        },
    
        equals: function ( line ) {
    
            return line.start.equals( this.start ) && line.end.equals( this.end );
    
        }
    
    } );
    
    /**
     * @author alteredq / http://alteredqualia.com/
     */
    
    function ImmediateRenderObject( material ) {
    
        Object3D.call( this );
    
        this.material = material;
        this.render = function ( /* renderCallback */ ) {};
    
    }
    
    ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
    
    ImmediateRenderObject.prototype.isImmediateRenderObject = true;
    
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     */
    
    var _vector$8 = new Vector3();
    
    function SpotLightHelper( light, color ) {
    
        Object3D.call( this );
    
        this.light = light;
        this.light.updateMatrixWorld();
    
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
    
        this.color = color;
    
        var geometry = new BufferGeometry();
    
        var positions = [
            0, 0, 0, 	0, 0, 1,
            0, 0, 0, 	1, 0, 1,
            0, 0, 0,	- 1, 0, 1,
            0, 0, 0, 	0, 1, 1,
            0, 0, 0, 	0, - 1, 1
        ];
    
        for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {
    
            var p1 = ( i / l ) * Math.PI * 2;
            var p2 = ( j / l ) * Math.PI * 2;
    
            positions.push(
                Math.cos( p1 ), Math.sin( p1 ), 1,
                Math.cos( p2 ), Math.sin( p2 ), 1
            );
    
        }
    
        geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
    
        var material = new LineBasicMaterial( { fog: false } );
    
        this.cone = new LineSegments( geometry, material );
        this.add( this.cone );
    
        this.update();
    
    }
    
    SpotLightHelper.prototype = Object.create( Object3D.prototype );
    SpotLightHelper.prototype.constructor = SpotLightHelper;
    
    SpotLightHelper.prototype.dispose = function () {
    
        this.cone.geometry.dispose();
        this.cone.material.dispose();
    
    };
    
    SpotLightHelper.prototype.update = function () {
    
        this.light.updateMatrixWorld();
    
        var coneLength = this.light.distance ? this.light.distance : 1000;
        var coneWidth = coneLength * Math.tan( this.light.angle );
    
        this.cone.scale.set( coneWidth, coneWidth, coneLength );
    
        _vector$8.setFromMatrixPosition( this.light.target.matrixWorld );
    
        this.cone.lookAt( _vector$8 );
    
        if ( this.color !== undefined ) {
    
            this.cone.material.color.set( this.color );
    
        } else {
    
            this.cone.material.color.copy( this.light.color );
    
        }
    
    };
    
    /**
     * @author Sean Griffin / http://twitter.com/sgrif
     * @author Michael Guerrero / http://realitymeltdown.com
     * @author mrdoob / http://mrdoob.com/
     * @author ikerr / http://verold.com
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    var _vector$9 = new Vector3();
    var _boneMatrix = new Matrix4();
    var _matrixWorldInv = new Matrix4();
    
    function getBoneList( object ) {
    
        var boneList = [];
    
        if ( object && object.isBone ) {
    
            boneList.push( object );
    
        }
    
        for ( var i = 0; i < object.children.length; i ++ ) {
    
            boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );
    
        }
    
        return boneList;
    
    }
    
    function SkeletonHelper( object ) {
    
        var bones = getBoneList( object );
    
        var geometry = new BufferGeometry();
    
        var vertices = [];
        var colors = [];
    
        var color1 = new Color( 0, 0, 1 );
        var color2 = new Color( 0, 1, 0 );
    
        for ( var i = 0; i < bones.length; i ++ ) {
    
            var bone = bones[ i ];
    
            if ( bone.parent && bone.parent.isBone ) {
    
                vertices.push( 0, 0, 0 );
                vertices.push( 0, 0, 0 );
                colors.push( color1.r, color1.g, color1.b );
                colors.push( color2.r, color2.g, color2.b );
    
            }
    
        }
    
        geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
    
        var material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, transparent: true } );
    
        LineSegments.call( this, geometry, material );
    
        this.root = object;
        this.bones = bones;
    
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
    
    }
    
    SkeletonHelper.prototype = Object.create( LineSegments.prototype );
    SkeletonHelper.prototype.constructor = SkeletonHelper;
    
    SkeletonHelper.prototype.isSkeletonHelper = true;
    
    SkeletonHelper.prototype.updateMatrixWorld = function ( force ) {
    
        var bones = this.bones;
    
        var geometry = this.geometry;
        var position = geometry.getAttribute( 'position' );
    
        _matrixWorldInv.getInverse( this.root.matrixWorld );
    
        for ( var i = 0, j = 0; i < bones.length; i ++ ) {
    
            var bone = bones[ i ];
    
            if ( bone.parent && bone.parent.isBone ) {
    
                _boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
                _vector$9.setFromMatrixPosition( _boneMatrix );
                position.setXYZ( j, _vector$9.x, _vector$9.y, _vector$9.z );
    
                _boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
                _vector$9.setFromMatrixPosition( _boneMatrix );
                position.setXYZ( j + 1, _vector$9.x, _vector$9.y, _vector$9.z );
    
                j += 2;
    
            }
    
        }
    
        geometry.getAttribute( 'position' ).needsUpdate = true;
    
        Object3D.prototype.updateMatrixWorld.call( this, force );
    
    };
    
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */
    
    function PointLightHelper( light, sphereSize, color ) {
    
        this.light = light;
        this.light.updateMatrixWorld();
    
        this.color = color;
    
        var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
        var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
    
        Mesh.call( this, geometry, material );
    
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
    
        this.update();
    
    
        /*
        var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
        var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
    
        this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
        this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
    
        var d = light.distance;
    
        if ( d === 0.0 ) {
    
            this.lightDistance.visible = false;
    
        } else {
    
            this.lightDistance.scale.set( d, d, d );
    
        }
    
        this.add( this.lightDistance );
        */
    
    }
    
    PointLightHelper.prototype = Object.create( Mesh.prototype );
    PointLightHelper.prototype.constructor = PointLightHelper;
    
    PointLightHelper.prototype.dispose = function () {
    
        this.geometry.dispose();
        this.material.dispose();
    
    };
    
    PointLightHelper.prototype.update = function () {
    
        if ( this.color !== undefined ) {
    
            this.material.color.set( this.color );
    
        } else {
    
            this.material.color.copy( this.light.color );
    
        }
    
        /*
        var d = this.light.distance;
    
        if ( d === 0.0 ) {
    
            this.lightDistance.visible = false;
    
        } else {
    
            this.lightDistance.visible = true;
            this.lightDistance.scale.set( d, d, d );
    
        }
        */
    
    };
    
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / https://github.com/Mugen87
     */
    
    var _vector$a = new Vector3();
    var _color1 = new Color();
    var _color2 = new Color();
    
    function HemisphereLightHelper( light, size, color ) {
    
        Object3D.call( this );
    
        this.light = light;
        this.light.updateMatrixWorld();
    
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
    
        this.color = color;
    
        var geometry = new OctahedronBufferGeometry( size );
        geometry.rotateY( Math.PI * 0.5 );
    
        this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
        if ( this.color === undefined ) this.material.vertexColors = true;
    
        var position = geometry.getAttribute( 'position' );
        var colors = new Float32Array( position.count * 3 );
    
        geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );
    
        this.add( new Mesh( geometry, this.material ) );
    
        this.update();
    
    }
    
    HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
    HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
    
    HemisphereLightHelper.prototype.dispose = function () {
    
        this.children[ 0 ].geometry.dispose();
        this.children[ 0 ].material.dispose();
    
    };
    
    HemisphereLightHelper.prototype.update = function () {
    
        var mesh = this.children[ 0 ];
    
        if ( this.color !== undefined ) {
    
            this.material.color.set( this.color );
    
        } else {
    
            var colors = mesh.geometry.getAttribute( 'color' );
    
            _color1.copy( this.light.color );
            _color2.copy( this.light.groundColor );
    
            for ( var i = 0, l = colors.count; i < l; i ++ ) {
    
                var color = ( i < ( l / 2 ) ) ? _color1 : _color2;
    
                colors.setXYZ( i, color.r, color.g, color.b );
    
            }
    
            colors.needsUpdate = true;
    
        }
    
        mesh.lookAt( _vector$a.setFromMatrixPosition( this.light.matrixWorld ).negate() );
    
    };
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function GridHelper( size, divisions, color1, color2 ) {
    
        size = size || 10;
        divisions = divisions || 10;
        color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
        color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
    
        var center = divisions / 2;
        var step = size / divisions;
        var halfSize = size / 2;
    
        var vertices = [], colors = [];
    
        for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {
    
            vertices.push( - halfSize, 0, k, halfSize, 0, k );
            vertices.push( k, 0, - halfSize, k, 0, halfSize );
    
            var color = i === center ? color1 : color2;
    
            color.toArray( colors, j ); j += 3;
            color.toArray( colors, j ); j += 3;
            color.toArray( colors, j ); j += 3;
            color.toArray( colors, j ); j += 3;
    
        }
    
        var geometry = new BufferGeometry();
        geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
    
        var material = new LineBasicMaterial( { vertexColors: true } );
    
        LineSegments.call( this, geometry, material );
    
    }
    
    GridHelper.prototype = Object.assign( Object.create( LineSegments.prototype ), {
    
        constructor: GridHelper,
    
        copy: function ( source ) {
    
            LineSegments.prototype.copy.call( this, source );
    
            this.geometry.copy( source.geometry );
            this.material.copy( source.material );
    
            return this;
    
        },
    
        clone: function () {
    
            return new this.constructor().copy( this );
    
        }
    
    } );
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / http://github.com/Mugen87
     * @author Hectate / http://www.github.com/Hectate
     */
    
    function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {
    
        radius = radius || 10;
        radials = radials || 16;
        circles = circles || 8;
        divisions = divisions || 64;
        color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
        color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
    
        var vertices = [];
        var colors = [];
    
        var x, z;
        var v, i, j, r, color;
    
        // create the radials
    
        for ( i = 0; i <= radials; i ++ ) {
    
            v = ( i / radials ) * ( Math.PI * 2 );
    
            x = Math.sin( v ) * radius;
            z = Math.cos( v ) * radius;
    
            vertices.push( 0, 0, 0 );
            vertices.push( x, 0, z );
    
            color = ( i & 1 ) ? color1 : color2;
    
            colors.push( color.r, color.g, color.b );
            colors.push( color.r, color.g, color.b );
    
        }
    
        // create the circles
    
        for ( i = 0; i <= circles; i ++ ) {
    
            color = ( i & 1 ) ? color1 : color2;
    
            r = radius - ( radius / circles * i );
    
            for ( j = 0; j < divisions; j ++ ) {
    
                // first vertex
    
                v = ( j / divisions ) * ( Math.PI * 2 );
    
                x = Math.sin( v ) * r;
                z = Math.cos( v ) * r;
    
                vertices.push( x, 0, z );
                colors.push( color.r, color.g, color.b );
    
                // second vertex
    
                v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );
    
                x = Math.sin( v ) * r;
                z = Math.cos( v ) * r;
    
                vertices.push( x, 0, z );
                colors.push( color.r, color.g, color.b );
    
            }
    
        }
    
        var geometry = new BufferGeometry();
        geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
    
        var material = new LineBasicMaterial( { vertexColors: true } );
    
        LineSegments.call( this, geometry, material );
    
    }
    
    PolarGridHelper.prototype = Object.create( LineSegments.prototype );
    PolarGridHelper.prototype.constructor = PolarGridHelper;
    
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     */
    
    var _v1$5 = new Vector3();
    var _v2$3 = new Vector3();
    var _v3$1 = new Vector3();
    
    function DirectionalLightHelper( light, size, color ) {
    
        Object3D.call( this );
    
        this.light = light;
        this.light.updateMatrixWorld();
    
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
    
        this.color = color;
    
        if ( size === undefined ) size = 1;
    
        var geometry = new BufferGeometry();
        geometry.setAttribute( 'position', new Float32BufferAttribute( [
            - size, size, 0,
            size, size, 0,
            size, - size, 0,
            - size, - size, 0,
            - size, size, 0
        ], 3 ) );
    
        var material = new LineBasicMaterial( { fog: false } );
    
        this.lightPlane = new Line( geometry, material );
        this.add( this.lightPlane );
    
        geometry = new BufferGeometry();
        geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );
    
        this.targetLine = new Line( geometry, material );
        this.add( this.targetLine );
    
        this.update();
    
    }
    
    DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
    DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
    
    DirectionalLightHelper.prototype.dispose = function () {
    
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
    
    };
    
    DirectionalLightHelper.prototype.update = function () {
    
        _v1$5.setFromMatrixPosition( this.light.matrixWorld );
        _v2$3.setFromMatrixPosition( this.light.target.matrixWorld );
        _v3$1.subVectors( _v2$3, _v1$5 );
    
        this.lightPlane.lookAt( _v2$3 );
    
        if ( this.color !== undefined ) {
    
            this.lightPlane.material.color.set( this.color );
            this.targetLine.material.color.set( this.color );
    
        } else {
    
            this.lightPlane.material.color.copy( this.light.color );
            this.targetLine.material.color.copy( this.light.color );
    
        }
    
        this.targetLine.lookAt( _v2$3 );
        this.targetLine.scale.z = _v3$1.length();
    
    };
    
    /**
     * @author alteredq / http://alteredqualia.com/
     * @author Mugen87 / https://github.com/Mugen87
     *
     *	- shows frustum, line of sight and up of the camera
     *	- suitable for fast updates
     * 	- based on frustum visualization in lightgl.js shadowmap example
     *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
     */
    
    var _vector$b = new Vector3();
    var _camera = new Camera();
    
    function CameraHelper( camera ) {
    
        var geometry = new BufferGeometry();
        var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true } );
    
        var vertices = [];
        var colors = [];
    
        var pointMap = {};
    
        // colors
    
        var colorFrustum = new Color( 0xffaa00 );
        var colorCone = new Color( 0xff0000 );
        var colorUp = new Color( 0x00aaff );
        var colorTarget = new Color( 0xffffff );
        var colorCross = new Color( 0x333333 );
    
        // near
    
        addLine( 'n1', 'n2', colorFrustum );
        addLine( 'n2', 'n4', colorFrustum );
        addLine( 'n4', 'n3', colorFrustum );
        addLine( 'n3', 'n1', colorFrustum );
    
        // far
    
        addLine( 'f1', 'f2', colorFrustum );
        addLine( 'f2', 'f4', colorFrustum );
        addLine( 'f4', 'f3', colorFrustum );
        addLine( 'f3', 'f1', colorFrustum );
    
        // sides
    
        addLine( 'n1', 'f1', colorFrustum );
        addLine( 'n2', 'f2', colorFrustum );
        addLine( 'n3', 'f3', colorFrustum );
        addLine( 'n4', 'f4', colorFrustum );
    
        // cone
    
        addLine( 'p', 'n1', colorCone );
        addLine( 'p', 'n2', colorCone );
        addLine( 'p', 'n3', colorCone );
        addLine( 'p', 'n4', colorCone );
    
        // up
    
        addLine( 'u1', 'u2', colorUp );
        addLine( 'u2', 'u3', colorUp );
        addLine( 'u3', 'u1', colorUp );
    
        // target
    
        addLine( 'c', 't', colorTarget );
        addLine( 'p', 'c', colorCross );
    
        // cross
    
        addLine( 'cn1', 'cn2', colorCross );
        addLine( 'cn3', 'cn4', colorCross );
    
        addLine( 'cf1', 'cf2', colorCross );
        addLine( 'cf3', 'cf4', colorCross );
    
        function addLine( a, b, color ) {
    
            addPoint( a, color );
            addPoint( b, color );
    
        }
    
        function addPoint( id, color ) {
    
            vertices.push( 0, 0, 0 );
            colors.push( color.r, color.g, color.b );
    
            if ( pointMap[ id ] === undefined ) {
    
                pointMap[ id ] = [];
    
            }
    
            pointMap[ id ].push( ( vertices.length / 3 ) - 1 );
    
        }
    
        geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
    
        LineSegments.call( this, geometry, material );
    
        this.camera = camera;
        if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();
    
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
    
        this.pointMap = pointMap;
    
        this.update();
    
    }
    
    CameraHelper.prototype = Object.create( LineSegments.prototype );
    CameraHelper.prototype.constructor = CameraHelper;
    
    CameraHelper.prototype.update = function () {
    
        var geometry = this.geometry;
        var pointMap = this.pointMap;
    
        var w = 1, h = 1;
    
        // we need just camera projection matrix inverse
        // world matrix must be identity
    
        _camera.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );
    
        // center / target
    
        setPoint( 'c', pointMap, geometry, _camera, 0, 0, - 1 );
        setPoint( 't', pointMap, geometry, _camera, 0, 0, 1 );
    
        // near
    
        setPoint( 'n1', pointMap, geometry, _camera, - w, - h, - 1 );
        setPoint( 'n2', pointMap, geometry, _camera, w, - h, - 1 );
        setPoint( 'n3', pointMap, geometry, _camera, - w, h, - 1 );
        setPoint( 'n4', pointMap, geometry, _camera, w, h, - 1 );
    
        // far
    
        setPoint( 'f1', pointMap, geometry, _camera, - w, - h, 1 );
        setPoint( 'f2', pointMap, geometry, _camera, w, - h, 1 );
        setPoint( 'f3', pointMap, geometry, _camera, - w, h, 1 );
        setPoint( 'f4', pointMap, geometry, _camera, w, h, 1 );
    
        // up
    
        setPoint( 'u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, - 1 );
        setPoint( 'u2', pointMap, geometry, _camera, - w * 0.7, h * 1.1, - 1 );
        setPoint( 'u3', pointMap, geometry, _camera, 0, h * 2, - 1 );
    
        // cross
    
        setPoint( 'cf1', pointMap, geometry, _camera, - w, 0, 1 );
        setPoint( 'cf2', pointMap, geometry, _camera, w, 0, 1 );
        setPoint( 'cf3', pointMap, geometry, _camera, 0, - h, 1 );
        setPoint( 'cf4', pointMap, geometry, _camera, 0, h, 1 );
    
        setPoint( 'cn1', pointMap, geometry, _camera, - w, 0, - 1 );
        setPoint( 'cn2', pointMap, geometry, _camera, w, 0, - 1 );
        setPoint( 'cn3', pointMap, geometry, _camera, 0, - h, - 1 );
        setPoint( 'cn4', pointMap, geometry, _camera, 0, h, - 1 );
    
        geometry.getAttribute( 'position' ).needsUpdate = true;
    
    };
    
    function setPoint( point, pointMap, geometry, camera, x, y, z ) {
    
        _vector$b.set( x, y, z ).unproject( camera );
    
        var points = pointMap[ point ];
    
        if ( points !== undefined ) {
    
            var position = geometry.getAttribute( 'position' );
    
            for ( var i = 0, l = points.length; i < l; i ++ ) {
    
                position.setXYZ( points[ i ], _vector$b.x, _vector$b.y, _vector$b.z );
    
            }
    
        }
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     * @author Mugen87 / http://github.com/Mugen87
     */
    
    var _box$3 = new Box3();
    
    function BoxHelper( object, color ) {
    
        this.object = object;
    
        if ( color === undefined ) color = 0xffff00;
    
        var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
        var positions = new Float32Array( 8 * 3 );
    
        var geometry = new BufferGeometry();
        geometry.setIndex( new BufferAttribute( indices, 1 ) );
        geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );
    
        LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
    
        this.matrixAutoUpdate = false;
    
        this.update();
    
    }
    
    BoxHelper.prototype = Object.create( LineSegments.prototype );
    BoxHelper.prototype.constructor = BoxHelper;
    
    BoxHelper.prototype.update = function ( object ) {
    
        if ( object !== undefined ) {
    
            console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );
    
        }
    
        if ( this.object !== undefined ) {
    
            _box$3.setFromObject( this.object );
    
        }
    
        if ( _box$3.isEmpty() ) return;
    
        var min = _box$3.min;
        var max = _box$3.max;
    
        /*
          5____4
        1/___0/|
        | 6__|_7
        2/___3/
    
        0: max.x, max.y, max.z
        1: min.x, max.y, max.z
        2: min.x, min.y, max.z
        3: max.x, min.y, max.z
        4: max.x, max.y, min.z
        5: min.x, max.y, min.z
        6: min.x, min.y, min.z
        7: max.x, min.y, min.z
        */
    
        var position = this.geometry.attributes.position;
        var array = position.array;
    
        array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
        array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
        array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
        array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
        array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
        array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
        array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
        array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
    
        position.needsUpdate = true;
    
        this.geometry.computeBoundingSphere();
    
    
    };
    
    BoxHelper.prototype.setFromObject = function ( object ) {
    
        this.object = object;
        this.update();
    
        return this;
    
    };
    
    BoxHelper.prototype.copy = function ( source ) {
    
        LineSegments.prototype.copy.call( this, source );
    
        this.object = source.object;
    
        return this;
    
    };
    
    BoxHelper.prototype.clone = function () {
    
        return new this.constructor().copy( this );
    
    };
    
    /**
     * @author WestLangley / http://github.com/WestLangley
     */
    
    function Box3Helper( box, color ) {
    
        this.type = 'Box3Helper';
    
        this.box = box;
    
        color = color || 0xffff00;
    
        var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
    
        var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];
    
        var geometry = new BufferGeometry();
    
        geometry.setIndex( new BufferAttribute( indices, 1 ) );
    
        geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
    
        LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
    
        this.geometry.computeBoundingSphere();
    
    }
    
    Box3Helper.prototype = Object.create( LineSegments.prototype );
    Box3Helper.prototype.constructor = Box3Helper;
    
    Box3Helper.prototype.updateMatrixWorld = function ( force ) {
    
        var box = this.box;
    
        if ( box.isEmpty() ) return;
    
        box.getCenter( this.position );
    
        box.getSize( this.scale );
    
        this.scale.multiplyScalar( 0.5 );
    
        Object3D.prototype.updateMatrixWorld.call( this, force );
    
    };
    
    /**
     * @author WestLangley / http://github.com/WestLangley
     */
    
    function PlaneHelper( plane, size, hex ) {
    
        this.type = 'PlaneHelper';
    
        this.plane = plane;
    
        this.size = ( size === undefined ) ? 1 : size;
    
        var color = ( hex !== undefined ) ? hex : 0xffff00;
    
        var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];
    
        var geometry = new BufferGeometry();
        geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
        geometry.computeBoundingSphere();
    
        Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );
    
        //
    
        var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];
    
        var geometry2 = new BufferGeometry();
        geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
        geometry2.computeBoundingSphere();
    
        this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );
    
    }
    
    PlaneHelper.prototype = Object.create( Line.prototype );
    PlaneHelper.prototype.constructor = PlaneHelper;
    
    PlaneHelper.prototype.updateMatrixWorld = function ( force ) {
    
        var scale = - this.plane.constant;
    
        if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter
    
        this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );
    
        this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here
    
        this.lookAt( this.plane.normal );
    
        Object3D.prototype.updateMatrixWorld.call( this, force );
    
    };
    
    /**
     * @author WestLangley / http://github.com/WestLangley
     * @author zz85 / http://github.com/zz85
     * @author bhouston / http://clara.io
     *
     * Creates an arrow for visualizing directions
     *
     * Parameters:
     *  dir - Vector3
     *  origin - Vector3
     *  length - Number
     *  color - color in hex value
     *  headLength - Number
     *  headWidth - Number
     */
    
    var _axis = new Vector3();
    var _lineGeometry, _coneGeometry;
    
    function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
    
        // dir is assumed to be normalized
    
        Object3D.call( this );
    
        if ( dir === undefined ) dir = new Vector3( 0, 0, 1 );
        if ( origin === undefined ) origin = new Vector3( 0, 0, 0 );
        if ( length === undefined ) length = 1;
        if ( color === undefined ) color = 0xffff00;
        if ( headLength === undefined ) headLength = 0.2 * length;
        if ( headWidth === undefined ) headWidth = 0.2 * headLength;
    
        if ( _lineGeometry === undefined ) {
    
            _lineGeometry = new BufferGeometry();
            _lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );
    
            _coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
            _coneGeometry.translate( 0, - 0.5, 0 );
    
        }
    
        this.position.copy( origin );
    
        this.line = new Line( _lineGeometry, new LineBasicMaterial( { color: color } ) );
        this.line.matrixAutoUpdate = false;
        this.add( this.line );
    
        this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color } ) );
        this.cone.matrixAutoUpdate = false;
        this.add( this.cone );
    
        this.setDirection( dir );
        this.setLength( length, headLength, headWidth );
    
    }
    
    ArrowHelper.prototype = Object.create( Object3D.prototype );
    ArrowHelper.prototype.constructor = ArrowHelper;
    
    ArrowHelper.prototype.setDirection = function ( dir ) {
    
        // dir is assumed to be normalized
    
        if ( dir.y > 0.99999 ) {
    
            this.quaternion.set( 0, 0, 0, 1 );
    
        } else if ( dir.y < - 0.99999 ) {
    
            this.quaternion.set( 1, 0, 0, 0 );
    
        } else {
    
            _axis.set( dir.z, 0, - dir.x ).normalize();
    
            var radians = Math.acos( dir.y );
    
            this.quaternion.setFromAxisAngle( _axis, radians );
    
        }
    
    };
    
    ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
    
        if ( headLength === undefined ) headLength = 0.2 * length;
        if ( headWidth === undefined ) headWidth = 0.2 * headLength;
    
        this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
        this.line.updateMatrix();
    
        this.cone.scale.set( headWidth, headLength, headWidth );
        this.cone.position.y = length;
        this.cone.updateMatrix();
    
    };
    
    ArrowHelper.prototype.setColor = function ( color ) {
    
        this.line.material.color.set( color );
        this.cone.material.color.set( color );
    
    };
    
    ArrowHelper.prototype.copy = function ( source ) {
    
        Object3D.prototype.copy.call( this, source, false );
    
        this.line.copy( source.line );
        this.cone.copy( source.cone );
    
        return this;
    
    };
    
    ArrowHelper.prototype.clone = function () {
    
        return new this.constructor().copy( this );
    
    };
    
    /**
     * @author sroucheray / http://sroucheray.org/
     * @author mrdoob / http://mrdoob.com/
     */
    
    function AxesHelper( size ) {
    
        size = size || 1;
    
        var vertices = [
            0, 0, 0,	size, 0, 0,
            0, 0, 0,	0, size, 0,
            0, 0, 0,	0, 0, size
        ];
    
        var colors = [
            1, 0, 0,	1, 0.6, 0,
            0, 1, 0,	0.6, 1, 0,
            0, 0, 1,	0, 0.6, 1
        ];
    
        var geometry = new BufferGeometry();
        geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
        geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
    
        var material = new LineBasicMaterial( { vertexColors: true } );
    
        LineSegments.call( this, geometry, material );
    
    }
    
    AxesHelper.prototype = Object.create( LineSegments.prototype );
    AxesHelper.prototype.constructor = AxesHelper;
    
    /**
     * @author Emmett Lalish / elalish
     *
     * This class generates a Prefiltered, Mipmapped Radiance Environment Map
     * (PMREM) from a cubeMap environment texture. This allows different levels of
     * blur to be quickly accessed based on material roughness. It is packed into a
     * special CubeUV format that allows us to perform custom interpolation so that
     * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
     * chain, it only goes down to the LOD_MIN level (above), and then creates extra
     * even more filtered 'mips' at the same LOD_MIN resolution, associated with
     * higher roughness levels. In this way we maintain resolution to smoothly
     * interpolate diffuse lighting while limiting sampling computation.
     */
    
    var LOD_MIN = 4;
    var LOD_MAX = 8;
    var SIZE_MAX = Math.pow( 2, LOD_MAX );
    // The standard deviations (radians) associated with the extra mips. These are
    // chosen to approximate a Trowbridge-Reitz distribution function times the
    // geometric shadowing function. These sigma values squared must match the
    // variance #defines in cube_uv_reflection_fragment.glsl.js.
    var EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];
    var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    // The maximum length of the blur for loop. Smaller sigmas will use fewer
    // samples and exit early, but not recompile the shader.
    var MAX_SAMPLES = 20;
    var ENCODINGS = {
        [ LinearEncoding ]: 0,
        [ sRGBEncoding ]: 1,
        [ RGBEEncoding ]: 2,
        [ RGBM7Encoding ]: 3,
        [ RGBM16Encoding ]: 4,
        [ RGBDEncoding ]: 5,
        [ GammaEncoding ]: 6
    };
    
    var _flatCamera = new OrthographicCamera();
    var _blurMaterial = _getBlurShader( MAX_SAMPLES );
    var _equirectShader = null;
    var _cubemapShader = null;
    
    var { _lodPlanes, _sizeLods, _sigmas } = _createPlanes();
    var _pingPongRenderTarget = null;
    var _renderer = null;
    
    var _oldTarget = null;
    
    // Golden Ratio
    var PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
    var INV_PHI = 1 / PHI;
    // Vertices of a dodecahedron (except the opposites, which represent the
    // same axis), used as axis directions evenly spread on a sphere.
    var _axisDirections = [
        new Vector3( 1, 1, 1 ),
        new Vector3( - 1, 1, 1 ),
        new Vector3( 1, 1, - 1 ),
        new Vector3( - 1, 1, - 1 ),
        new Vector3( 0, PHI, INV_PHI ),
        new Vector3( 0, PHI, - INV_PHI ),
        new Vector3( INV_PHI, 0, PHI ),
        new Vector3( - INV_PHI, 0, PHI ),
        new Vector3( PHI, INV_PHI, 0 ),
        new Vector3( - PHI, INV_PHI, 0 ) ];
    
    function PMREMGenerator( renderer ) {
    
        _renderer = renderer;
        _compileMaterial( _blurMaterial );
    
    }
    
    PMREMGenerator.prototype = {
    
        constructor: PMREMGenerator,
    
        /**
         * Generates a PMREM from a supplied Scene, which can be faster than using an
         * image if networking bandwidth is low. Optional sigma specifies a blur radius
         * in radians to be applied to the scene before PMREM generation. Optional near
         * and far planes ensure the scene is rendered in its entirety (the cubeCamera
         * is placed at the origin).
         */
        fromScene: function ( scene, sigma = 0, near = 0.1, far = 100 ) {
    
            _oldTarget = _renderer.getRenderTarget();
            var cubeUVRenderTarget = _allocateTargets();
            _sceneToCubeUV( scene, near, far, cubeUVRenderTarget );
            if ( sigma > 0 ) {
    
                _blur( cubeUVRenderTarget, 0, 0, sigma );
    
            }
            _applyPMREM( cubeUVRenderTarget );
            _cleanup( cubeUVRenderTarget );
    
            return cubeUVRenderTarget;
    
        },
    
        /**
         * Generates a PMREM from an equirectangular texture, which can be either LDR
         * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
         * as this matches best with the 256 x 256 cubemap output.
         */
        fromEquirectangular: function ( equirectangular ) {
    
            equirectangular.magFilter = NearestFilter;
            equirectangular.minFilter = NearestFilter;
            equirectangular.generateMipmaps = false;
    
            return this.fromCubemap( equirectangular );
    
        },
    
        /**
         * Generates a PMREM from an cubemap texture, which can be either LDR
         * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
         * as this matches best with the 256 x 256 cubemap output.
         */
        fromCubemap: function ( cubemap ) {
    
            _oldTarget = _renderer.getRenderTarget();
            var cubeUVRenderTarget = _allocateTargets( cubemap );
            _textureToCubeUV( cubemap, cubeUVRenderTarget );
            _applyPMREM( cubeUVRenderTarget );
            _cleanup( cubeUVRenderTarget );
    
            return cubeUVRenderTarget;
    
        },
    
        /**
         * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
         * your texture's network fetch for increased concurrency.
         */
        compileCubemapShader: function () {
    
            if ( _cubemapShader == null ) {
    
                _cubemapShader = _getCubemapShader();
                _compileMaterial( _cubemapShader );
    
            }
    
        },
    
        /**
         * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
         * your texture's network fetch for increased concurrency.
         */
        compileEquirectangularShader: function () {
    
            if ( _equirectShader == null ) {
    
                _equirectShader = _getEquirectShader();
                _compileMaterial( _equirectShader );
    
            }
    
        },
    
        /**
         * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
         * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
         * one of them will cause any others to also become unusable.
         */
        dispose: function () {
    
            _blurMaterial.dispose();
    
            if ( _cubemapShader != null ) _cubemapShader.dispose();
            if ( _equirectShader != null ) _equirectShader.dispose();
    
            for ( var i = 0; i < _lodPlanes.length; i ++ ) {
    
                _lodPlanes[ i ].dispose();
    
            }
    
        },
    
    };
    
    function _createPlanes() {
    
        var _lodPlanes = [];
        var _sizeLods = [];
        var _sigmas = [];
    
        var lod = LOD_MAX;
        for ( var i = 0; i < TOTAL_LODS; i ++ ) {
    
            var sizeLod = Math.pow( 2, lod );
            _sizeLods.push( sizeLod );
            var sigma = 1.0 / sizeLod;
            if ( i > LOD_MAX - LOD_MIN ) {
    
                sigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];
    
            } else if ( i == 0 ) {
    
                sigma = 0;
    
            }
            _sigmas.push( sigma );
    
            var texelSize = 1.0 / ( sizeLod - 1 );
            var min = - texelSize / 2;
            var max = 1 + texelSize / 2;
            var uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];
    
            var cubeFaces = 6;
            var vertices = 6;
            var positionSize = 3;
            var uvSize = 2;
            var faceIndexSize = 1;
    
            var position = new Float32Array( positionSize * vertices * cubeFaces );
            var uv = new Float32Array( uvSize * vertices * cubeFaces );
            var faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );
    
            for ( var face = 0; face < cubeFaces; face ++ ) {
    
                var x = ( face % 3 ) * 2 / 3 - 1;
                var y = face > 2 ? 0 : - 1;
                var coordinates = [
                    x, y, 0,
                    x + 2 / 3, y, 0,
                    x + 2 / 3, y + 1, 0,
                    x, y, 0,
                    x + 2 / 3, y + 1, 0,
                    x, y + 1, 0
                ];
                position.set( coordinates, positionSize * vertices * face );
                uv.set( uv1, uvSize * vertices * face );
                var fill = [ face, face, face, face, face, face ];
                faceIndex.set( fill, faceIndexSize * vertices * face );
    
            }
            var planes = new BufferGeometry();
            planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
            planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
            planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
            _lodPlanes.push( planes );
    
            if ( lod > LOD_MIN ) {
    
                lod --;
    
            }
    
        }
        return { _lodPlanes, _sizeLods, _sigmas };
    
    }
    
    function _allocateTargets( equirectangular ) {
    
        var params = {
            magFilter: NearestFilter,
            minFilter: NearestFilter,
            generateMipmaps: false,
            type: equirectangular ? equirectangular.type : UnsignedByteType,
            format: equirectangular ? equirectangular.format : RGBEFormat,
            encoding: equirectangular ? equirectangular.encoding : RGBEEncoding,
            depthBuffer: false,
            stencilBuffer: false
        };
        var cubeUVRenderTarget = _createRenderTarget( params );
        cubeUVRenderTarget.depthBuffer = equirectangular ? false : true;
        _pingPongRenderTarget = _createRenderTarget( params );
        return cubeUVRenderTarget;
    
    }
    
    function _cleanup( outputTarget ) {
    
        _pingPongRenderTarget.dispose();
        _renderer.setRenderTarget( _oldTarget );
        outputTarget.scissorTest = false;
        // reset viewport and scissor
        outputTarget.setSize( outputTarget.width, outputTarget.height );
    
    }
    
    function _sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {
    
        var fov = 90;
        var aspect = 1;
        var cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
        var upSign = [ 1, 1, 1, 1, - 1, 1 ];
        var forwardSign = [ 1, 1, - 1, - 1, - 1, 1 ];
    
        var outputEncoding = _renderer.outputEncoding;
        var toneMapping = _renderer.toneMapping;
        var toneMappingExposure = _renderer.toneMappingExposure;
        var clearColor = _renderer.getClearColor();
        var clearAlpha = _renderer.getClearAlpha();
    
        _renderer.toneMapping = LinearToneMapping;
        _renderer.toneMappingExposure = 1.0;
        _renderer.outputEncoding = LinearEncoding;
        scene.scale.z *= - 1;
    
        var background = scene.background;
        if ( background && background.isColor ) {
    
            background.convertSRGBToLinear();
            // Convert linear to RGBE
            var maxComponent = Math.max( background.r, background.g, background.b );
            var fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );
            background = background.multiplyScalar( Math.pow( 2.0, - fExp ) );
            var alpha = ( fExp + 128.0 ) / 255.0;
            _renderer.setClearColor( background, alpha );
            scene.background = null;
    
        }
    
        for ( var i = 0; i < 6; i ++ ) {
    
            var col = i % 3;
            if ( col == 0 ) {
    
                cubeCamera.up.set( 0, upSign[ i ], 0 );
                cubeCamera.lookAt( forwardSign[ i ], 0, 0 );
    
            } else if ( col == 1 ) {
    
                cubeCamera.up.set( 0, 0, upSign[ i ] );
                cubeCamera.lookAt( 0, forwardSign[ i ], 0 );
    
            } else {
    
                cubeCamera.up.set( 0, upSign[ i ], 0 );
                cubeCamera.lookAt( 0, 0, forwardSign[ i ] );
    
            }
            _setViewport( cubeUVRenderTarget,
                col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );
            _renderer.setRenderTarget( cubeUVRenderTarget );
            _renderer.render( scene, cubeCamera );
    
        }
    
        _renderer.toneMapping = toneMapping;
        _renderer.toneMappingExposure = toneMappingExposure;
        _renderer.outputEncoding = outputEncoding;
        _renderer.setClearColor( clearColor, clearAlpha );
        scene.scale.z *= - 1;
    
    }
    
    function _textureToCubeUV( texture, cubeUVRenderTarget ) {
    
        var scene = new Scene();
        if ( texture.isCubeTexture ) {
    
            if ( _cubemapShader == null ) {
    
                _cubemapShader = _getCubemapShader();
    
            }
    
        } else {
    
            if ( _equirectShader == null ) {
    
                _equirectShader = _getEquirectShader();
    
            }
    
        }
        var material = texture.isCubeTexture ? _cubemapShader : _equirectShader;
        scene.add( new Mesh( _lodPlanes[ 0 ], material ) );
        var uniforms = material.uniforms;
    
        uniforms[ 'envMap' ].value = texture;
        if ( ! texture.isCubeTexture ) {
    
            uniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );
    
        }
        uniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];
        uniforms[ 'outputEncoding' ].value = ENCODINGS[ texture.encoding ];
    
        _setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );
        _renderer.setRenderTarget( cubeUVRenderTarget );
        _renderer.render( scene, _flatCamera );
    
    }
    
    function _compileMaterial( material ) {
    
        var tmpScene = new Scene();
        tmpScene.add( new Mesh( _lodPlanes[ 0 ], material ) );
        _renderer.compile( tmpScene, _flatCamera );
    
    }
    
    function _createRenderTarget( params ) {
    
        var cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );
        cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
        cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
        cubeUVRenderTarget.scissorTest = true;
        return cubeUVRenderTarget;
    
    }
    
    function _setViewport( target, x, y, width, height ) {
    
        target.viewport.set( x, y, width, height );
        target.scissor.set( x, y, width, height );
    
    }
    
    function _applyPMREM( cubeUVRenderTarget ) {
    
        var autoClear = _renderer.autoClear;
        _renderer.autoClear = false;
    
        for ( var i = 1; i < TOTAL_LODS; i ++ ) {
    
            var sigma = Math.sqrt(
                _sigmas[ i ] * _sigmas[ i ] -
            _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );
            var poleAxis =
            _axisDirections[ ( i - 1 ) % _axisDirections.length ];
            _blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );
    
        }
    
        _renderer.autoClear = autoClear;
    
    }
    
    /**
     * This is a two-pass Gaussian blur for a cubemap. Normally this is done
     * vertically and horizontally, but this breaks down on a cube. Here we apply
     * the blur latitudinally (around the poles), and then longitudinally (towards
     * the poles) to approximate the orthogonally-separable blur. It is least
     * accurate at the poles, but still does a decent job.
     */
    function _blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {
    
        _halfBlur(
            cubeUVRenderTarget,
            _pingPongRenderTarget,
            lodIn,
            lodOut,
            sigma,
            'latitudinal',
            poleAxis );
    
        _halfBlur(
            _pingPongRenderTarget,
            cubeUVRenderTarget,
            lodOut,
            lodOut,
            sigma,
            'longitudinal',
            poleAxis );
    
    }
    
    function _halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {
    
        if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {
    
            console.error(
                'blur direction must be either latitudinal or longitudinal!' );
    
        }
    
        // Number of standard deviations at which to cut off the discrete approximation.
        var STANDARD_DEVIATIONS = 3;
    
        var blurScene = new Scene();
        blurScene.add( new Mesh( _lodPlanes[ lodOut ], _blurMaterial ) );
        var blurUniforms = _blurMaterial.uniforms;
    
        var pixels = _sizeLods[ lodIn ] - 1;
        var radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
        var sigmaPixels = sigmaRadians / radiansPerPixel;
        var samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;
    
        if ( samples > MAX_SAMPLES ) {
    
            console.warn( `sigmaRadians, ${
                sigmaRadians}, is too large and will clip, as it requested ${
                samples} samples when the maximum is set to ${MAX_SAMPLES}` );
    
        }
    
        var weights = [];
        var sum = 0;
    
        for ( var i = 0; i < MAX_SAMPLES; ++ i ) {
    
            var x = i / sigmaPixels;
            var weight = Math.exp( - x * x / 2 );
            weights.push( weight );
    
            if ( i == 0 ) {
    
                sum += weight;
    
            } else if ( i < samples ) {
    
                sum += 2 * weight;
    
            }
    
        }
    
        for ( var i = 0; i < weights.length; i ++ ) {
    
            weights[ i ] = weights[ i ] / sum;
    
        }
    
        blurUniforms[ 'envMap' ].value = targetIn.texture;
        blurUniforms[ 'samples' ].value = samples;
        blurUniforms[ 'weights' ].value = weights;
        blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';
        if ( poleAxis ) {
    
            blurUniforms[ 'poleAxis' ].value = poleAxis;
    
        }
        blurUniforms[ 'dTheta' ].value = radiansPerPixel;
        blurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;
        blurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];
        blurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];
    
        var outputSize = _sizeLods[ lodOut ];
        var x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );
        var y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) +
        2 * outputSize *
            ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );
    
        _setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
        _renderer.setRenderTarget( targetOut );
        _renderer.render( blurScene, _flatCamera );
    
    }
    
    function _getBlurShader( maxSamples ) {
    
        var weights = new Float32Array( maxSamples );
        var poleAxis = new Vector3( 0, 1, 0 );
        var shaderMaterial = new RawShaderMaterial( {
    
            defines: { 'n': maxSamples },
    
            uniforms: {
                'envMap': { value: null },
                'samples': { value: 1 },
                'weights': { value: weights },
                'latitudinal': { value: false },
                'dTheta': { value: 0 },
                'mipInt': { value: 0 },
                'poleAxis': { value: poleAxis },
                'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
                'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
            },
    
            vertexShader: _getCommonVertexShader(),
    
            fragmentShader: `
    precision mediump float;
    precision mediump int;
    varying vec3 vOutputDirection;
    uniform sampler2D envMap;
    uniform int samples;
    uniform float weights[n];
    uniform bool latitudinal;
    uniform float dTheta;
    uniform float mipInt;
    uniform vec3 poleAxis;
    
    ${_getEncodings()}
    
    #define ENVMAP_TYPE_CUBE_UV
    #include <cube_uv_reflection_fragment>
    
    void main() {
        gl_FragColor = vec4(0.0);
        for (int i = 0; i < n; i++) {
            if (i >= samples)
                break;
            for (int dir = -1; dir < 2; dir += 2) {
                if (i == 0 && dir == 1)
                    continue;
                vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);
                if (all(equal(axis, vec3(0.0))))
                    axis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);
                axis = normalize(axis);
                float theta = dTheta * float(dir * i);
                float cosTheta = cos(theta);
                // Rodrigues' axis-angle rotation
                vec3 sampleDirection = vOutputDirection * cosTheta
                        + cross(axis, vOutputDirection) * sin(theta)
                        + axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);
                gl_FragColor.rgb +=
                        weights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);
            }
        }
        gl_FragColor = linearToOutputTexel(gl_FragColor);
    }
            `,
    
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
    
        } );
    
        shaderMaterial.type = 'SphericalGaussianBlur';
    
        return shaderMaterial;
    
    }
    
    function _getEquirectShader() {
    
        var texelSize = new Vector2( 1, 1 );
        var shaderMaterial = new RawShaderMaterial( {
    
            uniforms: {
                'envMap': { value: null },
                'texelSize': { value: texelSize },
                'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
                'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
            },
    
            vertexShader: _getCommonVertexShader(),
    
            fragmentShader: `
    precision mediump float;
    precision mediump int;
    varying vec3 vOutputDirection;
    uniform sampler2D envMap;
    uniform vec2 texelSize;
    
    ${_getEncodings()}
    
    #define RECIPROCAL_PI 0.31830988618
    #define RECIPROCAL_PI2 0.15915494
    
    void main() {
        gl_FragColor = vec4(0.0);
        vec3 outputDirection = normalize(vOutputDirection);
        vec2 uv;
        uv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;
        uv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;
        vec2 f = fract(uv / texelSize - 0.5);
        uv -= f * texelSize;
        vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
        uv.x += texelSize.x;
        vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
        uv.y += texelSize.y;
        vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
        uv.x -= texelSize.x;
        vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
        vec3 tm = mix(tl, tr, f.x);
        vec3 bm = mix(bl, br, f.x);
        gl_FragColor.rgb = mix(tm, bm, f.y);
        gl_FragColor = linearToOutputTexel(gl_FragColor);
    }
            `,
    
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
    
        } );
    
        shaderMaterial.type = 'EquirectangularToCubeUV';
    
        return shaderMaterial;
    
    }
    
    function _getCubemapShader() {
    
        var shaderMaterial = new RawShaderMaterial( {
    
            uniforms: {
                'envMap': { value: null },
                'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
                'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
            },
    
            vertexShader: _getCommonVertexShader(),
    
            fragmentShader: `
    precision mediump float;
    precision mediump int;
    varying vec3 vOutputDirection;
    uniform samplerCube envMap;
    
    ${_getEncodings()}
    
    void main() {
        gl_FragColor = vec4(0.0);
        gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;
        gl_FragColor = linearToOutputTexel(gl_FragColor);
    }
            `,
    
            blending: NoBlending,
            depthTest: false,
            depthWrite: false
    
        } );
    
        shaderMaterial.type = 'CubemapToCubeUV';
    
        return shaderMaterial;
    
    }
    
    function _getCommonVertexShader() {
    
        return `
    precision mediump float;
    precision mediump int;
    attribute vec3 position;
    attribute vec2 uv;
    attribute float faceIndex;
    varying vec3 vOutputDirection;
    vec3 getDirection(vec2 uv, float face) {
        uv = 2.0 * uv - 1.0;
        vec3 direction = vec3(uv, 1.0);
        if (face == 0.0) {
            direction = direction.zyx;
            direction.z *= -1.0;
        } else if (face == 1.0) {
            direction = direction.xzy;
            direction.z *= -1.0;
        } else if (face == 3.0) {
            direction = direction.zyx;
            direction.x *= -1.0;
        } else if (face == 4.0) {
            direction = direction.xzy;
            direction.y *= -1.0;
        } else if (face == 5.0) {
            direction.xz *= -1.0;
        }
        return direction;
    }
    void main() {
        vOutputDirection = getDirection(uv, faceIndex);
        gl_Position = vec4( position, 1.0 );
    }
        `;
    
    }
    
    function _getEncodings() {
    
        return `
    uniform int inputEncoding;
    uniform int outputEncoding;
    
    #include <encodings_pars_fragment>
    
    vec4 inputTexelToLinear(vec4 value){
        if(inputEncoding == 0){
            return value;
        }else if(inputEncoding == 1){
            return sRGBToLinear(value);
        }else if(inputEncoding == 2){
            return RGBEToLinear(value);
        }else if(inputEncoding == 3){
            return RGBMToLinear(value, 7.0);
        }else if(inputEncoding == 4){
            return RGBMToLinear(value, 16.0);
        }else if(inputEncoding == 5){
            return RGBDToLinear(value, 256.0);
        }else{
            return GammaToLinear(value, 2.2);
        }
    }
    
    vec4 linearToOutputTexel(vec4 value){
        if(outputEncoding == 0){
            return value;
        }else if(outputEncoding == 1){
            return LinearTosRGB(value);
        }else if(outputEncoding == 2){
            return LinearToRGBE(value);
        }else if(outputEncoding == 3){
            return LinearToRGBM(value, 7.0);
        }else if(outputEncoding == 4){
            return LinearToRGBM(value, 16.0);
        }else if(outputEncoding == 5){
            return LinearToRGBD(value, 256.0);
        }else{
            return LinearToGamma(value, 2.2);
        }
    }
    
    vec4 envMapTexelToLinear(vec4 color) {
        return inputTexelToLinear(color);
    }
        `;
    
    }
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    function Face4( a, b, c, d, normal, color, materialIndex ) {
    
        console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
        return new Face3( a, b, c, normal, color, materialIndex );
    
    }
    
    var LineStrip = 0;
    var LinePieces = 1;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    
    function MeshFaceMaterial( materials ) {
    
        console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
        return materials;
    
    }
    
    function MultiMaterial( materials ) {
    
        if ( materials === undefined ) materials = [];
    
        console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
        materials.isMultiMaterial = true;
        materials.materials = materials;
        materials.clone = function () {
    
            return materials.slice();
    
        };
        return materials;
    
    }
    
    function PointCloud( geometry, material ) {
    
        console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
        return new Points( geometry, material );
    
    }
    
    function Particle( material ) {
    
        console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
        return new Sprite( material );
    
    }
    
    function ParticleSystem( geometry, material ) {
    
        console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
        return new Points( geometry, material );
    
    }
    
    function PointCloudMaterial( parameters ) {
    
        console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
        return new PointsMaterial( parameters );
    
    }
    
    function ParticleBasicMaterial( parameters ) {
    
        console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
        return new PointsMaterial( parameters );
    
    }
    
    function ParticleSystemMaterial( parameters ) {
    
        console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
        return new PointsMaterial( parameters );
    
    }
    
    function Vertex( x, y, z ) {
    
        console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
        return new Vector3( x, y, z );
    
    }
    
    //
    
    function DynamicBufferAttribute( array, itemSize ) {
    
        console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );
        return new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );
    
    }
    
    function Int8Attribute( array, itemSize ) {
    
        console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
        return new Int8BufferAttribute( array, itemSize );
    
    }
    
    function Uint8Attribute( array, itemSize ) {
    
        console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
        return new Uint8BufferAttribute( array, itemSize );
    
    }
    
    function Uint8ClampedAttribute( array, itemSize ) {
    
        console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
        return new Uint8ClampedBufferAttribute( array, itemSize );
    
    }
    
    function Int16Attribute( array, itemSize ) {
    
        console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
        return new Int16BufferAttribute( array, itemSize );
    
    }
    
    function Uint16Attribute( array, itemSize ) {
    
        console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
        return new Uint16BufferAttribute( array, itemSize );
    
    }
    
    function Int32Attribute( array, itemSize ) {
    
        console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
        return new Int32BufferAttribute( array, itemSize );
    
    }
    
    function Uint32Attribute( array, itemSize ) {
    
        console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
        return new Uint32BufferAttribute( array, itemSize );
    
    }
    
    function Float32Attribute( array, itemSize ) {
    
        console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
        return new Float32BufferAttribute( array, itemSize );
    
    }
    
    function Float64Attribute( array, itemSize ) {
    
        console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
        return new Float64BufferAttribute( array, itemSize );
    
    }
    
    //
    
    Curve.create = function ( construct, getPoint ) {
    
        console.log( 'THREE.Curve.create() has been deprecated' );
    
        construct.prototype = Object.create( Curve.prototype );
        construct.prototype.constructor = construct;
        construct.prototype.getPoint = getPoint;
    
        return construct;
    
    };
    
    //
    
    Object.assign( CurvePath.prototype, {
    
        createPointsGeometry: function ( divisions ) {
    
            console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
    
            // generate geometry from path points (for Line or Points objects)
    
            var pts = this.getPoints( divisions );
            return this.createGeometry( pts );
    
        },
    
        createSpacedPointsGeometry: function ( divisions ) {
    
            console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
    
            // generate geometry from equidistant sampling along the path
    
            var pts = this.getSpacedPoints( divisions );
            return this.createGeometry( pts );
    
        },
    
        createGeometry: function ( points ) {
    
            console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
    
            var geometry = new Geometry();
    
            for ( var i = 0, l = points.length; i < l; i ++ ) {
    
                var point = points[ i ];
                geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
    
            }
    
            return geometry;
    
        }
    
    } );
    
    //
    
    Object.assign( Path.prototype, {
    
        fromPoints: function ( points ) {
    
            console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
            return this.setFromPoints( points );
    
        }
    
    } );
    
    //
    
    function ClosedSplineCurve3( points ) {
    
        console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
    
        CatmullRomCurve3.call( this, points );
        this.type = 'catmullrom';
        this.closed = true;
    
    }
    
    ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
    
    //
    
    function SplineCurve3( points ) {
    
        console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
    
        CatmullRomCurve3.call( this, points );
        this.type = 'catmullrom';
    
    }
    
    SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
    
    //
    
    function Spline( points ) {
    
        console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );
    
        CatmullRomCurve3.call( this, points );
        this.type = 'catmullrom';
    
    }
    
    Spline.prototype = Object.create( CatmullRomCurve3.prototype );
    
    Object.assign( Spline.prototype, {
    
        initFromArray: function ( /* a */ ) {
    
            console.error( 'THREE.Spline: .initFromArray() has been removed.' );
    
        },
        getControlPointsArray: function ( /* optionalTarget */ ) {
    
            console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );
    
        },
        reparametrizeByArcLength: function ( /* samplingCoef */ ) {
    
            console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );
    
        }
    
    } );
    
    //
    
    function AxisHelper( size ) {
    
        console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
        return new AxesHelper( size );
    
    }
    
    function BoundingBoxHelper( object, color ) {
    
        console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
        return new BoxHelper( object, color );
    
    }
    
    function EdgesHelper( object, hex ) {
    
        console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
        return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
    
    }
    
    GridHelper.prototype.setColors = function () {
    
        console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );
    
    };
    
    SkeletonHelper.prototype.update = function () {
    
        console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );
    
    };
    
    function WireframeHelper( object, hex ) {
    
        console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
        return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
    
    }
    
    //
    
    Object.assign( Loader.prototype, {
    
        extractUrlBase: function ( url ) {
    
            console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
            return LoaderUtils.extractUrlBase( url );
    
        }
    
    } );
    
    Loader.Handlers = {
    
        add: function ( /* regex, loader */ ) {
    
            console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );
    
        },
    
        get: function ( /* file */ ) {
    
            console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );
    
        }
    
    };
    
    function XHRLoader( manager ) {
    
        console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
        return new FileLoader( manager );
    
    }
    
    function BinaryTextureLoader( manager ) {
    
        console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
        return new DataTextureLoader( manager );
    
    }
    
    Object.assign( ObjectLoader.prototype, {
    
        setTexturePath: function ( value ) {
    
            console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
            return this.setResourcePath( value );
    
        }
    
    } );
    
    //
    
    Object.assign( Box2.prototype, {
    
        center: function ( optionalTarget ) {
    
            console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
            return this.getCenter( optionalTarget );
    
        },
        empty: function () {
    
            console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
            return this.isEmpty();
    
        },
        isIntersectionBox: function ( box ) {
    
            console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
            return this.intersectsBox( box );
    
        },
        size: function ( optionalTarget ) {
    
            console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
            return this.getSize( optionalTarget );
    
        }
    } );
    
    Object.assign( Box3.prototype, {
    
        center: function ( optionalTarget ) {
    
            console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
            return this.getCenter( optionalTarget );
    
        },
        empty: function () {
    
            console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
            return this.isEmpty();
    
        },
        isIntersectionBox: function ( box ) {
    
            console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
            return this.intersectsBox( box );
    
        },
        isIntersectionSphere: function ( sphere ) {
    
            console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
            return this.intersectsSphere( sphere );
    
        },
        size: function ( optionalTarget ) {
    
            console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
            return this.getSize( optionalTarget );
    
        }
    } );
    
    Frustum.prototype.setFromMatrix = function ( m ) {
    
        console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
        return this.setFromProjectionMatrix( m );
    
    };
    
    Line3.prototype.center = function ( optionalTarget ) {
    
        console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
        return this.getCenter( optionalTarget );
    
    };
    
    Object.assign( MathUtils, {
    
        random16: function () {
    
            console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
            return Math.random();
    
        },
    
        nearestPowerOfTwo: function ( value ) {
    
            console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
            return MathUtils.floorPowerOfTwo( value );
    
        },
    
        nextPowerOfTwo: function ( value ) {
    
            console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
            return MathUtils.ceilPowerOfTwo( value );
    
        }
    
    } );
    
    Object.assign( Matrix3.prototype, {
    
        flattenToArrayOffset: function ( array, offset ) {
    
            console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
            return this.toArray( array, offset );
    
        },
        multiplyVector3: function ( vector ) {
    
            console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
            return vector.applyMatrix3( this );
    
        },
        multiplyVector3Array: function ( /* a */ ) {
    
            console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );
    
        },
        applyToBufferAttribute: function ( attribute ) {
    
            console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
            return attribute.applyMatrix3( this );
    
        },
        applyToVector3Array: function ( /* array, offset, length */ ) {
    
            console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );
    
        }
    
    } );
    
    Object.assign( Matrix4.prototype, {
    
        extractPosition: function ( m ) {
    
            console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
            return this.copyPosition( m );
    
        },
        flattenToArrayOffset: function ( array, offset ) {
    
            console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
            return this.toArray( array, offset );
    
        },
        getPosition: function () {
    
            console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
            return new Vector3().setFromMatrixColumn( this, 3 );
    
        },
        setRotationFromQuaternion: function ( q ) {
    
            console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
            return this.makeRotationFromQuaternion( q );
    
        },
        multiplyToArray: function () {
    
            console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );
    
        },
        multiplyVector3: function ( vector ) {
    
            console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
            return vector.applyMatrix4( this );
    
        },
        multiplyVector4: function ( vector ) {
    
            console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
            return vector.applyMatrix4( this );
    
        },
        multiplyVector3Array: function ( /* a */ ) {
    
            console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );
    
        },
        rotateAxis: function ( v ) {
    
            console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
            v.transformDirection( this );
    
        },
        crossVector: function ( vector ) {
    
            console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
            return vector.applyMatrix4( this );
    
        },
        translate: function () {
    
            console.error( 'THREE.Matrix4: .translate() has been removed.' );
    
        },
        rotateX: function () {
    
            console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
    
        },
        rotateY: function () {
    
            console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
    
        },
        rotateZ: function () {
    
            console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
    
        },
        rotateByAxis: function () {
    
            console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
    
        },
        applyToBufferAttribute: function ( attribute ) {
    
            console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
            return attribute.applyMatrix4( this );
    
        },
        applyToVector3Array: function ( /* array, offset, length */ ) {
    
            console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );
    
        },
        makeFrustum: function ( left, right, bottom, top, near, far ) {
    
            console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
            return this.makePerspective( left, right, top, bottom, near, far );
    
        }
    
    } );
    
    Plane.prototype.isIntersectionLine = function ( line ) {
    
        console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
        return this.intersectsLine( line );
    
    };
    
    Quaternion.prototype.multiplyVector3 = function ( vector ) {
    
        console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
        return vector.applyQuaternion( this );
    
    };
    
    Object.assign( Ray.prototype, {
    
        isIntersectionBox: function ( box ) {
    
            console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
            return this.intersectsBox( box );
    
        },
        isIntersectionPlane: function ( plane ) {
    
            console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
            return this.intersectsPlane( plane );
    
        },
        isIntersectionSphere: function ( sphere ) {
    
            console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
            return this.intersectsSphere( sphere );
    
        }
    
    } );
    
    Object.assign( Triangle.prototype, {
    
        area: function () {
    
            console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
            return this.getArea();
    
        },
        barycoordFromPoint: function ( point, target ) {
    
            console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
            return this.getBarycoord( point, target );
    
        },
        midpoint: function ( target ) {
    
            console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
            return this.getMidpoint( target );
    
        },
        normal: function ( target ) {
    
            console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
            return this.getNormal( target );
    
        },
        plane: function ( target ) {
    
            console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
            return this.getPlane( target );
    
        }
    
    } );
    
    Object.assign( Triangle, {
    
        barycoordFromPoint: function ( point, a, b, c, target ) {
    
            console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
            return Triangle.getBarycoord( point, a, b, c, target );
    
        },
        normal: function ( a, b, c, target ) {
    
            console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
            return Triangle.getNormal( a, b, c, target );
    
        }
    
    } );
    
    Object.assign( Shape.prototype, {
    
        extractAllPoints: function ( divisions ) {
    
            console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
            return this.extractPoints( divisions );
    
        },
        extrude: function ( options ) {
    
            console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
            return new ExtrudeGeometry( this, options );
    
        },
        makeGeometry: function ( options ) {
    
            console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
            return new ShapeGeometry( this, options );
    
        }
    
    } );
    
    Object.assign( Vector2.prototype, {
    
        fromAttribute: function ( attribute, index, offset ) {
    
            console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
            return this.fromBufferAttribute( attribute, index, offset );
    
        },
        distanceToManhattan: function ( v ) {
    
            console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
            return this.manhattanDistanceTo( v );
    
        },
        lengthManhattan: function () {
    
            console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
            return this.manhattanLength();
    
        }
    
    } );
    
    Object.assign( Vector3.prototype, {
    
        setEulerFromRotationMatrix: function () {
    
            console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
    
        },
        setEulerFromQuaternion: function () {
    
            console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
    
        },
        getPositionFromMatrix: function ( m ) {
    
            console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
            return this.setFromMatrixPosition( m );
    
        },
        getScaleFromMatrix: function ( m ) {
    
            console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
            return this.setFromMatrixScale( m );
    
        },
        getColumnFromMatrix: function ( index, matrix ) {
    
            console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
            return this.setFromMatrixColumn( matrix, index );
    
        },
        applyProjection: function ( m ) {
    
            console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
            return this.applyMatrix4( m );
    
        },
        fromAttribute: function ( attribute, index, offset ) {
    
            console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
            return this.fromBufferAttribute( attribute, index, offset );
    
        },
        distanceToManhattan: function ( v ) {
    
            console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
            return this.manhattanDistanceTo( v );
    
        },
        lengthManhattan: function () {
    
            console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
            return this.manhattanLength();
    
        }
    
    } );
    
    Object.assign( Vector4.prototype, {
    
        fromAttribute: function ( attribute, index, offset ) {
    
            console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
            return this.fromBufferAttribute( attribute, index, offset );
    
        },
        lengthManhattan: function () {
    
            console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
            return this.manhattanLength();
    
        }
    
    } );
    
    //
    
    Object.assign( Geometry.prototype, {
    
        computeTangents: function () {
    
            console.error( 'THREE.Geometry: .computeTangents() has been removed.' );
    
        },
        computeLineDistances: function () {
    
            console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );
    
        },
        applyMatrix: function ( matrix ) {
    
            console.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' );
            return this.applyMatrix4( matrix );
    
        }
    
    } );
    
    Object.assign( Object3D.prototype, {
    
        getChildByName: function ( name ) {
    
            console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
            return this.getObjectByName( name );
    
        },
        renderDepth: function () {
    
            console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
    
        },
        translate: function ( distance, axis ) {
    
            console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
            return this.translateOnAxis( axis, distance );
    
        },
        getWorldRotation: function () {
    
            console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );
    
        },
        applyMatrix: function ( matrix ) {
    
            console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
            return this.applyMatrix4( matrix );
    
        }
    
    } );
    
    Object.defineProperties( Object3D.prototype, {
    
        eulerOrder: {
            get: function () {
    
                console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
                return this.rotation.order;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
                this.rotation.order = value;
    
            }
        },
        useQuaternion: {
            get: function () {
    
                console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    
            },
            set: function () {
    
                console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    
            }
        }
    
    } );
    
    Object.assign( Mesh.prototype, {
    
        setDrawMode: function () {
    
            console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );
    
        },
    
    } );
    
    Object.defineProperties( Mesh.prototype, {
    
        drawMode: {
            get: function () {
    
                console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
                return TrianglesDrawMode;
    
            },
            set: function () {
    
                console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );
    
            }
        }
    
    } );
    
    Object.defineProperties( LOD.prototype, {
    
        objects: {
            get: function () {
    
                console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
                return this.levels;
    
            }
        }
    
    } );
    
    Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {
    
        get: function () {
    
            console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );
    
        },
        set: function () {
    
            console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );
    
        }
    
    } );
    
    SkinnedMesh.prototype.initBones = function () {
    
        console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );
    
    };
    
    Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {
    
        get: function () {
    
            console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
            return this.arcLengthDivisions;
    
        },
        set: function ( value ) {
    
            console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
            this.arcLengthDivisions = value;
    
        }
    
    } );
    
    //
    
    PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {
    
        console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
                "Use .setFocalLength and .filmGauge for a photographic setup." );
    
        if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
        this.setFocalLength( focalLength );
    
    };
    
    //
    
    Object.defineProperties( Light.prototype, {
        onlyShadow: {
            set: function () {
    
                console.warn( 'THREE.Light: .onlyShadow has been removed.' );
    
            }
        },
        shadowCameraFov: {
            set: function ( value ) {
    
                console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
                this.shadow.camera.fov = value;
    
            }
        },
        shadowCameraLeft: {
            set: function ( value ) {
    
                console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
                this.shadow.camera.left = value;
    
            }
        },
        shadowCameraRight: {
            set: function ( value ) {
    
                console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
                this.shadow.camera.right = value;
    
            }
        },
        shadowCameraTop: {
            set: function ( value ) {
    
                console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
                this.shadow.camera.top = value;
    
            }
        },
        shadowCameraBottom: {
            set: function ( value ) {
    
                console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
                this.shadow.camera.bottom = value;
    
            }
        },
        shadowCameraNear: {
            set: function ( value ) {
    
                console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
                this.shadow.camera.near = value;
    
            }
        },
        shadowCameraFar: {
            set: function ( value ) {
    
                console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
                this.shadow.camera.far = value;
    
            }
        },
        shadowCameraVisible: {
            set: function () {
    
                console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
    
            }
        },
        shadowBias: {
            set: function ( value ) {
    
                console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
                this.shadow.bias = value;
    
            }
        },
        shadowDarkness: {
            set: function () {
    
                console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
    
            }
        },
        shadowMapWidth: {
            set: function ( value ) {
    
                console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
                this.shadow.mapSize.width = value;
    
            }
        },
        shadowMapHeight: {
            set: function ( value ) {
    
                console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
                this.shadow.mapSize.height = value;
    
            }
        }
    } );
    
    //
    
    Object.defineProperties( BufferAttribute.prototype, {
    
        length: {
            get: function () {
    
                console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
                return this.array.length;
    
            }
        },
        dynamic: {
            get: function () {
    
                console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
                return this.usage === DynamicDrawUsage;
    
            },
            set: function ( /* value */ ) {
    
                console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
                this.setUsage( DynamicDrawUsage );
    
            }
        }
    
    } );
    
    Object.assign( BufferAttribute.prototype, {
        setDynamic: function ( value ) {
    
            console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
            this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
            return this;
    
        },
        copyIndicesArray: function ( /* indices */ ) {
    
            console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );
    
        },
        setArray: function ( /* array */ ) {
    
            console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );
    
        }
    } );
    
    Object.assign( BufferGeometry.prototype, {
    
        addIndex: function ( index ) {
    
            console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
            this.setIndex( index );
    
        },
        addAttribute: function ( name, attribute ) {
    
            console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );
    
            if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {
    
                console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
    
                return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
    
            }
    
            if ( name === 'index' ) {
    
                console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
                this.setIndex( attribute );
    
                return this;
    
            }
    
            return this.setAttribute( name, attribute );
    
        },
        addDrawCall: function ( start, count, indexOffset ) {
    
            if ( indexOffset !== undefined ) {
    
                console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
    
            }
            console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
            this.addGroup( start, count );
    
        },
        clearDrawCalls: function () {
    
            console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
            this.clearGroups();
    
        },
        computeTangents: function () {
    
            console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
    
        },
        computeOffsets: function () {
    
            console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
    
        },
        removeAttribute: function ( name ) {
    
            console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );
    
            return this.deleteAttribute( name );
    
        },
        applyMatrix: function ( matrix ) {
    
            console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
            return this.applyMatrix4( matrix );
    
        }
    
    } );
    
    Object.defineProperties( BufferGeometry.prototype, {
    
        drawcalls: {
            get: function () {
    
                console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
                return this.groups;
    
            }
        },
        offsets: {
            get: function () {
    
                console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
                return this.groups;
    
            }
        }
    
    } );
    
    Object.defineProperties( Raycaster.prototype, {
    
        linePrecision: {
            get: function () {
    
                console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
                return this.params.Line.threshold;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
                this.params.Line.threshold = value;
    
            }
        }
    
    } );
    
    Object.defineProperties( InterleavedBuffer.prototype, {
    
        dynamic: {
            get: function () {
    
                console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
                return this.usage === DynamicDrawUsage;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
                this.setUsage( value );
    
            }
        }
    
    } );
    
    Object.assign( InterleavedBuffer.prototype, {
        setDynamic: function ( value ) {
    
            console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
            this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
            return this;
    
        },
        setArray: function ( /* array */ ) {
    
            console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );
    
        }
    } );
    
    //
    
    Object.assign( ExtrudeBufferGeometry.prototype, {
    
        getArrays: function () {
    
            console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );
    
        },
    
        addShapeList: function () {
    
            console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );
    
        },
    
        addShape: function () {
    
            console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );
    
        }
    
    } );
    
    //
    
    Object.defineProperties( Uniform.prototype, {
    
        dynamic: {
            set: function () {
    
                console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );
    
            }
        },
        onUpdate: {
            value: function () {
    
                console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
                return this;
    
            }
        }
    
    } );
    
    //
    
    Object.defineProperties( Material.prototype, {
    
        wrapAround: {
            get: function () {
    
                console.warn( 'THREE.Material: .wrapAround has been removed.' );
    
            },
            set: function () {
    
                console.warn( 'THREE.Material: .wrapAround has been removed.' );
    
            }
        },
    
        overdraw: {
            get: function () {
    
                console.warn( 'THREE.Material: .overdraw has been removed.' );
    
            },
            set: function () {
    
                console.warn( 'THREE.Material: .overdraw has been removed.' );
    
            }
        },
    
        wrapRGB: {
            get: function () {
    
                console.warn( 'THREE.Material: .wrapRGB has been removed.' );
                return new Color();
    
            }
        },
    
        shading: {
            get: function () {
    
                console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
                this.flatShading = ( value === FlatShading );
    
            }
        },
    
        stencilMask: {
            get: function () {
    
                console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
                return this.stencilFuncMask;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
                this.stencilFuncMask = value;
    
            }
        }
    
    } );
    
    Object.defineProperties( MeshPhongMaterial.prototype, {
    
        metal: {
            get: function () {
    
                console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
                return false;
    
            },
            set: function () {
    
                console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
    
            }
        }
    
    } );
    
    Object.defineProperties( ShaderMaterial.prototype, {
    
        derivatives: {
            get: function () {
    
                console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
                return this.extensions.derivatives;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
                this.extensions.derivatives = value;
    
            }
        }
    
    } );
    
    //
    
    Object.assign( WebGLRenderer.prototype, {
    
        clearTarget: function ( renderTarget, color, depth, stencil ) {
    
            console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
            this.setRenderTarget( renderTarget );
            this.clear( color, depth, stencil );
    
        },
        animate: function ( callback ) {
    
            console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
            this.setAnimationLoop( callback );
    
        },
        getCurrentRenderTarget: function () {
    
            console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
            return this.getRenderTarget();
    
        },
        getMaxAnisotropy: function () {
    
            console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
            return this.capabilities.getMaxAnisotropy();
    
        },
        getPrecision: function () {
    
            console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
            return this.capabilities.precision;
    
        },
        resetGLState: function () {
    
            console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
            return this.state.reset();
    
        },
        supportsFloatTextures: function () {
    
            console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
            return this.extensions.get( 'OES_texture_float' );
    
        },
        supportsHalfFloatTextures: function () {
    
            console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
            return this.extensions.get( 'OES_texture_half_float' );
    
        },
        supportsStandardDerivatives: function () {
    
            console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
            return this.extensions.get( 'OES_standard_derivatives' );
    
        },
        supportsCompressedTextureS3TC: function () {
    
            console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
            return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
    
        },
        supportsCompressedTexturePVRTC: function () {
    
            console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
            return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
    
        },
        supportsBlendMinMax: function () {
    
            console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
            return this.extensions.get( 'EXT_blend_minmax' );
    
        },
        supportsVertexTextures: function () {
    
            console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
            return this.capabilities.vertexTextures;
    
        },
        supportsInstancedArrays: function () {
    
            console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
            return this.extensions.get( 'ANGLE_instanced_arrays' );
    
        },
        enableScissorTest: function ( boolean ) {
    
            console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
            this.setScissorTest( boolean );
    
        },
        initMaterial: function () {
    
            console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
    
        },
        addPrePlugin: function () {
    
            console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
    
        },
        addPostPlugin: function () {
    
            console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
    
        },
        updateShadowMap: function () {
    
            console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
    
        },
        setFaceCulling: function () {
    
            console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );
    
        },
        allocTextureUnit: function () {
    
            console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );
    
        },
        setTexture: function () {
    
            console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );
    
        },
        setTexture2D: function () {
    
            console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );
    
        },
        setTextureCube: function () {
    
            console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );
    
        },
        getActiveMipMapLevel: function () {
    
            console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
            return this.getActiveMipmapLevel();
    
        }
    
    } );
    
    Object.defineProperties( WebGLRenderer.prototype, {
    
        shadowMapEnabled: {
            get: function () {
    
                return this.shadowMap.enabled;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
                this.shadowMap.enabled = value;
    
            }
        },
        shadowMapType: {
            get: function () {
    
                return this.shadowMap.type;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
                this.shadowMap.type = value;
    
            }
        },
        shadowMapCullFace: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
                return undefined;
    
            },
            set: function ( /* value */ ) {
    
                console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
    
            }
        },
        context: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
                return this.getContext();
    
            }
        },
        vr: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
                return this.xr;
    
            }
        },
        gammaInput: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
                return false;
    
            },
            set: function () {
    
                console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
    
            }
        },
        gammaOutput: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
                return false;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
                this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;
    
            }
        }
    
    } );
    
    Object.defineProperties( WebGLShadowMap.prototype, {
    
        cullFace: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
                return undefined;
    
            },
            set: function ( /* cullFace */ ) {
    
                console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
    
            }
        },
        renderReverseSided: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
                return undefined;
    
            },
            set: function () {
    
                console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
    
            }
        },
        renderSingleSided: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
                return undefined;
    
            },
            set: function () {
    
                console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
    
            }
        }
    
    } );
    
    function WebGLRenderTargetCube( width, height, options ) {
    
        console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );
        return new WebGLCubeRenderTarget( width, options );
    
    }
    
    //
    
    Object.defineProperties( WebGLRenderTarget.prototype, {
    
        wrapS: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
                return this.texture.wrapS;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
                this.texture.wrapS = value;
    
            }
        },
        wrapT: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
                return this.texture.wrapT;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
                this.texture.wrapT = value;
    
            }
        },
        magFilter: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
                return this.texture.magFilter;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
                this.texture.magFilter = value;
    
            }
        },
        minFilter: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
                return this.texture.minFilter;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
                this.texture.minFilter = value;
    
            }
        },
        anisotropy: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
                return this.texture.anisotropy;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
                this.texture.anisotropy = value;
    
            }
        },
        offset: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
                return this.texture.offset;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
                this.texture.offset = value;
    
            }
        },
        repeat: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
                return this.texture.repeat;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
                this.texture.repeat = value;
    
            }
        },
        format: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
                return this.texture.format;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
                this.texture.format = value;
    
            }
        },
        type: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
                return this.texture.type;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
                this.texture.type = value;
    
            }
        },
        generateMipmaps: {
            get: function () {
    
                console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
                return this.texture.generateMipmaps;
    
            },
            set: function ( value ) {
    
                console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
                this.texture.generateMipmaps = value;
    
            }
        }
    
    } );
    
    //
    
    Object.defineProperties( Audio.prototype, {
    
        load: {
            value: function ( file ) {
    
                console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
                var scope = this;
                var audioLoader = new AudioLoader();
                audioLoader.load( file, function ( buffer ) {
    
                    scope.setBuffer( buffer );
    
                } );
                return this;
    
            }
        },
        startTime: {
            set: function () {
    
                console.warn( 'THREE.Audio: .startTime is now .play( delay ).' );
    
            }
        }
    
    } );
    
    AudioAnalyser.prototype.getData = function () {
    
        console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
        return this.getFrequencyData();
    
    };
    
    //
    
    CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {
    
        console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
        return this.update( renderer, scene );
    
    };
    
    //
    
    var GeometryUtils = {
    
        merge: function ( geometry1, geometry2, materialIndexOffset ) {
    
            console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
            var matrix;
    
            if ( geometry2.isMesh ) {
    
                geometry2.matrixAutoUpdate && geometry2.updateMatrix();
    
                matrix = geometry2.matrix;
                geometry2 = geometry2.geometry;
    
            }
    
            geometry1.merge( geometry2, matrix, materialIndexOffset );
    
        },
    
        center: function ( geometry ) {
    
            console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
            return geometry.center();
    
        }
    
    };
    
    ImageUtils.crossOrigin = undefined;
    
    ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {
    
        console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );
    
        var loader = new TextureLoader();
        loader.setCrossOrigin( this.crossOrigin );
    
        var texture = loader.load( url, onLoad, undefined, onError );
    
        if ( mapping ) texture.mapping = mapping;
    
        return texture;
    
    };
    
    ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {
    
        console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );
    
        var loader = new CubeTextureLoader();
        loader.setCrossOrigin( this.crossOrigin );
    
        var texture = loader.load( urls, onLoad, undefined, onError );
    
        if ( mapping ) texture.mapping = mapping;
    
        return texture;
    
    };
    
    ImageUtils.loadCompressedTexture = function () {
    
        console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );
    
    };
    
    ImageUtils.loadCompressedTextureCube = function () {
    
        console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );
    
    };
    
    //
    
    function CanvasRenderer() {
    
        console.error( 'THREE.CanvasRenderer has been removed' );
    
    }
    
    //
    
    function JSONLoader() {
    
        console.error( 'THREE.JSONLoader has been removed.' );
    
    }
    
    //
    
    var SceneUtils = {
    
        createMultiMaterialObject: function ( /* geometry, materials */ ) {
    
            console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );
    
        },
    
        detach: function ( /* child, parent, scene */ ) {
    
            console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );
    
        },
    
        attach: function ( /* child, scene, parent */ ) {
    
            console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );
    
        }
    
    };
    
    //
    
    function LensFlare() {
    
        console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );
    
    }
    
    if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {
    
        /* eslint-disable no-undef */
        __THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
            revision: REVISION,
        } } ) );
        /* eslint-enable no-undef */
    
    }
    
    
    
    
    /***/ }),
    
    /***/ "./node_modules/webpack/buildin/global.js":
    /*!***********************************!*\
      !*** (webpack)/buildin/global.js ***!
      \***********************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    var g;
    
    // This works in non-strict mode
    g = (function() {
        return this;
    })();
    
    try {
        // This works if eval is allowed (see CSP)
        g = g || new Function("return this")();
    } catch (e) {
        // This works if the window reference is available
        if (typeof window === "object") g = window;
    }
    
    // g can still be undefined, but nothing to do about it...
    // We return undefined, instead of nothing here, so it's
    // easier to handle this case. if(!global) { ...}
    
    module.exports = g;
    
    
    /***/ }),
    
    /***/ "./src/config.js":
    /*!***********************!*\
      !*** ./src/config.js ***!
      \***********************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    /* WEBPACK VAR INJECTION */(function(process) {
        // SERVER:
        module.exports.isNode = (typeof process !== "undefined") && (typeof process.release !== "undefined") && (process.release.name.search(/node|io.js/) !== -1);
        module.exports.isProd = module.exports.isNode ? !!process.env.IS_PROD : (location.hostname !== "127.0.0.1" && location.hostname !== "localhost" && !location.hostname.startsWith("192.168."));
        module.exports.enableHttps = module.exports.isProd || (!module.exports.isNode && localStorage.__FORCE_HTTPS__ == "true");
        module.exports.serverTickRate = (1000 / 30);
        module.exports.serverSendRate = (1000 / 10);
        module.exports.clientSendRate = (1000 / 30);
        module.exports.dltMx = Math.round(1000 / 30);
        module.exports.streamUpdate = 10000;
        module.exports.maxPlayers = 8;
        module.exports.serverSpread = 3;
        module.exports.minServerSpace = 3;
        module.exports.gamesPerServer = 3;
        module.exports.serverBrowserRate = (10 * 1000);
        module.exports.maxPlayersTotal = (module.exports.maxPlayers
            * module.exports.gamesPerServer) + 40;
        module.exports.kickTimer = 90000;
        if (module.exports.isNode) {
            module.exports.matchmakerURL = module.exports.isProd
                ? ((process.env.VULTR_SCHEME=="krunker_prod" || process.env.VULTR_SCHEME=="krunker_api")
                    ? "https://matchmaker.krunker.io"
                    : "https://matchmaker_beta.krunker.io")
                : "http://127.0.0.1:5050";
            module.exports.apiURL = module.exports.isProd
                ? (process.env.VULTR_SCHEME=="krunker_prod" || process.env.VULTR_SCHEME=="krunker_social"
                    ? "https://api.krunker.io"
                    : "https://api_beta.krunker.io")
                : "http://127.0.0.1:5060";
        } else {
            module.exports.matchmakerURL = module.exports.isProd
                ? (location.hostname=="krunker.io"
                    ? "https://matchmaker.krunker.io"
                    : "https://matchmaker_beta.krunker.io")
                : (localStorage.__MM_URL__ || "http://127.0.0.1:5050");
            module.exports.apiURL = module.exports.isProd
                ? (location.hostname=="krunker.io"
                    ? "https://api.krunker.io"
                    : "https://api_beta.krunker.io")
                : (localStorage.__API_URL__ || "http://127.0.0.1:5060");
        }
        module.exports.needsRestart = false;
        module.exports.useLooseClient = false;
        module.exports.nanConst = "_____NAN_____";
    
        // SEASONAL STUFF:
        module.exports.currentSeason = 2;
    
        // REWARDS:
        module.exports.rewardTime = 21600000;
        module.exports.rewardMinLvl = 15;
    
        // CHALLENGES:
        module.exports.chalVar = 0.03;
        module.exports.maxChal = 20;
        module.exports.minChalLevel = 30;
    
        // RANKED:
        module.exports.rankVar = 0.03;
        module.exports.eloPer = 120;
        module.exports.eloK = 32.0;
        module.exports.queues = [{
            id: "r1v1",
            name: "windows.ranked.mode.r1v1",
            maxPartySize: 1,
            key: "elo"
        }, {
            id: "r2v2",
            name: "windows.ranked.mode.r2v2",
            defaultQueue: true,
            maxPartySize: 2,
            key: "elo2"
        }, {
            id: "r4v4",
            name: "windows.ranked.mode.r4v4",
            maxPartySize: 4,
            key: "elo4"
        }];
        module.exports.minRankedLevel = 15;
        module.exports.rankedCooldown = 7200000;
        module.exports.rankedDeduction = 30;
    
        // GAME:
        module.exports.endTimer = 25000;
        module.exports.endAnim = 5000;
    
        // VOTE TO KICK:
        module.exports.voteKickReq = 4; // VOTES NEEDED TO KICK
        module.exports.voteKickMaxLvl = 10;
        module.exports.voteKickTimer = 35000;
    
        // THIRD PERSON:
        module.exports.thrdPZ = 14;
        module.exports.thrdPX = 5;
    
        // SERVER SETTINGS:
        module.exports.serverConfig = [{
            name: "Players",
            varN: "maxPlayers",
            def: 2,
            max: 10,
            maxF: 16,
            min: 1,
            step: 1
        }, {
            name: "Min Players",
            varN: "minPlayers",
            def: 0,
            max: 10,
            maxF: 16,
            min: 0,
            step: 1
        }, {
            name: "Lives",
            varN: "lives",
            def: 0,
            max: 10,
            min: 0,
            step: 1
        }, {
            name: "Minutes",
            varN: "gameTime",
            def: 4,
            max: 60,
            min: 0,
            step: 1
        }, {
            name: "Warmup",
            varN: "warmupTime",
            def: 0,
            max: 4,
            min: 0,
            step: 0.1
        }, {
            name: "Auto Respawn",
            varN: "forceSpawn",
            def: 0,
            max: 15,
            min: 0,
            step: 1
        }, {
            name: "Score Limit",
            varN: "scoreLimit",
            def: 0,
            max: 10000,
            min: 0,
            step: 100
        }, {
            name: "Gravity",
            varN: "gravMlt",
            dontChange: true,
            def: 1,
            max: 2,
            min: 0.1,
            step: 0.1
        }, {
            name: "Jump Force",
            varN: "jumpMlt",
            dontChange: true,
            def: 1,
            max: 3,
            min: 0.1,
            step: 0.1
        }, {
            name: "Hitbox Scale",
            varN: "hitBoxPad",
            dontChange: true,
            def: 1,
            max: 1,
            min: 0,
            step: 0.1
        }, {
            name: "Time Scale",
            varN: "deltaMlt",
            dontChange: true,
            def: 1,
            max: 1.5,
            min: 0.1,
            step: 0.1
        }, {
            name: "Strafe Speed",
            varN: "strafeSpd",
            dontChange: true,
            def: 1.2,
            max: 2,
            min: 1.0,
            step: 0.1
        }, {
            name: "Health Multiplier",
            varN: "healthMlt",
            dontChange: true,
            def: 1,
            max: 3,
            min: 0.1,
            step: 0.1
        }, {
            name: "Weapon Impulse",
            varN: "impulseMlt",
            dontChange: true,
            def: 1,
            max: 3,
            min: 0,
            step: 0.1
        }, {
            name: "Team 1 Name",
            varN: "nameTeam1",
            def: 'Team 1',
            hideE: true,
            input: true
        }, {
            name: "Team 2 Name",
            varN: "nameTeam2",
            def: 'Team 2',
            hideE: true,
            input: true
        }, {
            name: "Select Team",
            varN: "selTeam",
            def: false,
            bool: true
        }, {
            name: "Spectating",
            varN: "allowSpect",
            def: true,
            bool: true
        }, {
            name: "Kill Rewards",
            varN: "killRewards",
            dontChange: true,
            def: true,
            bool: true
        }, {
            name: "Headshots Only",
            varN: "headshotOnly",
            dontChange: true,
            def: false,
            bool: true
        }, {
            name: "No Secondaries",
            varN: "noSecondary",
            dontChange: true,
            def: false,
            bool: true
        }, {
            name: "Disable Streaks",
            varN: "noStreaks",
            dontChange: true,
            def: false,
            bool: true
        }, {
            name: "Sliding",
            varN: "canSlide",
            def: true,
            bool: true
        }, {
            name: "Auto Jump",
            varN: "autoJump",
            def: false,
            bool: true
        }, {
            name: "3rd Person",
            varN: "thirdPerson",
            def: false,
            bool: true
        }, {
            name: "Hide Nametags",
            varN: "nameTags",
            def: false,
            bool: true
        }, {
            name: "Health Regen",
            varN: "hpRegen",
            def: true,
            bool: true
        }, {
            name: "Disable Borders",
            varN: "disableB",
            def: false,
            bool: true
        }];
    
        // EDITOR:
        module.exports.prefabIDS = ["CUBE", "CRATE", "BARREL", "LADDER", "PLANE",
            "SPAWN_POINT", "CAMERA_POSITION", "VEHICLE", "STACK", "RAMP", "SCORE_ZONE",
            "BILLBOARD", "DEATH_ZONE", "PARTICLES", "OBJECTIVE", "TREE", "CONE",
            "CONTAINER", "GRASS", "CONTAINERR", "ACIDBARREL", "DOOR", "WINDOW",
            "FLAG", "GATE", "CHECK_POINT", "WEAPON_PICKUP", "TELEPORTER",
            "TEDDY", "TRIGGER", "SIGN", "DEPOSIT_BOX", "LIGHT_CONE", "SPECTATE_CAM",
            "SPHERE", "PLACEHOLDER", "CARDB", "PALLET"];
            //, "LIQUID"];
            //, "WATER"];
            //, "ZONE_MARKER"];
            //, "BEAM", "AI_SPAWNER"];
        module.exports.textureIDS = ["WALL", "DIRT", "FLOOR", "GRID",
            "GREY", "DEFAULT", "ROOF", "FLAG", "GRASS", "CHECK",
            "LINES", "BRICK", "LINK", "LIQUID"];
        module.exports.objectLimit = 3500;
        module.exports.objectLimitF = 6000;
        module.exports.spawnLimit = 20;
        module.exports.billboardCnt = 5;
        module.exports.signLimit = 20;
        module.exports.signTextLimit = 1500;
        module.exports.signFontMax = 120;
        module.exports.signFontMin = 10;
        module.exports.triggerLimit = 20;
        module.exports.interfaceLimit = 20;
        module.exports.gameConfig = [{
            name: "Type",
            varN: "camType",
            cat: 0,
            def: 0,
            options: ["Normal", "Top Down", "Platformer (X)", "Platformer (Z)"],
            select: true
        }, {
            name: "X Offset",
            varN: "camOffX",
            cat: 0,
            def: 0,
            max: 500,
            min: 0,
            step: 1
        }, {
            name: "Y Offset",
            varN: "camOffY",
            cat: 0,
            def: 0,
            max: 500,
            min: 0,
            step: 1
        }, {
            name: "Z Offset",
            varN: "camOffZ",
            cat: 0,
            def: 0,
            max: 500,
            min: 0,
            step: 1
        }, {
            name: "Enable Rotation",
            varN: "camRot",
            cat: 0,
            def: true,
            bool: true
        }, {
            name: "Model",
            varN: "mdl",
            cat: 1,
            def: 0,
            options: ["Normal", "Sprite"],
            select: true
        }, {
            name: "Speed X",
            varN: "speedX",
            cat: 1,
            def: 1,
            max: 3,
            min: 0,
            step: 0.1
        }, {
            name: "Speed Y",
            varN: "speedY",
            cat: 1,
            def: 1,
            max: 3,
            min: 0,
            step: 0.1
        }, {
            name: "Speed Z",
            varN: "speedZ",
            cat: 1,
            def: 1,
            max: 3,
            min: 0,
            step: 0.1
        }, {
            name: "Ladder Accel",
            varN: "ldA",
            cat: 1,
            def: 1,
            max: 5,
            min: 0.1,
            step: 0.1
        }, {
            name: "Air Accel",
            varN: "arA",
            cat: 1,
            def: 1,
            max: 3,
            min: 0.1,
            step: 0.1
        }, {
            name: "Slide Time",
            varN: "slT",
            cat: 1,
            def: 1,
            max: 3,
            min: 0.1,
            step: 0.1
        }, {
            name: "Slide Accel",
            varN: "slA",
            cat: 1,
            def: 1,
            max: 1.5,
            min: 0.1,
            step: 0.1
        }, {
            name: "Jump Cooldown",
            varN: "jpC",
            cat: 1,
            def: 1,
            max: 3,
            min: 0.1,
            step: 0.1
        }, {
            name: "Infinite Jump",
            varN: "infJ",
            cat: 1,
            def: false,
            bool: true
        }];
    
        // FOLLOW STUFF:
        module.exports.followInd = 3;
        module.exports.followURLS = [
            "https://twitter.com/officialkrunker",
            "https://www.youtube.com/channel/UCNqnu5PoPpfUfzIrFDMP_kg",
            "https://www.youtube.com/channel/UCOLc85dhRbkDdTIv179yMJw",
            "https://www.youtube.com/heyimzed"];
        // https://www.youtube.com/channel/UCFZTa6BgwwTTrr-2pPwEIpw
        // https://www.youtube.com/channel/UCMXs1RvdgXQIxt1JQFo2PWA
        // https://www.youtube.com/channel/UCCmJ2S56CnJmTWZYAKGKDFg
    
        // BIDDING SYSTEM:
        module.exports.minBid = 100;
        module.exports.billbTime = 3600000 * 3; // 3 HOURS
        module.exports.billbUpdtI = 300000;
        module.exports.bidMinLvl = 30;
        module.exports.bidEnabled = false;
    
        // WORLD:
        module.exports.gravity = 0.00015;
        module.exports.deathY = -100;
        module.exports.skyScale = 18000;
        module.exports.shadowDst = 1200;
        module.exports.shadowRes = 1024;
        module.exports.shadowOff = 0.004;
        module.exports.lightDistance = 500;
        module.exports.lightIntensity = 1.3;
        module.exports.ambIntensity = 1;
        module.exports.sunAngleX = 90;
        module.exports.sunAngleY = 54;
        module.exports.cornerPad = 1;
        module.exports.cornerScl = 2.5;
        module.exports.cornerH = 7;
        module.exports.wallH = 5;
        module.exports.wallW = 0.8;
    
        // OBJECTS:
        module.exports.propsH = ["crate", "barrel", "cone", "stack",
            "acidbarrel", "teddy"];
        module.exports.propsCPY = {
            "teddy": -3.0
        };
        module.exports.propsCP = {
            "barrel": -1.0,
            "teddy": -3.6,
            "cone": -2.0
        };
        module.exports.crateScale = 6;
        module.exports.cardbScale = 5;
        module.exports.palletScale = 6;
        module.exports.stackScale = 6;
        module.exports.teddyScale = 6;
        module.exports.barrelScale = 4;
        module.exports.acidbarrelScale = module.exports.barrelScale;
        module.exports.treeScale = 10;
        module.exports.doorScale = 5;
        module.exports.windowScale = 6;
        module.exports.coneScale = 4;
        module.exports.containerScale = 7;
        module.exports.containerrScale = module.exports.containerScale;
        module.exports.grassScale = 32;
        module.exports.vehicleScale = 20;
        module.exports.barrelMlt = 1;
        module.exports.ladderWidth = 3.2;
        module.exports.ladderScale = 0.5;
        module.exports.terrainGrid = 8;
        module.exports.maxTerrainS = 4000;
    
        // SOUND:
        module.exports.otherSoundMlt = 0.55;
    
        // PARTICLES:
        module.exports.particleIDS = ['default', 'grass'];
        module.exports.maxParticles = 100;
        module.exports.explosionRange = 200;
        module.exports.particleDist = 40;
    
        // CHAT:
        module.exports.chatMaxLength = 70;
        module.exports.chatListLength = 35;
        module.exports.chatInterval = 800;
        module.exports.voiceChatInterval = 2000;
        module.exports.voiceChatMaxLength = 0.65;
        module.exports.voiceRate = 500;
        module.exports.voiceDelay = 200;
        module.exports.invisChar = "&lrm;";
    
        // NET CODE:
        module.exports.movDirs = [];
        for (var i = 0; i < 8; ++i) {
            module.exports.movDirs.push(-Math.PI + ((i + 1) * Math.PI / 4));
        }
        module.exports.interpolation = 1.1;
        module.exports.stateHistory = 1000;
        module.exports.syncFreq = 1000;
        module.exports.pingCount = 10;
    
        // CONTROLS:
        module.exports.mouseSens = 0.0024;
        module.exports.camChaseTrn = 0.0022;
        module.exports.camChaseSpd = 0.0012;
        module.exports.camChaseSen = 0.2;
        module.exports.camChaseDst = 24;
    
        // SPECTATE:
        module.exports.specMinD = 10;
        module.exports.specMaxD = 160;
    
        // MENU:
        module.exports.menuCamDist = 200;
        module.exports.menuCamAngle = -0.5;
        module.exports.menuCamSpeed = 0.1;
    
        // WEAPON ANIMATION:
        module.exports.idleAnimS = 0.0015;
        module.exports.animMult = 1.2;
        module.exports.leanPull = 0.99;
        module.exports.leanSens = 0.05;
        module.exports.leanMax = 0.16;
        module.exports.leanPullZ = 0.99;
        module.exports.leanMltZ = 0.03;
        module.exports.bobMltY = 0.024;
        module.exports.bobMltZ = 0.02;
        module.exports.bobPullY = 0.985;
        module.exports.bobPullZ = 0.99;
        module.exports.landPull = 0.994;
        module.exports.landPullV = 0.985;
        module.exports.landOff = 0.15;
        module.exports.aimAnimMlt = 0.18;
        module.exports.aimSlow = 0.55;
        module.exports.aimJumpSlow = 0.85;
    
        // STEPS:
        module.exports.stepAnim = 0.075;
        module.exports.stepMlt = 0.25;
        module.exports.stepPull = 0.995;
    
        // PLAYER:
        module.exports.hpSegments = 7;
        module.exports.maxHealth = 100;
        module.exports.passiveInc = 500;
        module.exports.cameraHeight = 1.5;
        module.exports.playerSpeed = 0.00042;
        module.exports.slippingSpeed = 0.0003;
        module.exports.ladderSpeed = 0.035;
        module.exports.ladderDecel = 0.97;
        module.exports.slideDecel = 0.999;
        module.exports.slideTime = 350;
        module.exports.terrainSlideDecel = 0.9996;
        module.exports.groundDecel = 0.99;
        module.exports.terrainDecel = 0.99;
        module.exports.terrainSlipDecel = 0.99;
        module.exports.airSpeed = 0.000047;
        module.exports.airDecel = 0.9996;
        module.exports.jumpVel = 0.072;
        module.exports.jumpPush = 0.1;
        module.exports.decelMin = 0.0001;
        module.exports.climbHeight = 3;
        module.exports.wpnSpin = 0.018;
        module.exports.terrainSlideThreshold = 1.2;
        module.exports.terrainGravityMlt = 1.85;
        module.exports.playerSlideVelMlt = 1.2;
        module.exports.playerTerrainSlideVelMlt = 0.4;
        module.exports.playerSlippingJumpCooldown = 500;
    
        // MATERIALS:
        module.exports.materialDens = {
            "flesh": 0.2,
            "default": 0.5
        };
    
        // PLAYER NAME:
        module.exports.nameOffset = 0.6;
        module.exports.nameOffsetHat = 0.8;
        module.exports.maxNameLength = 14;
        module.exports.maxPassLength = 16;
    
        // HITREG:
        module.exports.playerHeight = 11;
        module.exports.chestWidth = 2.6;
        module.exports.chestScale = 1.3;
        module.exports.armScale = 1.3;
        module.exports.legScale = 1.3;
        module.exports.uArmLength = 2.7;
        module.exports.armInset = -0.1;
        module.exports.lArmLength = 2.7;
        module.exports.headScale = 2;
        module.exports.armOff = -0.8;
        module.exports.legHeight = 4.2;
        module.exports.playerScale = ((module.exports.armScale * 2) + (module.exports.chestWidth)
            + module.exports.armInset) / 2;
        module.exports.hitBoxPad = 1;
    
        // BULLETS:
        module.exports.tracerMinDst = 20;
        module.exports.tracerMaxDst = 500;
        module.exports.tracerChance = 1;
    
        // CROUCH:
        module.exports.crouchLean = -(Math.PI * 0.1);
        module.exports.crouchDst = 3;
        module.exports.crouchSlow = 0.3;
        module.exports.crouchSpeed = 0.007;
        module.exports.crouchJump = 0.25;
        module.exports.crouchSpread = 0.55;
        module.exports.crouchAnim = 0.0008;
        module.exports.crouchAnimMlt = 0.5;
    
        // SPREAD:
        module.exports.spreadMove = 25;
        module.exports.spreadFall = 30;
        module.exports.spreadRecover = 0.985;
        module.exports.spreadAdj = 0.00063;
        module.exports.spreadMlt = 240;
        module.exports.recoilMlt = 0.3;
    
        // OBJECTIVES:
        module.exports.flagMsg = "You have the Flag";
        module.exports.flagMsgE = "Enemy has your Flag";
        module.exports.flagMsgRC = "Enemy has your Flag";
        module.exports.flagZoneS = 24;
        module.exports.flagZoneH = 36;
        module.exports.flagScale = 12;
        module.exports.flagOff = 6;
        module.exports.flagHOff = 15;
        module.exports.flagUpdate = 2500;
    
        // PICKUP:
        module.exports.interactTimer = 100;
        module.exports.pickupZoneX = 12;
        module.exports.pickupZoneZ = 4;
        module.exports.pickupZoneH = 2;
        module.exports.pickupScale = 6;
        module.exports.pickupOff = 1;
    
        // SCORE & KILLS:
        module.exports.maxLevel = 102;
        module.exports.maxELOLevel = 8;
        module.exports.assistTime = 5000;
        module.exports.assistScore = 25;
        module.exports.assistMin = 20;
        module.exports.medalAnim = 1000;
        module.exports.medalDelay = 900;
        module.exports.scoreStreak = 2000;
        module.exports.feedTimer = 2000;
        module.exports.spinTimer = 1800;
        module.exports.endStats = ["sid", "name", "score", "kills", "deaths", "reward"];
        module.exports.endForm = {
            reward: function(val, game, pl) {
                return (val?("<span style='color:#F8C55C'>+" + val + "</span> KR"):
                    "NONE");
            }, MMR: function(val, game, pl) {
                var prev = (pl.account ? (pl.account[game.queueConfig.accountKey]||0) : 0);
                prev = (pl.ELO>=0 ? (prev - pl.ELO) : (prev + Math.abs(pl.ELO)));
                return ("<span style='color:#F8C55C'><span style='color:rgba(255, 255, 255, 0.7);'>"
                + (prev < 0 ? 0:prev).round(1) + "</span> " + (pl.ELO>=0?"+":"-")
                + Math.abs(pl.ELO.round(1)) + "</span>");
            }, time: function(val, game, pl) {
                return (pl.timer||"DNF");
            }, infected: function(val, game, pl) {
                return pl.convs;
            }, found: function(val, game, pl) {
                return pl.convs;
            }, weapon: function(val, game, pl){
                return pl.weaponTier;
            }
        };
        module.exports.hitLife = 2000;
    
        // HEALTH REGEN:
        module.exports.regenDelay = 5000;
        module.exports.regenVal = 0.1;
    
        // SPRAY:
        module.exports.sprayTimer = 1000;
        module.exports.sprayRange = 25;
        module.exports.sprayScale = 15;
    
        // DEATH ANIM:
        module.exports.deathDelay = 2800;
        module.exports.deathFollowD = 100;
    
        // MESSAGES:
        module.exports.suicides = ["uninstall life", "toaster bath",
            "alt f4", "not alive", "neck rope", "scooter ankle", "death.exe"];
    
        // TAUNTS:
        module.exports.taunts = [{
            id: "taunt_0",
            tm: 500
        }, {
            id: "taunt_1",
            tm: 1000
        }, {
            id: "taunt_2",
            tm: 2300
        }, {
            id: "taunt_3",
            tm: 3200
        }];
    
        // RENDER:
        module.exports.fov = 70;
        module.exports.viewDist = 2000;
        module.exports.nameVisRate = 200;
        module.exports.worldUV = 60;
        module.exports.ambientVal = 0.5;
        module.exports.ambD = 2;
        module.exports.ambMlt = 15;
        module.exports.ambOff = 0.09;
        module.exports.ambScale = 10;
        module.exports.ambDiv = 20;
        module.exports.ambSFactor = 1;
        module.exports.ambBleed = 0;
    
        // OBJECTS:
        module.exports.boosterSpd = 0.002;
        module.exports.boostRange = 100;
        module.exports.maxTerrainSize = 15000;
        module.exports.minTerrainSize = 0;
        module.exports.maxMountainMlt = 5;
        module.exports.minMountainMlt = 0.0;
        module.exports.maxZoneSize = 10000;
        module.exports.minZoneSize = 0;
        module.exports.maxShrinkSpeed = 10;
        module.exports.minShrinkSpeed = 1;
        module.exports.positionRange = 500000;
    
        // MAP:
        module.exports.borderH = 1000;
        module.exports.soundScapes = {
            "Default": 1,
            "City": 2,
            "Desert": 3,
            "Market": 4,
            "Scary": 5
        };
        module.exports.mapTabs = [{
            n: "Popular",
            cache: true,
            c: 27,
            t: "recent"
        }, {
            n: "New",
            cache: true,
            c: 27,
            t: "initialdate"
        }, {
            n: "My Maps",
            c: 27,
            sendID: true,
            t: "votes"
        }, {
            n: "Search",
            search: true,
            t: "votes"
        }];
    
        // MODS:
        module.exports.modTabs = [{
            n: "Hot",
            cache: true,
            c: 27,
            t: "recent"
        }, {
            n: "New",
            cache: true,
            c: 27,
            t: "initialdate"
        }, {
            n: "My Mods",
            c: 27,
            sendID: true,
            t: "votes"
        }, {
            n: "Search",
            search: true,
            t: "votes"
        }];
    
        // PREFABS:
        module.exports.prefabTabs = [{
            n: "Hot",
            cache: true,
            c: 27,
            t: "recent"
        }, {
            n: "New",
            cache: true,
            c: 27,
            t: "initialdate"
        }, {
            n: "My Prefabs",
            c: 27,
            sendID: true,
            t: "votes"
        }, {
            n: "Search",
            search: true,
            t: "votes"
        }];
    
        // MARKET:
        module.exports.saleMax = 10000000;
        module.exports.saleGrace = 300000;
        module.exports.marketMinLVl = 20;
    
        // GIFT KR:
        module.exports.giftMax = 10000000;
        module.exports.giftMin = 10;
        module.exports.giftMinLVl = 30;
    
        // STREAMS
        module.exports.streamRotation = 10000;
    
        module.exports.creatorReset = 86400000 * 7;
    
        // FEATURED CLANS:
        module.exports.verClans = ["DEV", "FaZe", "Lore", "nV",
            "Oxic", "Verb", "Omen", "ロリ幼女", "VOID", "JBP",
            "PHIL", "TIMP", "g59", "24/7", "GLXY", "MMOK", "KPOP",
            "SCTE"];
    
        // ACCOUNTS:
        module.exports.newDataInterval = 120000;
        module.exports.socials = ["leaders", "profile", "maps",
            "tourney", "market", "itemsales", "clan", "map"];
        module.exports.marketQueries = {
            market: {
                btn: "Info",
                checkItem: function(item) {
                    return (!!item.funds);
                }
            },
            inventory: {
                btn: "List to Sell",
                checkItem: function(item) {
                    return (!item.funds&&item.cnt);
                }
            },
            sales: {
                btn: "Unlist",
                checkItem: function(item) {
                    return (!!item.funds);
                }
            },
            stats: {
                btn: "Stats",
                checkItem: function(item) {
                    return (!!item.funds);
                }
            }
        };
        module.exports.leaderQueries = ["player_score", "player_elo",
            "player_elo2", "player_elo4", "player_kills",
            "player_wins", "player_timeplayed",
            "player_funds", "player_clan", "player_chal"];
        module.exports.leaderCal = {
            player_score: function(val) {
                var lvl = Math.max(1, Math.floor(module.exports.rankVar * Math.sqrt(val)));
                return ("<span class='floatR'><img src='./img/levels/" + Math.max(Math.min(
                    module.exports.maxLevel - 1, lvl.roundToNearest(2) - 1), 0) +
                    ".png' class='rnkIcon'>" + lvl + "</span>");
            },
            player_elo: function(val) {
                var lvl = Math.max(Math.min(module.exports.maxELOLevel, Math.floor((val||0)/module.exports.eloPer)), 1)-1;
                return ("<span class='floatR'><img src='./img/ranks/icon_"+lvl+".png' "
                    + "class='rnkIconR'></span>");
            },
            player_elo2: function(val) {
                var lvl = Math.max(Math.min(module.exports.maxELOLevel, Math.floor((val||0)/module.exports.eloPer)), 1)-1;
                return ("<span class='floatR'><img src='./img/ranks/icon_"+lvl+".png' "
                    + "class='rnkIconR'></span>");
            },
            player_elo4: function(val) {
                var lvl = Math.max(Math.min(module.exports.maxELOLevel, Math.floor((val||0)/module.exports.eloPer)), 1)-1;
                return ("<span class='floatR'><img src='./img/ranks/icon_"+lvl+".png' "
                    + "class='rnkIconR'></span>");
            },
            player_kills: function(val) {
                return (val + "<span class='lName'> kills</span>");
            },
            player_wins: function(val) {
                return (val + "<span class='lName'> wins</span>");
            },
            player_funds: function(val) {
                return ("<span style='color:rgba(0,0,0,0.4)'>"
                    + val.toString().replace(
                    /\B(?=(\d{3})+(?!\d))/g, ",") + "</span> KR");
            },
            player_timeplayed: function(ms) {
                var x = (ms / 1000) / 60;
                var minutes = parseInt(x % 60);
                x /= 60;
                var hours = parseInt(x % 24);
                x /= 24;
                var days = parseInt(x);
                return ((days?days+'d ':'')+(hours?hours+'h ':'')+(minutes?minutes:0)+'m ');
            },
            player_chal: function(val) {
                return Math.min(module.exports.maxChal, val+1);
            }
        };
    
        // REGIONS:
        module.exports.socialRegions = [
            'All Regions',
            'Oceania',
            'Asia',
            'Europe',
            'Americas'
        ];
        module.exports.regionNames = {
            "local": "Local",
            "us-nj": "New York",
            "us-il": "Chicago",
            "us-tx": "Dallas",
            "us-wa": "Seattle",
            "us-ca-la": "Los Angeles",
            "us-ga": "Atlanta",
            "nl-ams": "Amsterdam",
            "gb-lon": "London",
            "de-fra": "Frankfurt",
            "us-ca-sv": "Silicon Valley",
            "au-syd": "Sydney",
            "fr-par": "Paris",
            "jb-hnd": "Tokyo",
            "us-fl": "Miami",
            "sgp": "Singapore"
        };
    
        // LANGUAGES:
        module.exports.langNames = {
            "en": "English",
            "es": "Spanish",
            "de": "German",
            "kr": "Korean"
        };
    
        // SKIN COLORS:
        module.exports.skinColors = [
            0x805c4a, // Dark
            0xa77860, // Semi Dark
            0xd38d6f, // In Between
            0xcc997e, // Tan
            0xedbfa6 // Pale
        ];
    
        // CUSTOM RATIOS:
        module.exports.customRatios = [
            'Native',
            '800x600',
            '1024x768',
            '1280x960',
            '1280x1024',
            '1440x1080',
            '1656x1080'
        ];
    
        // USER REPORT OPTIONS:
        module.exports.reportOptions = [
            'Hacking',
            'Exploiting',
            'Market Manipulation',
            'Harassment',
            'Other'
        ];
    
        // LEAVE / JOIN MESSAGES
        module.exports.serverMessages = [
            "$ joined the game",
            "$ left the game",
            "$ was kicked",
            "$ was banned",
            "$ was vote kicked",
        ];
    
        // UNOBTAINABLE COLORS:
        module.exports.unObtainCols = [
            'Crimson',
            'orange',
            'yellow',
            'lime',
            'MediumBlue'
        ];
    
        // KILLCARD STATS:
        module.exports.killCardStats = [{
            'name': 'SPK',
            'stat': function (player) {
                return ((player.account.score||0) /
                    Math.max(player.account.kills||0, 1)).toFixed(2);
            }
        }, {
            'name': 'Kills',
            'stat': function (player) {
                return (player.account.kills||0);
            }
        }, {
            'name': 'Deaths',
            'stat': function (player) {
                return (player.account.deaths||0);
            }
        }, {
            'name': 'KDR',
            'stat': function (player) {
                return ((player.account.kills||0) /
                    Math.max(player.account.deaths||0, 1)).toFixed(2);
            }
        }, {
            'name': 'KPG',
            'stat': function (player) {
                return ((player.account.kills||0) /
                    Math.max(player.account.games||0, 1)).toFixed(2);
            }
        }, {
            'name': 'Games Played',
            'stat': function (player) {
                return (player.account.games||0);
            }
        }, {
            'name': 'Wins',
            'stat': function (player) {
                return (player.account.wins||0);
            }
        }, {
            'name': 'W/L',
            'stat': function (player) {
                return ((player.account.wins||0) /
                    Math.max(((player.account.games||0) -
                    (player.account.wins||0)), 1)).toFixed(2);
            }
        }, {
            'name': 'Nukes',
            'stat': function (player) {
                return (player.account.stats.n||0);
            }
        }, {
            'name': 'Melees',
            'stat': function (player) {
                return (player.account.stats.mk||0);
            }
        }, {
            'name': 'Accuracy',
            'stat': function (player) {
                return (player.account.stats.s?((player.account.stats.h||0)
                    /player.account.stats.s)*100:0).round(1) + "%";
            }
        }, {
            'name': 'KR',
            'stat': function (player) {
                return (player.account.funds||0);
            }
        }, {
            'name': 'Challenge Level',
            'stat': function (player) {
                return (player.account.chal||0) + 1;
            }
        }, {
            'name': 'Headshots',
            'stat': function (player) {
                return (player.account.stats.hs||0);
            }
        }, {
            'name': 'Solo Ranked',
            'stat': function (player) {
                return (player.account.elo||0);
            }
        }, {
            'name': 'Duo Ranked',
            'stat': function (player) {
                return (player.account.elo2||0);
            }
        }, {
            'name': 'Quad Ranked',
            'stat': function (player) {
                return (player.account.elo4||0);
            }
        }];
    
        // MAP GEN:
        /**
         * Describes how to serialize data on the map object from the map generation
         * server in order to send it to the game server with the same resulting
         * properties. If no special behavior is described (i.e. an empty object),
         * the default JSON serialization technique will be used.
         *
         * @prop {?Object} props A map of corresponding sub-properties to serialize. The objects corresponding to the properties will also use this same schema.
         * @prop {?boolean} isGameObject Determines if this is a list of `GameObject` values. If true, this will serialize the `GameObject._initData` property if `Array.isArray` is false. If `Array.isArray` is true, then this will recursively serialize the game objects as described before.
         * @prop {?boolean} isTerrainConfig Determines if this is a config for the `Terrain` object.
         * @prop {?boolean} isZoneConfig Determines if this is a config for the `Zone` object.
         */
        module.exports.mapGenProps = {
            manager: {
                props: {
                    aoOpac: {},
                    objects: { isGameObject: true },
                    objectives: {},
                    flags: { isGameObject: true },
                    pickups: { isGameObject: true },
                    gates: { isGameObject: true },
                    banks: { isGameObject: true },
                    interfaces: {},
                    teleporters: { isGameObject: true },
                    zoneMarkers: {},
                    spectateCams: { isGameObject: true, },
                }
            },
            maps: {},
            spawns: {},
            lastGen: {},
            terrainConfig: { isTerrainConfig: true },
            zoneConfig: { isZoneConfig: true },
            config: {},
            deathY: {},
            mapHeight: {},
        };
    
        /**
         * List of properties on `GameObject` that are a reference to other objects
         * game objects. The packing process will iterate through these props and
         * add the property with the given SID.
         */
        module.exports.gameObjectReferenceProps = [
            "flagObj",
        ];
    
    /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/process/browser.js */ "./node_modules/process/browser.js")))
    
    /***/ }),
    
    /***/ "./src/data/attach.js":
    /*!****************************!*\
      !*** ./src/data/attach.js ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
    // ATTACHMENTS:
    module.exports = [{
        name: "Red Dot",
        src: "attach_0",
        dotSrc: "dot_0",
        aimOffY: 0.16,
        scale: 1.2
    }];
    
    
    /***/ }),
    
    /***/ "./src/data/classes.js":
    /*!*****************************!*\
      !*** ./src/data/classes.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
        // COLORS:
        // skinColor shirtColor pantsColor shoeColor hairColor, sleeveColor
    
        // CLASSES:
        module.exports = [{
            name: "Triggerman",
            loadout: [1],
            secondary: true,
            colors: [0xa77860, 0x3d3d3d, 0x232323, 0x282828, 0x6c5042, 0xbfbfbf],
            health: 100,
            segs: 6,
            speed: 1.05
        }, {
            name: "Hunter",
            loadout: [0],
            secondary: true,
            colors: [0xa77860, 0x7b573d, 0x634732, 0x282828, 0x634732, 0x3d2b1d],
            health: 60,
            segs: 5,
            speed: 1.05
        }, {
            name: "Run N Gun",
            loadout: [3],
            colors: [0xa77860, 0x3e6382, 0x2f4b63, 0x282828, 0x634732, 0x1a2b3a],
            health: 100,
            segs: 6,
            speed: 1.18
        }, {
            name: "Spray N Pray",
            loadout: [6],
            txts: ["Calling in the Big Guns?", "Remember - No Russian.",
                "Pesky Snipers..."],
            colors: [0xa77860, 0x586849, 0x49563c, 0x282828, 0x282828, 0x303827],
            health: 170,
            segs: 7,
            regen: 0.05,
            speed: 0.95
        }, {
            name: "Vince",
            loadout: [5],
            secondary: true,
            colors: [0x805c4a, 0x545267, 0x3f3d4d, 0x282828, 0x282828, 0x292833],
            health: 100,
            segs: 6,
            speed: 1.0
        }, {
            name: "Detective",
            loadout: [4],
            colors: [0xa77860, 0x704e36, 0x434c5e, 0x282828, 0x634732, 0x3f2c1e],
            health: 100,
            segs: 6,
            speed: 1
        }, {
            name: "Marksman",
            loadout: [7],
            secondary: true,
            colors: [0xa77860, 0x586849, 0x49563c, 0x282828, 0x282828, 0x293022],
            health: 90,
            segs: 6,
            speed: 1.0
        }, {
            name: "Rocketeer",
            loadout: [8],
            secondary: true,
            txts: ["..."],
            colors: [0xa77860, 0x586849, 0x49563c, 0x282828, 0x6c5042, 0x2b3324],
            health: 130,
            segs: 7,
            speed: 0.86
        }, {
            name: "Agent",
            loadout: [9],
            colors: [0xa77860, 0x3d3d3d, 0x232323, 0x282828, 0x282828, 0xbfbfbf],
            health: 100,
            segs: 6,
            speed: 1.2
        }, {
            name: "Runner",
            txts: ["You sure about this?", "...", "Oh boy",
                "I don't know about this...", "Not me again..."],
            loadout: [12],
            colors: [0xa77860, 0x3d3d3d, 0x232323, 0x282828, 0x282828, 0x232323],
            health: 100,
            segs: 6,
            regen: 0.2,
            speed: 1.0
        }, {
            name: "Deagler",
            hide: true,
            loadout: [10],
            colors: [0xa77860, 0x3d3d3d, 0x232323, 0x282828, 0x282828, 0x232323],
            health: 60,
            segs: 5,
            speed: 1.0
        }, {
            name: "Bowman",
            loadout: [13],
            secondary: true,
            colors: [0xa77860, 0x916c52, 0x60432e, 0x282828, 0x282828, 0x473527],
            health: 100,
            segs: 6,
            speed: 1.0
        }, {
            name: "Commando",
            loadout: [14],
            secondary: true,
            colors: [0xa77860, 0x3d3d3d, 0x232323, 0x282828, 0x995C2C, 0x171717],
            health: 100,
            segs: 6,
            speed: 1.0
        }];
    
    
    /***/ }),
    
    /***/ "./src/data/colors.js":
    /*!****************************!*\
      !*** ./src/data/colors.js ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
        // GAME COLORS
        module.exports.verified = {
            clan: "#FBC02D",
            player: "#40C4FF" // SOCIAL IS #2196F3
        };
        module.exports.challLvl = [];
        module.exports.getChallCol = function(lvl, social) {
            if (lvl > 20) return "#fb2d2d";
            else if (lvl > 15) return "#c12dfb";
            else if (lvl > 10) return "#fb942d";
            return social ? false : "white";
        };
        module.exports.damage = "#DE292F";
        module.exports.critical = "#FFD542";
        module.exports.ready = "#32CD32";
        module.exports.crosshair = {
            background: "#ffffff",
            shadow: "#000000"
        };
        module.exports.hudHealth = {
            low: '#eb5656',
            high: '#9eeb56'
        };
        module.exports.popupScore = '#ffea78';
        module.exports.ping = {
            low: '#9eeb56',
            medium: '#ffd542',
            high: '#ff4b42'
        };
        module.exports.teams = [
            '#9eeb56',
            '#eb5656',
        ];
        module.exports.creationDate = {
            new: "#0a61f7",
            recent: "#E040FB",
            old: "#ed4242"
        };
        module.exports.matchVote = {
            selected: "rgba(251, 192, 45, 1)",
            notSelected: "rgba(255, 255, 255, 0.7)"
        };
        module.exports.killFeed = {
            enemy: "#eb5656",
            ally: "#9eeb56",
            you: "#fff"
        };
        module.exports.interactPopup = {
            key: "#FBC02D",
            enough: "#9eeb56",
            notEnough: "#eb5656"
        };
        module.exports.modeSpecific = {
            infected: {
                skin: 0x596151
            },
            stalker: {
                skin: 0x000000,
                body: [
                    0x000000,
                    0x000000,
                    0x000000,
                    0x000000,
                    0x000000,
                    0x000000
                ]
            }
        };
        module.exports.zones = {
            BR: [
                '#c542d9',
                '#c542d9',
                '#c542d9'
            ],
            sky: [
                '#74a4b9',
                '#dce8ed',
                '#dce8ed'
            ]
        };
    
    
    /***/ }),
    
    /***/ "./src/data/kills.js":
    /*!***************************!*\
      !*** ./src/data/kills.js ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
    // KILL FEEDS:
    var feeds = ["Double Kill", "Triple Kill", "Quad Kill",
        "Multi Kill", "Mega Kill", "Ultra Kill", "Super Kill"];
    
    // KILL REWARD:
    var tmpList = [];
    module.exports.reward = function(manager, player, killed, killInfo, game) {
        tmpList.length = 0;
        var playerWep = killInfo.weapon!=undefined?killInfo.weapon:player.weapon;
    
        if (game.mode.weaponOrder) {
            if (playerWep.melee) tmpList.push("Humiliation", null);
            else tmpList.push("Promotion", 1);
        } else {
    
            // FIRST BLOOD:
            if (game.kills <= 1) {
                tmpList.push("First Blood", 25);
                player.firstblood++;
            }
    
            // MELEE:
            if (playerWep.melee) tmpList.push("Execution", 150);
    
            else {
    
                // SPECIAL KILL:
                if (playerWep.kill) tmpList.push(playerWep.kill[0],
                    playerWep.kill[1]);
    
                // NO SCOPE:
                else if (playerWep.scope && player.aimVal == 1) {
                    tmpList.push("No Scope", 100);
                    player.noscopes++;
                }
    
                // NORMAL WEAPON:
                else if (!playerWep.scope || ((player.aimVal == 0 && player.aimTime > 180)
                     || player.aimDir == 1)) tmpList.push("", 50);
    
                // QUICKSCOPE:
                else {
                    tmpList.push("Quick Scope", 75);
                    player.quickscopes++;
                }
    
                // SPIN SHOTS:
                // var spinVal = manager.getSpin(player);
                // if (!playerWep.nSkill) {
                // 	if (spinVal >= 360) tmpList.push("360!", 150);
                // }
    
                // HEADSHOT:
                if (killInfo.headShot) tmpList.push("Headshot", 50);
    
                // WALLBANG
                if (killInfo.wallbang) tmpList.push("Wallbang", 25);
    
                // LONGSHOT:
                if (!playerWep.scope && killInfo.dst * playerWep.range > 200) {
                    tmpList.push("Longshot", 25);
                    player.longshots++;
                }
    
            }
    
            // FLAG CARRIER:
            if (killed.flag) tmpList.push("Snatched", 50);
    
            // CLOSE CALL:
            if (player.health <= player.maxHealth * 0.2 && player.active) {
                tmpList.push("Close Call", 20);
                player.closecalls++;
            }
    
            // COMEBACK:
            if (player.deathStreak >= 3) tmpList.push("Comeback", 25);
    
            // STREAK ENDER BONUS:
            if (killed.killStreak >= 10) tmpList.push("Buzzkill", 25);
            else if (killed.killStreak >= 5) tmpList.push("Buzzkill", 10);
    
            // SLIDE KILL:
            if (player.slideTimer > 0) {
                tmpList.push("Driftkill", 50);
                player.driftkills++;
            }
    
            // AIR KILL:
            if (player.airTime >= 400) {
                tmpList.push("Mid Air", 25);
                player.airKills++;
            }
    
            // KILL FEED:
            for (var i = feeds.length - 1; i >= 0; --i) {
                if (player.streak > i) {
                    tmpList.push(feeds[i], (i + 1) * 50);
                    break;
                }
            }
            
        }
    
        return tmpList.length?tmpList:null;
    };
    
    // CALC SCORE:
    module.exports.getScore = function(killData) {
        var tmpScore = null;
        if (killData) for (var i = 1; i < killData.length; i+=2) {
            if (killData[i]) tmpScore += killData[i];
        }
        return tmpScore;
    };
    
    
    /***/ }),
    
    /***/ "./src/data/map.js":
    /*!*************************!*\
      !*** ./src/data/map.js ***!
      \*************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    /* WEBPACK VAR INJECTION */(function(process) {
    // IMPORT:
    const config = __webpack_require__(/*! ../config.js */ "./src/config.js");
    const Terrain = __webpack_require__(/*! ../libs/Terrain.js */ "./src/libs/Terrain.js");
    const Zone = __webpack_require__(/*! ../libs/Zone.js */ "./src/libs/Zone.js");
    const WEAPONS = __webpack_require__(/*! ../data/weapons.js */ "./src/data/weapons.js");
    const Triggers = __webpack_require__(/*! ../data/triggers.js */ "./src/data/triggers.js");
    const MODES = __webpack_require__(/*! ../data/modes.js */ "./src/data/modes.js");
    const axios = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
    const fs = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js");
    const GameObject = __webpack_require__(/*! ./objects.js */ "./src/data/objects.js").GameObject;
    const errors = __webpack_require__(/*! ../libs/errors.js */ "./src/libs/errors.js");
    
    // GET API KEY:
    var apiKey;
    if (config.isNode) {
        const fs = __webpack_require__(/*! fs */ "./node_modules/node-libs-browser/mock/empty.js");
        const path = __webpack_require__(/*! path */ "./node_modules/node-libs-browser/mock/empty.js");
        apiKey = fs.readFileSync(path.join(process.cwd(), "apikey.txt"), "utf8");
    }
    
    // MODES
    var rotationModes = [0, 1, 2, 3, 16];
    
    // MAP DATA:
    // javascript-obfuscator:disable
    var maps = [
        __webpack_require__(/*! ../../maps/burg.json */ "./maps/burg.json"),
        __webpack_require__(/*! ../../maps/littletown.json */ "./maps/littletown.json"),
        __webpack_require__(/*! ../../maps/sandstorm.json */ "./maps/sandstorm.json"),
        __webpack_require__(/*! ../../maps/subzero.json */ "./maps/subzero.json"),
        __webpack_require__(/*! ../../maps/undergrowth.json */ "./maps/undergrowth.json"),
        __webpack_require__(/*! ../../maps/shipyard.json */ "./maps/shipyard.json"),
        __webpack_require__(/*! ../../maps/freight.json */ "./maps/freight.json"),
        __webpack_require__(/*! ../../maps/kanji.json */ "./maps/kanji.json"),
        __webpack_require__(/*! ../../maps/lostworld.json */ "./maps/lostworld.json")
    ];
    for (var i = 0; i < maps.length; ++i) {
        for (var x = 0; x < maps[i].objects.length; ++x) {
            maps[i].objects[x].i = config.prefabIDS[maps[i].objects[x].i||maps[i].objects[x].id||0];
            maps[i].objects[x].t = config.textureIDS[maps[i].objects[x].t||(maps[i].objects[x].i == "LADDER" ? 2:0)];
        }
    }
    module.exports.maps = maps;
    
    // MAP MANAGER:
    module.exports.manager = function(RENDER, PARTICLES, UTILS, config) {
    
        // INIT:
        this.manager = new (__webpack_require__(/*! ./objects.js */ "./src/data/objects.js")).manager(RENDER, UTILS, config);
        this.maps = maps;
        this.modes = MODES;
        this.rotationModes = rotationModes;
        this.rotationMaps = [0, 1, 2, 3, 4, 6, 7, 8];
        this.spawns = [];
        this.lastGen = null;
        this.terrain = null;
        this.zone = null;
        this.deathY = config.deathY;
        this.mapHeight = 0;
        var tmpObj, tmpObj2;
    
        // SET MAPS:
        this.setMaps = function(mps) {
            this.maps = (mps||maps);
        };
    
        // GET RANDOM MAP:
        this.getRandomMap = function() {
            return UTILS.randInt(0, this.maps.length - 1);
        };
    
        // OFFLOAD GENERATE:
        this.asyncGenerate = function(index, mode, force) {
            // TEST CACHE:
            var tmpIndx = generateMapIndex(index, mode);
            if (!force && this.lastGen === tmpIndx) {
                this.finishGenerate();
                return Promise.resolve();
            }
    
            // BUILD REQUEST BODY:
            var body = {
                maps: this.maps,
                generate: { index, mode, force },
            };
    
            // MAKE REQUEST:
            return axios.post("http://0.0.0.0:5080/generate?key=" + apiKey, body, {
                transformResponse: (res) => {
                    try {
                        return JSON.parse(res, function(k, v) {
                            // DESERIALIZE NAN:
                            if (v == config.nanConst) {
                                return NaN;
                            } else {
                                return v;
                            }
                        });
                    } catch (err) {
                        errors.warn("Failed to generate map", { err: err+"", res });
                        throw err;
                    }
                },
                responseType: "json",
            }).then(res => {
                var response = res.data;
    
                // BUILD CONTEXT:
                var unpackCtx = {
                    gameObjects: {},
                };
    
                // UNPACK GAME OBJECTS:
                for (var sid in response._ctx.gameObjects) {
                    var data = response._ctx.gameObjects[sid];
                    var go = new GameObject(data, parseInt(sid), false);
                    unpackCtx.gameObjects[sid] = go;
                }
    
                // UNPACK GAME OBJECTS:
                for (var sid in response._ctx.gameObjects) {
                    var data = response._ctx.gameObjects[sid];
                    var go = new GameObject(data, parseInt(sid), false);
                    unpackCtx.gameObjects[sid] = go;
                }
    
                // ADD GAME OBJECT REFERENCES:
                for (var sid in unpackCtx.gameObjects) {
                    var data = response._ctx.gameObjects[sid];
                    var go = unpackCtx.gameObjects[sid];
    
                    // CHECK IF ANY PROPERTIES REFERENCE GAME OBJECT SIDS:
                    for (var refProp of config.gameObjectReferenceProps) {
                        if (typeof data[refProp] == "number") {
                            // LOOKUP GAME OBJECT FOR THE GIVEN SID:
                            go[refProp] = unpackCtx.gameObjects[data[refProp]];
                        }
                    }
                }
    
                // UNPACK INTO MANAGER:
                unpackObject(unpackCtx, response, config.mapGenProps, this);
            });
        };
    
        // GENERATE:
        var lastMod = "";
        this.generate = function(index, mode, force) {
            var tmpMap = this.maps[index];
            tmpMap.game = tmpMap.game||{};
            this.config = {};
            for (var i = 0; i < config.gameConfig.length; ++i) {
                var tmpO = config.gameConfig[i];
                if (tmpO.bool) {
                    if (tmpMap.game[tmpO.varN] == undefined) this.config[tmpO.varN] = tmpO.def;
                    else this.config[tmpO.varN] = (!!tmpMap.game[tmpO.varN]);
                } else if (tmpO.input) {
                    var tmpD = tmpMap.game[tmpO.varN];
                    if (!UTILS.isString(tmpD)) tmpD = tmpO.def;
                    this.config[tmpO.varN] = UTILS.sanitizeStr(tmpD);
                    if (tmpD.length > 16) tmpD = tmpD.substring(0, 16);
                } else if (tmpO.select) {
                    if (tmpO.options[tmpMap.game[tmpO.varN]] == undefined) this.config[tmpO.varN] = tmpO.def;
                    else this.config[tmpO.varN] = parseInt(tmpMap.game[tmpO.varN]);
                } else {
                    var tmpD = tmpMap.game[tmpO.varN];
                    if (!UTILS.isNumber(tmpD)) tmpD = tmpO.def;
                    this.config[tmpO.varN] = UTILS.limitMM(tmpD, tmpO.min, tmpO.max);
                }
            }
    
            // CONFIG CHANGES
            if (tmpMap.dthY != undefined && UTILS.isNumber(tmpMap.dthY)) {
                this.deathY = tmpMap.dthY;
            } else {
                this.deathY = config.deathY;
            }
    
            // UPDATE UI:
            if (RENDER) {
                try {
                    mapInfo.innerHTML = (mode.alias + "_" + tmpMap.name);
                    gameMessage.innerHTML = specGMessage.innerHTML = "";
                    curGameInfo.innerHTML = mode.name + "<div style='color:rgba(255,255,255,0.6)'>on "
                        + tmpMap.name + "</div>" + (tmpMap.creator?"<div style='color:#fff'>"
                        + "<span style='color:rgba(255,255,255,0.6)'>by</span> " + tmpMap.creator + "</div>":"");
                    specGameInfo.innerHTML = mode.name;
                } catch (e) {}
            }
    
            // LOAD MOD:
            if (RENDER && lastMod != tmpMap.modURL) {
                lastMod = tmpMap.modURL;
                if (lastMod && lastMod != "") loadModPack(lastMod, true);
            }
    
            // INIT & RESET:
            var tmpIndx = generateMapIndex(index, mode);
            if (force || this.lastGen !== tmpIndx) {
                this.lastGen = tmpIndx;
                this.manager.removeAll();
                if (RENDER) RENDER.init(tmpMap, mode);
                if (PARTICLES) {
                    PARTICLES.reset();
                    RENDER.scene.add(PARTICLES.ExplosionManager);
                };
    
                // TERRAIN:
                if (tmpMap.terrainSeed && tmpMap.terrainWidth && tmpMap.terrainHeight) {
                    // BUILD CONFIG:
                    this.terrainConfig = UTILS.extractProperties(tmpMap, Terrain.CONFIG_PROPS);
    
                    // GENERATE TERRAIN:
                    this.terrain = Terrain.fromConfig(this.terrainConfig);
                    this.terrain.rotation.x = -Math.PI / 2;
                    if (RENDER) RENDER.scene.add(this.terrain);
                } else this.terrain = null;
    
                // ZONE:
                if (tmpMap.zone && tmpMap.zoneSize && tmpMap.zoneSpeed) {
                    // BUILD CONFIG:
                    this.zoneConfig = UTILS.extractProperties(tmpMap, Zone.CONFIG_PROPS);
    
                    // GENERATE ZONE:
                    this.zone = Zone.fromConfig(this.zoneConfig, RENDER);
                    if (RENDER) RENDER.scene.add(this.zone);
                } else this.zone = null;
    
                // MAP SIZE:
                var lowX = 0;
                var highX = 0;
                var lowZ = 0;
                var highZ = 0;
                var highY = 0;
    
                // OBJECTS:
                for (var i = 0; i < tmpMap.objects.length; ++i) {
                    tmpObj = tmpMap.objects[i];
                    var tX = UTILS.limit(tmpObj.p[0], config.positionRange);
                    var tY = UTILS.limit(tmpObj.p[1], config.positionRange);
                    var tZ = UTILS.limit(tmpObj.p[2], config.positionRange);
                    var textureFix = (tmpObj.t.toLowerCase() + "_" + (tmpObj.t == "GRASS" ? 1:0));
                    if (!(tmpObj.l||tmpObj.col) && tmpObj.i == "CUBE") {
                        if (tX - tmpObj.s[0] < lowX) lowX = (tX - tmpObj.s[0]);
                        if (tX + tmpObj.s[0] > highX) highX = (tX + tmpObj.s[0]);
                        if (tZ - tmpObj.s[2] < lowZ) lowZ = (tZ - tmpObj.s[2]);
                        if (tZ + tmpObj.s[2] > highZ) highZ = (tZ + tmpObj.s[2]);
                        if (tY + tmpObj.s[1] > highZ) highY = (tY + tmpObj.s[1]);
                    }
                    if (tmpObj.i == "CUBE") {
                        var hasBase = 1;
                        var amb = 0;
                        for (var x = 0; x < tmpMap.objects.length; ++x) {
                            tmpObj2 = tmpMap.objects[x];
                            if ((tmpObj2.i == "CUBE") && tmpObj != tmpObj2 &&
                                tY <= tmpObj2.p[1] + tmpObj2.s[1] && tY >= tmpObj2.p[1] &&
                                tX + (tmpObj.s[0] / 2) < tmpObj2.p[0] + (tmpObj2.s[0] / 2) &&
                                tX - (tmpObj.s[0] / 2) > tmpObj2.p[0] - (tmpObj2.s[0] / 2) &&
                                tZ + (tmpObj.s[2] / 2) < tmpObj2.p[2] + (tmpObj2.s[2] / 2) &&
                                tZ - (tmpObj.s[2] / 2) > tmpObj2.p[2] - (tmpObj2.s[2] / 2)) {
                                hasBase = 0;
                                break;
                            }
                        } this.manager.addBlock(tX, tY, tZ, tmpObj.s[0], tmpObj.s[2], tmpObj.s[1],
                            [(tmpObj.f && tmpObj.f[0] != undefined ? tmpObj.f[0] : 1),
                            (tmpObj.f && tmpObj.f[1] != undefined ? tmpObj.f[1] : 1),
                            (tmpObj.f && tmpObj.f[2] != undefined ? tmpObj.f[2] : 1),
                            hasBase ? (tmpObj.f && tmpObj.f[3] != undefined ? tmpObj.f[3] : 1) : 0,
                            (tmpObj.f && tmpObj.f[4] != undefined ? tmpObj.f[4] : 1),
                            (tmpObj.f && tmpObj.f[5] != undefined ? tmpObj.f[5] : 1)], {
                                src: textureFix,
                                colr: tmpObj.c,
                                emissive: (tmpObj.e||null),
                                opacity: (tmpObj.o!=1&&tmpObj.o!=undefined?tmpObj.o:1),
                                transparent: (tmpObj.o!=1&&tmpObj.o!=undefined?true:false),
                                penetrable: tmpObj.pe,
                                health: tmpObj.h||tmpObj.hp,
                                respawnT: parseFloat(tmpObj.rt) * 1000,
                                respawnR: (tmpObj.rr!=undefined),
                                amb: (tmpMap.nAmb||(tmpObj.ab!=undefined)?null:config.ambientVal),
                                yR: (tmpObj.r?tmpObj.r[0]:0),
                                xR: (tmpObj.r?tmpObj.r[1]:0),
                                zR: (tmpObj.r?tmpObj.r[2]:0),
                                noCol: (tmpObj.l||tmpObj.col),
                                isBorder: tmpObj.bo,
                                noVis: tmpObj.v,
                                  movT: tmpObj.ts!=undefined?tmpObj.ts/10000:false,
                                movD: tmpObj.td,
                                noAmb: (tmpObj.ab!=undefined),
                                interface: parseInt(tmpObj.in)||null
                            });
                    } else if (tmpObj.i == "SPHERE") {
                        this.manager.addSphere(tX, tY, tZ, tmpObj.s[0], tmpObj.s[2], tmpObj.s[1], {
                            src: textureFix,
                            colr: tmpObj.c,
                            emissive: (tmpObj.e||null),
                            opacity: (tmpObj.o!=1&&tmpObj.o!=undefined?tmpObj.o:1),
                            transparent: (tmpObj.o!=1&&tmpObj.o!=undefined?true:false),
                            amb: (tmpMap.nAmb||(tmpObj.ab!=undefined)?null:config.ambientVal),
                            yR: (tmpObj.r?tmpObj.r[0]:0),
                            xR: (tmpObj.r?tmpObj.r[1]:0),
                            zR: (tmpObj.r?tmpObj.r[2]:0),
                            noVis: tmpObj.v,
                            movT: tmpObj.ts!=undefined?tmpObj.ts/10000:false,
                            movD: tmpObj.td,
                            noAmb: (tmpObj.ab!=undefined)
                        });
                    } else if (tmpObj.i == "GATE") {
                        this.manager.addGate(tX, tY, tZ, tmpObj.s[0], tmpObj.s[2], tmpObj.s[1], {
                            src: textureFix,
                            colr: tmpObj.c,
                            emissive: (tmpObj.e||null),
                            opacity: (tmpObj.o!=1&&tmpObj.o!=undefined?tmpObj.o:1),
                            transparent: (tmpObj.o!=1&&tmpObj.o!=undefined?true:false),
                            penetrable: tmpObj.pe,
                            amb: (tmpMap.nAmb||(tmpObj.ab!=undefined)?null:config.ambientVal),
                            yR: (tmpObj.r?tmpObj.r[0]:0),
                            xR: (tmpObj.r?tmpObj.r[1]:0),
                            zR: (tmpObj.r?tmpObj.r[2]:0),
                            isBorder: tmpObj.bo,
                            noVis: tmpObj.v,
                            movT: tmpObj.ts!=undefined?tmpObj.ts/10000:false,
                            movD: tmpObj.td,
                            noAmb: (tmpObj.ab!=undefined),
                            scoreP: parseInt(tmpObj.sp)||0,
                            noMsg: (tmpObj.nm!=undefined),
                            method: parseInt(tmpObj.md)||0,
                            closeable: (tmpObj.cl!=undefined),
                            startClosed: (tmpObj.stc!=undefined),
                            interface: parseInt(tmpObj.in)||null
                        });
                    } else if (tmpObj.i == "TRIGGER") {
                        this.manager.addTrigger(tX, tY, tZ, tmpObj.s[0], tmpObj.s[2], tmpObj.s[1], {
                            src: textureFix,
                            colr: tmpObj.c,
                            emissive: (tmpObj.e||null),
                            opacity: (tmpObj.o!=1&&tmpObj.o!=undefined?tmpObj.o:1),
                            transparent: (tmpObj.o!=1&&tmpObj.o!=undefined?true:false),
                            health: tmpObj.h||tmpObj.hp,
                            respawnT: parseFloat(tmpObj.rt) * 1000,
                            respawnR: (tmpObj.rr!=undefined),
                            amb: (tmpMap.nAmb||(tmpObj.ab!=undefined)?null:config.ambientVal),
                            yR: (tmpObj.r?tmpObj.r[0]:0),
                            xR: (tmpObj.r?tmpObj.r[1]:0),
                            zR: (tmpObj.r?tmpObj.r[2]:0),
                            noVis: tmpObj.v,
                            movT: tmpObj.ts!=undefined?tmpObj.ts/10000:false,
                            movD: tmpObj.td,
                            noAmb: (tmpObj.ab!=undefined),
                            constant: parseInt(tmpObj.tc)||0,
                            event: parseInt(tmpObj.te)||0,
                            eventN: Triggers.events[parseInt(tmpObj.te)||0],
                            action: parseInt(tmpObj.ta)||0,
                            interface: parseInt(tmpObj.in)||null,
                            interfaceT: parseInt(tmpObj.tin)||null
                        });
                    } else if (tmpObj.i == "DEPOSIT_BOX") {
                        this.manager.addBank(tX, tY, tZ, tmpObj.s[0], tmpObj.s[2], tmpObj.s[1], {
                            src: textureFix,
                            colr: tmpObj.c,
                            emissive: (tmpObj.e||null),
                            opacity: (tmpObj.o!=1&&tmpObj.o!=undefined?tmpObj.o:1),
                            transparent: (tmpObj.o!=1&&tmpObj.o!=undefined?true:false),
                            penetrable: tmpObj.pe,
                            amb: (tmpMap.nAmb||(tmpObj.ab!=undefined)?null:config.ambientVal),
                            yR: (tmpObj.r?tmpObj.r[0]:0),
                            xR: (tmpObj.r?tmpObj.r[1]:0),
                            zR: (tmpObj.r?tmpObj.r[2]:0),
                            isBorder: tmpObj.bo,
                            noVis: tmpObj.v,
                            movT: tmpObj.ts!=undefined?tmpObj.ts/10000:false,
                            movD: tmpObj.td,
                            noAmb: (tmpObj.ab!=undefined),
                            interface: parseInt(tmpObj.in)||null,
                            withdraw: tmpObj.wd!=undefined ? (parseInt(tmpObj.wd)||0):1000,
                            deposit: tmpObj.dp!=undefined ? (parseInt(tmpObj.dp)||0):1000,
                        });
                    } else if (tmpObj.i == "LIGHT_CONE") {
                        this.manager.addLightCone(tX, tY, tZ, tmpObj.s[0], tmpObj.s[2], tmpObj.s[1], {
                            colr: tmpObj.c,
                            opacity: (tmpObj.o!=1&&tmpObj.o!=undefined?tmpObj.o:1),
                            yR: (tmpObj.r?tmpObj.r[0]:0),
                            xR: (tmpObj.r?tmpObj.r[1]:0),
                            zR: (tmpObj.r?tmpObj.r[2]:0),
                            noVis: tmpObj.v
                        });
                    } else if (tmpObj.i == "OBJECTIVE") {
                        this.manager.addObjective(tX, tY, tZ, tmpObj.s[0],
                            tmpObj.s[2], tmpObj.s[1], (tmpObj.obi||0));
                    } else if (tmpObj.i == "FLAG") {
                        this.manager.addFlag(tX, tY, tZ, (parseInt(tmpObj.tm||0)+1));
                    } else if (tmpObj.i == "WEAPON_PICKUP") {
                        this.manager.addWeapon(tX, tY, tZ, {
                            scoreP: parseInt(tmpObj.sp)||0,
                            noMsg: (tmpObj.nm!=undefined),
                            method: parseInt(tmpObj.md)||0,
                            noRep: tmpObj.wr,
                            weapon: WEAPONS[parseInt(tmpObj.w||tmpObj.wid||0)],
                            weaponId: parseInt(tmpObj.w||tmpObj.wid||0)
                        }, (tmpObj.r?tmpObj.r[2]:0), (tmpObj.r?tmpObj.r[0]:0), (tmpObj.r?tmpObj.r[1]:0));
                    } else if (tmpObj.i == "PARTICLES") {
                        if (PARTICLES) PARTICLES.area(tX, tY, tZ, tmpObj.s[0], tmpObj.s[1], tmpObj.s[2], {
                            txt: parseInt(tmpObj.pr)||0,
                            spd: parseInt(tmpObj.psp)||0,
                            decl: parseInt(tmpObj.pd)||1,
                            cnt: parseInt(tmpObj.pc)||0,
                            grav: parseInt(tmpObj.pg)||0,
                            scl: parseInt(tmpObj.psc)||1,
                            siz: parseInt(tmpObj.ps)||1,
                            dir: (tmpObj.d||0),
                            colr: tmpObj.c
                        });
                    } else if (tmpObj.i == "PLANE" || tmpObj.i == "BILLBOARD") {
                        this.manager.addPlane(tX, tY, tZ, tmpObj.s[2] / 2, tmpObj.s[0] / 2, {
                            src: ((tmpObj.i == "BILLBOARD")?("pubs/b_"
                                + (tmpObj.bb||UTILS.randInt(1, config.billboardCnt))):
                                textureFix),
                            scale: (tmpObj.i == "PLANE" ? 2 : 0),
                            emissive: (tmpObj.e||null),
                            noise: (tmpObj.en||0),
                            opacity: (tmpObj.o!=1&&tmpObj.o!=undefined?tmpObj.o:1),
                            penetrable: tmpObj.pe,
                            transparent: (tmpObj.o!=1&&tmpObj.o!=undefined?true:false),
                            health: tmpObj.h||tmpObj.hp,
                            respawnT: parseFloat(tmpObj.rt) * 1000,
                            respawnR: (tmpObj.rr!=undefined),
                            colr: tmpObj.c,
                            noCol: (tmpObj.l||tmpObj.col),
                            noVis: tmpObj.v,
                            side: tmpObj.i == "BILLBOARD" ? 2:0,
                            movT: tmpObj.ts!=undefined?tmpObj.ts/10000:false,
                            movD: tmpObj.td,
                            noAmb: (tmpObj.ab!=undefined),
                            interface: parseInt(tmpObj.in)||null,
                            showAd: (tmpObj.sad!=undefined),
                            text: null
                        }, (tmpObj.r?tmpObj.r[2]:0), (tmpObj.r?tmpObj.r[0]:0) - Math.PI / 2, (tmpObj.r?tmpObj.r[1]:0));
                    // } else if (tmpObj.i == "LIQUID") {
                    // 	this.manager.addLiquid(tX, tY, tZ, tmpObj.s[2] / 2, tmpObj.s[0] / 2, {
                    // 		src: textureFix,
                    // 		emissive: (tmpObj.e||null),
                    // 		opacity: (tmpObj.o!=1&&tmpObj.o!=undefined?tmpObj.o:1),
                    // 		colr: tmpObj.c,
                    // 		noVis: tmpObj.v,
                    // 		movT: tmpObj.ts!=undefined?tmpObj.ts/10000:false,
                    // 		movD: tmpObj.td,
                    // 		noAmb: (tmpObj.ab!=undefined),
                    // 		wHeight: parseFloat(tmpObj.wh)||0.5,
                    // 		wSpeed: parseFloat(tmpObj.ws)||10
                    // 	}, (tmpObj.r?tmpObj.r[2]:0), (tmpObj.r?tmpObj.r[0]:0) - Math.PI / 2, (tmpObj.r?tmpObj.r[1]:0), PARTICLES);
                    } else if (tmpObj.i == "SIGN") {
                        this.manager.addCanvas(tX, tY, tZ, tmpObj.s[2] / 2, tmpObj.s[0] / 2, {
                            noCol: (tmpObj.l||tmpObj.col),
                            fontSize: parseInt(tmpObj.sf)||10,
                            text: tmpObj.st,
                            tAlign: parseInt(tmpObj.sa)||0,
                            fcolr: tmpObj.sc,
                            bcolr: tmpObj.sb,
                            noBVis: tmpObj.bv,
                            movT: tmpObj.ts!=undefined?tmpObj.ts/10000:false,
                            movD: tmpObj.td,
                        }, (tmpObj.r?-tmpObj.r[2]:0), (tmpObj.r?tmpObj.r[0]:0) - Math.PI / 2, (tmpObj.r?tmpObj.r[1]:0));
                    } else if (tmpObj.i == "SPECTATE_CAM") {
                        this.manager.addSpectateCam(tX, tY, tZ, {
                            objLink: (tmpObj.obi||0),
                            yR: (tmpObj.r?tmpObj.r[0]:0),
                            xR: (tmpObj.r?tmpObj.r[1]:0),
                            zR: (tmpObj.r?tmpObj.r[2]:0)
                        });
                        //}, (tmpObj.r?-tmpObj.r[2]:0), (tmpObj.r?tmpObj.r[0]:0) - Math.PI / 2, (tmpObj.r?tmpObj.r[1]:0));
                    // } else if (tmpObj.i == "AI_SPAWNER") {
                    // 	this.manager.addAI(tX, tY, tZ, {
                    // 		classIndx: parseInt(tmpObj.ci)||0,
                    // 		respawnT: parseFloat(tmpObj.rt) * 1000,
                    // 		respawnR: (tmpObj.rr!=undefined),
                    // 		skill: parseInt(tmpObj.sk)||0,
                    // 		hpMlt: parseInt(tmpObj.hm)||1,
                    // 		dir: (tmpObj.d||0) * Math.PI / 2
                    // 	}, (tmpObj.d||0) * Math.PI / 2);
                    // } else if (tmpObj.i == "ZONE_MARKER") {
                    // 	this.manager.addZoneMarker(tX, tY, tZ);
                    } else if (tmpObj.i == "RAMP") this.manager.addRamp(tX, tY, tZ, tmpObj.s[0], tmpObj.s[1],
                        tmpObj.s[2], (tmpObj.d||0) * Math.PI / 2, tmpObj.b, tmpObj.t?textureFix:"grey_0",
                        tmpObj.v, tmpObj.c, config.ambScale, tmpObj.ts!=undefined?tmpObj.ts/10000:false,
                        tmpObj.td, (tmpObj.ab!=undefined), (tmpObj.e||null));
                    else if (tmpObj.i == "SCORE_ZONE") this.manager.addScoreZone(tX, tY, tZ,
                        tmpObj.s[0], tmpObj.s[2], tmpObj.s[1], parseInt(tmpObj.sp)||1);
                    else if (tmpObj.i == "DEATH_ZONE") this.manager.addDeathZone(tX, tY, tZ,
                        tmpObj.s[0], tmpObj.s[2], tmpObj.s[1]);
                    else if (tmpObj.i == "CHECK_POINT") this.manager.addCheckPoint(tX, tY, tZ,
                        tmpObj.s[0], tmpObj.s[2], tmpObj.s[1], tmpObj.su||false, (tmpObj.d||0));
                    else if (tmpObj.i == "TELEPORTER") this.manager.addTeleporter(tX, tY, tZ,
                        tmpObj.s[0], tmpObj.s[2], tmpObj.s[1], parseInt(tmpObj.ch||0), parseInt(tmpObj.n||0), tmpObj.m!=undefined?true:false);
                    else if (tmpObj.i == "LADDER") this.manager.addLadder(tX, tY, tZ,
                        tmpObj.s[1], (tmpObj.d||0) * Math.PI / 2, tmpObj.v, tmpObj.t?textureFix:"floor_0", tmpObj.c);
                    else this.manager.addMesh(tX, tY, tZ, tmpObj.r, tmpObj.s[0] / 2,
                        tmpObj.s[1] / 2, tmpObj.s[2] / 2, {
                        src: tmpObj.i.toLowerCase(),
                        health: tmpObj.h||tmpObj.hp,
                        respawnT: parseFloat(tmpObj.rt) * 1000,
                        respawnR: (tmpObj.rr!=undefined),
                        colr: tmpObj.c,
                        noCol: (tmpObj.l||tmpObj.col),
                        noVis: tmpObj.v,
                        noAmb: (tmpObj.ab!=undefined),
                        interface: parseInt(tmpObj.in)||null
                    });
                }
    
                // SET MAP HEIGHT FOR SPECTATING FEATURES (Birdseyes View)
                this.mapHeight = highY;
    
                // ADD NOISE PLANES:
                this.manager.addNoisePlanes();
    
                // SHADOW SCALE:
                tmpMap.shadLength = Math.round(Math.abs(highX - lowX) / 2.5);
                tmpMap.shadWidth = Math.round(Math.abs(highZ - lowZ) / 2.5);
                if (RENDER) RENDER.updateLightMap(tmpMap);
    
                // BAKE AMBIENT OCCLUSION:
                this.manager.aoOpac = 1;
                if (RENDER) {
                    var colData;
                    var ambOcScale = config.ambScale;
                    for (var i = 0; i < this.manager.objects.length; ++i) {
                        tmpObj = this.manager.objects[i];
                        if (!tmpObj.noVis && !(mode.id=="prop"&&tmpObj.propID) && !tmpObj.complexMesh
                            && !tmpObj.health && !tmpObj.noAmb && !tmpObj.gate)
                            for (var x = i + 1; x < this.manager.objects.length; ++x) {
                                tmpObj2 = this.manager.objects[x];
                                if (!tmpObj2.noVis && !(mode.id=="prop"&&tmpObj2.propID) && !tmpObj2.health
                                     && !tmpObj2.noAmb && !tmpObj2.gate && !tmpObj2.complexMesh && this.manager.collision(tmpObj, tmpObj2, 0)) {
                                    colData = UTILS.boxIntersection(tmpObj, tmpObj2, "x", "z", [Math.PI,0,Math.PI/2,-Math.PI/2]);
                                    if (colData) for (var c = 0; c < colData.length; ++c) {if (colData[c].dontUse) continue;
                                        var cInts = UTILS.getIntersection(tmpObj, tmpObj2, "y");var tmpL = ambOcScale * (tmpObj.aoMlt||1) * (tmpObj2.aoMlt||1);
                                        for (var s = 0; s < 2; s++) {
                                            var tmpD = (colData[c].d + ((Math.PI / 2) * s)) % (Math.PI * 2);
                                            tmpL = Math.min(tmpL, this.manager.limitAmb(ambOcScale, colData[c], tmpD, "x", "z", tmpObj, tmpObj2));
                                        } for (var s = 0; s < 2; s++) {
                                            var tmpD = (colData[c].d + ((Math.PI / 2) * s)) % (Math.PI * 2);
                                            this.manager.addAmbient(colData[c].x + (tmpL * Math.cos(tmpD)), cInts.y,
                                                colData[c].z + (tmpL * Math.sin(tmpD)), -tmpD + Math.PI, 0, 0, cInts.height, tmpL+ config.ambOff, 1);
                                            if (tmpD == Math.PI / 2 || tmpD == -Math.PI / 2 || tmpD == Math.PI * 1.5) {
                                                var tmpDat = UTILS.limitRect(colData[c].z + (tmpL * Math.sin(tmpD)),
                                                    cInts.y + tmpL + cInts.height + config.ambOff, tmpL, tmpL, 0, [tmpObj, tmpObj2], "z", "y");
                                                this.manager.addAmbient(colData[c].x + (tmpL * Math.cos(tmpD)), tmpDat.y, tmpDat.z,
                                                    -tmpD + Math.PI, Math.PI, 0, tmpDat.length, tmpDat.height, 0,
                                                    [tmpObj, tmpObj2], ("g1-"+s+"-"+c), [colData[c].x,
                                                        cInts.y + cInts.height, colData[c].z]);
                                                tmpDat = UTILS.limitRect(colData[c].z + (tmpL * Math.sin(tmpD)),
                                                    cInts.y - tmpL - cInts.height - config.ambOff, tmpL, tmpL, 0, [tmpObj, tmpObj2], "z", "y");
                                                this.manager.addAmbient(colData[c].x + (tmpL * Math.cos(tmpD)), tmpDat.y, tmpDat.z,
                                                    -tmpD + Math.PI, 0, 0, tmpDat.length, tmpDat.height,
                                                    0, [tmpObj, tmpObj2], ("g2-"+s+"-"+c), [colData[c].x,
                                                        cInts.y - cInts.height, colData[c].z]);
                                            } else {
                                                var tmpDat = UTILS.limitRect(colData[c].x + (tmpL * Math.cos(tmpD)),
                                                    cInts.y + tmpL + cInts.height + config.ambOff, tmpL, tmpL, 0, [tmpObj, tmpObj2], "x", "y");
                                                this.manager.addAmbient(tmpDat.x, tmpDat.y,
                                                    colData[c].z + (tmpL * Math.sin(tmpD)),
                                                    -tmpD + Math.PI, Math.PI, 0, tmpDat.width, tmpDat.height, 0,
                                                    [tmpObj, tmpObj2], ("g1-"+s+"-"+c), [colData[c].x,
                                                        cInts.y + cInts.height, colData[c].z]);
                                                tmpDat = UTILS.limitRect(colData[c].x + (tmpL * Math.cos(tmpD)),
                                                    cInts.y - tmpL - cInts.height - config.ambOff, tmpL, tmpL, 0, [tmpObj, tmpObj2], "x", "y");
                                                this.manager.addAmbient(tmpDat.x, tmpDat.y, colData[c].z + (tmpL
                                                    * Math.sin(tmpD)), -tmpD + Math.PI, 0, 0, tmpDat.width, tmpDat.height,
                                                    0, [tmpObj, tmpObj2], ("g2-"+s+"-"+c), [colData[c].x,
                                                        cInts.y - cInts.height, colData[c].z]);
                                            }
                                        }
                                    } colData = UTILS.boxIntersection(tmpObj, tmpObj2, "z", "y", [Math.PI,0,-Math.PI/2,Math.PI/2]);
                                    if (colData) for (var c = 0; c < colData.length; ++c) {if (colData[c].dontUse) continue;
                                        var cInts = UTILS.getIntersection(tmpObj, tmpObj2, "x");
                                        var tmpL = ambOcScale * (tmpObj.aoMlt||1) * (tmpObj2.aoMlt||1);
                                        for (var s = 0; s < 2; s++) {
                                            var tmpD = (colData[c].d + ((Math.PI / 2) * (s?0:1)));
                                            tmpL = Math.min(tmpL, this.manager.limitAmb(ambOcScale, colData[c], -tmpD + Math.PI/2, "z", "y", tmpObj, tmpObj2));
                                        } for (var s = 0; s < 2; s++) {
                                            var tmpD = (colData[c].d + ((Math.PI / 2) * (s?0:1)));
                                            this.manager.addAmbient(cInts.x, colData[c].y + (tmpL * Math.cos(tmpD)),
                                                colData[c].z +
                                                (tmpL * Math.sin(tmpD)), 0, tmpD, -Math.PI / 2,
                                                cInts.width, tmpL + config.ambOff, 1);
    
                                            var tmpDat = UTILS.limitRect(cInts.x + cInts.width + tmpL + config.ambOff,
                                                colData [c].z + (tmpL * Math.sin(tmpD)), tmpL, tmpL, 0, [tmpObj, tmpObj2], "x", "z");
                                            this.manager.addAmbient(tmpDat.x, colData[c].y + (
                                                tmpL * Math.cos(tmpD)),
                                                colData[c].z + (tmpL * Math.sin(tmpD)), Math.PI, ((tmpD == Math.PI)?tmpD:(-tmpD % Math.PI)), ((tmpD==Math.PI * 1.5)?0:-Math.PI/2),
                                                (tmpD==Math.PI*1.5?tmpL:tmpDat.length), (tmpD==Math.PI*1.5
                                                    ?tmpDat.length:tmpL), 0, [tmpObj, tmpObj2], ("g3-"+s+"-"+c),
                                                [cInts.x + cInts.width, colData[c].y, colData[c].z]);
                                            tmpDat = UTILS.limitRect(cInts.x - cInts.width - tmpL - config.ambOff,
                                                colData[c].z + (tmpL * Math.sin(tmpD)), tmpL, tmpL, Math.PI/2, [tmpObj, tmpObj2], "x", "z");
                                            this.manager.addAmbient(tmpDat.x, colData[c].y + (tmpL * Math.cos(tmpD)),
                                                colData[c].z + (tmpL * Math.sin(tmpD)), Math.PI, (-tmpD % Math.PI),
                                                ((tmpD==Math.PI||(tmpD==Math.PI * 1.5))?Math.PI/2:Math.PI),
                                                ((tmpD==Math.PI||(tmpD==Math.PI * 1.5))?tmpDat.width:tmpL),
                                                ((tmpD==Math.PI||(tmpD==Math.PI * 1.5))?tmpL:tmpDat.width), 0,
                                                [tmpObj, tmpObj2], ("g4-"+s+"-"+c),
                                                [cInts.x - cInts.width, colData[c].y, colData[c].z]);
                                        }
                                    } colData = UTILS.boxIntersection(tmpObj, tmpObj2, "x", "y", [Math.PI,0,-Math.PI/2,Math.PI/2]);
                                    if (colData) for (var c = 0; c < colData.length; ++c) {
                                        if (colData[c].dontUse) continue;
                                        var cInts = UTILS.getIntersection(tmpObj, tmpObj2, "z");
                                        var tmpL = ambOcScale * (tmpObj.aoMlt||1) * (tmpObj2.aoMlt||1);
                                        for (var s = 0; s < 2; s++) {
                                            var tmpD = (colData[c].d + ((Math.PI / 2) * (s?0:1)));
                                            tmpL = Math.min(tmpL, this.manager.limitAmb(ambOcScale, colData[c], -tmpD + Math.PI / 2, "x", "y", tmpObj, tmpObj2));
                                        } for (var s = 0; s < 2; s++) {
                                            var tmpD = (colData[c].d + ((Math.PI / 2) * (s?0:1)));
                                            this.manager.addAmbient(colData[c].x + (tmpL * Math.sin(tmpD)), colData[c].y +
                                                (tmpL * Math.cos(tmpD)), cInts.z, Math.PI / 2, tmpD, -Math.PI / 2,
                                                cInts.length, tmpL + config.ambOff, 1);
                                            if (tmpD == Math.PI || tmpD == 0) {
                                                var tmpDat = UTILS.limitRect(colData[c].z + (tmpL * Math.sin(tmpD)),
                                                    cInts.z + cInts.length + tmpL + config.ambOff, tmpL, tmpL, Math.PI/2, [tmpObj, tmpObj2], "x", "z");
                                                this.manager.addAmbient(colData[c].x + (tmpL * Math.sin(tmpD)), colData[c].y +
                                                    (tmpL * Math.cos(tmpD)), tmpDat.z, Math.PI / 2,
                                                    tmpD, -Math.PI / 2, tmpDat.length, tmpDat.width, 0,
                                                    [tmpObj, tmpObj2], ("g5-"+s+"-"+c), [colData[c].x,
                                                        colData[c].y, cInts.z + cInts.length]);
                                                tmpDat = UTILS.limitRect(colData[c].z + (tmpL * Math.sin(tmpD)),
                                                    cInts.z - cInts.length - tmpL - config.ambOff, tmpL, tmpL, Math.PI/2, [tmpObj, tmpObj2], "x", "z");
                                                this.manager.addAmbient(colData[c].x + (tmpL * Math.sin(tmpD)), colData[c].y +
                                                    (tmpL * Math.cos(tmpD)), tmpDat.z, Math.PI / 2,
                                                    tmpD, Math.PI, tmpDat.width, tmpDat.length, 0,
                                                    [tmpObj, tmpObj2], ("g6-"+s+"-"+c), [colData[c].x,
                                                        colData[c].y, cInts.z - cInts.length]);
                                            } else {
                                                var tmpDat = UTILS.limitRect(colData[c].x + (tmpL * Math.sin(tmpD)),
                                                    cInts.z + cInts.length + tmpL + config.ambOff, tmpL, tmpL, Math.PI/2, [tmpObj, tmpObj2], "x", "z");
                                                this.manager.addAmbient(tmpDat.x, colData[c].y +
                                                    (tmpL * Math.cos(tmpD)), tmpDat.z, Math.PI / 2,
                                                    tmpD, -Math.PI / 2, tmpDat.length, tmpDat.width, 0,
                                                    [tmpObj, tmpObj2], ("g5-"+s+"-"+c), [colData[c].x,
                                                        colData[c].y, cInts.z + cInts.length]);
                                                tmpDat = UTILS.limitRect(colData[c].x + (tmpL * Math.sin(tmpD)),
                                                    cInts.z - cInts.length - tmpL - config.ambOff, tmpL, tmpL, Math.PI/2, [tmpObj, tmpObj2], "x", "z");
                                                this.manager.addAmbient(tmpDat.x, colData[c].y +
                                                    (tmpL * Math.cos(tmpD)), tmpDat.z, Math.PI / 2,
                                                    tmpD, Math.PI, tmpDat.width, tmpDat.length, 0,
                                                    [tmpObj, tmpObj2], ("g6-"+s+"-"+c), [colData[c].x,
                                                        colData[c].y, cInts.z - cInts.length]);
                                            }
                                        }
                                    }
                                }}
                    } this.manager.addPendingAOs();
                }
    
                // SPAWNS:
                this.spawns.length = 0;
                for (var i = 0; i < tmpMap.spawns.length; ++i) {
                    this.spawns.push({
                        x: tmpMap.spawns[i][0],
                        y: tmpMap.spawns[i][1],
                        z: tmpMap.spawns[i][2],
                        team: tmpMap.spawns[i][3],
                        dir: parseInt(tmpMap.spawns[i][4])||0,
                        comp: !!(tmpMap.spawns[i][5]||0)
                    });
                }
    
                // ADD ALL THE GROUPED MESHES:
                if (RENDER) RENDER.addMeshGroups();
    
            }
    
            // FINISH GENERATION:
            this.finishGenerate();
        };
    
        this.finishGenerate = function() {
            // RESET ALL OBJECTS:
            this.manager.resetAll();
        };
    }
    
    /**
     * Unpacks objects sent from the map generation server to be
     * used on the game server. See `config.mapGenProps` for more
     * information.
     * @param {*} ctx Global context for unpacking data.
     * @param {*} obj Packed object to extract data from.
     * @param {*} objConfig Configuration object for the packed data. See `config.mapGenProps`.
     * @param {*} out The output object to write the data to. If nothing is passed in, a new object will be created. Othwerise, this will modify whatever object is passed in.
     */
    function unpackObject(ctx, obj, objConfig, out = {}) {
    
        // SERIALIZE ALL PROPERTIES:
        for (var prop in objConfig) {
            var value = obj[prop];
    
            // VALIDATE IN CONFIG:
            var propConfig = objConfig[prop];
    
            // SERIALIZE VALUE:
            var unpacked;
            if (propConfig.props) {
                unpacked = unpackObject(ctx, value, propConfig.props, out[prop]);
            } else if (propConfig.isGameObject) {
                unpacked = unpackGameObject(ctx, value);
            } else if (propConfig.isTerrainConfig) {
                if (value) {
                    out.terrain = Terrain.fromConfig(value);
                    out.terrain.rotation.x = -Math.PI / 2;
                    unpacked = value;
                } else {
                    unpacked = null;
                }
            } else if (propConfig.isZoneConfig) {
                if (value) {
                    out.zone = Zone.fromConfig(value);
                    unpacked = value;
                } else {
                    unpacked = null;
                }
            } else {
                unpacked = value;
            }
            out[prop] = unpacked;
        }
        return out;
    }
    
    /**
     * Unpacks game objects send from the game server.
     * @param {Object} go Game object initiation data to create a new game object with.
     */
    function unpackGameObject(ctx, data) {
        if (Array.isArray(data)) {
            return data.map(data => unpackGameObject(ctx, data));
        } else if (typeof data == "object") {
            var out = {};
            for (var key in data) {
                // CREATE GAME OBJECT:
                out[key] = unpackGameObject(ctx, data[key]);
            }
            return out;
         } else {
            var sid = data;
            return ctx.gameObjects[sid];
        }
    }
    
    /** Generates an index used for `lastGen`. */
    function generateMapIndex(index, mode) {
        return index+(mode.genID!=undefined?"_"+mode.genID:"");
    }
    
    /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */ "./node_modules/process/browser.js")))
    
    /***/ }),
    
    /***/ "./src/data/modes.js":
    /*!***************************!*\
      !*** ./src/data/modes.js ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    // MODES:
    var modes = [{
        id: "ffa",
        name: "Free for All",
        alias: "ffa"
    }, {
        id: "tdm",
        name: "Team Deathmatch",
        endStats: ["sid", "name", "score", "kills", "deaths", "assists", "reward"],
        alias: "tdm",
        teams: true
    }, {
        id: "point",
        name: "Hardpoint",
        alias: "point",
        endStats: ["sid", "name", "score", "kills", "deaths", "assists", "reward"],
        objective: true,
        teams: true,
        gameStart: function(game) {
            game.activeObjective = -1;
            game.nextObjective(null, true);
        }
    }, {
        id: "ctf",
        name: "Capture the Flag",
        alias: "ctf",
        endStats: ["sid", "name", "score", "kills", "deaths", "caps", "reward"],
        onKill: function(game, io, player, doer, info) {
            game.dropFlag(player.flag);
        },
        flags: true,
        teams: true,
        noScoreC: true
    }, {
        id: "bhop",
        name: "Parkour",
        endStats: ["sid", "name", "score", "deaths"],
        alias: "bhop",
        noKick: true,
        friendly: true
    }, {
        id: "hide",
        name: "Hide & Seek",
        alias: "hide",
        endStats: ["sid", "name", "score", "found", "reward"],
        winCondition: function(game) {
            var hideCount = 0;
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].active && game.players.list[i].team == "hide") hideCount++;
            } return (hideCount>0?"hide":"seek");
        },
        condition: [function(game) {
            var hideCount = 0;
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].active && game.players.list[i].team == "hide") hideCount++;
            } return (hideCount>0);
        }],
        minPlayers: 2,
        waitTimers: [{
            time: 10000,
            msg: "picking seeker in ",
            trigger: function(game) {
                game.pickSeeker();
            }
        }, {
            time: 45000,
            msg: "releasing seeker in ",
            trigger: function(game) {
                game.releaseSeeker();
            }
        }],
        spdMlt: {
            "hide": 0.8
        },
        killConv: true,
        noKick: true,
        showTeam: true,
        startTeam: "hide",
        convTeam: "seek",
        convWord: "found",
        noWeap: true,
        friendly: true,
        hideNames: true
    }, {
        id: "infect",
        name: "Infected",
        alias: "infect",
        endStats: ["sid", "name", "score", "kills", "infected", "reward"],
        winCondition: function(game) {
            var survivorCount = 0;
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].active && game.players.list[i].team == "surv") survivorCount++;
            } return (survivorCount>0?"surv":"inf");
        },
        condition: [function(game) {
            var survivorCount = 0;
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].active && game.players.list[i].team == "surv") survivorCount++;
            } return (survivorCount>0);
            return true;
        }],
        minPlayers: 2,
        waitTimers: [{
            time: 20000,
            msg: "infection in ",
            trigger: function(game) {
                game.infectRandom();
            }
        }],
        teamClass: {
            "inf": 9
        },
        spdMlt: {
            "inf": 1.15
        },
        killConv: true,
        noKick: true,
        startTeam: "surv",
        convWord: "infected",
        convTeam: "inf"
    }, {
        id: "race",
        name: "Race",
        alias: "race",
        endStats: ["sid", "name", "score", "time"],
        gameTime: 0,
        showMS: true,
        timed: true,
        endSort: function(a, b) {
            if (a.score === b.score && a.gameTimer && b.gameTimer)
                return a.gameTimer - b.gameTimer;
            return (b.score - a.score);
        }, gameStart: function(game) {
            game.lockMove(true);
            game.targetScore = 0;
            for (var i = 0; i < game.map.manager.objects.length; ++i) {
                if (game.map.manager.objects[i].score) game.targetScore += game.map.manager.objects[i].scoreP;
            }
        },
        condition: [function(game) {
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].score >= game.targetScore && !game.players.list[i].timer) {
                    game.players.list[i].timer = game.lastTimer;
                    game.players.list[i].gameTimer = game.gameTimer;
                    if (!game.waitTimers) game.waitTimers = [{
                        time: 10000,
                        contTime: true,
                        msg: "race ends in ",
                        trigger: function(game) {
                            game.gameTimer = "skip";
                        }
                    }]
                }
            } return true;
        }],
        waitTimers: [{
            time: 15000,
            msg: "race starting in ",
            trigger: function(game) {
                game.lockMove(false);
            }
        }],
        noWeap: true,
        friendly: true
    }, {
        id: "lms",
        name: "Last Man Standing",
        alias: "lms",
        endStats: ["sid", "name", "score", "kills", "deaths", "assists"],
        noRegen: true,
        noKick: true,
        teams: true,
        lives: 1,
        winCondition: function(game) {
            var t1C = 0;
            var t2C = 0;
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].lives > 0) {
                    var tmpV = game.players.list[i].lives;
                    if (game.players.list[i].team == 1) t1C+=tmpV;
                    else t2C+=tmpV;
                }
            } return (t1C>t2C?1:2);
        },
        gameTime: 300000
    }, {
        id: "simon",
        name: "Simon Says",
        alias: "simon",
        endStats: ["sid", "name", "score", "reward"],
        condition: [function(game) {
            var folloCnt = 0;
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].active && game.players.list[i].team == "foll")
                    folloCnt++;
            } return (folloCnt>0);
            return true;
        }],
        minPlayers: 3,
        waitTimers: [{
            time: 10000,
            msg: "starts in ",
            trigger: function(game) {
                game.pickSimon();
            }
        }],
        noKick: true,
        teamSee: ["simon", "foll"],
        startTeam: "foll"
    }, {
        id: "gun",
        name: "Gun Game",
        alias: "gun",
        endStats: ["sid", "name", "weapon", "kills", "melees", "setbacks", "reward"],
        leaderStat: "weaponTier",
        endSort: function(a, b) {
            if (a.weaponTier === b.weaponTier && a.kills && b.kills)
                return a.kills - b.kills;
            return (b.weaponTier - a.weaponTier);
        },
        winCondition: function(game) {
            var tmpTier = 0;
            var highestP = null;
            for (var i = 0; i < game.players.list.length; ++i) {
                if (highestP == null || game.players.list[i].weaponTier > tmpTier) {
                    tmpTier = game.players.list[i].weaponTier;
                    highestP = game.players.list[i];
                }
            } return (tmpTier == 0 ? null : highestP);
        },
        condition: [function(game) {
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].weaponTier >= game.mode.weaponOrder.length) return false;
            } return true;
        }],
        onKill: function(game, io, player, doer, info) {
            if (doer && doer != player) {
                if (game.weapons[info.weaponId!=undefined ? info.weaponId
                    : doer.loadout[doer.weaponIndex]].melee) {
                    game.decreaseWeapon(player);
                    if (doer.weaponTier == game.mode.weaponOrder.length - 1) game.increaseWeapon(doer, info);
                } else game.increaseWeapon(doer, info);
            } else game.decreaseWeapon(player);
            if (io) game.players.syncLeaders();
        },
        startingLoadout: [2],
        keepLoadout: true,
        rewardMlt: 50,
        noReward: true,
        noAssists: true,
        noStreaks: true,
        minPlayers: 2,
        noWeap: true,
        weaponOrder: [2, 10, 4, 11, 5, 3, 9, 1, 14, 6, 0, 7, 8, 13, 15, 12]
    }, {
        id: "prop",
        name: "Prop Hunt",
        alias: "prop",
        genID: "p",
        endStats: ["sid", "name", "score", "kills"],
        noRegen: true,
        noKick: true,
        teams: true,
        lives: 1,
        winCondition: function(game) {
            var propCount = 0;
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].active && game.players.list[i].team=="prop") propCount++;
            } return (propCount>0?"prop":"seek");
        },
        condition: [function(g) {
            var t1C = 0;
            var t2C = 0;
            for (var i = 0; i < g.players.list.length; ++i) {
                if (g.players.list[i].lives > 0 && g.players.list[i].active) {
                    if (g.players.list[i].team == "prop") t1C++;
                    else t2C++;
                }
            } return (t1C>=1&&t2C>=1);
        }],
        minPlayers: 2,
        waitTimers: [{
            time: 10000,
            msg: "locking seekers in ",
            trigger: function(game) {
                game.lockSeekers();
            }
        }, {
            time: 30000,
            msg: "releasing seekers in ",
            noJoin: true,
            trigger: function(game) {
                game.releaseSeeker();
            }
        }],
        teamNs: ["seek", "prop"],
        showTeam: true,
        hideNames: true
    }, {
        id: "boss",
        name: "Boss Hunt",
        alias: "boss",
        winCondition: function(game) {
            var bossCount = 0;
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].active && game.players.list[i].team == "boss") bossCount++;
            } return (bossCount>0?"boss":"heros");
        },
        condition: [function(g) {
            var bossCount = 0;
            for (var i = 0; i < g.players.list.length; ++i) {
                if (g.players.list[i].active && g.players.list[i].team == "boss") bossCount++;
            } return (bossCount>0);
        }],
        waitTimers: [{
            time: 15000,
            msg: "picking boss in ",
            trigger: function(game) {
                game.pickBoss();
            }
        }],
        noReward: true,
        minPlayers: 2,
        startTeam: "heros"
    }, { // RANKED TEAMS:
        id: "ranked",
        name: "Ranked",
        alias: "ranked",
        noReward: true,
        preventCustomGames: true,
        endStats: ["sid", "name", "score", "kills", "deaths", "MMR"],
        isRanked: true,
        noKick: true,
        needAll: true,
        infEndTimer: true,
        objective: true,
        teams: true,
        waitTimers: [{
            time: 10000,
            msg: "starts in ",
            trigger: function(game) {
                game.lockMove(false);
            }
        }],
        gameStart: function(game) {
            game.lockMove(true);
            game.activeObjective = -1;
            game.nextObjective(null, true);
        }
    }, { // RANKED 1V1
        id: "ranked",
        name: "Ranked",
        alias: "ranked",
        noReward: true,
        preventCustomGames: true,
        endStats: ["sid", "name", "score", "kills", "deaths", "MMR"],
        isRanked: true,
        noKick: true,
        needAll: true,
        infEndTimer: true,
        noRegen: true,
        killSort: true,
        forceSpawn: 15,
        winCondition: function(game) {
            var tmpKills = 0;
            var highestP = null;
            for (var i = 0; i < game.players.list.length; ++i) {
                if (highestP == null || game.players.list[i].kills > tmpKills) {
                    tmpKills = game.players.list[i].kills;
                    highestP = game.players.list[i];
                }
            } return (tmpKills == 0 ? null : highestP);
        },
        condition: [function(game) {
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].kills >= 10) return false;
            } return true;
        }],
        waitTimers: [{
            time: 10000,
            msg: "starts in ",
            trigger: function(game) {
                game.lockMove(false);
            }
        }],
        gameStart: function(game) {
            game.lockMove(true);
        }
    }, {
        id: "stalk",
        name: "Stalker",
        alias: "stalk",
        endStats: ["sid", "name", "score", "reward"],
        genID: "st",
        ambInd: 5,
        minPlayers: 2,
        fogD: 250,
        fogC: 0x1c1c1c,
        skyCol: 0x1c1c1c,
        lightCol: 0x0d0d0d,
        ambCol: 0x171717,
        lives: 1,
        condition: [function(g) {
            var t1C = 0;
            var t2C = 0;
            for (var i = 0; i < g.players.list.length; ++i) {
                if (g.players.list[i].lives > 0) {
                    if (g.players.list[i].team == "liv") t1C++;
                    else if (g.players.list[i].team == "stalk") t2C++;
                }
            } return (t1C>=1&&t2C>=1);
        }],
        winCondition: function(game) {
            var stalkCount = 0;
            for (var i = 0; i < game.players.list.length; ++i) {
                if (game.players.list[i].active && game.players.list[i].team
                    == "stalk") stalkCount++;
            } return (stalkCount>0?"stalk":"liv");
        },
        waitTimers: [{
            time: 15000,
            msg: "picking stalker in ",
            trigger: function(game) {
                game.pickStalker();
            }
        }],
        onMelee: function(game, doer, getter) {
            var isStalk = (doer && getter && doer.team == "stalk");
            if (isStalk) {
                game.triggerImgSound("scare_0", "scare_0", getter);
                game.players.changeHealth(doer, null, -40);
            }
            return isStalk;
        },
        hideNames: true,
        noReward: true,
        noKick: true,
        startTeam: "liv",
        spdMlt: {
            "liv": 0.65
        }
    }, {
        id: "king",
        name: "King of the Hill",
        alias: "king",
        endStats: ["sid", "name", "score", "kills", "deaths", "reward"],
        objective: true,
        noScoreK: true,
        objScore: 20,
        gameStart: function(game) {
            game.activeObjective = -1;
            game.nextObjective(null, true);
        }
    }];
    module.exports = modes;
    
    
    /***/ }),
    
    /***/ "./src/data/objects.js":
    /*!*****************************!*\
      !*** ./src/data/objects.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    
    // IMPORT:
    var prefabs, THREE;
    var sid = 0;
    
    // GAME OBJECT:
    var GameObject = function(data, overrideSid = null, saveData = true) {
        // DON'T MODIFY `data` SINCE THIS GETS USED FOR THE MAP GEN SERVER
    
        // SAVE DATA FOR SERIALIZATION ON MAP GENERATION SERVER:
        if (saveData) this._initData = data;
    
        // GENERATE AND SAVE NEW SID:
        this.sid = overrideSid || sid++;
        this.uid = data.uid;
        this.width = data.w;
        this.length = data.l;
        this.height = data.h;
        this.active = data.startClosed?false : true;
        this.x = data.x;
        this.orgX = this.x;
        this.y = data.y;
        this.orgY = this.y;
        this.z = data.z;
        this.orgZ = this.z;
        this.xR = data.xR;
        this.yR = data.yR;
        this.zR = data.zR;
        this.dir = data.d;
        this.src = data.src;
        this.ramp = data.ramp;
        this.ladder = data.ladder;
        this.jumpPad = data.jumpPad;
        this.noShoot = data.noShoot;
        this.stepSrc = data.s;
        this.score = data.score;
        this.scoreP = data.scoreP;
        this.kill = data.kill;
        this.dummy = data.dummy;
        this.noVis = data.noVis;
        this.complexMesh = data.complexMesh;
        this.penetrable = data.penetrable;
        this.health = data.health;
        this.startHealth = data.health;
        this.transparent = data.transparent;
        this.boost = data.boost;
        this.boostDr = data.boostDr;
        this.aoMlt = data.aoM;
        this.team = data.team;
    
        this.flag = data.flag;
        this.flagTimer = 0;
        this.img = {
            x: data.x,
            y: data.y,
            z: data.z
        };
    
        this.trigger = data.trigger;
        this.pickup = data.pickup;
        this.orgPickup = data.orgPickup;
        this.pickupRep = data.pickupRep;
        this.meshRef = data.meshRef;
        this.checkpoint = data.checkpoint;
        this.singleUse = data.singleUse;
        this.isBorder = data.isBorder;
        this.node = data.node;
        this.channel = data.channel;
        this.teleporter = data.teleporter;
          this.telCooldown = 0;
        this.propID = data.propID;
        this.telStopMo = data.momentum;
        this.noAmb = data.noAmb;
        this.tRadius = data.tRadius;
        this.gate = data.gate;
        this.noMsg = data.noMsg;
        this.method = data.method;
        this.closeable = data.closeable;
        this.startClosed = data.startClosed;
        this.triggerEvent = data.event;
        this.triggerAction = data.action;
        this.triggerConstant = data.constant;
        if (data.eventN) this[data.eventN] = true;
        this.classIndx = data.classIndx;
    
    
        var respawnT = data.respawnT != 0 && data.respawnT != null &&
            data.respawnT < 100 ? 100: data.respawnT;
        this.respawnT = respawnT;
        this.respawnR = data.respawnR;
        this.respawnTStart = respawnT;
        this.canRespawn = !!(data.respawnR||respawnT),
    
        this.skill = data.skill;
        this.hpMlt = data.hpMlt;
        this.destroyedBy = null;
        this.interface = data.interface;
        this.interfaceT = data.interfaceT;
        this.deposited = 0;
        this.withdrawAmnt = data.withdraw;
        this.depositAmnt = data.deposit;
        this.bank = data.bank;
    
        this.objLink = data.objLink;
        this.showAd = data.showAd;
    };
    module.exports.GameObject = GameObject;
    
    // OBJECT MANAGER:
    module.exports.manager = function(RENDER, UTILS, config) {
    
        // INIT:
        if (RENDER) {
            prefabs = __webpack_require__(/*! ../data/prefabs.js */ "./src/data/prefabs.js").prefabs;
            THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
        }
        this.aoOpac = 0;
        this.objects = [];
        this.objectives = [];
        this.flags = [];
        this.pickups = [];
        this.gates = [];
        this.banks = [];
        this.interfaces = [];
        this.teleporters = [];
        this.zoneMarkers = [];
        this.spectateCams = {};
        var tmpObj, tmpObj2;
    
        // COLLISION:
        this.collision = function(obj, other, pad) {
            return (obj.x - obj.width - pad <= other.x + other.width
                && obj.x + obj.width + pad >= other.x - other.width
                && obj.z - obj.length - pad <= other.z + other.length
                && obj.z + obj.length + pad >= other.z - other.length
                 && obj.y - obj.height - pad <= other.y + other.height
                && obj.y + obj.height + pad >= other.y - other.height);
        };
    
        // CHECK POS:
        this.checkPos = function(x, y, z, obj1, obj2) {
            for (var i = 0; i < this.objects.length; ++i) {
                if (this.objects[i] != obj1 && this.objects[i] != obj2 && !this.objects[i].ramp
                    && UTILS.pointInBox3D(x, y, z, this.objects[i])) return false;
            } return true;
        };
    
        // FIND BY UID
        this.findByUid = function(uid, other) {
            tmpObj = other||this.objects;
            for (var i = 0; i < tmpObj.length; ++i) {
                if (tmpObj[i].uid === uid) return tmpObj[i];
            } return null;
        };
    
        // FIND BY SID:
        this.findBySid = function(sid, other) {
            tmpObj = other||this.objects;
            for (var i = 0; i < tmpObj.length; ++i) {
                if (tmpObj[i].sid === sid) return tmpObj[i];
            } return null;
        };
    
    
        // ADD CYLINDER:
        this.addCylinder = function(x, y, z, s, h, data) {
            if (RENDER) {
                data.shadows = true;
                RENDER.addCylinder(x, y, z, s, h, data);
            }
        };
    
        // ADD FLAG:
        this.getZoneDat = function(team, player) {
            return {
                src: "zone_r",
                texSrc: ("zone_" + (player?(team==player.team?"b":"r"):"r")),
                noGroup: true,
                mat: THREE.MeshBasicMaterial,
                transparent: true,
                depthWrite: false,
                side: 2
            };
        };
        this.getFlagDat = function(team, player) {
            var cInd = (player?(team==player.team?"1":"0"):"0");
            return {
                src: ("crystal_0"),
                texSrc: ("crystal_" + cInd),
                noGroup: true,
                noShadow: true,
                noFog: true,
                emissive: (cInd=="0"?0x853434:0x428a9d)
            };
        };
        this.addFlag = function(x, y, z, team) {
            var flagMesh = null;
            if (RENDER) {
                flagMesh = RENDER.loadMesh(this.getFlagDat(team), x, y +
                    config.flagOff, z, 0, config.flagScale, RENDER.scene);
                //flagMesh.layers.set(2);
                flagMesh.zoneMesh = RENDER.addCube(x, y, z, config.flagZoneS, config.flagZoneH,
                    config.flagZoneS, [1, 1, 0, 0, 1, 1], this.getZoneDat(team));
            } var tmpFlg = new GameObject({
                uid: this.objects.length,
                meshRef: flagMesh,
                x: x,
                z: z,
                y: y + (config.flagScale / 2) + config.flagOff,
                w: config.flagScale,
                l: config.flagScale,
                h: config.flagScale / 2,
                team: team,
                flag: true,
                noShoot: true,
                complexMesh: true
            });
            this.flags.push(tmpFlg);
            this.objects.push(tmpFlg);
            var tmpZon = new GameObject({
                x: x,
                z: z,
                y: y + (config.flagZoneH / 2),
                w: config.flagZoneS / 2,
                l: config.flagZoneS / 2,
                h: config.flagZoneH / 2,
                team: team,
                trigger: true,
                noShoot: true,
                complexMesh: true
            });
            tmpZon.flagObj = tmpFlg;
            this.objects.push(tmpZon);
        };
    
        // ADD WEAPON PICKUP:
        this.addWeapon = function(x, y, z, data, xR, yR, zR) {
            data = data||{};
            var wepMesh = null;
            if (RENDER) {
                wepMesh = RENDER.loadMesh({
                    src: "weapons/" + data.weapon.src,
                    texSrc: "weapons/" + data.weapon.src,
                    tFilter: THREE.LinearFilter,
                    noGroup: true,
                    uv2: true,
                    noShadow: true,
                    shininess: (data.weapon.shine||60),
                    specular: 0x292929,
                    transparent: data.weapon.seeThrough,
                    emissive: (data.weapon.transp?0xffffff:null)
                }, x, y + config.pickupOff, z, 0, data.weapon.scale, RENDER.scene);
    
                wepMesh.rotateY(xR||0);
                wepMesh.rotateX((yR||0) - Math.PI / 2);
                wepMesh.rotateZ(zR||0);
            }
            var tmpWep = new GameObject({
                uid: this.objects.length,
                meshRef: wepMesh,
                x: x,
                z: z,
                y: y + (config.pickupZoneH / 2),
                w: config.pickupZoneX,
                l: config.pickupZoneZ,
                h: config.pickupZoneH * 2,
                pickup: data.weaponId,
                pickupRep: !data.noRep,
                orgPickup: data.weaponId,
                scoreP: data.scoreP,
                noMsg: data.noMsg,
                method: data.method,
                trigger: true,
                noShoot: true,
                complexMesh: true
            });
            this.pickups.push(tmpWep);
            this.objects.push(tmpWep);
        };
    
    
        // ADD OBJECTIVE:
        this.addObjective = function(x, y, z, w, l, h, objLink) {
            var tmpMesh;
            if (RENDER) {
                tmpMesh = RENDER.addCube(x, y, z, w, h, l, [1, 1, 0, 0, 1, 1], {
                    src: "objective_0",
                    noGroup: true,
                    mat: THREE.MeshBasicMaterial,
                    transparent: true,
                    depthWrite: false,
                    side: 2
                });
                tmpMesh.visible = false;
            } this.objectives.push({
                x: x,
                z: z,
                y: y + (h / 2),
                mesh: tmpMesh,
                width: w / 2,
                length: l / 2,
                height: h / 2,
                objLink: (objLink||0)
            });
        };
    
        // ADD DEATH ZONE:
        this.addDeathZone = function(x, y, z, w, l, h) {
            this.objects.push(new GameObject({
                x: x,
                z: z,
                y: y + (h / 2),
                w: w / 2,
                l: l / 2,
                h: h / 2,
                kill: true,
                noShoot: true,
                complexMesh: true
            }));
        };
    
        // ADD SCORE ZONE:
        this.addScoreZone = function(x, y, z, w, l, h, sp) {
            this.objects.push(new GameObject({
                x: x,
                z: z,
                y: y + (h / 2),
                w: w / 2,
                l: l / 2,
                h: h / 2,
                score: true,
                scoreP: sp,
                noShoot: true,
                complexMesh: true
            }));
        };
    
        // ADD CHECK POINT:
        this.addCheckPoint = function(x, y, z, w, l, h, su, dir) {
            this.objects.push(new GameObject({
                uid: this.objects.length,
                x: x,
                z: z,
                y: y + (h / 2),
                w: w / 2,
                l: l / 2,
                h: h / 2,
                d: parseInt(dir)||0,
                checkpoint: true,
                singleUse: su,
                noShoot: true,
                complexMesh: true
            }));
        };
    
        // ADD TELEPORTER:
        this.addTeleporter = function(x, y, z, w, l, h, ch, n, m) {
            var tmp = new GameObject({
                  uid: this.objects.length,
                x: x,
                z: z,
                y: y + (h / 2),
                w: w / 2,
                l: l / 2,
                h: h / 2,
                teleporter: true,
                channel: ch||0,
                node: n||0,
                momentum: m,
                noShoot: true,
                complexMesh: true
            });
            this.objects.push(tmp);
            this.teleporters.push(tmp);
        };
    
        // ADD ZONE MARKER:
        this.addZoneMarker = function(x, y, z) {
            this.zoneMarkers.push([x, y, z]);
        };
    
        // ADD GRASS:
        this.addGrass = function(x, y, z, w, h, l, data) {
            data = data||{};
            if (RENDER && !data.noVis) {
                data.side = THREE.DoubleSide;
                data.transparent = true;
                data.alphaTest = 0.2;
                data.vertexColors = THREE.VertexColors;
                data.shadowsR = true;
                data.noGroup = (!!data.health);
                RENDER.addGrass(x, y, z, w, h, l, data);
            }
        };
    
        // ADD LADDER:
        this.addLadder = function(x, y, z, h, d, vis, tex, colr) {
           var tW = config.ladderScale;
           var tL = config.ladderScale;
           if (d == 0 || d == Math.PI) tL = config.ladderWidth;
           else tW = config.ladderWidth;
           tmpObj = new GameObject({
               ladder: true,
               complexMesh: true,
               noShoot: true,
               d: d,
               x: x + (config.ladderScale * Math.cos(d)),
               z: z + (config.ladderScale * Math.sin(d)),
               y: y,
               w: tW,
               l: tL,
               h: h
           });
           this.objects.push(tmpObj);
           if (RENDER && !vis) {
               var tmpDat = {
                   src: tex||"floor_0",
                   vertexColors: THREE.VertexColors,
                   colr: colr,
                   scale: 0.02,
                   amb: config.ambientVal,
                   shadows: true
               };
               RENDER.addCube(tmpObj.x + (config.ladderWidth * Math.sin(d)), tmpObj.y, tmpObj.z +
                   (config.ladderWidth * Math.cos(d)), config.ladderScale * 2, h + 2, config.ladderScale * 2, [1,1,1,1,1,1], tmpDat);
               RENDER.addCube(tmpObj.x - (config.ladderWidth * Math.sin(d)), tmpObj.y, tmpObj.z -
               (config.ladderWidth * Math.cos(d)), config.ladderScale * 2, h + 2, config.ladderScale * 2, [1,1,1,1,1,1], tmpDat);
               var stepH = 6;
               var max = Math.floor(h / stepH);
               for (var i = 0; i < max; ++i) {
                   tmpDat.dark = (0.6 + ((1 - 0.6) * (i / max)));
                   RENDER.addPlane(tmpObj.x, y + (stepH * (i + 1)) + UTILS.randFloat(-1, 1), tmpObj.z,
                       config.ladderWidth, config.ladderScale, tmpDat, -d + Math.PI / 2, Math.PI / 2,
                       UTILS.randFloat(-0.1, 0.1));
                }
            }
        };
    
        // ADD RAMP:
        this.addRamp = function(x, y, z, w, h, l, dir, boost, tex, vis, colr, ambS, movT, movD, noAmb, emiss) {
            var rot = (dir != 0 && dir != Math.PI);
            var tW = (rot?l:w)/2;
            var rl = Math.sqrt((h * h) + (l * l));
            var xD = (Math.asin(h / rl));
            this.objects.push(new GameObject({
                x: x,
                z: z,
                y: y + (h / 2),
                w: w / 2,
                l: l / 2,
                h: h / 2,
                d: dir,
                noShoot: true,
                complexMesh: true,
                boostDr: boost?xD:null,
                boost: boost?UTILS.limit(boost, config.boostRange):null,
                ramp: {
                    sX: x - (tW * Math.cos(dir)),
                    sZ: z - (tW * Math.sin(dir)),
                    eX: x + (tW * Math.cos(dir)),
                    eZ: z + (tW * Math.sin(dir))
                },
                noAmb: noAmb
            }));
            if (RENDER && !vis) {
                var tmpDat = {
                    src: tex||"default",
                    vertexColors: THREE.VertexColors,
                    colr: colr,
                    scale: 1,
                    shadowsR: true,
                    side: THREE.DoubleSide,
                    movT: movT,
                    movD: movD,
                    emissive: emiss,
                };
                tmpDat.transparent = (tmpDat.src=="link_0");
                if (tmpDat.src=="link_0") {
                    tmpDat.depthWrite = true;
                    tmpDat.alphaTest = (tmpDat.transparent?0.02:0);
                }
                RENDER.addRamp(x, y, z, (rot?w:l), h, (rot?l:w)/2, dir, tmpDat);
                if (!noAmb) {
                    y += config.ambOff;
                    var tmpV = ((rot?w:l)/2) - ambS;
                    if (rot) w = ambS * 2;
                    else l = ambS * 2;
                    for (var i = 0; i < 2; ++i) {
                        var tm = (i?1:-1);
                        RENDER.addRamp(x + (tmpV * tm * Math.cos(dir + Math.PI / 2)), y, z + (tmpV *
                            tm * Math.sin(dir + Math.PI / 2)), (rot?w:l), h, (rot?l:w)/2, dir, {
                            src: "ambient_1",
                            euler: "ZYX",
                            depthWrite: false,
                            transparent: true,
                              side: THREE.DoubleSide
                        }, (i?0:Math.PI));
                    }
                }
            }
        };
    
        // ADD GATE:
        this.addGate = function(x, y, z, w, l, h, data) {
            data = data||{};
            data.src = data.src||"wall_0";
            var tmpGate = new GameObject({
                x: x,
                z: z,
                y: y + (h / 2),
                w: w / 2,
                l: l / 2,
                h: h / 2,
                uid: this.objects.length,
                src: data.src,
                noVis: data.noVis,
                noAmb: data.noAmb,
                transparent: (data.transparent || data.src == "link_0"),
                penetrable: data.penetrable,
                isBorder: data.isBorder,
                complexMesh: (data.xR||data.yR||data.zR
                    ||data.src=="link_0"),
                ter: true,
                tRadius: 7,
                gate: true,
                scoreP: data.scoreP,
                noMsg: data.noMsg,
                method: data.method,
                closeable: data.closeable,
                startClosed: (data.startClosed && data.closeable),
                interface: data.interface
            });
            if (data.interface) this.interfaces.push(tmpGate.uid);
            if (RENDER && !data.noVis) {
                data.transparent = (data.src=="link_0"||data.opacity!=1);
                  if (data.src=="link_0") {
                    data.depthWrite = (data.opacity==1);
                    data.alphaTest = (data.transparent?0.02:0);
                }
                data.vertexColors = THREE.VertexColors;
                data.scale = (data.scale==undefined?1:data.scale);
                data.shadows = (!data.shadowsR&&data.opacity==1);
                data.noGroup = true;
                var tmpM = RENDER.addCube(x, y, z, w, h, l, [1,1,1,1,1,1], data);
                tmpGate.meshRef = tmpM;
            }
            this.objects.push(tmpGate);
            this.gates.push(tmpGate);
        };
    
        // ADD BANK:
        this.addBank = function(x, y, z, w, l, h, data) {
            data = data||{};
            data.src = data.src||"wall_0";
            var tmpBank = new GameObject({
                x: x,
                z: z,
                y: y + (h / 2),
                w: w / 2,
                l: l / 2,
                h: h / 2,
                uid: this.objects.length,
                src: data.src,
                noVis: data.noVis,
                noAmb: data.noAmb,
                transparent: (data.transparent || data.src == "link_0"),
                penetrable: data.penetrable,
                isBorder: data.isBorder,
                complexMesh: (data.xR||data.yR||data.zR
                    ||data.src=="link_0"),
                ter: true,
                tRadius: 7,
                bank: true,
                interface: data.interface,
                withdraw: Math.abs(data.withdraw),
                deposit: Math.abs(data.deposit)
            });
            if (data.interface) this.interfaces.push(tmpBank.uid);
            if (RENDER && !data.noVis) {
                data.transparent = (data.src=="link_0"||data.opacity!=1);
                  if (data.src=="link_0") {
                    data.depthWrite = (data.opacity==1);
                    data.alphaTest = (data.transparent?0.02:0);
                }
                data.vertexColors = THREE.VertexColors;
                data.scale = (data.scale==undefined?1:data.scale);
                data.shadows = (!data.shadowsR&&data.opacity==1);
                RENDER.addCube(x, y, z, w, h, l, [1,1,1,1,1,1], data);
            }
            this.objects.push(tmpBank);
            this.banks.push(tmpBank);
        };
    
        // ADD TRIGGER:
        this.addTrigger = function(x, y, z, w, l, h, data) {
            data = data||{};
            data.src = data.src||"wall_0";
            var tmpTrig = new GameObject({
                x: x,
                z: z,
                y: y + (h / 2),
                w: w / 2,
                l: l / 2,
                h: h / 2,
                uid: this.objects.length,
                src: data.src,
                noVis: data.noVis,
                noAmb: data.noAmb,
                health: data.health,
                respawnT: data.respawnT,
                respawnR: data.respawnR,
                transparent: (data.transparent || data.src == "link_0"),
                complexMesh: (data.xR||data.yR||data.zR
                    ||data.src=="link_0"),
                ter: true,
                constant: data.constant,
                eventN: data.eventN,
                event: data.event,
                action: data.action,
                interface: data.interface,
                interfaceT: data.interfaceT,
            });
            if (data.interface) this.interfaces.push(tmpTrig.uid);
            if (RENDER && !data.noVis) {
                data.transparent = (data.src=="link_0"||data.opacity!=1);
                  if (data.src=="link_0") {
                    data.depthWrite = (data.opacity==1);
                    data.alphaTest = (data.transparent?0.02:0);
                }
                data.vertexColors = THREE.VertexColors;
                data.scale = (data.scale==undefined?1:data.scale);
                data.shadows = (!data.shadowsR&&data.opacity==1);
                data.noGroup = (!!data.health);
                var tmpM = RENDER.addCube(x, y, z, w, h, l, [1,1,1,1,1,1], data);
                if (data.health && !data.noCol) {
                    tmpTrig.meshRef = tmpM;
                }
            }
            this.objects.push(tmpTrig);
        };
    
        // ADD AI:
        this.addAI = function(x, y, z, data, dir) {
            data = data||{};
            var tmpAI = new GameObject({
                x: x,
                z: z,
                y: y + (h / 2),
                w: 5,
                l: 5,
                h: 10,
                d: dir,
                uid: this.objects.length,
                classIndx: data.classIndx,
                respawnT: data.respawnT,
                respawnR: data.respawnR,
                skill: data.skill,
                hpMlt: data.hpMlt
            });
            if (RENDER) {
                // Spawn AI
            }
            this.objects.push(tmpAI);
        };
    
        // ADD LIGHT CONE:
        this.addLightCone = function(x, y, z, w, l, h, data) {
            data = data||{};
            data.src = "lightcone_0";
            if (RENDER && !data.noVis) {
                data.depthWrite = false;
                data.scale = (data.scale==undefined?1:data.scale);
                data.shadows = false;
                data.side = THREE.DoubleSide;
                data.blending = THREE.AdditiveBlending;
                data.mat = THREE.MeshBasicMaterial;
                data.vertexColors = THREE.VertexColors;
                var tmpM = RENDER.addCone(x, y, z, w, h, l, data);
            }
        };
    
        // ADD BOX:
        this.addBlock = function(x, y, z, w, l, h, s, data) {
            data = data||{};
            data.src = data.src||"wall_0";
            if (!data.noCol) this.objects.push(new GameObject({
                x: x,
                z: z,
                y: y + (h / 2),
                w: w / 2,
                l: l / 2,
                h: h / 2,
                uid: this.objects.length,
                s: data.sound,
                src: data.src,
                noVis: data.noVis,
                noAmb: data.noAmb,
                health: data.health,
                respawnT: data.respawnT,
                respawnR: data.respawnR,
                transparent: (data.transparent || data.src == "link_0"),
                penetrable: data.penetrable,
                isBorder: data.isBorder,
                complexMesh: (data.xR||data.yR||data.zR
                    ||data.src=="link_0"),
                ter: true,
                trigger: data.trig,
                interface: data.interface
            }));
            if (data.interface && !data.noCol) this.interfaces.push(this.objects.length - 1);
            if (RENDER && !data.noVis) {
                data.transparent = (data.src=="link_0"||data.opacity!=1);
                if (data.src == "link_0") {
                    data.depthWrite = (data.opacity==1);
                    data.alphaTest = (data.transparent?0.02:0);
                }
                data.vertexColors = THREE.VertexColors;
                data.scale = (data.scale==undefined?1:data.scale);
                data.shadows = (!data.shadowsR&&data.opacity==1);
                data.noGroup = (!!data.health);
                var tmpM = RENDER.addCube(x, y, z, w, h, l, s, data);
                if (data.health && !data.noCol) {
                    this.objects[this.objects.length - 1].meshRef = tmpM;
                }
            }
        };
    
        // ADD SPHERE:
        this.addSphere = function(x, y, z, w, l, h, data) {
            data = data||{};
            data.src = data.src||"wall_0";
            if (RENDER && !data.noVis) {
                data.transparent = (data.src=="link_0"||data.opacity!=1);
                if (data.src == "link_0") {
                    data.depthWrite = (data.opacity==1);
                    data.alphaTest = (data.transparent?0.02:0);
                }
                data.vertexColors = THREE.VertexColors;
                data.scale = (data.scale==undefined?1:data.scale);
                data.shadows = false;
                data.shadowsR = false;
                data.noGroup = (!!data.health);
                data.side = THREE.DoubleSide;
                RENDER.addSphere(x, y, z, w, h, l, data);
            }
        };
    
        // ADD A CANVAS:
        this.addCanvas = function(x, y, z, h, l, data, xR, yR, zR) {
            data = data||{};
            if (RENDER) {
                data.canvas = UTILS.createCanvasText(l*2, h*2, data.text||"Hello World",
                    data.fontSize||10, data.fcolr||"#000", data.bcolr||"#fff",
                    data.noBVis, data.tAlign||0);
                data.transparent = true;
                data.depthWrite = true;
                data.alphaTest = 0.02;
                data.side = THREE.DoubleSide;
                //if (xR != 0) xR -= (Math.PI / 2);
                RENDER.addPlane(x, y, z, l, h, data, xR, (yR||0) + (Math.PI / 2), zR);
            }
        };
    
        this.addSpectateCam = function(x, y, z, data) {
            data = data||{};
            data.objLink = (data.objLink||0);
            if (!this.spectateCams[data.objLink]) {
                this.spectateCams[data.objLink] = [];
            }
            this.spectateCams[data.objLink].push(new GameObject({
                x: x,
                z: z,
                y: y + 5,
                xR: data.xR,
                yR: data.yR,
                zR: data.zR
            }));
        };
    
        // ADD MESH:
        this.addMesh = function(x, y, z, r, w, h, l, data) {
            data = data||{};
            y += h;
            if (!data.noCol) this.objects.push(new GameObject({
                complexMesh: (prefabs?prefabs[data.src.toUpperCase()].complex:false),
                aoM: (prefabs?prefabs[data.src.toUpperCase()].aoMlt||0:0),
                propID: (config.propsH.indexOf(data.src)>=0?data.src:null),
                x: x,
                z: z,
                y: y,
                w: w,
                l: l,
                h: h,
                uid: this.objects.length,
                ter: true,
                noVis: data.noVis,
                noAmb: data.noAmb,
                health: data.health,
                respawnT: data.respawnT,
                respawnR: data.respawnR,
                interface: data.interface
            }));
            if (data.interface && !data.noCol) this.interfaces.push(this.objects.length - 1);
            if (prefabs && prefabs[data.src.toUpperCase()].transparent)
                y += UTILS.randFloat(-0.01, 0.01);
            if (RENDER && !data.noVis) {
                var tmpM = RENDER.loadMesh({
                    src: data.src + "_0",
                    emissive: (prefabs[data.src.toUpperCase()].emiss?0xffffff:null),
                    side: (prefabs[data.src.toUpperCase()].doubleSide?
                        THREE.DoubleSide:THREE.FrontSide),
                    transparent: prefabs[data.src.toUpperCase()].transparent,
                    shadows: prefabs[data.src.toUpperCase()].castShadow,
                    shadowsR: prefabs[data.src.toUpperCase()].receiveShadow,
                    vertexColors: THREE.VertexColors,
                    color: (data.colr||0xffffff),
                    noGroup: (!!data.health),
                    backup: [w, l, h]
                }, x, y, z, r, config[data.src + "Scale"], RENDER.scene, (!data.health));
                if (data.health && !data.noCol) {
                    this.objects[this.objects.length - 1].meshRef = tmpM;
                }
            }
        };
    
        // ADD NOISE PLANES:
        var noisePlanes = [];
        this.addNoisePlanes = function() {
            for (var i = 0; i < noisePlanes.length; ++i) {
                noisePlanes[i][5].objects = this.objects;
                var tmpM = RENDER.addPlane(...noisePlanes[i]);
                if (noisePlanes[i].length == 10) this.objects[noisePlanes[i][9]].meshRef = tmpM;
            } noisePlanes.length = 0;
        };
    
        // ADD PLANE:
        this.addPlane = function(x, y, z, h, l, data, xR, yR, zR) {
            data = data||{};
            if (!data.noCol) this.objects.push(new GameObject({
                x: x,
                z: z,
                y: y,
                w: l,
                l: h,
                h: 0,
                uid: this.objects.length,
                s: data.sound,
                health: data.health,
                respawnT: data.respawnT,
                respawnR: data.respawnR,
                transparent: (data.transparent || data.src == "link_0"),
                penetrable: data.penetrable,
                noVis: data.noVis,
                noAmb: data.noAmb,
                interface: data.interface,
                showAd: data.showAd
            }));
            if (data.interface && !data.noCol) this.interfaces.push(this.objects.length - 1);
            if (RENDER && !data.noVis) {
                if (data.showAd) {
                    var array = ["Support Krunker Streamers", "Your Ad Here"];
                    data.text = data.text||UTILS.getRandom(array);
                    data.canvas = UTILS.createCanvasAD(data.text);
                }
                data.transparent = true;
                data.side = THREE.DoubleSide;
                data.vertexColors = THREE.VertexColors;
                data.noGroup = (!!data.health);
                if (data.noise) {
                    data.pinEdges = true;
                    data.margin = 5;
                    data.tilesX = Math.round(l / 5);
                    data.tilesZ = Math.round(h / 5);
                }
                var tmpDat = [x, y, z, l, h, data, xR, (yR||0) + (Math.PI / 2), zR];
                if (data.noise) {
                    if (data.health && !data.noCol) tmpDat.push(this.objects.length - 1);
                    noisePlanes.push(tmpDat);
                } else {
                    var tmpM = RENDER.addPlane(...tmpDat);
                    if (data.health && !data.noCol) {
                        this.objects[this.objects.length - 1].meshRef = tmpM;
                    }
                }
            }
        };
    
        // ADD LIQUID:
        this.addLiquid = function(x, y, z, h, l, data, xR, yR, zR, PARTICLES) {
            data = data||{};
            if (RENDER && !data.noVis) {
                // if (PARTICLES) {
                // 	var tmpPr = PARTICLES.prefabs[0];
                // 	PARTICLES.area(x, y, z, l * 2, 1, h * 2, {
                // 		src: tmpPr.src,
                // 		blending: tmpPr.blending,
                // 		spd: tmpPr.spd,
                // 		cnt: tmpPr.cnt,
                // 		count: Math.round(((l * 2) + (h * 2) + 0.1) / tmpPr.cnt),
                // 		grav: tmpPr.grav,
                // 		scl: tmpPr.scl,
                // 		dir: tmpPr.dir,
                // 		colr: data.colr
                // 	});
                // }
                data.shadowsR = true;
                data.transparent = true;
                data.side = THREE.DoubleSide;
                data.scale = 2;
                data.vertexColors = THREE.VertexColors;
                data.noGroup = true;
                data.tilesX = Math.round((l * 2) / 10);
                data.tilesZ = Math.round((h * 2) / 10);
                data.mat = THREE.MeshLambertMaterial;
                var tmpM = RENDER.addPlane(x, y, z, l, h, data, xR, (yR||0) + (Math.PI / 2), zR);
                RENDER.liquids.push({
                    mesh: tmpM,
                    spd: data.wSpeed||10,
                    hght: data.wHeight||0.5,
                });
            }
        };
    
        // CHECK IF POINT IS INSIDE ANY OBJECTS:
        this.pointInObjs = function(pnt, parents, marg) {
            for (var i = 0; i < this.objects.length; ++i) {
                tmpObj = this.objects[i];
                if (!tmpObj.noVis && !tmpObj.complexMesh && !tmpObj.health
                    && parents.indexOf(tmpObj.sid) < 0
                    && UTILS.pointInBox3D(pnt[0], pnt[1], pnt[2], tmpObj, (marg||0))) {
                    return true;
                }
            } return false;
        };
    
        // SET MAX AO:
        this.setMaxAO = function(obj1, obj2, ao) {
            obj1.maxAOS = obj1.maxAOS||{};
            obj1.maxAOS[obj2.sid] = Math.max(ao, obj1.maxAOS[obj2.sid]||0);
            obj2.maxAOS = obj2.maxAOS||{};
            obj2.maxAOS[obj1.sid] = Math.max(ao, obj2.maxAOS[obj1.sid]||0);
        };
    
        // ADD AMBIENT:
        this.aosToAdd = {};
        this.addAmbient = function(x, y, z, xD, yD, zD, w, h, i, par, grp, orgn) {
            var doAdd = (!par);
            if (par) for (var ind = 0; ind < par.length; ++ind) {
                if (UTILS.pointInBox3D(x, y, z, par[ind], config.ambOff * 2)) {
                    doAdd = true;
                    break;
                }
            } if (doAdd) {
                if (par) {
                    var tmpSID = (par[0].sid + "-" + par[1].sid);
                    if (!this.aosToAdd[tmpSID]) this.aosToAdd[tmpSID] = [];
                    this.aosToAdd[tmpSID].push({
                        vals: [x, y, z, xD, yD, zD, w + config.ambOff, h + config.ambOff, i],
                        group: grp
                    });
                } else this.addPlane(x, y, z, w, h, {
                    src: "ambient_" + (i||0),
                    euler: "ZYX",
                    depthWrite: false,
                    noCol: true
                }, xD, yD, zD);
            }
        };
        var matchedGroups = [
            ["g6-1-2", "g4-1-2"],
            ["g5-1-2", "g4-0-1"],
            ["g6-0-1", "g3-1-2"],
            ["g5-0-1", "g3-0-1"],
            ["g6-0-3", "g2-0-3"],
            ["g5-0-3", "g2-1-1"],
            ["g6-1-1", "g1-0-3"],
            ["g5-1-1", "g1-1-1"],
            ["g6-0-2", "g1-1-0"],
            ["g5-0-2", "g1-0-2"],
            ["g6-1-0", "g2-1-0"],
            ["g5-1-0", "g2-0-2"],
            ["g4-0-2", "g1-0-0"],
            ["g3-0-2", "g1-1-3"],
            ["g4-1-0", "g2-0-0"],
            ["g3-1-0", "g2-1-3"],
            ["g4-0-3", "g2-1-2"],
            ["g3-0-3", "g2-0-1"],
            ["g4-1-1", "g1-1-2"],
            ["g3-1-1", "g1-0-1"],
            ["g6-1-3", "g3-0-0"],
            ["g5-1-3", "g3-1-3"],
            ["g6-0-0", "g4-0-0"],
            ["g5-0-0", "g4-1-3"]
        ];
        this.groupsMatch = function(group1, group2) {
            for (var i = 0; i < matchedGroups.length; ++i) {
                if (matchedGroups[i].indexOf(group1) >= 0
                    && matchedGroups[i].indexOf(group2) >= 0) {
                    return true;
                }
            } return false;
        };
        this.clearAOGroup = function(group) {
            for (var i = group.length - 1; i >= 0; --i) {
                tmpObj = group[i];
                for (var x = group.length - 1; x >= 0; --x) {
                    tmpObj2 = group[x];
                    if (!tmpObj.dontAdd && !tmpObj2.dontAdd && tmpObj != tmpObj2
                        && this.groupsMatch(tmpObj.group, tmpObj2.group)) {
                        if (tmpObj.vals[6] + tmpObj.vals[7] >= tmpObj2.vals[6]
                            + tmpObj2.vals[7]) tmpObj2.dontAdd = true;
                        else tmpObj.dontAdd = true;
                        break;
                    }
                }
            }
        };
        this.addPendingAOs = function() {
            for (var group in this.aosToAdd) {
                if (this.aosToAdd.hasOwnProperty(group)) {
                    this.clearAOGroup(this.aosToAdd[group]);
                    for (var i = 0; i < this.aosToAdd[group].length; ++i) {
                        if (!this.aosToAdd[group][i].dontAdd)
                            this.addAmbient(...this.aosToAdd[group][i].vals);
                    }
                }
            } this.aosToAdd = {};
        };
    
        // LIMIT AMB:
        this.limitAmb = function(l, data, d, v1, v2, obj1, obj2) {
            var v3 = [UTILS.cdv[v1]];
            var v4 = [UTILS.cdv[v2]];
            if (d == -Math.PI / 2 || d == Math.PI + Math.PI / 2) l = Math.min(l,
                (data[v2] - Math.min(obj1[v2] - obj1[v4], obj2[v2] - obj2[v4])) / 2);
            else if (d == Math.PI / 2) l = Math.min(l, (Math.max(obj1[v2] + obj1[v4],
                obj2[v2] + obj2[v4]) - data[v2]) / 2);
            else if (d == 0) l = Math.min(l, (Math.max(obj1[v1] + obj1[v3], obj2[v1] + obj2[v3]) - data[v1]) / 2);
            else l = Math.min(l, (data[v1] - Math.min(obj1[v1] - obj1[v3], obj2[v1] - obj2[v3])) / 2);
            return l;
        }
    
        // RESET ALL:
        this.resetAll = function() {
            this.aosToAdd = {};
            for (var i = 0; i < this.objects.length; ++i) {
                this.objects[i].active = this.objects[i].startClosed ? false : true;
                if (this.objects[i].startHealth) this.objects[i].health
                    = this.objects[i].startHealth;
                if (this.objects[i].meshRef)
                    this.objects[i].meshRef.visible = this.objects[i].startClosed ? false : true;
            } if (RENDER) RENDER.updateShadowMap();
        };
    
        // REMOVE ALL:
        this.removeAll = function() {
            this.objects.length = 0;
            this.objectives.length = 0;
            this.flags.length = 0;
            this.pickups.length = 0;
            this.teleporters.length = 0;
            this.zoneMarkers.length = 0;
            this.spectateCams = {};
        };
    
    };
    
    
    /***/ }),
    
    /***/ "./src/data/players.js":
    /*!*****************************!*\
      !*** ./src/data/players.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    var THREE;
    try {
        if (window) THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
    } catch (e) {}
    
    // PLAYER OBJECT:
    var Player = function(id, manager, UTILS, COLORS, config, game, isYTMP) {
    
        // VALS:
        this.id = id;
        this.isYTMP = isYTMP;
        this.sentTo = [];
        this.inputs = [];
        this.spins = [];
        this.stateHistory = [];
        this.weaponMeshes = [];
        this.weaponGeos = {};
        this.legMeshes = [];
        this.armMeshes = [];
        this.lastInput = {};
        this.lastDeltas = [];
        this.reloads = [];
        this.ammos = [];
        this.ping = 0;
        this.pings = [];
        this.avgSpn = 0;
        this.score = 0;
        this.scoreObjs = {};
        this.checkPoint = null;
        this.checkPointList = [];
        this.lstDrs = [];
        this.convs = 0;
        this.timer = null;
        this.gameTimer = null;
        this.classScores = {};
        this.kills = 0;
        this.weaponKills = {};
        this.deaths = 0;
        this.assists = 0;
        this.nukes = 0;
        this.headshots = 0;
        this.quickscopes = 0;
        this.noscopes = 0;
        this.wallbangs = 0;
        this.longshots = 0;
        this.driftkills = 0;
        this.closecalls = 0;
        this.firstblood = 0;
        this.airKills = 0;
        this.melees = 0;
        this.setbacks = 0;
        this.caps = 0;
        this.deathStreak = 0;
        this.highestStreak = 0;
        this.level = 0;
        this.lives = (game.waitTimers&&game.config?(game.config.lives||game.mode.lives||0):0);
        this.deltaAdd = 0;
        this.deltaDiv = 1;
        this.sprayIndex = 0;
        this.hatIndex = -1;
        this.backIndex = -1;
        this.meleeIndex = -1;
        this.skinColIndex = -1;
        this.dyeIndex = -1;
        this.attachIndex = 0;
        this.kcStatIndex = -1;
        this.lastSpray = 0;
        this.lastInteract = 0;
        this.lastPicked = [];
        this.playTime = 0;
        this.sCount = 0;
        this.streaks = {};
        this.deathInfo = {};
        this.ELO = 0;
        this.weaponTier = 0;
        this.inputLock = false;
        this.godMode = false;
        this.smite = false;
        this.noclip = false;
        this.home = {};
        this.lastLoadout = [];
        this.kicked = false;
        this.banned = false;
        this.kickedByVote = false;
        this.dmgDealt = 0;
        var tmpObj;
    
        // INIT:
        this.init = function(x, y, z, name, isYou, isHacker) {
            /*WP_S*/this.x = x/*WP_E*/;
            /*WP_S*/this.y = y/*WP_E*/;
            /*WP_S*/this.z = z/*WP_E*/;
            this.stepSrc = null;
            this.name = name||"unknown";
            this.xVel = 0;
            this.yVel = 0;
            this.zVel = 0;
            this.lastInObj = 0;
            this.renderMinimal = false;
            this.spins.length = 0;
            this.noMovTimer = 0;
            this.noMovT = 0;
            this.xDire = 0;
            this.yDire = 0;
            this.hitTimer = 0;
            this.ticker = 0;
            this.spread = 0;
            this.spreadPlus = 0;
            this.aimVal = 1;
            this.aimDir = 0;
            this.aimTime = 0;
            this.streak = 0;
            this.killStreak = 0;
            this.realKillStreak = 0;
            this.lastKill = 0;
            this.stateHistory.length = 0;
            this.lastInput = {};
            this.swapTweenA = 0;
            this.dmgReceived = {};
            this.landBobY = 0;
            this.landBobYR = 0;
            this.jumpBobY = 0;
            this.slideTimer = 0;
            this.canSlide = true;
            this.leanAnimX = 0;
            this.leanAnimY = 0;
            this.leanAnimZ = 0;
            this.bobAnimZ = 0;
            this.bobAnimY = 0;
            this.idleAnim = 0;
            this.inspecting = false;
            this.inspectX = false;
            this.stepVal = 0;
            this.stepChase = 0;
            this.stepDir = 1;
            this.stepDirR = 1;
            this.reward = 0;
            this.recoilAnim = 0;
            this.recoilAnimY = 0;
            this.recoilForce = 0;
            this.recoilTweenY = 0;
            this.recoilTweenYM = 0;
            this.recoilTweenZ = 0;
            this.burstCount = 0;
            this.jumpRot = 0;
            this.jumpRotM = 0;
            this.slideLegV = 0;
            this.recoilX = 0;
            this.recoilZ = 0;
            this.crouchVal = 0;
            this.onGround = true;
            this.onLadder = false;
            this.terrainSlipping = false;
            this.rampFix = null;
            this.didJump = false;
            this.jumpCooldown = 0;
            this.didShoot = false;
            this.lodActive = false;
            this.locked = false;
            this.latestData = false;
            this.airTime = 0;
            this.height = config.playerHeight;
            this.headScale = config.cameraHeight;
            this.scale = config.playerScale;
            this.active = true;
            this.interpolate = false;
            this.isYou = isYou;
            this.sfres = !isYou && !(this.id === -1);
            this.renderYou = isYou && game.controls.camType.isNormal;
            this.sentTo.length = 0;
            this.inputSN = 0;
            this.inputs.length = 0;
            this.weaponIndex = 0;
            this.swapTime = 0;
            this.recon = false;
            this.meleeAnim = {};
            this.isHacker = isHacker;
            this.customLoadout = null;
            this.isHidden = false;
            this.lastPicked.length = 0;
            this.propID = 0;
            this.weaponTier = 0;
            this.inObject = null;
            this.inputFreq = 0;
            this.cnBSeen = false;
            this.lastLoadout.length = 0;
        };
    
        // SET CLASS:
        this.setClass = function(game, index, secIndex, skip) {
            if (!skip) {
                if (game.config && game.config.classes.indexOf(index) < 0) {
                    if (index != game.config.classes[0]) this.skins = [-1,-1];
                    index = game.config.classes[0];
                } if (game.mode) {
                    if (game.mode.noWeap) index = 9;
                    if (game.mode.teamClass && game.mode.teamClass[this.team]) {
                        index = game.mode.teamClass[this.team];
                        this.skins = [-1,-1];
                    }
                }
            } if (index == undefined || index == null)
                index = (game.classes.length - 1);
            this.classIndex = index;
            this.reloads.length = 0;
            this.ammos.length = 0;
            this.loadout = [game.classes[index].loadout[0]];
            if (!(game.config?game.config.noSecondary:false)) {
                if (!game.classes[index].secondary) this.secIndex = null;
                else if (UTILS.isNumber(secIndex)) this.loadout.push(secIndex);
            }
            if (this.loadout.indexOf(12) < 0) this.loadout.push(12);
            this.speed = game.classes[index].speed||1;
            for (var i = 0; i < this.loadout.length; ++i) {
                this.reloads.push(0);
                this.ammos.push(game.weapons[this.loadout[i]].ammo);
            }
            this.reloadTimer = 0;
            this.regenDelay = (game.classes[index].regenDelay
                ||config.regenDelay);
            this.maxHealth = (game.mode&&game.mode.maxHealth ?
                game.mode.maxHealth : game.classes[index].health
                * (game.config?game.config.healthMlt||1:1));
            this.health = this.maxHealth;
            this.hpChase = 1;
            this.regen = (((game.mode&&game.mode.noRegen)
                ||!(game.config&&game.config.hpRegen))?0:
                (game.classes[index].regen||config.regenVal));
        };
    
        // UPDATE LOADOUT:
        this.updateLoadout = function(game, wepIndex, regen = true, index, secIndex) {
            this.weaponIndex = wepIndex;
            this.reloads.length = 0;
            this.ammos.length = 0;
            this.loadout = [index];
            this.skins = [-1, -1];
            if (UTILS.isNumber(secIndex)) this.loadout.push(secIndex);
            if (UTILS.isNumber(secIndex)) this.secIndex = secIndex;
            if (this.loadout.indexOf(12) < 0) this.loadout.push(12);
            for (var i = 0; i < this.loadout.length; ++i) {
                this.reloads.push(0);
                this.ammos.push(game.weapons[this.loadout[i]].ammo);
            }
            this.customLoadout = [...this.loadout];
            if (regen && this.active) manager.regenMeshes(this);
        };
    
        // RESET INPUTS:
        this.resetInputs = function() {
            this.inputs.length = 0;
        };
    
        // PROCESS INPUT:
        this.procInputs = function(input, game, recon, lock) {
    
            // RECON:
            this.recon = recon;
    
            if (this.noclip) this.onGround = true;
    
            // VALS:
            var delta = Math.max(0, Math.min(input[1],
                config.dltMx)) / this.deltaDiv;
            this.inputSN = input[0];
            var xDrIn = (input[2]||0)/1000;
            var yDrIn = (input[3]||0)/1000;
    
            // SPINNING:
            var spinDist = UTILS.getAngleDst(xDrIn, this.xDire);
            manager.saveSpin(this, spinDist);
    
            // ANIMATE:
            var animate = (!recon && this.renderYou);
            if (animate) {
                this.leanAnimX -= spinDist * config.leanSens;
                this.leanAnimX = UTILS.limit(this.leanAnimX, config.leanMax);
                this.leanAnimY -= UTILS.getAngleDst(yDrIn, this.yDire) * config.leanSens;
                this.leanAnimY = UTILS.limit(this.leanAnimY, config.leanMax);
                if (this.leanAnimX) this.leanAnimX *= Math.pow(config.leanPull, delta);
                if (this.leanAnimY) this.leanAnimY *= Math.pow(config.leanPull, delta);
                if (this.leanAnimZ) this.leanAnimZ *= Math.pow(config.leanPullZ, delta);
                if (this.bobAnimZ) this.bobAnimZ *= Math.pow(config.bobPullZ, delta);
                if (this.bobAnimY) this.bobAnimY *= Math.pow(config.bobPullY, delta);
                if (this.recoilX) this.recoilX *= Math.pow(config.leanPull, delta);
                if (this.recoilZ) this.recoilZ *= Math.pow(config.leanPull, delta);
                if (this.inspecting) {
                    if (this.inspectX < Math.PI / 2.8) {
                        this.inspectX += ((Math.PI / 2.8) - this.inspectX) * 0.1;
                    }
                }
            }
    
            // DIRECTION:
            this.xDire = xDrIn.round(3);
            this.yDire = yDrIn.round(3);
            if (this.yDire > (Math.PI / 2)) this.yDire = (Math.PI / 2);
            else if (this.yDire < -(Math.PI / 2)) this.yDire = -(Math.PI / 2);
    
            // IF LOCKED RETURN:
            if (lock) return;
    
            // SWAP WEAPON:
            if (input[11] == 2) manager.swapMelee(this, recon);
            else if (input[11] == 1) manager.swapSecondary(this, recon);
            else if (input[11] == 3) manager.swapWeapon(this, null,
                null, undefined, 0, recon);
            else if (input[10]) manager.swapWeapon(this, input[10],
                false, undefined, undefined, recon);
    
            // RECOIL:
            if (!recon) {
                if (this.recoilForce) {
                     this.recoilAnim += this.recoilForce * delta;
                     this.recoilAnimY += (this.recoilForce * (this.weapon.recoilY||1)
                         * (1 - (0.3 * this.crouchVal))) * delta;
                    this.recoilForce *= Math.pow(this.weapon.recoverF, delta);
                } if (this.recoilAnim) this.recoilAnim *= Math.pow(this.weapon.recover, delta);
                if (this.recoilAnimY) this.recoilAnimY *= Math.pow(this.weapon.recoverY||this.weapon.recover, delta);
            }
    
            // PREVIOUS POSITIONS:
            this.oldX = this.x;
            this.oldY = this.y;
            this.oldZ = this.z;
    
            // AIM ANIMATION:
            if (this.weapon.zoom && this.team != "prop" && (!this.weapon.noAim || this.swapTime > 0)) {
                var canZoom = (this.reloadTimer <= 0 && this.swapTime <= 0);
                if (input[6] && this.aimVal > 0 && canZoom) {
                    manager.cancelInspect(this);
                    this.aimDir = 0;
                    this.aimVal -= 1 / (this.weapon.aimSpeed / delta);
                    if (this.aimVal <= 0) {
                        this.aimVal = 0;
                        if (this.isYou && !recon) manager.toggleAim(this, 1);
                    }
                    if (this.isYou && !recon && !this.weapon.scope)
                        manager.updateAim(this, (1 - this.aimVal));
                } else if (!canZoom || (!input[6] && this.aimVal < 1)) {
                    this.aimDir = 1;
                    if (!this.aimVal && this.isYou && !recon) manager.toggleAim(this, 0);
                    this.aimVal += 1 / (this.weapon.aimSpeed / delta);
                    if (this.aimVal >= 1) this.aimVal = 1;
                    if (this.isYou && !recon && !this.weapon.scope)
                        manager.updateAim(this, (1 - this.aimVal));
                }
                if (this.aimVal == 0) this.aimTime += delta;
                else this.aimTime = 0;
            }
    
            // CROUCHING:
            if (input[8] && this.crouchVal < 1 && !this.onLadder) {
                this.crouchVal += config.crouchSpeed * delta;
                if (this.crouchVal >= 1) this.crouchVal = 1;
                if (!this.onGround) this.y += config.crouchSpeed * delta;
                else if (animate) this.bobAnimY -= (config.crouchAnim * 1.4) * delta;
            } else if (!input[8] && this.crouchVal > 0) {
                this.crouchVal -= config.crouchSpeed * delta;
                if (this.crouchVal <= 0) this.crouchVal = 0;
                if (!this.onGround) this.y -= config.crouchSpeed * delta;
                else if (animate) this.bobAnimY += config.crouchAnim * delta;
            } if (this.crouchVal)
                this.crouchVal = this.crouchVal.round(3);
    
            // SET HEIGHT:
            manager.updateHeight(this);
    
            // SPEEDS:
            var grounded = this.onGround||this.onLadder;
            var tmpSpeed;
            if (grounded) {
                tmpSpeed = (this.terrainSlipping ? config.slippingSpeed : config.playerSpeed) * this.speed;
            } else {
                tmpSpeed = config.airSpeed * game.map.config.arA;
            } tmpSpeed *= this.aimVal?1:config.aimSlow;
            tmpSpeed *= game.mode.spdMlt?(game.mode.spdMlt[this.team]||1):1
            tmpSpeed *= this.crouchVal?config.crouchSlow:1;
            tmpSpeed *= this.weapon.spdMlt * delta;
            var tmpDecel = 0;
            if (this.onLadder) tmpDecel = config.ladderDecel;
            else if (this.terrainSlipping) tmpDecel = config.terrainSlipDecel;
            else if (this.onTerrain) tmpDecel = config.terrainDecel;
            else if (this.onGround) tmpDecel = config.groundDecel;
            else tmpDecel = config.airDecel;
    
            // SLIDE:
            if (this.crouchVal <= 0.5) {
                this.canSlide = true;
            } if (!this.onGround || !this.crouchVal) {
                this.slideTimer = 0;
            } if (this.slideTimer) {
                this.slideTimer -= delta;
                if (this.slideTimer <= 0) {
                    this.slideTimer = 0;
                } else {
                    tmpSpeed *= 0.25;
                    tmpDecel = this.onTerrain ? config.terrainSlideDecel : config.slideDecel;
                    var totalSpeed = UTILS.getDistance(this.xVel, this.zVel, 0, 0);
                    var curDir = UTILS.getDir(0, 0, this.xVel, this.zVel);
                    var tDir = UTILS.getDir(Math.sin(this.xDire), Math.cos(this.xDire), 0, 0);
                    var tDst = UTILS.getAngleDst(tDir, curDir) * 0.03;
                    this.xVel = (totalSpeed * Math.cos(curDir + Math.PI - tDst));
                    this.zVel = (totalSpeed * Math.sin(curDir + Math.PI - tDst));
                }
            }
    
            // JUMP:
            this.jumpCooldown = Math.max(this.jumpCooldown - delta, 0);
            if ((this.onGround || (game.map.config && game.map.config.infJ)) && this.jumpCooldown <= 0) manager.tryJump(this, input[7]);
    
            // GRAVITY:
            if (!grounded) this.yVel -= (delta * (config.gravity *
                (game.config?game.config.gravMlt:1)));
    
            // SPEED LIMITER:
            var speedLimit = UTILS.limitMM(input[12], 0, 1);
            tmpSpeed *= speedLimit;
    
            // MOVE:
            var inputDir = config.movDirs[input[4]];
            if (inputDir != Math.PI && inputDir != 0 && inputDir != Math.PI / 2
                && inputDir != -Math.PI / 2) {
                tmpSpeed *= (game.config?game.config.strafeSpd:1);
            } if (inputDir !== undefined) {
                // GET ANGLE:
                var moveAngle = this.xDire;
                if (game.map.config.camType == 1) {
                    moveAngle = 0;
                } else if (game.map.config.camType == 2) {
                    moveAngle = 0;
                } else if (game.map.config.camType == 3) {
                    moveAngle = -Math.PI / 2;
                }
    
                // MOVE:
                this.xVel += tmpSpeed * Math.cos(inputDir - moveAngle);
                if (this.noclip) this.yVel += tmpSpeed * (this.yDire * (inputDir > 0 ? -1:1));
                this.zVel += tmpSpeed * Math.sin(inputDir - moveAngle);
            }
    
            // APPLY VELOCITY:
            if (this.xVel) {
                this.x += (this.xVel * game.map.config.speedX * delta);
                this.xVel *= Math.pow(tmpDecel, delta);
                this.xVel = UTILS.cropVal(this.xVel, config.decelMin);
            } if (this.yVel) {
                this.y += (this.yVel * game.map.config.speedY * delta);
                this.yVel *= Math.pow(tmpDecel, delta);
            } if (this.zVel) {
                this.z +=  (this.zVel * game.map.config.speedZ * delta);
                this.zVel *= Math.pow(tmpDecel, delta);
                this.zVel = UTILS.cropVal(this.zVel, config.decelMin);
            }
    
            // NO MOVE UPDATE:
            if (!recon) {
                if (!this.xVel && !this.yVel && !this.zVel) {
                    this.noMovT += delta;
                } else this.noMovT = 0;
                var tmpHid = (this.team == "stalk" && this.noMovT >= 300);
                if (this.isHidden != tmpHid) {
                    this.isHidden = tmpHid;
                    if (this.isYou) hiddenMsg.style.display
                        = (this.isHidden?"block":"none");
                }
            }
    
            // PICK PROP:
            if (this.team == "prop" && input[5]) manager.pickProp(this);
    
            // COLLISIONS:
            var wasOnGround = this.onGround && !this.didJump;
            var onRamp = false;
            var rampMaxY = null;
            this.onGround = (this.noclip || false);
            this.onLadder = false;
            var interact = false;
            var interactMsg = "Pickup";
            var interactBank = false;
            if (!this.noclip) for (var i = 0; i < game.map.manager.objects.length; ++i) {
                tmpObj = game.map.manager.objects[i];
    
                // TRIGGER RADIUS:
                if ((tmpObj.active||!tmpObj.active && tmpObj.closeable)
                    && tmpObj.tRadius && this.collides(tmpObj, tmpObj.tRadius)) {
                    if (tmpObj.gate) {
                        if (!tmpObj.noMsg) {
                            interactBank = false;
                            interact = true;
                            interactMsg = (!tmpObj.active && tmpObj.closeable ? "Close":"Open")
                                + " gate" + (tmpObj.scoreP != 0 ? (" <span style='color:"
                                + (this.score >= tmpObj.scoreP ? COLORS.interactPopup.enough:COLORS.interactPopup.notEnough)
                                + "'>["+(tmpObj.scoreP||0)+"]</span>"):"");
                        }
                    } else if (tmpObj.bank) {
                        interact = true;
                        interactMsg = "<span style='color:"+COLORS.interactPopup.notEnough+"'>["+UTILS.commaFormatNum(tmpObj.deposited||0)+"]</span>";
                        interactBank = [tmpObj.depositAmnt, tmpObj.withdrawAmnt];
                    }
                }
                if (tmpObj.active && this.collides(tmpObj)) {
    
                    // TRIGGER ON ENTER
                    if (tmpObj.onEnter && this.inObject != tmpObj.sid) {
                        game.onTrigger(this, tmpObj);
                        this.inObject = tmpObj.sid;
                    }
    
                    // SCORE OBJECT:
                    else if (tmpObj.score) {
                        if (!this.scoreObjs[tmpObj.sid]) {
                            this.scoreObjs[tmpObj.sid] = 1;
                            manager.score(this, tmpObj.scoreP);
                        }
                    }
    
                    // TELEPORTER:
                    else if (tmpObj.teleporter) game.checkTeleport(this, tmpObj);
    
                    // CHECK POINT:
                    else if (tmpObj.checkpoint) game.setCheckPoint(this, tmpObj);
    
                    // WEAPON PICKUP:
                    else if (UTILS.isNumber(tmpObj.pickup) && this.team != "inf") {
                        if (!tmpObj.noMsg) {
                            interact = true;
                            interactBank = false;
                            interactMsg = "Pickup weapon" + (tmpObj.scoreP != 0 ? (" <span style='color:"
                                + (this.score >= tmpObj.scoreP ? COLORS.interactPopup.enough:COLORS.interactPopup.notEnough)
                                + "'>["+(tmpObj.scoreP||0)+"]</span>"):"");
                        }
                    }
    
                    // FLAG:
                    else if (tmpObj.flag) game.pickupFlag(this, tmpObj);
    
                    // TRIGGER ZONE:
                    else if (tmpObj.trigger) {
    
                        // CAPTURE FLAG:
                        if (this.flag && tmpObj.team == this.team && tmpObj.flagObj
                            && !tmpObj.flagObj.carrier
                            && tmpObj.flagObj.x == tmpObj.flagObj.orgX
                            && tmpObj.flagObj.y == tmpObj.flagObj.orgY
                            && tmpObj.flagObj.z == tmpObj.flagObj.orgZ) {
                            game.capFlag(this, this.flag)
                        }
                    }
    
                    // KILL OBJECT:
                    else if (tmpObj.kill) {
                        if (this.flag) {
                            game.resetFlag(this.flag);
                            this.flag = null;
                        }
                        if (manager.hasServer && !this.godMode) manager.kill(this);
    
                    // LADDER:
                    } else if (tmpObj.ladder) {
                        if (this.y < tmpObj.y + tmpObj.height && this.crouchVal == 0) {
                            this.yVel = 0;
                            this.onLadder = true;
                            this.onTerrain = false;
                            this.stepSrc = null;
                            if (inputDir !== undefined) {
                                var tmpDr = (Math.abs(UTILS.getAngleDst(tmpObj.dir, inputDir - this.xDire))
                                    - (Math.PI / 2)) / (Math.PI / 2);
                                if (tmpDr > 0) {
                                    this.y += (config.ladderSpeed * game.map.config.ldA) * this.weapon.spdMlt * delta * tmpDr;
                                    if (this.y <= tmpObj.y - tmpObj.height) this.y = tmpObj.y - tmpObj.height;
                                    else if (this.y >= tmpObj.y + tmpObj.height) this.y = tmpObj.y + tmpObj.height;
                                }
                            }
                        }
                    }
    
                    // RAMP:
                    else if (tmpObj.ramp) {
                        if (this.y < tmpObj.y + tmpObj.height) {
                            var tmpProg = Math.max(0, Math.min(1, UTILS.progressOnLine(tmpObj.ramp.sX, tmpObj.ramp.sZ,
                                tmpObj.ramp.eX, tmpObj.ramp.eZ, this.x + (this.scale * Math.cos(tmpObj.dir)),
                                this.z + (this.scale * Math.sin(tmpObj.dir)))));
                            var tmpY = (tmpObj.y - tmpObj.height) + ((tmpObj.height * 2) * tmpProg);
                            if (rampMaxY === null) rampMaxY = tmpY;
                            if ((this.y <= tmpY || wasOnGround) && rampMaxY <= tmpY) {
                                rampMaxY = tmpY;
                                if (tmpObj.boost) {
                                    this.y = tmpY;
                                    var tmpSpd = (tmpObj.boost * config.boosterSpd * delta);
                                    this.xVel += (tmpSpd * Math.sin(-tmpObj.dir + (Math.PI/2)) * Math.cos(tmpObj.boostDr));
                                    this.zVel += (tmpSpd * Math.cos(-tmpObj.dir + (Math.PI/2)) * Math.cos(tmpObj.boostDr));
                                    this.yVel += (tmpSpd * Math.sin(tmpObj.boostDr));
                                } else {
                                    if (this.oldY > this.y) manager.resetStep(this, recon);
                                    this.y = tmpY;
                                    this.yVel = 0;
                                    this.onGround = true;
                                    this.onTerrain = false;
                                    onRamp = true;
                                    this.rampFix = (tmpObj.y - tmpObj.height) + ((tmpObj.height * 2) * Math.round(tmpProg));
                                }
                            }
                        }
                    }
    
                    // AUTO CLIMB:
                    else if (!(tmpObj.isBorder && !(game.config && game.config.disableB)) && this.y < tmpObj.y + tmpObj.height && tmpObj.y
                        + tmpObj.height - this.y
                        <= config.climbHeight && this.oldY < tmpObj.y + tmpObj.height && wasOnGround) {
                        this.y += ((tmpObj.y + tmpObj.height) - this.y) * 0.3;
                        this.onGround = true;
                        this.onTerrain = false;
                    }
    
                    // RECTANGLE:
                    else if (this.oldY >= tmpObj.y + tmpObj.height +
                        (tmpObj.isBorder && !(game.config && game.config.disableB)?config.borderH:0)) {
                        this.stepSrc = tmpObj.stepSrc;
                        if (this.oldY > this.y) manager.resetStep(this, recon);
                        this.y = tmpObj.y + tmpObj.height +
                            (tmpObj.isBorder && !(game.config && game.config.disableB)?config.borderH:0);
                        this.yVel = 0;
                        this.onGround = true;
                        this.onTerrain = false;
                    } else if (this.oldX - this.scale >= tmpObj.x + tmpObj.width - 0.00001) {
                        this.x = tmpObj.x + tmpObj.width + this.scale;
                        this.xVel = 0;
                    } else if (this.oldX + this.scale <= tmpObj.x - tmpObj.width + 0.00001) {
                        this.x = tmpObj.x - tmpObj.width - this.scale;
                        this.xVel = 0;
                    } else if (this.oldZ - this.scale >= tmpObj.z + tmpObj.length - 0.00001) {
                        this.z = tmpObj.z + tmpObj.length + this.scale;
                        this.zVel = 0;
                    } else if (this.oldZ + this.scale <= tmpObj.z - tmpObj.length + 0.00001) {
                        this.z = tmpObj.z - tmpObj.length - this.scale;
                        this.zVel = 0;
                    } else if (this.oldY + this.height <= tmpObj.y - tmpObj.height) {
                        this.y = tmpObj.y - tmpObj.height - this.height;
                        this.yVel = 0;
                    }
                } else if (tmpObj.sid == this.inObject) this.inObject = null;
            }
    
            // FIX RAMP:
            if (!this.didJump && this.rampFix != null && Math.abs(this.y - this.rampFix) <= config.climbHeight) {
                if (!onRamp) {
                    this.y = this.rampFix;
                    this.onGround = true;
                    this.yVel = 0;
                    this.rampFix = null;
                }
            } else {
                this.rampFix = null;
            }
    
            // TERRAIN:
            var terrain = game.map.terrain;
            if (terrain && !this.noclip) {
                var intersectPoint = terrain.raycast(this.x, -this.z, 10000, 0, 0, -20000, true);
                if (intersectPoint) {
    
                    // GET TERRAIN HEIGHT:
                    var terrainHeight = intersectPoint.z;
    
                    // RESET STEP:
                    if (this.y <= terrainHeight) {
                        if (this.oldY > this.y) manager.resetStep(this, recon);
    
                        // UPDATE STATE:
                        this.onTerrain = true;
                    }
                    if (this.onTerrain) {
    
                        // UPDATE STATE:
                        this.onGround = true;
    
                        // GET TERRAIN NORMAL AND CONVERT COORDINATE SPACES:
                        var tN = terrain._raycastNormal;
                        tN.set(tN.x, tN.z, -tN.y);
    
                        // UPDATE POSITION:
                        if (false) { var dH, nH, nY, dY; } else {
                            // UPDATE Y POS:
                            this.y = terrainHeight;
                        }
    
                        // GET SLIDING NORMAL:
                        var sX = tN.x;
                        var sY = -1 + tN.y;
                        var sZ = tN.z;
    
                        // TERRAIN SLIPPING:
                        var sLen = Math.sqrt(sX * sX + sY * sY + sZ * sZ);  // ADJUST MIN SLIDE
                        this.terrainSlipping = sLen > config.terrainSlideThreshold;
                        this.terrainSlipping = false;  // TEMP: DISABLE SLIPPING
                        if (this.terrainSlipping) {
    
                            // UPDATE SLIDE LEN:
                            var gravity = (config.gravity * (game.config?game.config.gravMlt:1)) * config.terrainGravityMlt;
                            sLen *= gravity * delta;
    
                            // UPDATE VELOCITY
                            this.xVel += sX * sLen;
                            this.yVel += sY * sLen;
                            this.zVel += sZ * sLen;
                        } else {
    
                            // REMOVE VERTICAL VELOCITY:
                            this.yVel = 0;
    
                            // REMOVE JUMP COOLDOWN:
                            this.jumpCooldown = 0;
                        }
                    }
                }
    
                // REMOVE SLIDING IF NEEDED:
                if (!this.onTerrain) this.terrainSlipping = false;
            }
    
            // AIR TIME:
            if (!this.onGround) this.airTime += delta;
            else this.airTime = 0;
    
            // NOT RECONCILING:
            if (!recon && this.team != "prop" && !(game.map.config && game.map.config.mdl)) {
    
                // MOVEMENT ANIMATION CLIENT:
                var moveVal = UTILS.getD3D(this.oldX, this.oldY, this.oldZ,
                    this.x, this.y, this.z);
                if (this.renderYou) {
                    if (this.onLadder) moveVal *= 1.4;
                    var moveDir = UTILS.getDir(this.oldX, this.oldZ, this.x, this.z);
                    this.bobAnimZ += UTILS.getDistance(this.oldX, this.oldZ, this.x, this.z) * config.bobMltZ;
                    this.bobAnimY -= (this.oldY - this.y) * config.bobMltY;
                }
                if (this.isYou && grounded && inputDir !== undefined) manager.playerStep(this, moveVal);
                if (this.renderYou) {
                    if (grounded && inputDir !== undefined) {
                        this.leanAnimZ -= (moveVal * config.leanMltZ
                            * (this.weapon.zLnM||1)) * Math.cos(inputDir);
                    } else {
                        this.stepVal *= Math.pow(config.stepPull, delta);
                    }
                    if (this.stepChase != this.stepVal)
                        this.stepChase += (this.stepVal - this.stepChase) * 0.15;
                }
    
                // SET SPREAD:
                this.spreadPlus += (moveVal * config.spreadMove) + (Math.abs(this.oldY - this.y)
                     * config.spreadFall);
                this.spreadPlus *= Math.pow(config.spreadRecover, delta);
                this.spread = Math.max(this.weapon.minSpread||0, ((this.weapon.spread - (this.weapon.spread * config.crouchSpread
                    * this.crouchVal) + (this.recoilAnim * (this.weapon.spreadInc||1) * config.spreadMlt))
                    + this.spreadPlus) * this.aimVal);
    
                // RELOAD:
                if (input[9]) manager.reload(this);
                if (this.reloadTimer > 0) {
                    var lastTimer = this.reloadTimer;
                    this.reloadTimer -= delta;
                    if (this.isYou && lastTimer >= (this.weapon.reload / 2) &&
                         this.reloadTimer < (this.weapon.reload / 2)) manager.endReload(this.weapon);
                    if (this.reloadTimer <= 0) {
                        this.reloadTimer = 0;
                        this.didShoot = false;
                        this.ammos[this.weaponIndex] = this.weapon.ammo;
                        manager.updatePlayerAmmo(this);
                    }
                }
    
                // SHOOTING:
                if (this.swapTime > 0) {
                    this.swapTime -= delta;
                    if (this.swapTime < 0) this.swapTime = 0;
                }
                for (var i = 0; i < this.reloads.length; ++i) {
                    if (this.reloads[i] > 0) {
                        this.reloads[i] -= delta;
                        if (this.reloads[i] < 0) this.reloads[i] = 0;
                    }
                }
                if (this.weapon) {
                    var shooting = (this.burstCount||(this.weapon.nAuto?false:input[5]));
                    if (this.didShoot && !input[5]) this.didShoot = false;
                    if (!this.didShoot && input[5]) shooting = true;
                    if (shooting && this.reloads[this.weaponIndex] <= 0 &&
                        this.swapTime <= 0 && this.reloadTimer <= 0) {
                        this.noMovTimer = 0;
                        if (this.weapon.melee) {
                            manager.melee(this);
                        } else {
                            if (this.ammos[this.weaponIndex] > 0) manager.shoot(this, input);
                            else manager.reload(this);
                        }
                    }
                }
            }
    
            // SHOOT VELOCITY RECON:
            if (recon && input.velObj) {
                this.xVel -= input.velObj.x;
                this.zVel -= input.velObj.y;
                if (!this.noclip) this.yVel -= input.velObj.z;
                this.onGround = false;
            }
    
            // PLAYER COLLISIONS:
            manager.playerCollisions(this);
            manager.updateInteract(this, interact, interactMsg, interactBank);
    
         };
    
        // COLLIDES:
        this.collides = function(other, padding) {
            return (this.x - this.scale < other.x + (other.width + (padding||0))
                && this.x + this.scale > other.x - (other.width + (padding||0))
                && this.z - this.scale < other.z + (other.length + (padding||0))
                && this.z + this.scale > other.z - (other.length + (padding||0))
                 && this.y <= other.y + other.height + (other.isBorder &&
                    !(game.config && game.config.disableB)?config.borderH:0)
                && this.y + this.height >= other.y - other.height);
        };
    
        // GET STATE CONSTANT:
        this.getStateConst = function() {
            return (this.ping * (this.lagComp||1));
        };
    
        // UPDATE:
        this.update = function(game, delta) {
            if (this.active) {
    
                // PROCESS INPUTS:
                if (this.inputs.length) {
                    for (var i = 0; i < this.inputs.length; ++i) {
                        this.procInputs(this.inputs[i], game);
                    }
                    this.resetInputs();
                }
    
                // IDLE SWAY:
                this.idleAnim += (config.idleAnimS * delta);
    
                // HEALTH CHASE:
                if (this.hpChase > (this.health / this.maxHealth)) {
                    this.hpChase -= (0.0002 * delta);
                    if (this.hpChase <= 0) {
                        this.hpChase = 0;
                    }
                } else this.hpChase = (this.health / this.maxHealth);
    
                if (typeof Module === "undefined") { 
    
                // INTERPOLATE:
                if (this.interpolate) {
                    this.dt += delta;
                    var rate = Math.min(1.6, this.dt / (config.serverSendRate * config.interpolation));
                    rate /= (game.config?game.config.deltaMlt:1);
                    this.oldX = this.x;
                    this.oldY = this.y;
                    this.oldZ = this.z;
                    this.x = this.x1 + ((this.x2 - this.x1) * rate);
                    this.y = this.y1 + ((this.y2 - this.y1) * rate);
                    this.z = this.z1 + ((this.z2 - this.z1) * rate);
                    if (this.onGround) /*WP_S*/manager.playerStep(this, UTILS.getDistance(
                        this.oldX, this.oldZ, this.x, this.z))/*WP_E*/;
                    this.xDire = Math.lerpAngle(this.xDir2, this.xDir1, Math.min(1, rate));
                    this.yDire = Math.lerpAngle(this.yDir2, this.yDir1, Math.min(1, rate));
                }
    
                } else {
    
                    Module.interpolatePlayer(this, manager, UTILS, config, game, delta);
    
                }
    
            }
        };
    
        // RESET PLAYER ANIM:
        this.resetMeleeAnim = function() {
            this.meleeAnim.armT = 0;
            this.meleeAnim.armM = 0;
            this.meleeAnim.armE = 0;
            this.meleeAnim.weaR = 0;
            this.meleeAnim.weaM = 0;
            this.meleeAnim.armY = 0;
            this.meleeAnim.armR = 0;
            this.meleeAnim.lArm = 0;
            this.meleeAnim.flipW = 0;
        };
    
        // RESET PLAYER:
        this.reset = function() {
            this.checkPoint = null;
            this.checkPointList.length = 0;
            this.weaponTier = 0;
            this.customLoadout = null;
            this.lastLoadout.length = 0;
            this.lastPicked.length = 0;
            this.inObject = null;
        };
    
    };
    
    
    var orgPlr = Player; 
    
    if (typeof window !== "undefined" && typeof Module !== "undefined"){
    
        var Player = module.exports.Player = function(){
    
            var originalPlayer = new orgPlr(...arguments);
    
            // No need to delete originalPlayer["x"], etc... not created until later
    
            if (!originalPlayer.isYTMP) { 
            
                var protectedPlayer = new Module.Player(); 
                var sid = originalPlayer["id"];
    
                delete originalPlayer["id"];
    
    
                Object.setPrototypeOf(originalPlayer, protectedPlayer);
    
                originalPlayer.id = sid; // Restore saved id value 
    
            }
    
            // if (!window.pplr) window.pplr = [];
            // window.pplr.push(originalPlayer);
    
    
    
            return originalPlayer;
    
    
    
        }
    
     
    
    
    
        
    } else { 
    
    module.exports.Player = Player;
    
    }
    
    // PLAYER MANAGER:
    module.exports.manager = function(game, RENDER, SOUND, PARTICLES, UTILS, COLORS, config, io) {
    
        // INIT:
        this.list = [];
        var tmpObj, tmpObj2, tmpData;
        var KILLS = __webpack_require__(/*! ./kills.js */ "./src/data/kills.js");
        this.hasServer = (io?1:0);
    
        // SET TEAM:
        this.setTeam = function(player) {
            if (game.config.isFromQueue) {
                if (player.tmpAccountName) {
                    player.team = game.getAccountTeamIndex(player.tmpAccountName) + 1;
                    if (player.team == -1) console.warn("Could not find team index");
                } else {
                    console.warn("Player should have account");
                    player.team = -1;
                }
            } else if (!game.waitTimers && game.mode.convTeam) {
                player.team = game.mode.convTeam;
            } else if (game.mode.startTeam) {
                player.team = game.mode.startTeam;
            } else if (game.mode.friendly) {
                player.team = 1;
            } else if (game.mode.clanWar) {
                player.team = (player.account&&player.account.clan?player.account.clan:1);
            } else if (!player.team && game.mode.teams && !player.spectating) {
                var t1c = 0;
                var t2c = 0;
                for (var i = 0; i < this.list.length; ++i) {
                    if (!this.list[i].spectating) {
                        if (this.list[i].team == (game.mode.teamNs?game.mode.teamNs[0]:1)) t1c++;
                        if (this.list[i].team == (game.mode.teamNs?game.mode.teamNs[1]:2)) t2c++;
                    }
                }
                player.team = (t1c>=t2c)?2:1;
                if (game.mode.teamNs) player.team =
                    game.mode.teamNs[player.team-1];
            }
        };
    
        // UPDATE:
        this.update = function(delta) {
    
            // UPDATE PLAYERS:
            for (var i = 0; i < this.list.length; ++i) {
                if (this.list[i].active) {
                    this.list[i].update(game, delta);
                    if (io) {
                        this.tickPlayer(this.list[i], delta);
                        this.storeState(this.list[i]);
                        if (this.list[i].y <= game.map.deathY) {
                            if (this.list[i].flag) {
                                game.resetFlag(this.list[i].flag);
                                this.list[i].flag = null;
                            } this.kill(this.list[i]);
                        }
                    } if (RENDER) {
                        this.updateMsh(this.list[i]);
                        this.updateHeight(this.list[i]);
                    }
                } else {
                    if (this.list[i].deathInfo && this.list[i].deathInfo.tillNext) {
                        this.list[i].deathInfo.tillNext -= delta;
                        if (this.list[i].deathInfo.tillNext <= 0) {
                            this.list[i].deathInfo.tillNext = null;
                            io.send(this.list[i].id, "frs");
                            // FORCE RESPAWN
                        }
                    }
                }
            }
        };
    
        // PLAYER COLLISIONS:
        this.playerCollisions = function(player) {
            if (io && game.mode.convTeam && !game.waitTimers) {
                for (var i = 0; i < this.list.length; ++i) {
                    if (player.active && this.list[i].active && player.team == game.mode.convTeam
                        && player.team != this.list[i].team && !this.list[i].godMode) {
                        var tmH = (config.playerHeight / 2);
                        var tmpDst = /*WP_S*/UTILS.getD3D(player.x, player.y + tmH, player.z,
                            this.list[i].x, this.list[i].y + tmH, this.list[i].z)/*WP_E*/;
                        if (tmpDst <= tmH * 2.4) {
                            io.broadcast("game" + game.sid, "ac", player.sid,
                                this.list[i].sid, game.mode.convWord);
                            this.score(player, 100);
                            player.convs++;
                            game.updateTeam(this.list[i], player.team);
                            if (game.mode.killConv) /*WP_S*/this.kill(this.list[i], null, null, true)/*WP_E*/;
                            if (game.gameTimer) /*WP_S*/game.gameTimer += 10000/*WP_E*/;
                        }
                    }
                }
            }
        };
    
        // GET ACTIVE COUNT:
        this.activeCount = function() {
            var tmpC = 0;
            for (var i = 0; i < this.list.length; ++i) {
                if (this.list[i].active) tmpC++;
            } return tmpC;
        };
    
        // FORCE POSITION:
        this.forcePos = function() {
            for (var i = 0; i < this.list.length; ++i) {
                this.list[i].forcePos = true;
                if (this.list[i].objInstances) {
                    var player = this.list[i];
                    /*WP_S*/player.objInstances.visible = false/*WP_E*/;
                    this.list[i].cnBSeen = false;
                }
            }
        };
    
        // SPINS:
        this.saveSpin = function(player, spins) {
            if (io) {
                player.spins.unshift(spins);
                if (player.spins.length > (config.spinTimer / config.serverTickRate))
                    player.spins.length = Math.round(config.spinTimer / config.serverTickRate);
            }
        };
        this.getSpin = function(player) {
            var tmpSpin = 0;
            for (var i = 0; i < player.spins.length; ++i) {
                tmpSpin += player.spins[i];
            }
            return Math.abs(tmpSpin * (180 / Math.PI));
        };
    
        // STORE STATE:
        this.storeState = function(player) {
            player.stateHistory.unshift({
                time: game.now,
                x: player.x,
                y: player.y,
                z: player.z
            });
            for (var i = player.stateHistory.length - 1; i >= 0; --i) {
                if (game.now - player.stateHistory[i].time >= config.stateHistory)
                    player.stateHistory.splice(i , 1);
            };
        };
    
        // FETCH STATE:
        this.fetchState = function(player, ping) {
            var backTime = game.now - (ping + (config.serverSendRate * config.interpolation));
            for (var i = 0; i < player.stateHistory.length; ++i) {
                if (player.stateHistory[i].time <= backTime) return player.stateHistory[i];
            };
            return player.stateHistory[player.stateHistory.length - 1];
        };
    
        // UPDATE PLAYER MESH:
        this.updateMsh = function(player, prv) {
            if (!player.objInstances) return;
    
            // CAMERA OFFSET:
            var offsetCam = game.config.thirdPerson
                ||!(game.controls && game.controls.camType.isNormal)
                ||(game.map.config&&(game.map.config.camOffX
                ||game.map.config.camOffY||game.map.config.camOffZ));
    
            // VALUES:
            var playerAV = RENDER.aimAnim?player.aimVal:1;
            var aimVM = (player.weapon.animWhileAim?1:playerAV);
            var animMlt = (1 - ((1 - config.aimAnimMlt) * (1 -
                playerAV))) * config.animMult * RENDER.weaponBob;
            var animMltC = (1 - (0.8 * player.crouchVal));
            var animMltL = (1 - (1 - playerAV)) * config.animMult;
            var animMltRcY = (1 - ((1 - playerAV) * (player.weapon.recoilYMA
                ||1))) * config.animMult;
            if (!player.renderYou) (animMltL = 0);
            var recoilZMlt = (1 - ((player.weapon.recoilZM||0.5) * (1 - aimVM)));
            var animRMlt = ((1 - ((player.weapon.zRot||0.3)
                * (1 - aimVM))) * (player.weapon.zRM||1)) * RENDER.weaponBob;
            var animYMlt = (1 - ((player.weapon.jYMlt||1) * (1 - aimVM)));
            var leanAimMlt = (1 - (0.45 * (1 - aimVM)));
            var bobAnimY = ((player.bobAnimY * 0.9 * animYMlt) *
                RENDER.weaponBob) * animMltL;
            var landBobY = ((player.landBobY * (player.weapon.landBob||1)
                * 0.6) * (1 - (0.75 * (1 - aimVM)))) * RENDER.weaponBob;
            if (player.landBobYR != landBobY) {
                player.landBobYR += (landBobY - player.landBobYR) * 0.1;
            } var landBobYA = (player.landBobY * (player.weapon.landBob||1) * 0.1);
            var bobCMlt = (1 - (0.5 * player.crouchVal));
            var cIMlt = (1 - (1 * player.crouchVal));
            var jumpRot = (player.jumpRot * bobCMlt * animMltL) * RENDER.weaponBob;
            if (player.jumpRotM != jumpRot) {
                player.jumpRotM += (jumpRot - player.jumpRotM) * 0.08;
            } var jumpBobY = (player.jumpBobY * (player.weapon.jumpYM||1)
                * animMltL * bobCMlt) * RENDER.weaponBob;
            var recAMlt = (1 - (0.75 * (1 - aimVM)));
            var recMlt = (1 - ((player.weapon.aimRecMlt||1) * (1 - aimVM)));
            var stepMlt = (prv?0.05:config.stepAnim);
            var stepAnim = Math.sin(player.stepVal) * stepMlt;
            var stepHalf = (Math.cos(2 * player.stepVal) / 2) * stepMlt;
            var stepAnimR = -Math.sin(player.stepChase) * stepMlt;
            var stepHalfR = -(Math.cos(2 * player.stepChase) / 2) * stepMlt;
            var aimVal = (offsetCam?0:(1 - playerAV));
            var aimLean = ((aimVal<=0.5)?aimVal:(0.5-(aimVal-0.5))) * 0.5;
            var swapAnim = (player.swapTime / player.weapon.swapTime);
            var wXoff = player.weapon.xOff * (player.renderYou?RENDER.weaponOffX:1);
            var wYoff = player.weapon.yOff * (player.renderYou?RENDER.weaponOffY:1);
            var wZoff = player.weapon.zOff * (player.renderYou?RENDER.weaponOffZ:1);
            var reloadAnim = 0;
            if (player.reloadTimer > 0) {
                reloadAnim = (1 - (player.reloadTimer / player.weapon.reload));
                reloadAnim = (reloadAnim>0.5)?0.5-(reloadAnim-0.5):reloadAnim;
            } reloadAnim *= player.renderYou ? 1 : 0.3;
            var idleAim = ((1 - (0.88 * (1 - playerAV))) * 1.75 * RENDER.weaponBob);
    
            // POSITION MESH:
            var resval = (player.renderYou&&!offsetCam?Math.abs(stepAnimR * 0.5)*animMltL:
            Math.abs(stepAnim * 3.5));
            /*WP_S*/RENDER.moveMesh(player.objInstances, player.x, player.y +
                resval, player.z)/*WP_E*/;
            var reslow = (player.renderYou?offsetCam?-stepAnim * 0.5:0:-stepAnim * 2);
    
            if (player.team != "prop" && !(game.map.config && game.map.config.mdl)) /*WP_S*/RENDER.rotateMesh(player.objInstances, player.xDire + reslow)/*WP_E*/;
    
            // FIX VALS:
            stepHalf -= stepHalf * (player.crouchVal * config.crouchAnimMlt);
            stepAnim -= stepAnim * (player.crouchVal * config.crouchAnimMlt);
    
            // LEGS:
            for (var i = 0; i < player.legMeshes.length; ++i) {
                if (RENDER.lowSpec) player.legMeshes[i].visible = false;
                else player.legMeshes[i].rotation.x = (stepAnim * ((i==1||i==3)?1:-1) * 7)
                    + (i > 1?(-0.6):0);
            }
    
    
    
            // ARMS:
            for (var i = 0; i < player.armMeshes.length; ++i) {
                var tmpArmM = -(player[((i==0?"l":"r")+"HndTweenA")]||0);
                player.armMeshes[i].position.z = (stepAnim * (!i?1:-1));
                player.armMeshes[i].rotation.x = (player.armMeshes[i].xR||0);
                player.armMeshes[i].rotation.y = (player.armMeshes[i].yR||0);
                player.armMeshes[i].position.x = (player.armMeshes[i].xP||0);
                player.armMeshes[i].position.y = (player.armMeshes[i].yP||0);
                if (i == 1) {
                    player.armMeshes[1].rotation.z = player.armMeshes[i].zR
                        + (player.crouchVal * 0.12) + (-1.0 * stepHalfR)
                        + (player.jumpBobY * 0.2);
                    if (player.meleeAnim && player.weaponGeos[player.weaponIndex]) {
                        player.armMeshes[1].rotation.z += (player.meleeAnim.armR||0) * animMltL;
                        player.armMeshes[1].rotation.y += (player.meleeAnim.armT||0) * animMltL;
                        player.armMeshes[1].position.x += (player.meleeAnim.armM||0) * animMltL;
                        player.armMeshes[1].position.z += (player.meleeAnim.armE||0) * animMltL;
                        player.armMeshes[1].position.y += (player.meleeAnim.armY||0) * animMltL;
                        if (player.weaponGeos[player.weaponIndex]) {
                            player.weaponGeos[player.weaponIndex].rotation.z =
                                player.weaponGeos[player.weaponIndex].zR +
                                (player.meleeAnim.weaR||0);
                            player.weaponGeos[player.weaponIndex].position.x =
                                player.weaponGeos[player.weaponIndex].xP
                                + (player.meleeAnim.weaM||0);
                            player.weaponGeos[player.weaponIndex].rotation.y =
                                player.weaponGeos[player.weaponIndex].yR +
                                (player.meleeAnim.flipW||0);
                        }
                    }
                } else {
                    if (player.meleeAnim && player.weaponGeos[player.weaponIndex]) {
                        player.armMeshes[0].position.z += (player.meleeAnim.lArm||0);
                        player.armMeshes[0].rotation.y += (player.meleeAnim.lArm||0)*0.1;
                        player.armMeshes[0].position.x -= (player.meleeAnim.lArm||0)*0.3;
                    }
                }
            }
    
    
    
            // ATTACHMENT:
            var tmpAttach = (player.weapon.attach != undefined &&
                game.attach[player.attachIndex]?game.attach[player.attachIndex]:null);
            var aimYOff = (tmpAttach?tmpAttach.aimOffY||0:0);
    
            // FLAP:
            if (player.weaponMeshes[player.weaponIndex] &&
                player.weaponMeshes[player.weaponIndex].flapMesh && player.weapon.flap) {
                fRot = (stepHalfR * 3) + (player.recoilAnim * 2.8) - (player.leanAnimZ)
                    - (player.leanAnimX * 3) - (player.landBobYR * 1.8) + (bobAnimY)
                    + (player.crouchVal * 0.1);
                RENDER.rotateMesh(player.weaponMeshes[player.weaponIndex].flapMesh,
                    (player.weapon.flap.rot * player.swapTweenA) + fRot, null, null);
            }
    
            // ANIMATE YOU:
            var thrdRed = (offsetCam?0.4:1);
            RENDER.rotateMesh(player.upperBody, (reloadAnim * -(1.0 * thrdRed)), (-(bobAnimY * 0.2) +
                 + (landBobYA) + (reloadAnim * -(2.8 * thrdRed)) + (player.yDire * (player.renderYou&&!offsetCam?1:0.5)) +
                (-(Math.PI / 4) * swapAnim  + (player.recoilAnimY * config.recoilMlt))) + (player.weapon.yRot||0));
            RENDER.moveMesh(player.upperBody, 0, (player.recoilAnimY * ((player.weapon.recoilYM||0.3) * animMltRcY))
                + (player.height - config.cameraHeight - config.legHeight), 0);
    
    
            RENDER.rotateMesh(player.weaponMeshes[player.weaponIndex],
    
                player.inspectX + (player.jumpRotM * 0.2) + (player.recoilX * recAMlt) + (player.leanAnimX * leanAimMlt
                    * RENDER.weaponLean * (player.weapon.leanMlt||1)) + ((((-stepAnimR * 0.16)
                    * animMltL * animMltC) + (player.leanAnimZ * 0.2)) * animMlt),
    
                   (-Math.cos(player.idleAnim) * bobCMlt * 0.01 * idleAim)
                    + ((player.weapon.rotOff||0) * animMltL)
                    - ((player.swapTweenR||0) * 0.25 * animMltL)
                     + (-player.landBobYR * 0.6) + (player.recoilTweenY * recMlt) +
                    (player.leanAnimY * leanAimMlt * RENDER.weaponLean
                    * (player.weapon.leanMlt||1)) + (-(stepHalfR * 0.9) * animMlt),
    
                jumpRot + aimLean + (player.recoilX * recAMlt) + ((player.swapTweenR||0) * animMltL * 0.1)
                    + (player.leanAnimZ * animRMlt) + (-player.inspectX * (player.weapon.inspectR||0))
                    + ((((player.weapon.cLean||0) * player.crouchVal * animMltL) + (-stepAnimR * 0.0)) * animMlt));
    
            RENDER.moveMesh(player.weaponMeshes[player.weaponIndex],
    
                -(player.jumpRotM * animMltL * 1.3) + (-player.inspectX * (player.weapon.inspectM||0)) + (((player.leanAnimZ * 0.35)
                - ((player.weapon.cRot||0) * player.crouchVal * animMltL) + ((stepAnim * 0.5) * animMltC * animMltL))
                * playerAV) * animMlt + wXoff - ((wXoff - player.weapon.xOrg) * aimVal),
    
                (Math.sin(player.idleAnim) * 0.02 * idleAim) + (player.recoilTweenYM * recMlt) + jumpBobY
                + (landBobY * 0.7) - (bobAnimY * 1.5) +
                ((stepHalf * 0.85) - ((player.weapon.cDrop||0) * player.crouchVal * animMltL))
                * animMlt + wYoff - ((wYoff - player.weapon.yOrg + aimYOff) * aimVal),
    
                (wZoff - ((wZoff - player.weapon.zOrg) * aimVal)) +
                (player.bobAnimZ * animMlt) + ((player.recoilAnim * (player.weapon.recoilZ||0)) * recoilZMlt));
    
        };
    
        // UPDATE HEIGHT:
        this.updateHeight = function(player) {
            var offsetCam = game.config.thirdPerson || (game.map.config && (game.map.config.camOffX
                ||game.map.config.camOffY||game.map.config.camOffZ));
            var cVal = (config.crouchDst * player.crouchVal);
            if (RENDER && (!player.renderYou || offsetCam)) {
                var crouchLean = (config.crouchLean * player.crouchVal);
                RENDER.rotateMesh(player.lowerBody, 0, crouchLean + (player.yDire * 0.5), 0);
                if (player.upperBody) player.upperBody.rotation.x -= crouchLean;
                RENDER.moveMesh(player.lowerBody, 0, config.legHeight - cVal, 0);
                for (var i = 0; i < 4; ++i) {
                    if (player.legMeshes[i] && !RENDER.lowSpec) {
                        if (i <= 1) player.legMeshes[i].visible = !player.crouchVal;
                        else player.legMeshes[i].visible = player.crouchVal?true:false;
                    }
                }
            } else player.height = config.playerHeight - cVal;
        };
    
        // GENERATE PLAYER MESH:
        this.generateMeshes = function(player, isYou, viewer = false, customConfig) {
    
            // COLORS:
            var colors = game.classes[player.classIndex].colors;
            var skinColor = (config.skinColors[player.skinColIndex] || colors[0]);
            var shirtColor = colors[1];
            var sleeveColor = colors[5];
            var pantsColor = colors[2];
            var shoeColor = colors[3];
    
    
            if (player.dyeIndex != -1) {
                var dye = game.store.skins[player.dyeIndex];
                if (dye) {
                    //if (dye.skin) skinColor = dye.skin;
                    if (dye.shirtCol) shirtColor = dye.shirtCol;
                    if (dye.sleeveCol) sleeveColor = dye.sleeveCol;
                    if (dye.pantsCol) pantsColor = dye.pantsCol;
                    if (dye.shoeCol) shoeColor = dye.shoeCol;
                }
            }
    
            // GEN BODY:
            var genBod = (game.config.thirdPerson||(game.map.config && (game.map.config.camOffX
                ||game.map.config.camOffY||game.map.config.camOffZ))||!isYou);
            var holdObj = RENDER.genObj3D(0, 0, 0);
            // player.objInstances = RENDER.genObj3D(player.x, player.y, player.z, player.id);
            if (player.id === -1){
                player.id = "-1";
            }
            
            player.objInstances = 1;
            if (typeof Module !== "undefined") { 
                Module.setObjInstances(player, RENDER);
            } else {
                player.objInstances = RENDER.genObj3D(player.x, player.y, player.z, player.id);
            } 
            /*WP_S*/player.objInstances.add(holdObj)/*WP_E*/;
            // CHANGE LOOKS FOR MODES:
            
            if (player.team == "inf") {
                skinColor = COLORS.modeSpecific.infected.skin;
                player.hatIndex = 122;
            } else if (player.team == "stalk") {
                player.backIndex = -1;
                player.hatIndex = -1;
                player.meleeIndex = -1;
                skinColor = COLORS.modeSpecific.stalker.skin;
                shirtColor = COLORS.modeSpecific.stalker.body[1];
                sleeveColor = COLORS.modeSpecific.stalker.body[5];
                pantsColor = COLORS.modeSpecific.stalker.body[2];
                shoeColor = COLORS.modeSpecific.stalker.body[3];
                colors = COLORS.modeSpecific.stalker.body;
            }
    
            // CUSTOM PLAYER MODEL (SPRITE):
            if (game.map.config && game.map.config.mdl) {
                var mainObj = {
                    src: "sprite_0",
                    color: 0xffffff,
                    mat: THREE.SpriteMaterial,
                    depthWrite: true,
                    transparent: true,
                    alphaTest: 0.02
                };
                
                /*WP_S*/RENDER.loadSprite(mainObj, player.objInstances)/*WP_E*/;
            }
    
            // PROP PLAYER MODEL:
            else if (player.team == "prop") {
                var meshID = config.propsH[player.propID];
    
                var mainObj = {
                    src: (meshID + "_0"),
                    emissive: (meshID == "acidbarrel" ?0xffffff:null)
                };
    
                var configTest = (config[meshID + "Scale"] + (config.propsCPY[meshID]||0));
                var configRes = (config[meshID + "Scale"] + configTest);
                var configResTop = config[meshID + "Scale"];
    
                /*WP_S*/RENDER.loadMesh(mainObj, 0, configRes,
                     0, 0, configResTop, player.objInstances, false)/*WP_E*/;
            }
    
            // REGULAR PLAYER MODEL:
            else {
                var tmpItem;
    
                // BODY:
                player.lowerBody = RENDER.genObj3D(0, config.legHeight, 0);
                if (genBod) player.lowerBody.add(RENDER.genBody(shirtColor,
                    pantsColor, colors[4], skinColor, player.renderYou));
    
                // UPPER BODY:
                player.upperBody = RENDER.genObj3D(0, 0, 0);
                player.lowerBody.add(player.upperBody);
    
                // ADD BACK ITEM:
                if (player.backIndex >= 0 && genBod) {
                    if (customConfig && customConfig[2]) {
                        tmpItem = {...game.store.skins[player.backIndex]};
                        for (var key in tmpItem) {
                            if (customConfig[2][key] != undefined) {
                                tmpItem[key] = customConfig[2][key];
                            }
                        }
                    } else tmpItem = game.store.skins[player.backIndex];
                    player.backMesh = RENDER.genObj3D(0, ((config.playerHeight
                        - config.legHeight - config.headScale) / 2)
                        - (tmpItem.sitOff||0),
                        - (tmpItem.sitOffZ||0));
                    player.lowerBody.add(player.backMesh);
                    RENDER.loadMesh({
                        src: ("body/body_" + tmpItem.id),
                        texSrc: (tmpItem.tex?"body/body_"
                            + tmpItem.id
                            + "_" + tmpItem.tex:null),
                        frames: tmpItem.frames,
                        frameT: tmpItem.frameT,
                        glowText: tmpItem.glow,
                        emissive: (tmpItem.glow?0xffffff:null),
                        noGreen: true
                    }, 0, 0, 0, (Math.PI/2), 2.1 * (tmpItem.sclMlt||1), player.backMesh);
                }
    
                // ADD HAT:
                if (player.hatIndex >= 0 && genBod) {
                    if (customConfig && customConfig[1]) {
                        tmpItem = {...game.store.skins[player.hatIndex]};
                        for (var key in tmpItem) {
                            if (customConfig[1][key] != undefined) {
                                tmpItem[key] = customConfig[1][key];
                            }
                        }
                    } else tmpItem = game.store.skins[player.hatIndex];
                    player.hatMesh = RENDER.genObj3D(0, (config.playerHeight - config.legHeight)
                        - (tmpItem.sitOff||0),
                        - (tmpItem.sitOffZ||0));
                    player.lowerBody.add(player.hatMesh);
                    RENDER.loadMesh({
                        src: ("hats/hat_" + tmpItem.id),
                        texSrc: (tmpItem.tex?"hats/hat_"
                            + tmpItem.id
                            + "_" + tmpItem.tex:null),
                        frames: tmpItem.frames,
                        frameT: tmpItem.frameT,
                        glowText: tmpItem.glow,
                        emissive: (tmpItem.glow?0xffffff:null),
                        noGreen: true
                    }, 0, 0, 0, (Math.PI/2), 2.1 * (tmpItem.sclMlt||1), player.hatMesh);
                }
    
                // LEGS:
                if (genBod) {
                    for (var i = 0; i < 4; ++i) {
                        player.legMeshes.push(RENDER.genLeg((i==1||i==3), pantsColor, shoeColor, (i>1)));
                        if (i >= 2) RENDER.rotateMesh(player.legMeshes[i], (i==2?-(Math.PI / 6)
                            :(Math.PI / 8)), 0, 0);
                        player.legMeshes[i].visible = (i <= 1);
                        holdObj.add(player.legMeshes[i]);
                    }
                }
    
                // WEAPONS & ARMS:
                for (var i = 0; i < player.ammos.length; ++i) {
                    var tmpMesh = RENDER.genObj3D(0, 0, 0);
                    var tmpWeap = game.weapons[player.loadout[i]];
                    var tmpSkin = game.store.skins[tmpWeap.melee?
                        player.meleeIndex:player.skins[i]];
                    if (!tmpSkin) {
                        tmpSkin = {};
                        if (tmpWeap.altSkin) tmpSkin = game.store.skins[
                            tmpWeap.altSkin]||{};
                    }
                    if (!tmpWeap.melee && tmpSkin && (tmpSkin.weapon - 1 !=
                        player.loadout[i])) tmpSkin = {};
                    var tmpAttach = (tmpWeap.attach != undefined &&
                        game.attach[player.attachIndex]?game.attach[player.attachIndex]:null);
                    if (player.isYou && tmpWeap.ammo) {
                        tmpMesh.muzzles = [];
                        tmpMesh.casings = [];
                        for (var x = 0; x < 2; ++x) {
                            if (!(x&&!tmpWeap.akimbo)) {
                                tmpMesh.muzzles.push(new THREE.Sprite());
                                tmpMesh.muzzles[x].visible = false;
                                tmpMesh.muzzles[x].static = true;
                                PARTICLES.particles.push(tmpMesh.muzzles[x]);
                                tmpMesh.add(tmpMesh.muzzles[x]);
                                tmpMesh.casings.push(RENDER.genObj3D((x?-tmpWeap.xOff*2:0), tmpWeap.caseYOff||0,
                                    tmpWeap.caseZOff||0));
                                tmpMesh.add(tmpMesh.casings[x]);
                            }
                        } tmpMesh.muzzleFlash = RENDER.genObj3D(0, 0.4, 0);
                        tmpMesh.muzzles[0].add(tmpMesh.muzzleFlash);
                    }
                    if (tmpWeap.src || !player.renderYou) { // MERGED ARMS:
                        tmpMesh.add(RENDER.genArms(tmpWeap, shirtColor, sleeveColor,
                            skinColor, null, !genBod));
                    } else { // SEPARATE ARMS:
                        for (var x = 0; x < 2; ++x) {
                            var tmpA = RENDER.genArms(tmpWeap, shirtColor, sleeveColor,
                                skinColor, x + 1, !genBod);
                            tmpMesh.add(tmpA);
                            player.armMeshes.push(tmpA);
                        }
                    }
                    player.weaponMeshes.push(tmpMesh);
                    player.weaponMeshes[i].visible = false;
                    player.upperBody.add(player.weaponMeshes[i]);
    
                    // LOAD MELEE MODEL ON HANDS:
                    if (tmpWeap.melee && !(!player.renderYou && player.team == "inf")) {
                        player.weaponGeos[i] = RENDER.loadMesh({
                            src: "melee/melee_" + (tmpSkin.id||0),
                            texSrc: (player.team=="stalk"?"melee/melee_0_5"
                                :(tmpSkin.tex?"melee/melee_"+(tmpSkin.id||0)
                                + "_" + tmpSkin.tex:"")),
                            glowText: tmpSkin.glow,
                            emissive: (tmpSkin.glow?0xffffff:null),
                            pulsT: tmpSkin.pulsT,
                            frames: tmpSkin.frames,
                            frameT: tmpSkin.frameT,
                            tFilter: THREE.LinearFilter,
                            mat: (viewer||player.renderYou?THREE.MeshPhongMaterial:null),
                            noGreen: true,
                            uv2: true,
                            specular: 0x292929,
                            shininess: 100
                        }, (player.renderYou?0.9:1.7)+(player.renderYou?tmpSkin.sxOff||0:0),
                            (player.renderYou?-0.95:-0.4)+(player.renderYou?tmpSkin.syOff||0:0),
                            (player.renderYou?0.72:1.2)+(player.renderYou?tmpSkin.szOff||0:0),
                            [-(Math.PI/3.5), (player.renderYou?0.3+(tmpSkin.flip?Math.PI:0):Math.PI/2),
                            -(Math.PI * 0.9) + (player.renderYou?tmpSkin.sxRot||0:0)], (tmpSkin.sclMlt||0.9),
                            (player.armMeshes[1]?player.armMeshes[1]:player.weaponMeshes[i]));
                        if (player.armMeshes[1]) {
                            player.armMeshes[1].yR = player.armMeshes[1].rotation.y;
                            if (player.renderYou) {
                                player.armMeshes[1].zR = player.armMeshes[1].rotation.z = -0.3;
                                player.armMeshes[1].xR = player.armMeshes[1].rotation.x = -0.4;
                                player.armMeshes[1].xP = player.armMeshes[1].position.x = 0.4;
                                player.armMeshes[1].yP = player.armMeshes[1].position.y = 0.3;
                            } else {
                                player.armMeshes[1].zR = player.armMeshes[1].rotation.z = 0.3;
                                player.armMeshes[1].yP = player.armMeshes[1].position.y = -0.4;
                                player.armMeshes[1].xR = player.armMeshes[1].rotation.x;
                                player.armMeshes[1].xP = player.armMeshes[1].position.x = -0.2;
                            }
                            player.armMeshes[0].xP = player.armMeshes[0].position.x = 0.3;
                            player.armMeshes[0].yP = player.armMeshes[0].position.y = -0.5;
                            player.armMeshes[0].zR = player.armMeshes[0].rotation.z = -0.4;
                            player.armMeshes[0].yR = player.armMeshes[0].rotation.y;
                        }
                    }
    
                    // LOAD WEAPON MODEL:
                    if (tmpWeap.src) {
                        var emGlow = (player.skins[i]>=0&&(tmpSkin.glow||tmpSkin.sameGlow));
                        for (var x = 0; x < 2; ++x) {
                            if (!(x && !tmpWeap.akimbo)) RENDER.loadMesh({
                                src: "weapons/" + tmpWeap.src + (tmpSkin.mid
                                    !=undefined?"_"+tmpSkin.mid:""),
                                texSrc: (tmpSkin.mid!=undefined?tmpSkin.midT:
                                    (tmpSkin.tex?tmpSkin.tex:(tmpSkin && tmpSkin.id
                                    ?"weapons/skins/" + tmpWeap.src
                                    + "_" + tmpSkin.id:null))),
                                tFilter: THREE.LinearFilter,
                                mat: (viewer||player.renderYou?THREE.MeshPhongMaterial:null),
                                movT: tmpSkin.movT,
                                movD: tmpSkin.movD,
                                pulsT: tmpSkin.pulsT,
                                frames: tmpSkin.frames,
                                frameT: tmpSkin.frameT,
                                sameGlow: tmpSkin.sameGlow,
                                glowText: emGlow,
                                noGreen: true,
                                uv2: true,
                                ao: isYou&&!tmpWeap.noAo,
                                shininess: (tmpSkin.shine||tmpWeap.shine||60),
                                specular: 0x292929,
                                transparent: tmpWeap.seeThrough,
                                emissive: ((tmpWeap.transp||emGlow)?0xffffff:null)
                            }, (x==1?-(tmpWeap.xOff*2):0), (tmpSkin.yOff||0),
                                 (tmpSkin.zOff||0), (Math.PI/2),
                                (tmpSkin.mScl||tmpWeap.scale), player.weaponMeshes[i]);
                        }
                    }
    
                    // LOAD FLAP:
                    if (isYou && tmpWeap.flap && RENDER.sniperFlap) {
                        player.weaponMeshes[i].flapMesh = RENDER.loadMesh({
                            src: "attach/" + tmpWeap.flap.src,
                            tFilter: THREE.LinearFilter,
                            noGreen: true,
                            mat: THREE.MeshPhongMaterial,
                            shininess: 60,
                            transparent: true
                        }, tmpWeap.flap.xOff, tmpWeap.flap.yOff, tmpWeap.flap.zOff, (Math.PI/2),
                            tmpWeap.flap.scl, player.weaponMeshes[i]);
                    }
    
                    // LOAD ATTACHMENT MODEL:
                    if (tmpAttach && (isYou||viewer)) RENDER.loadMesh({
                        src: "attach/" + tmpAttach.src,
                        tFilter: THREE.LinearFilter,
                        noGreen: true,
                        mat: (player.renderYou?THREE.MeshPhongMaterial:null),
                        specular: 0x292929,
                        shininess: 60,
                        transparent: true
                    }, 0, -(tmpWeap.yOrg||0) + (tmpWeap.attachYOff||0),
                        -(tmpWeap.attachZOff||0), (Math.PI/2),
                        tmpAttach.scale, player.weaponMeshes[i]);
    
                }
    
                // LOWER BODY:
                holdObj.add(player.lowerBody);
    
                // ADD TO LAYER:
                var lset = function(c) {
                    c.layers.set(1);
                };
                
                if (!genBod) /*WP_S*/player.objInstances.traverse(lset)/*WP_E*/;
            }
    
            // RETURN:
            return player.objInstances;
    
        };
    
        // PICK PROP TO CHANGE TO:
        this.pickProp = function(player) {
            if (io && player && player.active && (!player.lastPropPick
                || game.now - player.lastPropPick >= 200)) {
                player.lastPropPick = game.now;
    
                // RAY COLLISION:
                var sdX = player.xDire;
                var sdY = player.yDire;
                var rayLen = 25;
                tmpList.length = 0;
                var tmpDst = 0;
                var dx = 1 / (rayLen * Math.sin(sdX + Math.PI) * Math.cos(sdY));
                var dz = 1 / (rayLen * Math.cos(sdX + Math.PI) * Math.cos(sdY));
                var dy = 1 / (rayLen * Math.sin(sdY));
                var startY = (player.y + player.height - config.cameraHeight);
    
                // MAP OBJECTS:
                for (var i = 0; i < game.map.manager.objects.length; ++i) {
                    var tmpProp = game.map.manager.objects[i];
                    if (tmpProp.active && tmpProp.propID && !tmpProp.noShoot) {
                        tmpDst = /*WP_S*/UTILS.lineInRect(player.x, player.z, startY,
                            dx, dz, dy, tmpProp.x - tmpProp.width, tmpProp.z - tmpProp.length, tmpProp.y -
                            tmpProp.height, tmpProp.x + tmpProp.width, tmpProp.z + tmpProp.length, tmpProp.y + tmpProp.height)/*WP_E*/;
                        if (tmpDst && tmpDst <= 1) {
                            tmpList.push({
                                obj: tmpProp,
                                dst: tmpDst
                            });
                        }
                    }
                }
    
                // PICK CLOSEST OBJ:
                var tmpRange = rayLen;
                if (tmpList.length) {
                    tmpList.sort(UTILS.orderByDst);
                    if (tmpList[0] && tmpList[0].obj) {
                        /*WP_S*/this.updateProp(player, config.propsH.indexOf(
                            tmpList[0].obj.propID))/*WP_E*/;
                    }
                }
            }
    
        };
    
        // UPDATE PROP:
        this.updateProp = function(player, id, genM) {
            if (player && player.active) {
                if (id != undefined) player.propID = id;
                var tmpS = config[config.propsH[id] + "Scale"];
                var tmpP = (config.propsCP[config.propsH[id]]||0);
                player.height = tmpS + tmpP;
                player.scale = tmpS + tmpP;
                if (genM) this.regenMeshes(player);
                if (io) io.broadcast("game" + game.sid, "up", player.sid, id);
            }
        };
    
        // REGENERATE MESHES:
        this.regenMeshes = function(player) {
            if (player.objInstances) this.disposeMesh(player, true);
            if (RENDER) { 
                this.generateMeshes(player, player.renderYou);
                /*WP_S*/RENDER.add(player.objInstances)/*WP_E*/;
            }
            this.swapWeapon(player, 0, true);
            if (RENDER) this.resetAim();
        };
    
        // HIDE:
        this.hideAll = function() {
            for (var i = 0; i < this.list.length; ++i) {
                if  (this.list[i].active && this.list[i].objInstances) {
                    this.list[i].forcePos = !this.list[i].latestData;
                    this.list[i].latestData = false;
                    if (!this.list[i].isYou) { 
                        var player = this.list[i];
                        /*WP_S*/player.objInstances.visible = true/*WP_E*/;
                    }
    
                }
            }
        };
    
        // CLEAR ALL PLAYERS:
        this.clear = function() {
            if (RENDER) for (var i = 0; i < this.list.length; ++i) {
                this.disposeMesh(this.list[i]);
            }
            this.list.length = 0;
        };
    
        // TOGGLE LOD:
        this.toggleLOD = function(player, vis) {
            if (player.latestData) {
                if (player.objInstances) /*WP_S*/player.objInstances.visible = vis/*WP_E*/;
                player.lodActive = !vis;
            }
        };
    
        // DISPOSE PLAYER MESH:
        this.disposeMesh = function(player, refresh) {
            /*WP_S*/RENDER.remove(player.objInstances)/*WP_E*/;
            /*WP_S*/player.objInstances = null/*WP_E*/;
            player.objInstances = null;
            player.hatMesh = null;
            player.backMesh = null;
            player.weaponMeshes.length = 0;
            player.weaponGeos = {};
            player.armMeshes.length = 0;
            player.legMeshes.length = 0;
    
            console.log("POST DISPOSE");
            /*WP_S*/console.log(player.objInstances)/*WP_E*/;
            console.log(player.objInstances);
            console.log(player.weaponMeshes);
            console.log("</post>")
        };
    
        // ADD PLAYER:
        this.add = function(id, sid, x, y, z, name, classIndex, skins, hatIndex,
            backIndex, meleeIndex, skinColIndex, dyeIndex, attachIndex, kcStatIndex,
            secIndex, propID, team, isYou, isHacker, customLoadout, tmpAccountName) {
    
            // GENERATE OBJECT:
            var tmpPlayer;
            for (var i = 0; i < this.list.length; ++i) {
                if (this.list[i].id == id) {
                    tmpPlayer = this.list[i];
                    break;
                }
            } if (!tmpPlayer) {
                 tmpPlayer = new Player(id, this, UTILS, COLORS, config, game, isYou);
                 if (sid) tmpPlayer.sid = sid;
                 else tmpPlayer.sid = UTILS.generateSID(this.list);
                 this.list.push(tmpPlayer);
            } else {
                tmpPlayer.weaponMeshes.length = 0;
                tmpPlayer.weaponGeos = {};
                tmpPlayer.legMeshes.length = 0;
                tmpPlayer.armMeshes.length = 0;
            }
    
            // SETUP:
            if (!name) name = ("Guest_" + tmpPlayer.sid);
            tmpPlayer.init(x, y, z, name, isYou, isHacker);
            tmpPlayer.tmpAccountName = tmpAccountName;
            if (io && game.mode != undefined) this.setTeam(tmpPlayer);
            if (team) tmpPlayer.team = team;
            tmpPlayer.skins = skins||[-1,-1];
            tmpPlayer.hatIndex = hatIndex;
            tmpPlayer.backIndex = backIndex;
            tmpPlayer.meleeIndex = meleeIndex;
            tmpPlayer.skinColIndex = skinColIndex;
            tmpPlayer.dyeIndex = dyeIndex;
            tmpPlayer.kcStatIndex = kcStatIndex;
            tmpPlayer.attachIndex = attachIndex;
            tmpPlayer.secIndex = secIndex;
            tmpPlayer.setClass(game, classIndex, secIndex, (!!RENDER));
            if (!customLoadout && game.mode.startingLoadout) customLoadout = game.mode.startingLoadout;
            if (customLoadout) tmpPlayer.updateLoadout(game, tmpPlayer.weaponIndex, false, ...customLoadout);
            if (RENDER) { 
                this.generateMeshes(tmpPlayer, tmpPlayer.renderYou);
                var player = tmpPlayer; 
                /*WP_S*/RENDER.add(player.objInstances)/*WP_E*/;
            }
            if (tmpPlayer.team == "prop") this.updateProp(tmpPlayer, (propID||0), true);
            this.swapWeapon(tmpPlayer, 0, true);
            if (typeof window !== 'undefined' && 'updateWindow' in window)
                window.updateWindow(23);
            return tmpPlayer;
    
        };
    
        // REMOVE PLAYER:
        this.remove = function(sid) {
            var tmpIndx = this.indexBySid(sid);
            if (tmpIndx >= 0) {
                if (io && this.list[tmpIndx]) {
                    game.dropFlag(this.list[tmpIndx].flag);
                    this.dropWeapon(this.list[tmpIndx], true);
                }
                var tmpID = this.list[tmpIndx].id;
                if (this.list[tmpIndx].objInstances) this.disposeMesh(this.list[tmpIndx]);
                this.list.splice(tmpIndx, 1);
                if (io) {
                    for (var i = this.list.length - 1; i >= 0; --i) {
                        tmpIndx = this.list[i].sentTo.indexOf(tmpID);
                        if (tmpIndx >= 0) this.list[i].sentTo.splice(tmpIndx, 1);
                    }
                    io.broadcast("game" + game.sid, "2", sid);
                    this.syncLeaders();
                }
                if (typeof window !== 'undefined' && 'updateWindow' in window)
                    window.updateWindow(23);
            }
        };
    
        // GET STEP SOUND:
        var stepSounds = [0, 1, 2];
        this.getStepSound = function() {
            var rand = UTILS.randInt(0, stepSounds.length - 1);
            var soundIndx = stepSounds[rand]
            stepSounds.splice(rand, 1);
            if (stepSounds.length <= 0) stepSounds.push(0, 1, 2);
            return soundIndx;
        };
    
        // PLAYER STEP:
        this.playerStep = function(player, val, prv) {
            if (val) {
                if (!player.renderYou && player.crouchVal) val *= 1.6;
                player.stepVal += val * config.stepMlt * player.stepDir;
                if ((player.stepVal >= Math.PI / 2 && player.stepDir == 1) ||
                    (player.stepVal <= -Math.PI / 2 && player.stepDir == -1)) {
                    if (SOUND && !prv && player.team != "stalk") {
                        var stepVol = UTILS.randFloat(0.15, 0.25) * (player.crouchVal<1?1:(player.isYou?0.5:0));
                        var stepRate = (player.crouchVal<1?1:0.8) * UTILS.randFloat(0.8, 1.2);
                        var stepSrc = (player.stepSrc?("_"+player.stepSrc):"");
                        if (player.isYou) SOUND.play("step_" + this.getStepSound() +
                            stepSrc, stepVol, false, stepRate);
                        else if (stepVol) game.playerSound("step_" + UTILS.randInt(0, 2)
                            + stepSrc, 0, stepVol, player, stepRate, 180);
                    } player.stepDir *= -1;
                }
            }
        };
    
        // RESET STEP:
        this.resetStep = function(player, recon) {
            if (!recon && player.renderYou && player.yVel) {
                if (player.jumpTween) player.jumpTween.stop();
                if (player.landTween) player.landTween.stop();
                player.landTween = new TWEEN.Tween(player).to({
                    landBobY: (6.0 * player.yVel),
                    jumpBobY: 0
                }, 100).easing(TWEEN.Easing.Linear.None).onComplete(function() {
                    player.landTween = new TWEEN.Tween(player).to({
                        landBobY: 0
                    }, 1100).easing(TWEEN.Easing.Elastic.Out).start();
                }).start();
            } if (SOUND && !recon && player.yVel && player.team != "stalk") {
                var stepSrc = (player.stepSrc?("_"+player.stepSrc):"");
                SOUND.play("step_" + this.getStepSound(), 0.7, false, UTILS.randFloat(0.9, 1.2));
                if (player.renderYou) {
                    if (player.crouchVal && game.config.canSlide && player.canSlide) SOUND.play(
                        "slide_0", 0.35, false, UTILS.randFloat(0.9, 1.1));
                }
            } if (game.config.canSlide && player.crouchVal && player.canSlide) {
                player.canSlide = false;
                player.slideTimer = ((config.slideTime * game.map.config.slT) * player.crouchVal);
                var velMlt = (this.onTerrain?config.playerTerrainSlideVelMlt
                    :config.playerSlideVelMlt) * game.map.config.slA;
                player.xVel *= velMlt;
                player.zVel *= velMlt;
            }
        };
    
        // TRY TO JUMP:
        this.tryJump = function(player, jKey) {
            if (game.config && game.config.autoJump && jKey) this.jump(player);
            else {
                if (player.didJump && !jKey) player.didJump = false;
                if (!player.didJump && jKey) this.jump(player);
            }
        };
    
        // JUMP:
        this.jump = function(player) {
            player.jumpCooldown = (player.terrainSlipping ? config.playerSlippingJumpCooldown : 0) * game.map.config.jpC;
            player.didJump = true;
            player.onTerrain = false;
            var jumpVel = config.jumpVel * (game.config?game.config.jumpMlt:1);
            var jumpPull = config.jumpPush * (game.config?game.config.jumpMlt:1);
            player.yVel += (jumpVel - (jumpVel * (config.crouchJump * player.crouchVal))) *
                 player.weapon.spdMlt * (player.aimVal?1:config.aimJumpSlow);
            var tmpSpd = UTILS.getDistance(0, 0, player.xVel, player.zVel);
            player.xVel -= (jumpPull * tmpSpd) * Math.sin(player.xDire);
            player.zVel -= (jumpPull * tmpSpd) * Math.cos(player.xDire);
            if (SOUND && !player.recon && player.renderYou) {
                if (player.landTween) player.landTween.stop();
                player.landTween = new TWEEN.Tween(player).to({
                    landBobY: 0
                }, 100).easing(TWEEN.Easing.Linear.None).start();
                if (player.jumpTween) player.jumpTween.stop();
                player.jumpTween = new TWEEN.Tween(player).to({
                    jumpBobY: 0.22
                }, 500).easing(TWEEN.Easing.Back.Out).start();
                var jRotV = UTILS.randFloat(0.12, 0.15);
                var tmpTween = new TWEEN.Tween(player).to({
                    jumpRot: [jRotV, 0]
                }, 900).easing(TWEEN.Easing.Back.Out).start();
                SOUND.play("jump_" + UTILS.randInt(0, 1), 0.04,
                    false, UTILS.randFloat(0.9, 1));
            }
        };
    
        // UPDATE AIM:
        this.updateAim = function(player, mlt) {
            RENDER.zoom(1 + ((player.weapon.zoom - 1) * mlt));
        };
    
        // TOGGLE AIM:
        this.toggleAim = function(player, aim) {
            if (SOUND && !player.recon) SOUND.play("aim_" + aim, 0.1);
            if (!aim || player.team == "prop") this.resetAim();
            if (game.controls.camType.isNormal && player.weapon.scope && player.weaponMeshes && player.weaponMeshes[player.weaponIndex]) {
                RENDER.zoom(aim?player.weapon.zoom:1);
                player.weaponMeshes[player.weaponIndex].visible = (!this.isWeaponHidden(player, player.weaponIndex) && !aim);
                aimRecticle.style.opacity = (aim?1:0);
            }
            var tmpAttach = player.weapon.attach != undefined &&
                game.attach[player.attachIndex] ? game.attach[player.attachIndex] : null;
            var tmpReticle = player.weapon.attach != undefined &&
                game.reticles[RENDER.reticleIndex] ? game.reticles[RENDER.reticleIndex] : null;
    
            if (game.controls.camType.isNormal && tmpAttach) {
                var tmpSrc;
                if (RENDER.reticleIndex == -2 && RENDER.customADS.length) tmpSrc = RENDER.customADS;
                else if (RENDER.reticleIndex != -1) {
                    tmpSrc = UTILS.assetsUrl("/textures/reticles/reticle_" +
                        (tmpReticle ? tmpReticle.id : 0) + ".png");
                }
                if (aimDot.src != tmpSrc) aimDot.src = tmpSrc;
                aimDot.style.opacity = (aim?1:0);
                aimDot.style.display = (RENDER.reticleIndex == -1 ? "none" : "");
            }
            if (game.controls.camType.isNormal && player.weaponMeshes && player.weaponMeshes[player.weaponIndex] && RENDER.hideADS) {
                if (aim) player.weaponMeshes[player.weaponIndex].visible = false;
                else player.weaponMeshes[player.weaponIndex].visible = !this.isWeaponHidden(player, player.weaponIndex);
            }
        };
    
        // RESET AIM:
        this.resetAim = function() {
            RENDER.zoom(1);
            aimRecticle.style.opacity = 0;
            aimDot.style.opacity = 0;
        };
    
        // CHECK IF WEAPON IS VISIBLE:
        this.isWeaponHidden = function(player, index) {
            var loadout = player.loadout[index];
            if (game.weapons[loadout].melee && game.hideWeapon[2]) return true;
            else if (game.weapons[loadout].secondary && game.hideWeapon[1]) return true;
            else if (!(game.weapons[loadout].melee||game.weapons[loadout].secondary) && game.hideWeapon[0]) return true;
            return false;
        };
    
        // RELOAD:
        this.reload = function(player) {
            if (!player.reloadTimer && player.ammos[player.weaponIndex] < player.weapon.ammo) {
                if (SOUND) SOUND.play("reload_1", 0.25);
                player.reloadTimer = player.weapon.reload;
                player.burstCount = 0;
                if (player.isYou) this.cancelInspect(player);
            }
        };
    
        // END RELOAD:
        this.endReload = function(weapon) {
            if (SOUND) {
                SOUND.play("reload_2" + (weapon.custReload||""), 0.25);
            }
            //if (RENDER) this.resetAim();
        };
    
        // UPDATE PLAYER AMMO:
        this.updatePlayerAmmo = function(player) {
            if (player.isYou) {
                ammoDisplay.style.display = "inline-block";
                ammoVal.innerHTML = (player.ammos[player.weaponIndex]||
                    (player.weapon.melee?"-":0)) +
                    " <span id='ammoMax'> | " + (player.weapon.ammo||"-") + "</span>";
                if (player.ammos[player.weaponIndex] <= 0) {
                    reloadMsg.innerHTML = "[R] Reload"
                    reloadMsg.style.display = "block"
                } else reloadMsg.style.display = "none";
            }
        };
    
        // CANCEL INSPECT:
        this.cancelInspect = function(player) {
            player.inspecting = false;
            player.inspectX = 0;
        };
    
        // INSPECT WEAPON:
        this.wInspect = function(player) {
            if (player.inspecting) {
                this.cancelInspect(player);
            } else if (!player.weapon.nInsp && !player.inspecting &&
                player.aimVal == 1 && !player.reloadTimer) {
                player.inspecting = true;
            }
        };
    
        // MELEE:
        this.melee = function(player) {
            player.reloads[player.weaponIndex] = player.weapon.rate;
            player.didShoot = true;
            if (player.isYou) {
                if (player.isYou && game.controls) {
                     if (game.controls.vibration && game.controls.gamepad.active)
                        game.controls.gamepad.rumble(player.weapon.rumbleDur||200, player.weapon.rumble||0.5);
                    else if (game.controls.vibrationMbl && !game.controls.isMobile && "vibrate" in navigator)
                        navigator.vibrate(player.weapon.rumbleDur||200);
                }
                if (player.weapon.anim) {
                    var tmpSkin = game.store.skins[player.meleeIndex]||{};
                    player.weapon.anim(player, TWEEN, tmpSkin.animInd||1);
                }
                if (player.weapon.sounds) SOUND.play(player.weapon.sounds[
                    UTILS.randInt(0, player.weapon.sounds.length - 1)],
                    0.1, false, UTILS.randFloat(0.9, 1.1));
            }
    
            // HIT SCAN:
            var sdX = player.xDire;
            var sdY = player.yDire;
            tmpList.length = 0;
            var tmpDst = 0;
            var dx = 1 / (player.weapon.range * Math.sin(sdX + Math.PI) * Math.cos(sdY));
            var dz = 1 / (player.weapon.range * Math.cos(sdX + Math.PI) * Math.cos(sdY));
            var dy = 1 / (player.weapon.range * Math.sin(sdY));
            var startY = (player.y + player.height - config.cameraHeight);
    
            // MAP OBJECTS:
            for (var i = 0; i < game.map.manager.objects.length; ++i) {
                tmpObj2 = game.map.manager.objects[i];
                if (tmpObj2.active && !tmpObj2.noShoot) {
                    tmpDst = /*WP_S*/UTILS.lineInRect(player.x, player.z, startY,
                        dx, dz, dy, tmpObj2.x - tmpObj2.width, tmpObj2.z - tmpObj2.length, tmpObj2.y -
                        tmpObj2.height, tmpObj2.x + tmpObj2.width, tmpObj2.z + tmpObj2.length, tmpObj2.y + tmpObj2.height)/*WP_E*/;
                    if (tmpDst && tmpDst <= 1) {
                        tmpList.push({
                            obj: tmpObj2,
                            dst: tmpDst
                        });
                    }
                }
            }
    
            // PLAYERS:
            if (io) for (var i = 0; i < this.list.length; ++i) {
                if (this.list[i].active && player != this.list[i] && !(player.team && player.team == this.list[i].team)) {
                    tmpObj2 = this.fetchState(this.list[i], player.getStateConst());
                    if (tmpObj2) {
                        tmpDst = /*WP_S*/UTILS.lineInRect(player.x, player.z, startY, dx, dz, dy,
                            tmpObj2.x - this.list[i].scale - game.config.hitBoxPad,
                            tmpObj2.z - this.list[i].scale - game.config.hitBoxPad, tmpObj2.y,
                            tmpObj2.x + this.list[i].scale + game.config.hitBoxPad,
                            tmpObj2.z + this.list[i].scale + game.config.hitBoxPad, tmpObj2.y
                            + this.list[i].height + game.config.hitBoxPad)/*WP_E*/;
                        if (tmpDst && tmpDst <= 1) {
                            tmpList.push({
                                player: true,
                                obj: this.list[i],
                                dst: tmpDst
                            });
                        }
                    }
                }
            }
    
            // HIT CLOSEST OBJ:
            var tmpRange = player.weapon.range;
            if (tmpList.length) {
                tmpList.sort(UTILS.orderByDst);
                var DMG = player.smite ? 10000 : player.weapon.dmg;
                for (var i = 0; i < tmpList.length; ++i) {
                    tmpObj2 = tmpList[i];
                    tmpRange = player.weapon.range * tmpObj2.dst;
                    if (io) {
                        var headShot = false;
                        var legShot = false;
                        if (io && !game.waitTimers && tmpObj2.obj &&
                            tmpObj2.obj.health && !tmpObj2.player) {
                            io.send(player.id, "4");
                            tmpObj2.obj.health -= DMG;
                            if (tmpObj2.obj.health <= 0) {
                                tmpObj2.obj.active = false;
                                tmpObj2.obj.health = 0;
                                tmpObj2.obj.destroyedBy = player;
                                game.destObjs.push(tmpObj2.obj.uid);
                                io.broadcast("game" + game.sid, "do", tmpObj2.obj.uid);
                                if (tmpObj2.obj && tmpObj2.obj.onDestroy)
                                    game.onTrigger(player, tmpObj2.obj);
                            }
                        }
    
                        // NORMAL PROP:
                        if (io && player.team == "seek" && !tmpObj2.player && tmpObj2.obj && tmpObj2.obj.propID) {
                            if (this.changeHealth(player, null, 10)) this.kill(player, null, {});
                        }
    
                        // ON MELEE TRIGGER
                        if (tmpObj2.obj && (tmpObj2.obj.onMelee || tmpObj2.obj.onDamage))
                            game.onTrigger(player, tmpObj2.obj);
    
                        // APPLY DAMAGE TO PLAYER:
                        if (tmpObj2.player || (tmpObj2.obj && tmpObj2.obj.dummy)) {
                            if (game.mode && game.mode.onMelee &&
                                game.mode.onMelee(game, player, tmpObj2.obj)) {
                                DMG = (tmpObj2.obj.health||DMG);
                            }
                            if (this.changeHealth(tmpObj2.obj, player, DMG)) {
                                if (player) {
                                    player.melees++;
                                    if (io) game.incStat("mk", player);
                                }
                                this.kill(tmpObj2.obj, player, {
                                    weaponId: game.weapons.findIndexBySrc(player.weapon.src),
                                    weapon: player.weapon
                                });
                            } DMG -= (player.weapon.pierce!=undefined)?(player.weapon.dmg *
                                config.materialDens["flesh"]) * player.weapon.pierce:DMG;
                        } else break;
                        if (DMG <= 0) break;
                    } else break;
                }
            }
    
        };
    
        // SHOOT:
        var tmpList = [];
        this.shoot = function(player, input) {
            var didHit = false;
            if (io) game.incStat("s", player);
            if (!game.config.noReload) player.ammos[player.weaponIndex]--;
            player.didShoot = true;
            if (player.burstCount) player.burstCount--;
            else player.burstCount = (player.weapon.burst?
                player.weapon.burst.c-1:0);
            player.reloads[player.weaponIndex] = (player.burstCount&&
                player.weapon.burst?player.weapon.burst.r:player.weapon.rate);
            this.updatePlayerAmmo(player);
            if (game.playSound) {
                var gClick = (player.ammos[player.weaponIndex] / game.weapons[player.loadout[player.weaponIndex]].ammo);
                var tmpSkin = game.store.skins[player.skins[player.weaponIndex]];
                if (!tmpSkin && player.weapon.altSkin != undefined) tmpSkin =
                    game.store.skins[player.weapon.altSkin];
                var tmpSound = (player.weapon.sound + (tmpSkin&&tmpSkin.mid
                    !=undefined?"_"+tmpSkin.mid:""));
                if (player.renderYou && gClick <= 0.25 && !player.weapon.nRing) {
                    game.playSound(tmpSound, 0.85, player, false,
                        UTILS.randFloat(0.9, 1.0) + (0.15 * (1 - (gClick / 0.25))));
                } else game.playSound(tmpSound, 0.85, player, false,
                    UTILS.randFloat(0.9, 1.0));
            } player.recoilForce += player.weapon.recoil;
            if (player.isYou && game.controls) {
                 if (game.controls.vibration && game.controls.gamepad.active)
                    game.controls.gamepad.rumble(player.weapon.rumbleDur||200, player.weapon.rumble||0.5);
                else if (game.controls.vibrationMbl && !game.controls.isMobile && "vibrate" in navigator)
                    navigator.vibrate(player.weapon.rumbleDur||200);
            }
            if (player.renderYou) {
                var tmpVl = UTILS.randInt(0,1)?-player.weapon.recoilR:player.weapon.recoilR;
                player.recoilX += tmpVl;
                player.recoilZ += tmpVl;
                if (player.recoilTween) player.recoilTween.stop();
                var tweenTime = (player.weapon.recoilAnim?(player.weapon.recoilAnim.time||
                    player.weapon.rate):player.weapon.rate);
                if (player.aimVal == 0 && player.weapon.recoilAnim && player.weapon.recoilAnim.aimTime)
                    tweenTime = player.weapon.recoilAnim.aimTime;
                player.recoilTween = new TWEEN.Tween(player).to(player.weapon.recoilAnim||{},
                    tweenTime * 0.15).easing(TWEEN.Easing.Linear.None).onComplete(function() {
                    player.recoilTween = new TWEEN.Tween(player).to({
                        recoilTweenY: 0,
                        recoilTweenYM: 0,
                        recoilTweenZ: 0
                    }, tweenTime * 0.95).easing(TWEEN.Easing.Back.Out).start();
                }).start();
                this.cancelInspect(player);
            }
    
            // PARTICLES:
            if (player.renderYou && !this.isWeaponHidden(player, player.weaponIndex)) {
                var tmpMesh = player.weaponMeshes[player.weaponIndex];
                var scopedIn = (player.aimVal == 0 && player.weapon.scope);
                if (PARTICLES.showMuzzle && !player.weapon.nMuz &&
                    (RENDER.useDepthMap == 0 || RENDER.useDepthMap == "0") && !game.controls.camOffset) {
                    for (var x = 0; x < tmpMesh.muzzles.length; ++x) {
                        tmpMesh.muzzles[x].visible = true;
                        PARTICLES.setMaterial(tmpMesh.muzzles[x], (player.weapon.muzID||2), 1, true);
                        tmpMesh.muzzles[x].init((x?-(player.weapon.xOff*2):0), player.weapon.muzOffY||0, -player.weapon.muzOff,
                            0, 0, 0, 4 * (player.weapon.muzMlt||1), 1);
                    } if (!scopedIn) {
                        var tmpPos = player.weaponMeshes[player.weaponIndex].muzzles[0].getWorldPosition().clone();
                        tmpPos.project(RENDER.camera);
                        tmpPos.x = (tmpPos.x + 1) / 2;
                        tmpPos.y = (tmpPos.y + 1) / 2;
                        RENDER.flash(tmpPos.x, tmpPos.y);
                    }
                } if (!player.weapon.nCase && PARTICLES.active) {
                    for (var x = 0; x < player.weaponMeshes[player.weaponIndex].casings.length; ++x) {
                        var tmpPos = player.weaponMeshes[player.weaponIndex].casings[x].getWorldPosition();
                        if (SOUND && (game.now - (player.lastShell||0)) > 400) {
                            player.lastShell = game.now;
                            SOUND.play3D("case_" + UTILS.randInt(0, 1),
                            tmpPos.x, tmpPos.y, tmpPos.z, 0.65,
                            UTILS.randFloat(0.8, 1.3));
                        } if (!scopedIn) {
                            var randM = (UTILS.randInt(0,1)?1.4:0.8);
                            PARTICLES.physObj(tmpPos.x, tmpPos.y, tmpPos.z, player.xDire -
                                ((Math.PI / 2) * (x?-1:1)), (Math.PI / 5) *
                                UTILS.randFloat(0.75, 1.2) * randM,
                                25, false, player.weapon.caseInd||1, player);
                        }
                    }
                }
            }
    
            // PROJECTILE:
            var weaponId = game.weapons.findIndexBySrc(player.weapon.src);
            if (player.weapon.projectile != undefined) {
                if (io) {
                    var tmpSpr = (player.spread + (player.weapon.innac||0)) * config.spreadAdj;
                    var sdX = player.xDire + UTILS.randFloat(-tmpSpr, tmpSpr);
                    var sdY = player.yDire + (player.recoilAnimY * config.recoilMlt)
                        + UTILS.randFloat(-tmpSpr, tmpSpr);
                    var retObj = {
                        weaponId: weaponId,
                        weapon: game.weapons[weaponId]
                    };
                    /*WP_S*/game.projectiles.init(player.x, player.y + player.height - config.cameraHeight,
                    player.z, sdX, sdY, player.weapon.projectile, player, retObj)/*WP_E*/;
                }
            }
            if (player.weapon.projectile == undefined || player.weapon.physPow) {
    
                // HIT SCAN:
                var sCnt = 0;
                for (var s = (player.weapon.physPow?-1:0); s < (player.weapon.shots
                    ==undefined?1:player.weapon.shots); ++s) {
    
                    // SPREAD:
                    var sdX = 0;
                    var sdY = 0;
                    if (player.weapon.cSpread && s >= 0) {
                        var rMlt = UTILS.randFloat(0.3, 0.32);
                        var sprdInd = (player.ammos[player.weaponIndex] * (player.weapon.shots * 2));
                        sdX = player.xDire + (player.weapon.cSpread[sprdInd+sCnt] * rMlt);
                        sdY = player.yDire + (player.weapon.cSpread[sprdInd+sCnt+1] * rMlt);
                        sCnt+=2;
                    } else {
                        var tmpSpr = (s>=0?((player.spread + (player.weapon.innac
                            ||0)) * config.spreadAdj):0);
                        sdX = player.xDire + UTILS.randFloat(-tmpSpr, tmpSpr);
                        sdY = player.yDire + UTILS.randFloat(-tmpSpr, tmpSpr);
                    }
                    sdY += (player.recoilAnimY * config.recoilMlt);
    
                    // RANGE:
                    var weapRange = player.weapon.range;
                    if (s < 0) weapRange = player.weapon.physRang;
    
                    // BULLET COLLISION:
                    tmpList.length = 0;
                    var tmpDst = 0;
                    var dx = 1 / (weapRange * Math.sin(sdX + Math.PI) * Math.cos(sdY));
                    var dz = 1 / (weapRange * Math.cos(sdX + Math.PI) * Math.cos(sdY));
                    var dy = 1 / (weapRange * Math.sin(sdY));
    
                    // START POSITION:
                    var startY = (player.y + player.height - config.cameraHeight);
    
                    // MAP OBJECTS:
                    for (var i = 0; i < game.map.manager.objects.length; ++i) {
                        tmpObj2 = game.map.manager.objects[i];
                        if (tmpObj2.active && !tmpObj2.noShoot) {
                            tmpDst = /*WP_S*/UTILS.lineInRect(player.x, player.z, startY,
                                dx, dz, dy, tmpObj2.x - tmpObj2.width, tmpObj2.z - tmpObj2.length, tmpObj2.y -
                                tmpObj2.height, tmpObj2.x + tmpObj2.width, tmpObj2.z + tmpObj2.length, tmpObj2.y + tmpObj2.height)/*WP_E*/;
                            if (tmpDst && tmpDst <= 1) {
                                tmpList.push({
                                    obj: tmpObj2,
                                    dst: tmpDst
                                });
                            }
                        }
                    }
    
                    // PLAYERS:
                    if (io && s >= 0) for (var i = 0; i < this.list.length; ++i) {
                        if (this.list[i].active && player != this.list[i] && !(player.team && player.team == this.list[i].team)) {
                            tmpObj2 = this.fetchState(this.list[i], player.getStateConst());
                            if (tmpObj2) {
                                tmpDst = /*WP_S*/UTILS.lineInRect(player.x, player.z, startY, dx, dz, dy,
                                    tmpObj2.x - this.list[i].scale - game.config.hitBoxPad,
                                    tmpObj2.z - this.list[i].scale - game.config.hitBoxPad,
                                    tmpObj2.y,
                                    tmpObj2.x + this.list[i].scale + game.config.hitBoxPad,
                                    tmpObj2.z + this.list[i].scale + game.config.hitBoxPad,
                                    tmpObj2.y + this.list[i].height + game.config.hitBoxPad)/*WP_E*/;
                                if (tmpDst && tmpDst <= 1) {
                                    tmpList.push({
                                        player: true,
                                        obj: this.list[i],
                                        dst: tmpDst
                                    });
                                }
                            }
                        }
                    }
    
                    // TERRAIN:
                    var terrain = game.map.terrain;
                    if (terrain) {
                        var terrainRaycast = /*WP_S*/terrain.raycast(player.x, -player.z, startY, 1/dx, -1/dz, 1/dy)/*WP_E*/;
                        if (terrainRaycast) {
                            let dst = /*WP_S*/UTILS.getD3D(player.x, startY, player.z,
                                terrainRaycast.x, terrainRaycast.z, -terrainRaycast.y)/*WP_E*/;
                            tmpList.push({
                                terrain: true,
                                dst: (dst / weapRange)
                            })
                        }
                    }
    
                    // HIT CLOSEST OBJ:
                    var tmpRange = weapRange;
                    if (tmpList.length) {
                        tmpList.sort(UTILS.orderByDst);
                        var DMG = player.smite ? 10000 : player.weapon.dmg;
                        var wallbang = false;
                        for (var i = 0; i < tmpList.length; ++i) {
                            tmpObj2 = tmpList[i];
                            tmpRange = weapRange * tmpObj2.dst;
                            if (s < 0) {
                                var impulse = (1 - tmpObj2.dst) * (player.weapon.physPow * (game.config?game.config.impulseMlt:1));
                                var tXV = (impulse * Math.sin(sdX + Math.PI) * Math.cos(sdY));
                                player.xVel -= tXV;
                                var tYV = (impulse * Math.cos(sdX + Math.PI) * Math.cos(sdY));
                                player.zVel -= tYV;
                                var tZV = (impulse * Math.sin(sdY));
                                player.yVel -= tZV;
                                player.onGround = false;
                                if (!io) input.velObj = {
                                    x: tXV,
                                    y: tYV,
                                    z: tZV
                                };
                                break;
                            } else if (io) {
    
                                // CALCULATE DAMAGE:
                                var dropStart = (player.weapon.dropStart||0);
                                var tmpDrop = Math.min(1, (1 - ((1 - tmpObj2.dst) * weapRange)
                                    / (weapRange - dropStart)));
                                var tmpDMG = DMG - (player.weapon.dmgDrop * tmpDrop);
                                var headShot = false;
                                var legShot = false;
                                if (tmpObj2.player) {
                                    var hitY = startY + (tmpRange * Math.sin(sdY));
                                    headShot = ((tmpObj2.obj.y + tmpObj2.obj.height) - hitY < config.headScale);
                                    legShot = ((tmpObj2.obj.y + config.legHeight) > hitY);
                                    tmpDMG *= (headShot&&!player.weapon.noHeadShot?1.5:1);
                                    tmpDMG *= (legShot?0.5:1);
                                    if (!headShot && (game.config?game.config.headshotOnly:false))
                                        tmpDMG = 0;
                                }
    
                                // DESTRUCTABLE OBJECT:
                                if (io && !game.waitTimers && tmpObj2.obj && tmpObj2.obj.health
                                    && !tmpObj2.player) {
                                    tmpObj2.obj.health -= tmpDMG;
                                    io.send(player.id, "4");
                                    if (tmpObj2.obj.health <= 0) {
                                        tmpObj2.obj.active = false;
                                        tmpObj2.obj.health = 0;
                                        tmpObj2.obj.destroyedBy = player;
                                        game.destObjs.push(tmpObj2.obj.uid);
                                        io.broadcast("game" + game.sid, "do", tmpObj2.obj.uid);
                                        if (tmpObj2.obj && tmpObj2.obj.onDestroy) // DESTROY TRIGGER
                                            game.onTrigger(player, tmpObj2.obj);
                                    }
                                }
    
                                // NORMAL PROP:
                                if (io && player.team == "seek" && !tmpObj2.player && tmpObj2.obj && tmpObj2.obj.propID) {
                                    if (this.changeHealth(player, null, 10)) this.kill(player, null, {});
                                }
    
                                // ON SHOOT TRIGGER
                                if (tmpObj2.obj && (tmpObj2.obj.onShoot || tmpObj2.obj.onDamage))
                                    game.onTrigger(player, tmpObj2.obj);
    
                                // APPLY DAMAGE:
                                if (tmpObj2.player || (tmpObj2.obj && tmpObj2.obj.dummy)) {
                                    if (tmpObj2.player) didHit = true;
                                    if (this.changeHealth(tmpObj2.obj, player, tmpDMG, null, headShot)) {
                                        if (wallbang) player.wallbangs++;
                                        if (headShot) {
                                            player.headshots++;
                                            if (io) game.incStat("hs", player);
                                        }
                                        this.kill(tmpObj2.obj, player, {
                                            dst: tmpObj2.dst,
                                            headShot: headShot,
                                            wallbang: wallbang,
                                            weaponId: weaponId,
                                            weapon: game.weapons[weaponId]
                                        });
                                    }
                                    DMG -= (player.weapon.pierce!=undefined)?(player.weapon.dmg *
                                        config.materialDens["flesh"])*player.weapon.pierce:DMG;
                                } else if (tmpObj2.obj && tmpObj2.obj.penetrable) {
                                    wallbang = true;
                                    DMG -= (player.weapon.pierce!=undefined)?(player.weapon.dmg *
                                        config.materialDens["default"])*player.weapon.pierce:DMG;
                                } else break;
                                if (DMG <= 0) break;
                            } else break;
                        }
    
                    }
    
                    // SKIP FIRST:
                    if (s < 0) continue;
    
                    // HIT LOCATION:
                    tmpRange -= 0.12;
                    var hitX = /*WP_S*/player.x + (tmpRange * Math.sin(sdX + Math.PI) * Math.cos(sdY))/*WP_E*/;
                    var hitY = startY + (tmpRange * Math.sin(sdY));
                    var hitZ = /*WP_S*/player.z + (tmpRange * Math.cos(sdX + Math.PI) * Math.cos(sdY))/*WP_E*/;
                    var xDr = 0;
                    var yDr = 0;
    
                    // IMPACT ANIMATION & PARTICLES:
                    if (tmpList.length) {
                        if (tmpObj2.terrain) {
                            yDr = Math.PI / 2;
                        } else {
                            if (hitY >= tmpObj2.obj.y + tmpObj2.obj.height) yDr = Math.PI / 2;
                            else if (hitY <= tmpObj2.obj.y - tmpObj2.obj.height) yDr = -Math.PI / 2;
                            else if (hitX <= tmpObj2.obj.x - tmpObj2.obj.width) xDr = -Math.PI / 2;
                            else if (hitX >= tmpObj2.obj.x + tmpObj2.obj.width) xDr = Math.PI / 2;
                            else if (hitZ <= tmpObj2.obj.z - tmpObj2.obj.length) xDr = Math.PI;
                        }
                        if (!io) PARTICLES.effect(hitX, hitY, hitZ, xDr, yDr, 0);
                    } if (io) {
                        var sendTrail = (player.weapon&&player.weapon.trail?1:0);
                        for (var i = 0; i < this.list.length; ++i) {
                            if ((this.list[i].active || this.list[i].spectating) && this.list[i] != player) {
                                if (tmpList.length && !tmpObj2.player) io.send(this.list[i].id, "9",
                                    player.sid, Math.round(hitX), Math.round(hitY),
                                    Math.round(hitZ), xDr.round(1), yDr.round(1), sendTrail);
                                else io.send(this.list[i].id, "9", player.sid, Math.round(hitX),
                                     Math.round(hitY), Math.round(hitZ), undefined,
                                    undefined, sendTrail);
                            }
                        }
                    }
    
                    // TRACER:
                    if (player.isYou && tmpRange >= config.tracerMinDst) {
                        var randMuz = UTILS.randInt(0, player.weaponMeshes[player.weaponIndex].muzzles.length - 1);
                        var tmpPos = player.weaponMeshes[player.weaponIndex].muzzles[randMuz].getWorldPosition();
                        var extender = ((player.weapon&&player.weapon.scope&&player.aimVal==0)?7:0);
                        var tX = tmpPos.x -(extender * Math.sin(sdX + Math.PI) * Math.cos(sdY));;
                        var tY = tmpPos.y -(extender * Math.sin(sdY));;
                        var tZ = tmpPos.z -(extender * Math.cos(sdX + Math.PI) * Math.cos(sdY));;
                        var td = UTILS.getD3D(tX, tY, tZ, hitX, hitY, hitZ);
                        var xDr = UTILS.getDir(tZ, tX, hitZ, hitX);
                        var yDr = UTILS.getDir(UTILS.getDistance(tX, tZ, hitX, hitZ), hitY, 0, tY);
                        PARTICLES.physObj(tX, tY, tZ, xDr, yDr, Math.min(tmpRange + extender,
                            config.tracerMaxDst), (player.weapon
                            &&player.weapon.trail), 0, player);
                    }
    
                }
            }
            if (didHit && io) game.incStat("h", player);
        };
    
        // SPRAY:
        this.spray = function(player) {
            if (game.now - player.lastSpray >= config.sprayTimer) {
                tmpList.length = 0;
                var tmpDst = 0;
                var dx = 1 / (config.sprayRange * Math.sin(player.xDire + Math.PI) * Math.cos(player.yDire));
                var dz = 1 / (config.sprayRange * Math.cos(player.xDire + Math.PI) * Math.cos(player.yDire));
                var dy = 1 / (config.sprayRange * Math.sin(player.yDire));
                for (var i = 0; i < game.map.manager.objects.length; ++i) {
                    tmpObj2 = game.map.manager.objects[i];
                    if (!tmpObj2.noShoot && !tmpObj2.noVis) {
                        tmpDst = /*WP_S*/UTILS.lineInRect(player.x, player.z, player.y + player.height - config.cameraHeight,
                            dx, dz, dy, tmpObj2.x - tmpObj2.width, tmpObj2.z - tmpObj2.length, tmpObj2.y -
                            tmpObj2.height, tmpObj2.x + tmpObj2.width, tmpObj2.z + tmpObj2.length, tmpObj2.y + tmpObj2.height)/*WP_E*/;
                        if (tmpDst && tmpDst <= 1) {
                            tmpList.push({
                                obj: tmpObj2,
                                dst: tmpDst
                            });
                        }
                    }
                }
                if (tmpList.length) {
                    tmpList.sort(UTILS.orderByDst);
                    tmpObj2 = tmpList[0].obj;
                    if (tmpObj2) {
                        var tmpRange = (config.sprayRange * tmpList[0].dst) - 0.1;
                        var hitY = /*WP_S*/(player.y + player.height - config.cameraHeight) + (tmpRange * Math.sin(player.yDire))/*WP_E*/;
                        var hitX = /*WP_S*/player.x + (tmpRange * Math.sin(player.xDire + Math.PI) * Math.cos(player.yDire))/*WP_E*/;
                        var hitZ = /*WP_S*/player.z + (tmpRange * Math.cos(player.xDire + Math.PI) * Math.cos(player.yDire))/*WP_E*/;
                        var xDr = 0;
                        var yDr = 0;
                        if (hitY >= tmpObj2.y + tmpObj2.height) yDr = -90;
                        else if (hitY <= tmpObj2.y - tmpObj2.height) yDr = 90;
                        else if (hitX <= tmpObj2.x - tmpObj2.width) xDr = -90;
                        else if (hitX >= tmpObj2.x + tmpObj2.width) xDr = 90;
                        else if (hitZ <= tmpObj2.z - tmpObj2.length) xDr = 180;
                        var tS = config.sprayScale / 2;
                        if (yDr) {
                            if (tmpObj2.width < tS || tmpObj2.length < tS) return;
                            if (hitZ - tS < tmpObj2.z - tmpObj2.length)
                                hitZ = tmpObj2.z - tmpObj2.length + tS;
                            else if (hitZ + tS > tmpObj2.z + tmpObj2.length)
                                hitZ = tmpObj2.z + tmpObj2.length - tS;
                            if (hitX - tS < tmpObj2.x - tmpObj2.width)
                                hitX = tmpObj2.x - tmpObj2.width + tS;
                            else if (hitX + tS > tmpObj2.x + tmpObj2.width)
                                hitX = tmpObj2.x + tmpObj2.width - tS;
                        } else {
                            if (tmpObj2.height < tS) return;
                            if (xDr == 90 || xDr == -90) {
                                if (tmpObj2.length < tS) return;
                                if (hitZ - tS < tmpObj2.z - tmpObj2.length)
                                    hitZ = tmpObj2.z - tmpObj2.length + tS;
                                else if (hitZ + tS > tmpObj2.z + tmpObj2.length)
                                    hitZ = tmpObj2.z + tmpObj2.length - tS;
                            } else {
                                if (tmpObj2.width < tS) return;
                                if (hitX - tS < tmpObj2.x - tmpObj2.width)
                                    hitX = tmpObj2.x - tmpObj2.width + tS;
                                else if (hitX + tS > tmpObj2.x + tmpObj2.width)
                                    hitX = tmpObj2.x + tmpObj2.width - tS;
                            } if (hitY + tS > tmpObj2.y + tmpObj2.height)
                                hitY = tmpObj2.y + tmpObj2.height - tS;
                        }
                        player.lastSpray = game.now;
                        if (game.playSound) game.playSound("spray", 0.4, player, true);
                        io.broadcast("game" + game.sid, "sp", player.sid, player.sprayIndex, hitX.round(2),
                            hitY.round(2), hitZ.round(2), xDr, yDr);
                    }
                }
    
            }
        };
    
        // INTERACT:
        this.interact = function(player, secondaryAction) {
            if (game.now - player.lastInteract >= config.interactTimer) {
                player.lastInteract = game.now;
                if (!secondaryAction) {
                    if (player.team != "inf") {
                        for (var i = 0; i < game.map.manager.pickups.length; ++i) {
                            tmpObj = game.map.manager.pickups[i];
                            if (tmpObj.pickup != undefined && player.collides(tmpObj)
                                && player.loadout.indexOf(tmpObj.pickup) == -1) {
                                if (player.score >= tmpObj.scoreP) {
                                    // ONLY HAS MELEE & IS TRYING TO PICKUP ANYTHING
                                    if ((game.weapons[player.loadout[0]] && game.weapons[player.loadout[0]].melee)
                                        && player.loadout.length == 1) {
                                        tmpObj2 = undefined;
                                        player.loadout[0] = tmpObj.pickup;
                                        player.weaponIndex = 0;
                                        if (tmpObj.pickupRep && tmpObj2 == undefined) this.addPicked(player, tmpObj.pickup);
                                    } else if (game.weapons[tmpObj.pickup].type) { // TRYING TO PICKUP SECONDARY
    
                                        // ONLY HAS SECONDARY & TRYING TO PICKUP SECONDARY
                                        if (game.weapons[player.loadout[0]].type) {
                                            tmpObj2 = player.loadout[0];
                                            player.loadout[0] = tmpObj.pickup;
                                            player.weaponIndex = 0;
    
                                        // HAS PRIMARY & TRYING TO PICKUP OR SWAP SECONDARY
                                        } else if (!game.weapons[player.loadout[0]].type) { // PRIMARY
                                            tmpObj2 = (game.weapons[player.loadout[1]]
                                                && game.weapons[player.loadout[1]].melee) ? undefined : player.loadout[1];
                                            player.loadout[1] = tmpObj.pickup;
                                            player.weaponIndex = 1;
                                        }
                                        this.removePicked(player, tmpObj2);
                                        if (tmpObj.pickupRep && tmpObj2 == undefined) this.addPicked(player, tmpObj.pickup);
                                    } else if (!game.weapons[tmpObj.pickup].type) { // TRYING TO PICKUP PRIMARY
                                        tmpObj2 = (game.weapons[player.loadout[0]]
                                            && game.weapons[player.loadout[0]].melee) ? undefined : player.loadout[0];
                                        var wasDropable = false;
    
                                        // ONLY HAS SECONDARY & TRYING TO PICKUP PRIMARY
                                        if (game.weapons[player.loadout[0]].type) {
                                            player.loadout.splice(0, 0, tmpObj.pickup);
                                            if (game.weapons[player.loadout[1]]
                                                && game.weapons[player.loadout[1]].melee) player.loadout.length = 1;
                                            tmpObj2 = undefined;
    
                                            // HAS PRIMARY & TRYING TO SWAP PRIMARY
                                        } else if (!game.weapons[player.loadout[0]].type) {
                                            if (!(game.weapons[player.loadout[0]]
                                                && game.weapons[player.loadout[0]].melee)) wasDropable = this.removePicked(player, player.loadout[0]);
                                            player.loadout[0] = tmpObj.pickup;
                                        }
                                        if (tmpObj.pickupRep && (tmpObj2 == undefined || wasDropable)) this.addPicked(player, tmpObj.pickup);
                                        player.weaponIndex = 0;
                                    }
                                    if (tmpObj.pickupRep) tmpObj.pickup = tmpObj2;
                                    io.broadcast("game" + game.sid, "inat", player.sid, player.loadout,
                                        player.weaponIndex, tmpObj.uid, (tmpObj.pickupRep?tmpObj2:tmpObj.pickup));
                                    player.updateLoadout(game, player.weaponIndex, true, ...player.loadout);
                                    if (tmpObj.scoreP != 0 && !tmpObj.method) {
                                        io.send(player.id, "am", ["Purchased", null]);
                                        this.score(player, -tmpObj.scoreP);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    for (var i = 0; i < game.map.manager.gates.length; ++i) {
                        tmpObj = game.map.manager.gates[i];
                        if ((tmpObj.active||!tmpObj.active && tmpObj.closeable)
                            && player.collides(tmpObj, tmpObj.tRadius)) {
                            if (player.score >= tmpObj.scoreP) {
                                if (tmpObj.scoreP != 0) {
                                    io.send(player.id, "am", [(tmpObj.method ? "Unlocked":"Purchased"), null]);
                                    if (!tmpObj.method) this.score(player, -tmpObj.scoreP);
                                }
                                io.broadcast("game" + game.sid, "gte", tmpObj.uid, (!tmpObj.active && tmpObj.closeable));
                                tmpObj.active = !tmpObj.active;
                                break;
                            }
                        }
                    }
                }
                for (var i = 0; i < game.map.manager.banks.length; ++i) {
                    tmpObj = game.map.manager.banks[i];
                    if (tmpObj.active && player.collides(tmpObj, tmpObj.tRadius)) {
                        // WITHDRAW POINTS
                        if (tmpObj.deposited != 0 && secondaryAction) {
                            if (tmpObj.withdrawAmnt && tmpObj.deposited > tmpObj.withdrawAmnt) {
                                tmpObj.deposited -= tmpObj.withdrawAmnt;
                                this.score(player, tmpObj.withdrawAmnt);
                            } else {
                                this.score(player, tmpObj.deposited);
                                tmpObj.deposited = 0;
                            }
                        // DEPOSIT POINTS
                        } else if (player.score != 0 && !secondaryAction) {
                            if (tmpObj.depositAmnt && player.score > tmpObj.depositAmnt) {
                                tmpObj.deposited += tmpObj.depositAmnt;
                                this.score(player, -tmpObj.depositAmnt);
                            } else {
                                tmpObj.deposited += player.score;
                                this.score(player, -player.score);
                            }
                        }
                        io.broadcast("game" + game.sid, "bnk", tmpObj.uid, tmpObj.deposited);
                        break;
                    }
                }
            }
        };
        this.findEmptyPickup = function() {
            var tmp;
            for (var i = 0; i < game.map.manager.pickups.length; ++i) {
                tmp = game.map.manager.pickups[i];
                if (tmp.pickupRep && tmp.pickup == undefined) return tmp.uid;
            }
            return null;
        };
        this.addPicked = function(player, wid) {
            var index = player.lastPicked.indexOf(wid);
            if (index == -1) player.lastPicked.push(wid);
        }
        this.removePicked = function(player, wid) {
            var index = player.lastPicked.indexOf(wid);
            if (index > -1) player.lastPicked.splice(index, 1);
            return index > -1;
        }
        this.dropWeapon = function(player, died) {
            if (!game.map.manager.pickups.length) return;
            var index = player.weaponIndex;
            var drop = player.loadout[index];
            var tmp;
            var cords = [/*WP_S*/player.x + UTILS.randInt(-5, 5)/*WP_E*/, /*WP_S*/player.y + 1/*WP_E*/, /*WP_S*/player.z + UTILS.randInt(-5, 5)/*WP_E*/];
            if (died) {
                for (var i = 0; i < player.loadout.length; i++) {
                    drop = player.loadout[i];
                    tmp = this.findEmptyPickup();
                    if (tmp && player.lastPicked.indexOf(drop) > -1 && !game.weapons[drop].melee) {
                        cords = [/*WP_S*/player.x + UTILS.randInt(-5, 5)/*WP_E*/, /*WP_S*/player.y + 1/*WP_E*/, /*WP_S*/player.z + UTILS.randInt(-5, 5)/*WP_E*/];
                        game.updatePickup(tmp, drop, null, cords);
                        io.broadcast("game" + game.sid, "inat", -1, null,
                            null, tmp, drop, true, cords);
                    }
                }
                player.lastPicked.length = 0;
            } else if (!game.weapons[drop].melee) {
                tmp = this.findEmptyPickup();
                var pickup = (tmp && player.lastPicked.indexOf(drop) > -1);
                if (pickup) {
                    this.removePicked(player, drop);
                    game.updatePickup(tmp, drop, null, cords);
                }
                player.loadout = player.loadout.length == 1 ? [] : [player.loadout[index?0:1]];
                player.weaponIndex = 0;
                io.broadcast("game" + game.sid, "inat", player.sid, player.loadout,
                    player.weaponIndex, tmp, drop, pickup, cords);
                player.updateLoadout(game, player.weaponIndex, true, ...player.loadout);
            }
        };
    
        // UPDATE INTERACT:
        var inter = null;
        this.updateInteract = function(player, dis, msg = "Pickup weapon", bank) {
            if (!(game.map.manager.pickups.length||game.map.manager.gates.length||game.map.manager.banks.length)) return;
            if (player.isYou) {
                inner = bank ? (msg + "<div style='color: #fff;margin-top:-30px;'>Press "
                    + "<span style='color:"+COLORS.interactPopup.key+"'>["+UTILS.getKeyName(game.controls.interactKey)
                        +"]</span> to Deposit - "+(bank[0]||"All")+"</div>"
                    + "<div style='color: #fff;margin-top:-30px;'>Press "
                    + "<span style='color:"+COLORS.interactPopup.key+"'>["+UTILS.getKeyName(game.controls.interactSecKey)
                        +"]</span> to Withdraw - "+(bank[1]||"All")+"</div>")
                    : ('Press <span style="color:'+COLORS.interactPopup.key+'">' +
                    '['+UTILS.getKeyName(game.controls.interactKey)+']' +
                    '</span> to ' + msg);
                var vis = dis?"block":"none";
                if (interactMsg.innerHTML != inner) interactMsg.innerHTML = inner;
                if (interactMsg.style.display != vis) interactMsg.style.display = vis;
            }
        };
    
        // SYNC LEADERBOARD:
        var tmpLeaders = [];
        this.syncLeaders = function() {
            var leaderStat = (game.mode.leaderStat||"score");
            if (game.mode.killSort) tmpData = this.list.slice().sort(UTILS.orderByKills);
            else tmpData = this.list.slice().sort(UTILS.orderByScore);
            tmpLeaders.length = 0;
            var tmpC = 0;
            var specC = 0;
            for (var i = 0; i < tmpData.length; ++i) {
                if (!tmpData[i].spectating) {
                    if (tmpC < 10) {
                        tmpC++;
                        tmpLeaders.push(tmpData[i].sid, (tmpData[i].account?
                            tmpData[i].account.name:tmpData[i].name), tmpData[i].team,
                            (game.mode.killSort?tmpData[i].kills:
                                (config.endForm[leaderStat]?
                                config.endForm[leaderStat](tmpData[i][leaderStat], game, tmpData[i])
                          :tmpData[i][leaderStat])),
                            (tmpData[i].account?tmpData[i].account.clan:0),
                            (tmpData[i].account?tmpData[i].account.featured:0),
                            (tmpData[i].account&&game.mode.isRanked?UTILS.getElo(tmpData[i].account, game.queueConfig&&game.queueConfig.id):null)
                        );
                    }
                } else if (!(tmpData[i].account && tmpData[i].account.moderator)) specC++;
            } io.broadcast("game" + game.sid, "7", tmpLeaders, specC);
        };
    
        // SAVE CLASS SCORES:
        this.saveClassScores = function(player) {
            var tmpIndex;
            if (player.classScores) for (var i = 0; i <
                game.config.classes.length; ++i) {
                tmpIndex = game.config.classes[i];
                if (player.classScores[tmpIndex]) {
                    if (!player.account.stats["c"+tmpIndex])
                        player.account.stats["c"+tmpIndex] = 0;
                    player.account.stats["c"+tmpIndex] += player.classScores[tmpIndex];
                }
            }
        };
    
        // SCORE:
        this.score = function(player, amount, fromKill, set) {
            if (io) {
    
    
                // YOUR SCORE:
                if (set) player.score = amount;
                else if (!(fromKill && game.mode.noScoreK)) {
                    player.score += amount;
                }
                if (game.host == undefined && player.score > 13000) {
                    player.score = 13000;
                    amount = 0;
                }
                if (!set) io.send(player.id, "5", amount);
                this.syncLeaders();
    
                // SAVE CLASS SCORE STAT:
                if (game.host == undefined) {
                    if (!player.classScores[player.classIndex])
                        player.classScores[player.classIndex] = 0;
                    player.classScores[player.classIndex] += amount;
                }
    
                // TEAM SCORE:
                if (game.mode.teams && player.team && game.teams &&
                    !game.mode.noScoreC && !(fromKill && game.mode.objective)) {
                    if (!game.teams[player.team]) game.teams[player.team] = amount;
                    else game.teams[player.team] += amount;
                    io.broadcast("game" + game.sid, "ts", player.team,
                        game.teams[player.team]);
                }
    
            }
        };
    
        // TICK PLAYER:
        this.tickPlayer = function(player, delta) {
            player.playTime += delta;
            if (player.hitTimer > 0) player.hitTimer -= delta;
            player.ticker -= delta;
            if (player.ticker <= 0) {
                player.ticker = 500;
                if (player.hitTimer <= 0 && !player.challMode) this.changeHealth(
                    player, null, -(player.maxHealth * (player.regen||0)));
            }
        };
    
        // CHANGE HEALTH:
        this.changeHealth = function(getter, doer, val, force, crit) {
            if (game.waitTimers && !game.waitTimers[0].canDMG) return;
            if (val < 0 && getter.health == getter.maxHealth) return;
    
            // HACK CHECK:
            if (doer && doer.account && doer.account.hack && val) val *= 0.2;
            if (doer && doer.avgSpn >= 0.1) val *= 0.2;
            if (doer && doer.isHacker) val *= 0.1;
            if (doer && doer.lastHack && game.now - doer.lastHack <= 400) val *= 0.2;
    
            // CONTINUE:
            if (!force && getter.team && doer && getter.team == doer.team && val > 0) return;
            if (doer && doer != getter && val > 0) io.send(doer.id, "4",
                getter.sid, Math.round(val), crit);
            if (getter.dummy) return true;
            if (val > 0) getter.hitTimer = (getter.regenDelay||0);
            getter.health -= val;
            getter.health = Math.max(Math.min(getter.maxHealth, getter.health), 0);
            if (getter.godMode) getter.health = getter.maxHealth;
            if (doer) {
                io.send(getter.id, "h", Math.ceil(getter.health), null, Math.round(doer.x), Math.round(doer.z));
                if (doer != getter) {
                    doer.dmgDealt += val;
                    if (!getter.dmgReceived[doer.id]) {
                        getter.dmgReceived[doer.id] = {
                            time: game.now,
                            val: val
                        }
                    } else {
                        getter.dmgReceived[doer.id].val += val;
                        getter.dmgReceived[doer.id].time = game.now;
                    }
                }
            } else io.send(getter.id, "h", Math.ceil(getter.health));
            for (var i = 0; i < this.list.length; ++i) {
                if (this.list[i] != getter) io.send(this.list[i].id, "h",
                    Math.ceil(getter.health), getter.sid);
            }
            return (getter.health <= 0);
        };
    
        // CHANGE PLAYER POSITION
        this.changePosition = function(player, x, y, z, stopMo) {
            /*WP_S*/ player.x = player.oldX  /*WP_E*/;
            /*WP_S*/ player.y = player.oldY /*WP_E*/;
            /*WP_S*/ player.z = player.oldZ  /*WP_E*/;
    
            /*WP_S*/ player.x = x/*WP_E*/;
            /*WP_S*/ player.y = y/*WP_E*/;
            /*WP_S*/ player.z = z/*WP_E*/;
    
            if (stopMo) {
                /*WP_S*/player.lastX = x/*WP_E*/;
                /*WP_S*/player.lastY = y/*WP_E*/;
                /*WP_S*/player.lastZ = z/*WP_E*/;
                player.stepVal = 0;
                player.xVel = 0;
                player.yVel = 0;
                player.zVel = 0;
            }
        };
    
        // SWAP MELEE:
        this.swapMelee = function(player, recon) {
            if (player.ammos.length <= 1) return;
            if (player.weaponIndex != (player.ammos.length - 1)) {
                this.swapWeapon(player, null, null, undefined,
                    (player.ammos.length - 1), recon);
            } else this.swapWeapon(player, 1, false, undefined,
                undefined, recon);
        };
    
        // SWAP SECONDARY:
        this.swapSecondary = function(player, recon) {
            if (player.ammos.length <= 1) return;
            for (var i = 0; i < player.ammos.length; ++i) {
                var tmpIn = player.loadout[i];
                if (game.weapons[tmpIn] && game.weapons[tmpIn].secondary) {
                    if (player.weaponIndex != i) this.swapWeapon(player,
                        null, null, undefined, i, recon);
                    else this.swapWeapon(player, null, null, undefined, 0, recon);
                }
            }
        };
    
        // SWAP WEAPON:
        this.swapWeapon = function(player, dir, force, set, lSet, recon) {
            if ((player.ammos.length <= 1 && dir) || (set > player.ammos.length)) return;
            var lastIndex = player.weaponIndex;
            if (dir) {
                if (dir != 1 && dir != -1) dir = 0;
                player.weaponIndex += dir;
                if (dir == 1) {
                    if (player.weaponIndex > player.ammos.length - 2)
                        player.weaponIndex = 0;
                } else {
                    if (player.weaponIndex < 0) player.weaponIndex = Math.min(
                        player.ammos.length - 1, 2);
                    else player.weaponIndex = 0;
                }
            }
            if (set != undefined) player.weaponIndex = set;
            if (lSet != undefined) player.weaponIndex = lSet;
            if ((dir != undefined || lSet != undefined) && (lastIndex != player.weaponIndex || force)) {
                player.reloadTimer = 0;
                player.didShoot = false;
                player.burstCount = 0;
            }
            player.weapon = game.weapons[player.loadout[player.weaponIndex]];
            if (!player.weapon) {
                player.weapon = game.weapons[player.loadout[0]];
                if (player.weapon) player.weaponIndex = 0;
            }
            if (RENDER && (lastIndex != player.weaponIndex || force)) {
                this.cancelInspect(player);
                for (var i = 0; i < player.weaponMeshes.length; ++i) {
                    player.weaponMeshes[i].visible = false;
                } if (player.weaponMeshes[player.weaponIndex]) {
                    player.weaponMeshes[player.weaponIndex].visible = (!this.isWeaponHidden(player, player.weaponIndex)||!player.renderYou);
                    if (player.weapon.melee) {
                        if (player.armMeshes[0]) player.armMeshes[0].visible = RENDER.showHands;
                        if (player.armMeshes[1]) {
                            if (!player.armMeshes[1].realMat) player.armMeshes[1].realMat = player.armMeshes[1].material;
                            player.armMeshes[1].material = RENDER.showHands ? player.armMeshes[1].realMat : RENDER.invisMat;
                        }
                    } else if (player.weaponMeshes[player.weaponIndex].children[2])
                        player.weaponMeshes[player.weaponIndex].children[2].visible = RENDER.showHands;
                }
            } if (set == undefined && player.weapon && !(RENDER && !player.isYou)) {
                if (!(player.isYou && lastIndex == player.weaponIndex) && !recon)
                    player.swapTime = player.weapon.swapTime;
                if (player.isYou && (lastIndex != player.weaponIndex || force)) {
                    var tmpHTML = "";
                    var dontUpdateHTML = (player.loadout.toString() === player.lastLoadout.toString()
                        && weapDisplay.innerHTML.length);
                    for (var i = 0; i < player.ammos.length; ++i) {
                        var isActive = (i==player.weaponIndex);
                        if (game.weapons[player.loadout[i]].icon){
                            if (dontUpdateHTML) {
                                var doc = document.getElementById('weapItem_' + i);
                                doc.lastChild.style.opacity = (isActive?1:0.7);
                                doc.lastChild.style.marginRight = (i?"25px":"");
                                if (i>0) {
                                    doc.firstChild.innerText = (game.weapons[player.loadout[i]].melee?
                                    "["+UTILS.getKeyName(game.controls.meleeKey)+"]":
                                    "["+UTILS.getKeyName(game.controls.swapKey)+"]")
                                }
                            } else {
                                tmpHTML += "<div class='weapItem' id='weapItem_" + i + "'>"
                                + (i>0?"<div class='weapKey'>" +
                                (game.weapons[player.loadout[i]].melee?
                                "["+UTILS.getKeyName(game.controls.meleeKey)+"]":
                                "["+UTILS.getKeyName(game.controls.swapKey)+"]") +"</div>":"")
                                + "<img style='opacity:" + (isActive?1:0.7)
                                + (i?";margin-right:25px":"") + "' class='weapIcon' src='" +
                                UTILS.assetsUrl((game.weapons[player.loadout[i]].melee?
                                "/textures/melee/icon_"+(game.store.skins[player.meleeIndex]?
                                (game.store.skins[player.meleeIndex].id||0):0):
                                "/textures/weapons/"+game.weapons[player.loadout[i]].icon) + ".png")
                                + "' /></div>";
                            }
                        }
                    }
    
                    // DONT DO ON RECON:
                    if (!recon) {
    
                        // FLAP ANIM:
                        if (player.swapTween) player.swapTween.stop();
                        player.swapTweenA = 0.5;
                        player.swapTween = new TWEEN.Tween(player).to({
                            swapTweenA: 1
                        }, 1200).easing(TWEEN.Easing.Elastic.Out).start();
    
                        // WEAPON SWAP ROT ANIM:
                        if (lastIndex != player.weaponIndex && player.aimVal == 1) {
                            if (player.swapTweenAnim) player.swapTweenAnim.stop();
                            player.swapTweenR = (player.weapon.swapWiggle||0.6);
                            player.swapTweenAnim = new TWEEN.Tween(player).to({
                                swapTweenR: 0
                            }, player.weapon.swapTime + 220).easing(
                                TWEEN.Easing.Back.InOut).start();
                        }
    
                        // MELEE SWAP ANIM:
                        if (lastIndex != player.weaponIndex && player.aimVal == 1) {
                            if (player.meleeAnim.anim) player.meleeAnim.anim.stop();
                            player.resetMeleeAnim();
                            player.meleeAnim.armR = 0.15;
                            if (player.weapon.melee) player.meleeAnim.anim = new TWEEN.Tween(player.meleeAnim).to({
                                armR: 0
                            }, 700).easing(TWEEN.Easing.Back.InOut).start();
                        }
                    }
    
                    // UPDATE GUI:
                    if (!dontUpdateHTML) weapDisplay.innerHTML = tmpHTML;
                    player.lastLoadout = [...player.loadout];
                    this.updatePlayerAmmo(player);
    
                }
            }
        };
    
        // TAUNT:
        this.taunt = function(player, index) {
            if (player && player.active && config.taunts[index] && (!player.lastTaunt
                || game.now - player.lastTaunt >= 0)) {
                player.lastTaunt = game.now + config.taunts[index].tm;
                game.playSound(config.taunts[index].id, 0.3, player,
                    true, UTILS.randFloat(0.9, 1.0));
            }
        };
    
        // CHECK KILL STREAK:
        this.checkStreak = function(player) {
            for (var i = 0; i < game.streaks.length; ++i) {
                if (player.realKillStreak == game.streaks[i].kills)
                    this.addStreak(player, i);
            }
            if (player.realKillStreak >= game.maxStreak) player.realKillStreak = 0;
        };
    
        // REMOVE STREAK:
        this.useStreak = function(player, index) {
            if (player.streaks[index] && player.streaks[index].streak.activate(game, player)) {
                if (player.streaks[index].cnt > 1) player.streaks[index].cnt--;
                else player.streaks[index] = null;
    
                io.send(player.id, "st", index, player.streaks[index] ? (player.streaks[index].cnt||0):0);
            }
        };
    
        // ADD STREAK TO PLAYER:
        this.addStreak = function(player, index) {
            if (!player.streaks[index]) {
                player.streaks[index] = {
                    cnt: 1,
                    streak: game.streaks[index]
                };
            } else player.streaks[index].cnt++;
            io.send(player.id, "st", index, player.streaks[index].cnt);
        };
    
        // KILL PLAYER:
        this.kill = function(player, doer, info, silent, skipScore) {
            if (!player.dummy && !player.active) return;
            var didScore = false;
            if (!player.dummy) {
                player.active = false;
                if (player.isYou) this.toggleAim(player, 0);
                if (player.objInstances) this.disposeMesh(player);
                /*WP_S*/console.log(player.objInstances)/*WP_E*/;
                console.log("^ Just Died");
            } if (io) {
                  var strk = 0;
                var killData;
                player.deaths++;
                player.deathInfo.doer = doer;
                player.deathInfo.time = game.now;
                player.deathInfo.tillNext = (game.forceSpawn ? (game.forceSpawn * 1000) + config.deathDelay : null);
                if (!(game.mode.noStreaks||game.config.noStreaks)) player.deathStreak++;
                if (player.lives && !game.waitTimers) {
                    player.lives--;
                    io.send(player.id, "lv", player.lives);
                } game.kills++;
                if (doer && doer != player) {
                    if (!player.dummy) {
                        doer.kills++;
                        var wid = (info.weaponId!=undefined?info.weaponId:
                            doer.loadout[doer.weaponIndex]);
                        if (!doer.weaponKills[wid]) doer.weaponKills[wid] = 1;
                        else doer.weaponKills[wid]++;
                    }
                    if (!(game.mode.noStreaks||game.config.noStreaks)) {
                        doer.streak++;
                        doer.killStreak++;
                        doer.realKillStreak++;
                        if (doer.killStreak > doer.highestStreak) doer.highestStreak = doer.killStreak;
                        doer.deathStreak = 0;
                        this.checkStreak(doer);
                        if (doer.killStreak % 5 === 0) strk = doer.killStreak;
                        if (game.now - doer.lastKill >= config.feedTimer) doer.streak = 0;
                    }
                    doer.lastKill = game.now;
                    if (!skipScore && game.config.killRewards && !game.mode.noKillRewards) {
                        killData = KILLS.reward(this, doer, player, info, game);
                        if (killData) io.send(doer.id, "6", killData, info.headShot?1:0, doer.kills);
                        this.score(doer, KILLS.getScore(killData), true);
                        didScore = true;
                    }
                    game.players.dropWeapon(player, true);
                }
                if (info && info.weapon) delete info.weapon;
                if (!player.dummy) {
                    for (var i = 0; i < this.list.length; ++i) {
                        if (!game.mode.noAssists && player.dmgReceived[this.list[i].id]
                            && doer != this.list[i] && player.dmgReceived[this.list[i].id].val
                            >= config.assistMin && game.now - player.dmgReceived[this.list[i].id].time <= config.assistTime) {
                            this.list[i].assists++;
                            this.score(this.list[i], config.assistScore, true);
                            io.send(this.list[i].id, "10");
                            didScore = true;
                        } if (this.list[i] == player) {
                            io.send(player.id, "3", player.sid, player.deaths, (doer?doer.sid:0),
                                [doer?(info.weaponId!=undefined?info.weaponId:
                                doer.loadout[doer.weaponIndex]):-1,
                                killData?KILLS.getScore(killData):0,
                                 (doer&&doer.account&&doer.account.stats["c"+doer.classIndex]?
                                doer.account.stats["c"+doer.classIndex]:0),
                                (doer && doer.account && doer.kcStatIndex != -1 ? [
                                    config.killCardStats[doer.kcStatIndex].name,
                                    config.killCardStats[doer.kcStatIndex].stat(doer)
                                ] : null)
                            ], info, silent);
                        } else io.send(this.list[i].id, "3", player.sid, player.deaths,
                            (doer?doer.sid:0), null, info, silent);
                    }
                }
                if (game.mode.onKill) game.mode.onKill(game, io, player, doer, info);
                  if (strk) io.broadcast("game" + game.sid, "kst", doer.sid, strk);
            }
            if (io && !didScore) this.syncLeaders();
        };
    
        // INDEX BY SID:
        this.indexBySid = function(sid) {
            for (var i = 0; i < this.list.length; ++i) {
                if (this.list[i].sid == sid) return i;
            } return -1;
        };
    
        // FIND BY SID:
        this.findBySid = function(sid) {
            for (var i = 0; i < this.list.length; ++i) {
                if (this.list[i].sid === sid) return this.list[i];
            } return null;
        };
    
    };
    
    
    /***/ }),
    
    /***/ "./src/data/prefabs.js":
    /*!*****************************!*\
      !*** ./src/data/prefabs.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    let THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js"); // To silence the warning
    
    // IMPORTS:
    const config = __webpack_require__(/*! ../config.js */ "./src/config.js");
    const GEOS = __webpack_require__(/*! ../libs/geos.js */ "./src/libs/geos.js");
    const UTILS = __webpack_require__(/*! ../libs/utils.js */ "./src/libs/utils.js");
    const WEAPONS = __webpack_require__(/*! ../data/weapons.js */ "./src/data/weapons.js");
    
    // LOAD OBJ:
    let textureLoader = new THREE.TextureLoader();
    let loadManager = new THREE.LoadingManager();
    let objLoader = new THREE.OBJLoader(loadManager);
    window.loadedGeos = [];
    function createMesh(parent, tmpGeo, textureSrc, scale, colr, yOffset, xR, yR, foo) {
        var texture;
        if (textureSrc) {
            texture = textureLoader.load(UTILS.assetsUrl(textureSrc), texture => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
                texture.minFilter = THREE.NearestFilter;
                texture.magFilter = THREE.NearestFilter;
                texture.needsUpdate = true;
            });
        }
        var material = new THREE.StrippedLambertMaterial({
            map: texture,
            vertexColors: THREE.VertexColors,
            color: (colr||0xffffff)
        });
        var tmpMesh = new THREE.Mesh(tmpGeo, material);
        tmpMesh.scale.setScalar(scale||1);
        tmpMesh.position.y = tmpMesh.position.y + yOffset;
        tmpMesh.rotateX(xR||0);
        tmpMesh.rotateY(yR||0);
        if (foo) {
            if (parent[foo]) {
                parent.remove(parent[foo]);
                parent[foo] = null;
            }
            parent[foo] = tmpMesh;
            parent.add(parent[foo]);
        } else {
            parent.add(tmpMesh);
        } return tmpMesh;
    }
    function loadObj(parent, src, textureSrc, scale, colr, yOffset = 0, xR = 0, yR = 0, foo = null) {
        return new Promise(resolve => {
            var tmpGeo = window.loadedGeos[src];
            if (!tmpGeo) {
                tmpGeo = new THREE.BufferGeometry();
                objLoader.load(UTILS.assetsUrl(src), model => {
                    tmpGeo.copy(model.children[0].geometry);
                    window.loadedGeos[src] = tmpGeo;
                    resolve(createMesh(parent, tmpGeo, textureSrc,
                        scale, colr, yOffset, xR, yR, foo));
                });
            } else resolve(createMesh(parent, tmpGeo, textureSrc,
                scale, colr, yOffset, xR, yR, foo));
        });
    }
    
    // GENERATE MESH:
    const cubeGeometry = new THREE.BoxBufferGeometry(1, 1, 1);
    const planeGeometry = new THREE.PlaneBufferGeometry(1, 1); planeGeometry.rotateX(-Math.PI / 2);
    const ladderMaterial = new THREE.StrippedLambertMaterial({ color: 0x00ff00 });
    const cubeMaterial = new THREE.StrippedLambertMaterial({ color: 0x555555 });
    
    // GENERATE SPRITE:
    function generateSprite(parent, src, scale) {
        let spriteMap = new THREE.TextureLoader().load(src);
        spriteMap.magFilter = THREE.NearestFilter;
        let spriteMaterial = new THREE.SpriteMaterial( { map: spriteMap, color: 0xffffff } );
        let sprite = new THREE.Sprite(spriteMaterial);
        if (scale) {
            sprite.scale.set(scale, scale, 1);
        }
        parent.add(sprite);
    }
    
    // GENERATE PLANE:
    function generatePlane(w, l) {
        var tmpGeo = GEOS.generatePlane(l, w, {
            scale: 1
        }, 0, 0, 0);
        tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
        tmpGeo.scale(w, l, 1);
        tmpGeo.rotateX(-Math.PI / 2);
        return tmpGeo;
    }
    
    // GENERATE LIQUID:
    function generateLiquid(w, l) {
        var tmpGeo = GEOS.generatePlane(l, w, {
            scale: 1,
            tilesX: Math.round(w / 5),
            tilesZ: Math.round(l / 5)
        }, 0, 0, 0);
        tmpGeo.scale(w, l, 1);
        tmpGeo.rotateX(-Math.PI / 2);
        return tmpGeo;
    }
    
    // GENERATE CUBE:
    function generateCube(w, h, l, amb, faces) {
        var tmpGeo = GEOS.generateCube(faces||[1,1,1,1,1,1], w, h, l, {
            scale: 1,
            amb: amb,
            useScale: true
        });
        tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
        return tmpGeo;
    }
    
    // GENERATE SPHERE:
    function generateSphere(x, y, z, amb) {
        var tmpGeo = GEOS.generateSphere(x, y, z, {
            scale: 1,
            amb: amb,
            useScale: true
        });
        tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
        return tmpGeo;
    }
    
    // GENERATE CONE:
    function generateCone(x, y, z, amb) {
        var tmpGeo = GEOS.generateCone(x, y, z, {
            scale: 1,
            useScale: true
        });
        tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
        return tmpGeo;
    }
    
    // GENERATE RAMP:
    function generateRamp(x, y, z, w, h, l, dir) {
        var geo = new THREE.Geometry();
        dir = dir * Math.PI / 2;
        y = 0 - (h / 2);
    
        var rot = (dir != 0 && dir != Math.PI);
    
        let addRamp = (x, y, z, w, h, l, dir, data, zD) => {
            data = data||{};
            var mesh = new THREE.Mesh(GEOS.generatePlane(l * 2, w, data));
            mesh.position.set(x, y + (h / 2), z);
            l *= 2;
            var rl = Math.sqrt((h * h) + (l * l));
            mesh.scale.set(w, rl, 2);
            mesh.rotateY(-(Math.PI / 2) - dir);
            mesh.rotateX(Math.asin(h / rl) - (Math.PI / 2));
            mesh.rotateZ(zD||0);
            mesh.updateMatrix();
            geo.merge(mesh.geometry, mesh.matrix);
        };
    
        addRamp(x, y, z, (rot?w:l), h, (rot?l:w)/2, dir, {scale: 1});
    
        return geo;
    }
    
    let addPlane = (geo, x, y, z, w, l, data, xR, yR, zR) => {
        data = data||{};
        data.premultipliedAlpha = true;
    
        var mesh = new THREE.Mesh(GEOS.generatePlane(l, w, data, x, y, z));
        mesh.position.set(x, y, z);
        mesh.rotateY(xR||0);
        mesh.rotateX((yR||0) - Math.PI / 2);
        mesh.rotateZ(zR||0);
        mesh.scale.set(w * 2, l * 2, 1);
        mesh.updateMatrix();
        geo.merge(mesh.geometry, mesh.matrix);
    };
    
    let addCube = (parent, x, y, z, w, h, l, sides, data) => {
        data = data||{};
        var mesh = new THREE.Mesh(GEOS.generateCube(sides, w, h, l, data));
        mesh.position.set(x, y, z);
        mesh.rotation.set(data.yR||0, data.xR||0, data.zR||0);
        mesh.scale.set(w, h, l);
        //if (data.src && !data.noGroup) this.meshGroup(mesh, data);
        if (parent instanceof THREE.Geometry) {
            mesh.updateMatrix();
            parent.merge(mesh.geometry, mesh.matrix);
        } else {
            parent.add(mesh);
        }
        return mesh;
    };
    
    // GENERATE LADDER:
    function generateLadder(w, h, l, d) {
        var geo = new THREE.Geometry();
        d = d * Math.PI / 2;
    
        let tmpObj = {
            x: 0 + (config.ladderScale * Math.cos(d)),
            z: 0 + (config.ladderScale * Math.sin(d)),
            y: 0 - (h / 2),
        };
        addCube(geo, tmpObj.x + (config.ladderWidth * Math.sin(d)),
            tmpObj.y, tmpObj.z + (config.ladderWidth * Math.cos(d)),
            config.ladderScale * 2, h + 2, config.ladderScale * 2,
            [1,1,1,1,1,1], {scale: 0.02});
        addCube(geo, tmpObj.x - (config.ladderWidth * Math.sin(d)),
            tmpObj.y, tmpObj.z - (config.ladderWidth * Math.cos(d)),
            config.ladderScale * 2, h + 2, config.ladderScale * 2,
            [1,1,1,1,1,1], {scale: 0.02});
    
        var stepH = 6;
        var max = Math.floor(h / stepH);
        for (var i = 0; i < max; ++i) {
            addPlane(geo, tmpObj.x, tmpObj.y + (stepH * (i + 1)) + UTILS.randFloat(-1, 1),
                tmpObj.z, config.ladderWidth, config.ladderScale, {scale: 0.02},
                -d + Math.PI / 2, Math.PI / 2, UTILS.randFloat(-0.1, 0.1));
        }
    
        return geo;
    }
    
    // GENERATE BILLBOARD:
    function generateBillboard(x, y, z, w, h, l) {
        var tmpGeo = GEOS.generatePlane(l, w, {}, x, y, z);
        tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
        tmpGeo.scale(w, l, 1);
        tmpGeo.rotateX(-Math.PI / 2);
        return tmpGeo;
    }
    
    // GENERATE SIGN:
    function generateSign(parent, x, y, z, w, h, l) {
        var tmpGeo = GEOS.generatePlane(l, w, {}, x, y, z);
        tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
        tmpGeo.scale(w, l, 1);
        tmpGeo.rotateX(-Math.PI / 2);
        return tmpGeo;
    }
    
    function generateFlag(parent, amb) {
        let crystal = loadObj(parent, "models/crystal_0.obj", "textures/crystal_0.png",
            config.flagScale, 0xffffff, config.flagOff/2);
        var tmpGeo = GEOS.generateCube([1, 1, 0, 0, 1, 1], ...parent.size, {
            scale: 1,
            amb: amb,
            useScale: true,
            transparent: true,
            depthWrite: false,
            side: 2
        });
        tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
        return tmpGeo;
    }
    
    function generateWeapon(parent, amb) {
        let tmpGeo = GEOS.generateCube([1,1,1,1,1,1], ...parent.size, {
            scale: 1,
            amb: amb,
            useScale: true
        });
        tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
        let weapon = loadObj(parent, "models/weapons/" + WEAPONS[parent.weaponId].src + ".obj",
            "textures/weapons/" + WEAPONS[parent.weaponId].src + ".png",
            WEAPONS[parent.weaponId].scale, 0xffffff, -0.5, -1.6, 0, 'wepMesh');
        return tmpGeo;
    }
    
    
    function generateSpawn(parent, amb) {
        let spawn = loadObj(parent, "models/spawn_0.obj", "textures/spawn_0.png", 1, 0xffffff, -5.5, 0,
          -((parent.direction||0)+1) * Math.PI / 2, 'spwnMesh');
        let tmpGeo = GEOS.generateCube([1,1,1,1,1,1], 7, 11, 7, {
            scale: 1,
            amb: amb,
            transparent: true,
            useScale: true,
            depthWrite: false,
            side: 2
        });
        tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
        return tmpGeo;
    }
    
    function generateBorder(x, y, z, amb) {
        var geo = new THREE.Geometry();
        var tmpGeo = new THREE.SphereGeometry(.5, 32, 32);
        var mesh = new THREE.Mesh(tmpGeo);
        mesh.scale.set(x, y, z);
        mesh.updateMatrix();
        geo.merge(mesh.geometry, mesh.matrix);
        geo = new THREE.BufferGeometry().fromGeometry(geo);
        return geo;
    }
    
    function generateGrass(w, h, l, amb) {
        let tmpGeo = new THREE.Geometry();
        let angle = (Math.PI * 2) * Math.random();
    
        let tmpMesh = new THREE.Mesh(GEOS.generatePlane(w, h, {}));
        tmpMesh.scale.set(w, h, l);
        tmpMesh.rotateY(angle * (Math.PI / 2));
        tmpMesh.updateMatrix();
        tmpGeo.merge(tmpMesh.geometry, tmpMesh.matrix);
    
        let tmpMesh2 = new THREE.Mesh(GEOS.generatePlane(w, h, {}));
        tmpMesh2.scale.set(w, h, l);
        tmpMesh2.rotateY((angle + 1) * (Math.PI / 2));
        tmpMesh2.updateMatrix();
        tmpGeo.merge(tmpMesh2.geometry, tmpMesh2.matrix);
    
        tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
        return tmpGeo;
    }
    
    // PREFABS:
    module.exports.prefabs = {
        CRATE: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            gen: parent => loadObj(parent, "models/crate_0.obj",
                "textures/crate_0.png", config.crateScale, parent.color),
            dummy: false,
            castShadow: true,
            receiveShadow: true
        },
        STACK: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            gen: parent => loadObj(parent, "models/stack_0.obj",
                "textures/stack_0.png", config.crateScale, parent.color),
            dummy: false,
            castShadow: true,
            receiveShadow: true
        },
        CARDB: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            gen: parent => loadObj(parent, "models/cardb_0.obj",
                "textures/cardb_0.png", config.cardbScale, parent.color),
            dummy: false,
            castShadow: true,
            receiveShadow: true
        },
        PALLET: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            complex: true,
            gen: parent => loadObj(parent, "models/pallet_0.obj",
                "textures/pallet_0.png", config.palletScale, parent.color),
            dummy: false,
            castShadow: true,
            receiveShadow: true
        },
        BARREL: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            gen: parent => loadObj(parent, "models/barrel_0.obj",
                "textures/barrel_0.png", config.barrelScale, parent.color),
            castShadow: true,
            receiveShadow: true
        },
        ACIDBARREL: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            emiss: true,
            gen: parent => loadObj(parent, "models/acidbarrel_0.obj",
                "textures/acidbarrel_0.png", config.acidbarrelScale, parent.color),
            castShadow: true,
            receiveShadow: true
        },
        TREE: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            complex: true,
            gen: parent => loadObj(parent, "models/tree_0.obj",
                "textures/tree_0.png", config.treeScale, parent.color),
            castShadow: true,
            receiveShadow: true
        },
        CONE: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            complex: true,
            gen: parent => loadObj(parent, "models/cone_0.obj",
                "textures/cone_0.png", config.coneScale, parent.color),
            castShadow: true,
            receiveShadow: true
        },
        TEDDY: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            complex: true,
            gen: parent => loadObj(parent, "models/teddy_0.obj",
                "textures/teddy_0.png", config.teddyScale, parent.color),
            castShadow: true,
            receiveShadow: true
        },
        CONTAINER: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            gen: parent => loadObj(parent, "models/container_0.obj",
                "textures/container_0.png", config.containerScale, parent.color),
            castShadow: true,
            receiveShadow: true
        },
        CONTAINERR: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            gen: parent => loadObj(parent, "models/containerr_0.obj",
                "textures/containerr_0.png", config.containerScale, parent.color),
            castShadow: true,
            receiveShadow: true
        },
        DOOR: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            gen: parent => loadObj(parent, "models/door_0.obj",
                "textures/door_0.png", config.doorScale, parent.color),
            castShadow: true,
            receiveShadow: true
        },
        WINDOW: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            gen: parent => loadObj(parent, "models/window_0.obj",
                "textures/window_0.png", config.windowScale, parent.color),
            castShadow: true,
            transparent: true,
            receiveShadow: true
        },
        GRASS: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            complex: true,
            doubleSide: true,
            transparent: true,
            gen: parent => loadObj(parent, "models/grass_0.obj",
                "textures/grass_0.png", config.grassScale, parent.color),
            receiveShadow: true
        },
        WEAPON_PICKUP: {
            notStyleable: true,
            interact: true,
            customScore: true,
            defaultSize: [config.pickupZoneX, config.pickupZoneH, config.pickupZoneZ],
            scalable: false,
            tool: true,
            scaleWithSize: false,
            lineCol: 0x36DBFF,
            noTexture: true,
            texturable: false,
            opacity: 0.1,
            genGeo: async (instance, amb) => generateWeapon(instance, amb),
            stepSrc: "a"
        },
        /*GRASS: {
            noCollision: true,
            defaultSize: [12, 6, 12],
            scalable: true,
            editAmb: true,
            scaleWithSize: false,
            editColor: true,
            editEmissive: true,
            hideBoundingBox: false,
            genGeo: async (instance, amb) => generateGrass(...instance.size, amb),
            stepSrc: "a",
            dummy: false,
            castShadow: true,
            receiveShadow: true,
            alphaTest: 0.2,
            transparent: true,
            receiveShadow: true,
            doubleSide: true
        },*/
        VEHICLE: {
            canInterface: true,
            hasHealth: true,
            editColor: true,
            dontRound: true,
            complex: true,
            emiss: true,
            gen: parent => loadObj(parent, "models/vehicle_0.obj",
                "textures/vehicle_0.png", config.vehicleScale, parent.color),
            castShadow: true,
            receiveShadow: true
        },
        LADDER: {
            notTechnical: true,
            defaultSize: [2, 10, 4],
            scalable: true,
            scaleWithSize: false,
            editColor: true,
            hideBoundingBox: false,
            texturable: true,
            genGeo: async instance => generateLadder(...instance.size, instance.direction),
            customDirection: true,
            stepSrc: "a",
            dummy: false,
            castShadow: true,
            receiveShadow: true
        },
        CUBE: {
            editFaces: true,
            canInterface: true,
            movingTexture: true,
            defaultSize: [10, 10, 10],
            hasHealth: true,
            scalable: true,
            editAmb: true,
            scaleWithSize: false,
            editColor: true,
            editEmissive: true,
            editOpac: true,
            hideBoundingBox: false,
            editPen: true,
            texturable: true,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb, instance.faces),
            stepSrc: "a",
            dummy: false,
            castShadow: true,
            receiveShadow: true,
            hasBorder: true,
        },
        SPHERE: {
            notTechnical: true,
            movingTexture: true,
            defaultSize: [5, 5, 5],
            scalable: true,
            scaleWithSize: false,
            editColor: true,
            editEmissive: true,
            editOpac: true,
            hideBoundingBox: false,
            noCollision: true,
            texturable: true,
            genGeo: async (instance, amb) => generateSphere(...instance.size, amb),
            stepSrc: "a",
            dummy: false,
            castShadow: false,
            receiveShadow: false
        },
        RAMP: {
            notTechnical: true,
            defaultSize: [10, 5, 10],
            movingTexture: true,
            scalable: true,
            scaleWithSize: false,
            hideBoundingBox: false,
            boostable: true,
            editColor: true,
            editEmissive: true,
            texturable: true,
            genGeo: async instance => generateRamp(0, 0, 0, ...instance.size, instance.direction),
            shootable: true,
            customDirection: true,
            stepSrc: "a",
            dummy: false,
            castShadow: true,
            receiveShadow: true,
            doubleSide: true
        },
        PLANE: {
            canInterface: true,
            hasHealth: true,
            defaultSize: [4, 0.01, 4],
            movingTexture: true,
            dontRound: true,
            scalable: true,
            canTerrain: true,
            edgeNoise: true,
            scaleWithSize: true,
            editColor: true,
            editPen: true,
            editEmissive: true,
            editOpac: true,
            hideBoundingBox: false,
            texturable: true,
            genGeo: async instance => generatePlane(instance.size[0], instance.size[2]),
            stepSrc: "a",
            dummy: false,
            castShadow: true,
            receiveShadow: true,
            doubleSide: true
        },
        // LIQUID: {
        //     noCollision: true,
        //     notTechnical: true,
        //     defaultSize: [25, 0.01, 25],
        //     movingTexture: true,
        //     dontRound: true,
        //     scalable: true,
        //     canTerrain: true,
        //     //scaleWithSize: true,
        //     editColor: true,
        //     editEmissive: true,
        //     editOpac: true,
        //     hideBoundingBox: false,
        //     texturable: true,
        //     genGeo: async instance => generateLiquid(instance.size[0], instance.size[2]),
        //     stepSrc: "a",
        //     dummy: false,
        //     castShadow: true,
        //     receiveShadow: true,
        //     doubleSide: true
        // },
        OBJECTIVE: {
            objectiveLink: true,
            notTechnical: true,
            notStyleable: true,
            defaultSize: [50, 50, 50],
            scalable: true,
            noTexture: true,
            opacity: 0.2,
            lineCol: 0xC800FF,
            tool: true,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb),
            stepSrc: "a"
        },
        PARTICLES: {
            customDirection: true,
            notTechnical: true,
            defaultSize: [20, 20, 20],
            hasParticles: true,
            editColor: true,
            scalable: true,
            noTexture: true,
            opacity: 0.3,
            lineCol: 0x2EFFFF,
            tool: true,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb),
            stepSrc: "a"
        },
        BILLBOARD: {
            canInterface: true,
            hasHealth: true,
            defaultSize: [40, 0.01, 10],
            lineCol: 0xffff00,
            dontRound: true,
            scalable: true,
            canTerrain: true,
            scaleWithSize: true,
            hideBoundingBox: false,
            genGeo: async instance => generateBillboard(0, 0, 0, ...instance.size),
            stepSrc: "a",
            dummy: false,
            castShadow: true,
            receiveShadow: true,
            doubleSide: true
        },
        SCORE_ZONE: {
            notStyleable: true,
            customScore: true,
            defaultSize: [10, 10, 10],
            scalable: true,
            noTexture: true,
            opacity: 0.3,
            lineCol: 0xffff00,
            tool: true,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb),
            stepSrc: "a"
        },
        DEATH_ZONE: {
            notTechnical: true,
            notStyleable: true,
            defaultSize: [10, 10, 10],
            scalable: true,
            noTexture: true,
            opacity: 0.3,
            lineCol: 0xff0000,
            tool: true,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb),
            stepSrc: "a"
        },
        SPAWN_POINT: {
            notTechnical: true,
            notStyleable: true,
            scalable: false,
            alwaysSee: true,
            tool: true,
            scaleWithSize: false,
            teamable: true,
            noTexture: true,
            opacity: 0.00001,
            stepSrc: "a",
            customDirection: true,
            dontRound: true,
            genGeo: async (instance, amb) => generateSpawn(instance, amb),
            dummy: false,
            castShadow: false,
            receiveShadow: false
        },
        CHECK_POINT: {
            notStyleable: true,
            defaultSize: [10, 10, 10],
            scalable: true,
            noTexture: true,
            opacity: 0.3,
            lineCol: 0x03dac5,
            tool: true,
            customDirection: true,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb),
            stepSrc: "a"
        },
        TELEPORTER: {
            notStyleable: true,
            hasSignals: true,
            defaultSize: [10, 10, 10],
            scalable: true,
            noTexture: true,
            opacity: 0.3,
            lineCol: 0xb1fff0,
            tool: true,
            //customDirection: true,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb),
            stepSrc: "a"
        },
        CAMERA_POSITION: {
            notTechnical: true,
            notStyleable: true,
            defaultSize: [2, 2, 2],
            scalable: false,
            alwaysSee: true,
            tool: true,
            scaleWithSize: false,
            hideBoundingBox: true,
            editorGen: parent => generateSprite(parent, "img/crosshair.png", 5),
            stepSrc: "a",
            dummy: false,
            castShadow: false,
            receiveShadow: false
        },
        SPECTATE_CAM: {
            objectiveLink: true,
            isCam: true,
            notTechnical: true,
            notStyleable: true,
            defaultSize: [10, 10, 10],
            scalable: false,
            tool: true,
            scaleWithSize: false,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb),
            stepSrc: "a",
            dummy: false,
            castShadow: false,
            receiveShadow: false
        },
        FLAG: {
            notTechnical: true,
            notStyleable: true,
            defaultSize: [config.flagZoneS, config.flagZoneH, config.flagZoneS],
            scalable: false,
            tool: true,
            scaleWithSize: false,
            lineCol: 0xC800FF,
            teamable: true,
            noDefault: true,
            genGeo: async (instance, amb) => generateFlag(instance, amb),
            stepSrc: "a",
            dummy: false,
            castShadow: false,
            receiveShadow: false
        },
        GATE: {
            canInterface: true,
            canUndo: true,
            interact: true,
            customScore: true,
            movingTexture: true,
            defaultSize: [10, 10, 10],
            scalable: true,
            forceCollision: true,
            editAmb: true,
            scaleWithSize: false,
            editColor: true,
            editEmissive: true,
            editOpac: true,
            lineCol: 0xff00ff,
            texturable: true,
            tool2: true,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb),
            stepSrc: "a",
            dummy: false,
            castShadow: true,
            receiveShadow: true,
            complex: true,
            hasBorder: true,
        },
        TRIGGER: {
            canInterface: true,
            canTargetInterface: true,
            hasHealth: true,
            movingTexture: true,
            defaultSize: [10, 10, 10],
            scalable: true,
            forceCollision: true,
            editAmb: true,
            scaleWithSize: false,
            editColor: true,
            editEmissive: true,
            editOpac: true,
            lineCol: 0xff00ff,
            texturable: true,
            tool2: true,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb),
            stepSrc: "a",
            dummy: false,
            castShadow: true,
            receiveShadow: true,
            complex: true
        },
        SIGN: {
            notTechnical: true,
            movingTexture: true,
            hasText: true,
            defaultSize: [40, 0.01, 10],
            forceCollision: true,
            lineCol: 0xffff00,
            scalable: true,
            scaleWithSize: true,
            hideBoundingBox: false,
            tool: true,
            genGeo: async instance => generateSign(instance, 0, 0, 0, ...instance.size),
            stepSrc: "a",
            dummy: false,
            castShadow: true,
            receiveShadow: true,
            doubleSide: true
        },
        DEPOSIT_BOX: {
            canInterface: true,
            movingTexture: true,
            defaultSize: [10, 10, 10],
            scalable: true,
            forceCollision: true,
            editAmb: true,
            scaleWithSize: false,
            editColor: true,
            editEmissive: true,
            editOpac: true,
            lineCol: 0xff00ff,
            texturable: true,
            tool2: true,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb),
            stepSrc: "a",
            dummy: false,
            castShadow: true,
            receiveShadow: true,
            complex: true,
            hasBorder: true,
        },
        LIGHT_CONE: {
            notTechnical: true,
            defaultSize: [10, 10, 10],
            scalable: true,
            noCollision: true,
            scaleWithSize: false,
            editOpac: true,
            editColor: true,
            lineCol: 0xff00ff,
            genGeo: async (instance, amb) => generateCone(...instance.size, amb),
            stepSrc: "a",
            dummy: false,
            castShadow: true,
            receiveShadow: true,
            complex: true,
            doubleSide: true,
            blending: THREE.AdditiveBlending
        },
        // ZONE_MARKER: {
        //     notTechnical: true,
        //     notStyleable: true,
        //     defaultSize: [10, 30, 10],
        //     scalable: false,
        //     tool: true,
        //     scaleWithSize: false,
        //     lineCol: 0xC800FF,
        //     genGeo: async (instance, amb) => generateCube(...instance.size, amb),
        //     stepSrc: "a",
        //     dummy: false,
        //     castShadow: false,
        //     receiveShadow: false
        // },
        // AI_SPAWNER: {
        //     scalable: false,
        //     alwaysSee: true,
        //     tool: true,
        //     scaleWithSize: false,
        //     noTexture: true,
        //     opacity: 0.00001,
        //     stepSrc: "a",
        //     customDirection: true,
        //     dontRound: true,
        //     genGeo: async (instance, amb) => generateSpawn(instance, amb),
        //     dummy: false,
        //     castShadow: false,
        //     receiveShadow: false,
        //     lineCol: 0xffff00,
        // },
        PLACEHOLDER: {
            notStyleable: true,
            defaultSize: [10, 10, 10],
            scalable: true,
            noTexture: true,
            noExport: true,
            tool: true,
            opacity: 0.1,
            lineCol: 0x000000,
            genGeo: async (instance, amb) => generateCube(...instance.size, amb),
            stepSrc: "a"
        }
    };
    
    // TEXTURE PREFABS:
    module.exports.texturePrefabs = {
        WALL: {
            src: "wall_0",
            filter: THREE.NearestFilter
        },
        DIRT: {
            src: "dirt_0",
            filter: THREE.NearestFilter
        },
        FLOOR: {
            src: "floor_0",
            filter: THREE.NearestFilter
        },
        GRID: {
            src: "grid_0",
            filter: THREE.NearestFilter
        },
        GREY: {
            src: "grey_0",
            filter: THREE.NearestFilter
        },
        DEFAULT: {
            src: "default",
            filter: THREE.NearestFilter
        },
        ROOF: {
            src: "roof_0",
            filter: THREE.NearestFilter
        },
        FLAG: {
            src: "flag_0",
            filter: THREE.NearestFilter
        },
        CHECK: {
            src: "check_0",
            filter: THREE.NearestFilter
        },
        GRASS: {
            src: "grass_1",
            filter: THREE.NearestFilter
        },
        LINES: {
            src: "lines_0",
            filter: THREE.NearestFilter
        },
        BRICK: {
            src: "brick_0",
            filter: THREE.NearestFilter
        },
        LINK: {
            src: "link_0",
            trans: true,
            filter: THREE.NearestFilter
        },
        LIQUID: {
            src: "liquid_0",
            trans: true,
            filter: THREE.NearestFilter
        }
    };
    
    let getTexture = (src) => {
        return { src: src };
    };
    
    // LOAD IMAGE TEXTURE:
    let getImageTexture = (img) => {
        var texture = new THREE.Texture(img);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(1, 1);
        texture.minFilter = THREE.NearestFilter;
        texture.magFilter = THREE.NearestFilter;
        texture.needsUpdate = true;
        return texture;
    };
    
    // LOAD TEXTURE:
    var loadedTextures = [];
    module.exports.loadTexturePrefab = function(id, instance = null) {
        if (instance.prefab.hasText) {
            instance.defaultMaterial.map = getImageTexture(UTILS.createCanvasText(instance.size[0],
                instance.size[2], instance.text||"Hello World",
                instance.fsize||10, instance.fcolor||"#000",
                instance.bcolor||"#fff", !instance.backVisible, instance.tAlign||0));
        } else if (instance.texturePrefab.src) {
            let prefab = instance.objType != "BILLBOARD" ? module.exports.texturePrefabs[id] :
                getTexture("pubs/b_" + (instance.poster||UTILS.randInt(1, config.billboardCnt)));
            prefab = instance.objType != "FLAG" ? prefab : getTexture("zone_r");
            prefab = instance.objType != "LIGHT_CONE" ? prefab : getTexture("lightcone_0");
            prefab = instance.objType != "SPECTATE_CAM" ? prefab : getTexture("spectatecam_0");
            prefab = instance.objType != "ZONE_MARKER" ? prefab : getTexture("zone_0");
            //prefab = instance.objType != "GRASS" ? prefab : getTexture("grass_0");
    
            if (prefab.src == "default") return instance.defaultMaterial.map = undefined;
    
            if (!loadedTextures[prefab.src]) {
                textureLoader.load(UTILS.assetsUrl("/textures/" + prefab.src + ".png"), texture => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(1, 1);
                    texture.minFilter = (prefab.filter || THREE.NearestFilter);
                    texture.magFilter = (prefab.filter || THREE.NearestFilter);
                    texture.needsUpdate = true;
    
                    loadedTextures[prefab.src] = texture;
                    instance.defaultMaterial.map = texture;
                    instance.defaultMaterial.needsUpdate = true;
                });
            } else {
                instance.defaultMaterial.map = loadedTextures[prefab.src].clone();
                instance.defaultMaterial.map.needsUpdate = true;
                instance.defaultMaterial.map.offset.x = 0;
                instance.defaultMaterial.map.offset.y = 0;
                instance.defaultMaterial.needsUpdate = true;
            }
        } else instance.defaultMaterial.map = undefined;
    };
    
    
    /***/ }),
    
    /***/ "./src/data/sprays.js":
    /*!****************************!*\
      !*** ./src/data/sprays.js ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
        // SPRAYS:
        module.exports = [{
            name: "Krunker",
            id: 0,
            opacity: 0.6
        }, {
            name: "Target",
            id: 1,
            opacity: 0.6
        }, {
            name: "GG",
            id: 2,
            opacity: 0.6
        }, {
            name: "Pumpkin",
            id: 3,
            opacity: 0.6
        }, {
            name: "Spooky",
            id: 4,
            opacity: 0.6
        }, {
            name: "Ded",
            id: 5,
            opacity: 0.6
        }, {
            name: "Sadface",
            id: 6,
            opacity: 0.6
        }, {
            name: "Laugh Cry",
            id: 7,
            opacity: 0.7
        }, {
            name: "Sid",
            id: 8,
            opacity: 0.9
        }, {
            name: "Vince",
            id: 9,
            opacity: 0.9
        }, {
            name: "Kiki",
            id: 10,
            opacity: 0.6
        }, {
            name: "Ladder",
            id: 11,
            opacity: 1.0
        }, {
            name: "Dummy",
            id: 12,
            opacity: 1.0
        }, {
            name: "8 Ball",
            id: 13,
            opacity: 0.6
        }, {
            name: "xD",
            id: 14,
            opacity: 0.6
        }, {
            name: "MMOK",
            id: 15,
            opacity: 0.7
        }, {
            name: "Madman",
            id: 16,
            opacity: 0.6
        }, {
            name: "Terminal",
            id: 17,
            opacity: 0.6
        }, {
            name: "YODO",
            id: 18,
            opacity: 0.6
        }, {
            name: "Crayon",
            id: 19,
            opacity: 0.6
        }, {
            name: "Myth",
            id: 20,
            opacity: 0.85
        }, {
            name: "SpikyJohn",
            id: 21,
            opacity: 0.85
        }, {
            name: "LevelGaming",
            id: 22,
            opacity: 0.9
        }, {
            name: "PolarAce",
            id: 23,
            opacity: 0.9
        }, {
            name: "FrostyWolf",
            id: 24,
            opacity: 0.85
        }, {
            name: "Waspy",
            id: 25,
            opacity: 0.85
        }, {
            name: "Jazzmittens",
            id: 26,
            opacity: 0.85
        }, {
            name: "Wolfmaan",
            id: 27,
            opacity: 0.85
        }, {
            name: "KPL",
            id: 28 ,
            opacity: 0.9
        }, {
            name: "BV Hype",
            id: 29,
            opacity: 0.85
        }, {
            name: "LandPhil",
            id: 30,
            opacity: 0.85
        }, {
            name: "Deal With It",
            id: 31,
            opacity: 0.9
        }, {
            name: "Rice",
            id: 32,
            opacity: 0.9
        }, {
            name: "Lore",
            id: 33,
            opacity: 0.95
        }, {
            name: "Desu Sid",
            id: 34,
            opacity: 0.85
        }, {
            name: "Anomaly",
            id: 35,
            opacity: 0.85
        }, {
            name: "FaZe",
            id: 36,
            opacity: 0.9
        }, {
            name: "Nudah",
            id: 37,
            opacity: 0.9
        }, {
            name: "Misfits",
            id: 38,
            opacity: 0.9
        }, {
            name: "Bill $aber",
            id: 54,
            opacity: 0.9
        }, {
            name: "Fields Food v1",
            id: 55,
            opacity: 0.9
        }, {
            name: "Fields Food v2",
            id: 56,
            opacity: 0.9
        }, {
            name: "Phil",
            id: 57,
            opacity: 0.9
        }];
    
    
    /***/ }),
    
    /***/ "./src/data/store.js":
    /*!***************************!*\
      !*** ./src/data/store.js ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
    // PRIZE WHEELS:
    module.exports.wheels = [{
        name: "Starter",
        lab: {
            nm: "Any",
            col: "#E040FB"
        },
        price: 50,
        rarities: [75, 22, 3, 0, 0, 0]
    }, {
        name: "Elite",
        lab: {
            nm: "Any",
            col: "#E040FB"
        },
        price: 100,
        rarities: [50, 30, 15, 5, 0, 0]
    }, {
        name: "Heroic",
        lab: {
            nm: "Any",
            col: "#E040FB"
        },
        price: 500,
        rarities: [0, 48, 35, 14, 2.4, 0.5, 0.1]
    }, {
        name: "Hunter",
        lab: {
            nm: "Snipers Only!",
            col: "#fab640"
        },
        itemTypes: [0],
        weaponType: 1,
        price: 600,
        rarities: [43, 33, 17, 6, 1, 0]
    }, {
        name: "Attire",
        lab: {
            nm: "Outfits & Dyes!",
            col: "#ed4242"
        },
        itemTypes: [1, 2, 5],
        price: 750,
        rarities: [43, 33, 16, 6, 2, 0]
    }, {
        name: "Free",
        free: true,
        openURL: true,
        minLvl: 15,
        price: 0,
        priceT: "Follow for a free Spin",
        rarities: [0, 48, 35, 14, 3, 0]
    }];
    
    // ITEM TYPES:
    module.exports.types = ["weapons/weapon_",
        "hats/hat_", "body/body_", "melee/melee_",
        "sprays/", "dyes/"];
    
    // BUY KR:
    module.exports.purchases = [{
        val: 300,
        price: 0.99
    }, {
        val: 600,
        price: 1.79
    }, {
        val: 2600,
        price: 7.49
    }, {
        val: 7000,
        price: 15.99
    }, {
        val: 20000,
        price: 34.99,
        tag: "Popular!",
        tagCol: "#ed4242",
    }, {
        val: 60000,
        tag: "Best Value!",
        tagCol: "#E040FB",
        price: 99.99
    }];
    
    // RARITIES:
    module.exports.rarities = [{
        name: "Uncommon",
        rar: 60,
        color: "#b2f252"
    }, {
        name: "Rare",
        rar: 40,
        color: "#2196F3"
    }, {
        name: "Epic",
        rar: 25,
        color: "#E040FB"
    }, {
        name: "Legendary",
        rar: 10,
        color: "#FBC02D"
    }, {
        name: "Relic",
        rar: 2.5,
        color: "#ed4242"
    }, {
        name: "Contraband",
        rar: 0.5,
        color: "#292929"
    }, {
        name: "Unobtainable",
        rar: 0.0,
        color: "#fff53d",
        animate: true
    }];
    
    // SKINS:
    module.exports.previews = {
        "1": {
            xOff: -2.0,
            yOff: -2.6,
            zRota: 0.2,
            scl: 1.31 * 0.0010509883417085
        },
        "2": {
            xOff: -1.4,
            yOff: -0.8,
            scl: 1.2 * 0.00095745145728643
        },
        "3": {
            xOff: 0,
            yOff: 1.0,
            scl: 1.8 * 0.00037606512562814
        },
        "4": {
            xOff: -1.5,
            yOff: 0.5,
            scl: 1.8 * 0.00052263417085427
        },
        "5": {
            xOff: -0.8,
            yOff: 0.5,
            scl: 2 * 0.00039656251256281
        },
        "6": {
            xOff: -1.0,
            yOff: -1.1,
            scl: 1.2
        },
        "7": {
            xOff: -1.0,
            yOff: -0.9,
            scl: 1.6 * 0.00076344904522613
        },
        "8": {
            xOff: -1.0,
            yOff: -0.6,
            scl: 1.3 * 0.00093686221105528
        },
        "9": {
            xOff: -1.2,
            yOff: -1,
            scl: 1.4 * 0.00076263407035176
        },
        "10": {
            scl: 1.6
        },
        "15": {
            scl: 1.0 * 0.00098426884422111
        }
    };
    module.exports.skins = [{
        name: "Arctic Hunt",
        id: 0,
        weapon: 1,
        rarity: 1
    }, {
        name: "Autumn Hunt",
        id: 1,
        weapon: 1,
        rarity: 1
    }, {
        name: "Reticle Blaze",
        id: 2,
        weapon: 1,
        rarity: 2
    }, {
        name: "Digital Hunt",
        id: 3,
        weapon: 1,
        rarity: 0
    }, {
        name: "Moon Dragon",
        id: 4,
        weapon: 1,
        rarity: 3
    }, {
        name: "Scharfschütze",
        id: 5,
        weapon: 1,
        rarity: 1
    }, {
        name: "Woodland Sniper",
        id: 6,
        weapon: 1,
        rarity: 0
    }, {
        name: "Hazard Reticle",
        id: 7,
        weapon: 1,
        rarity: 1
    }, {
        name: "Kodac Reticle",
        id: 8,
        weapon: 1,
        rarity: 1
    }, {
        name: "Seafarer",
        id: 9,
        weapon: 1,
        rarity: 0
    }, {
        name: "Acid Breath",
        glow: true,
        id: 10,
        weapon: 1,
        rarity: 3
    }, {
        name: "Trail Scout",
        id: 11,
        weapon: 1,
        rarity: 0
    }, {
        name: "Arctic AK",
        id: 0,
        weapon: 2,
        rarity: 1
    }, {
        name: "Autumn AK",
        id: 1,
        weapon: 2,
        rarity: 1
    }, {
        name: "Blaze AK",
        id: 2,
        weapon: 2,
        rarity: 2
    }, {
        name: "Digital AK",
        id: 3,
        weapon: 2,
        rarity: 0
    }, {
        name: "Luna Dragon",
        id: 4,
        weapon: 2,
        rarity: 3
    }, {
        name: "Flecken AK",
        id: 5,
        weapon: 2,
        rarity: 1
    }, {
        name: "Woodland AK",
        id: 6,
        weapon: 2,
        rarity: 0
    }, {
        name: "Hazard AK",
        id: 7,
        weapon: 2,
        rarity: 1
    }, {
        name: "Kodac AK",
        id: 8,
        weapon: 2,
        rarity: 1
    }, {
        name: "Seafarer AK",
        id: 9,
        weapon: 2,
        rarity: 0
    }, {
        name: "Trail AK",
        id: 10,
        weapon: 2,
        rarity: 0
    }, {
        name: "SMG Arctic",
        id: 0,
        weapon: 4,
        rarity: 1
    }, {
        name: "SMG Autumn",
        id: 1,
        weapon: 4,
        rarity: 1
    }, {
        name: "SMG Blaze",
        id: 2,
        weapon: 4,
        rarity: 2
    }, {
        name: "SMG Digital",
        id: 3,
        weapon: 4,
        rarity: 0
    }, {
        name: "SMG Flecken",
        id: 4,
        weapon: 4,
        rarity: 1
    }, {
        name: "SMG Woodland",
        id: 5,
        weapon: 4,
        rarity: 0
    }, {
        name: "SMG Hazard",
        id: 6,
        weapon: 4,
        rarity: 1
    }, {
        name: "SMG Kodac",
        id: 7,
        weapon: 4,
        rarity: 1
    }, {
        name: "SMG Seafarer",
        id: 8,
        weapon: 4,
        rarity: 0
    }, {
        name: "SMG Trail",
        id: 9,
        weapon: 4,
        rarity: 0
    }, {
        name: "Arctic Python",
        id: 0,
        weapon: 5,
        rarity: 1
    }, {
        name: "Autumn Python",
        id: 1,
        weapon: 5,
        rarity: 1
    }, {
        name: "Blaze Python",
        id: 2,
        weapon: 5,
        rarity: 2
    }, {
        name: "Digital Python",
        id: 3,
        weapon: 5,
        rarity: 0
    }, {
        name: "Flecken Python",
        id: 4,
        weapon: 5,
        rarity: 1
    }, {
        name: "Woodland",
        id: 5,
        weapon: 5,
        rarity: 0
    }, {
        name: "Hazard Python",
        id: 6,
        weapon: 5,
        rarity: 1
    }, {
        name: "Kodac Python",
        id: 7,
        weapon: 5,
        rarity: 1
    }, {
        name: "Seafarer",
        id: 8,
        weapon: 5,
        rarity: 0
    }, {
        name: "Trail Python",
        id: 9,
        weapon: 5,
        rarity: 0
    }, {
        name: "Arctic Slug",
        id: 0,
        weapon: 6,
        rarity: 1
    }, {
        name: "Autumn Slug",
        id: 1,
        weapon: 6,
        rarity: 1
    }, {
        name: "Twin Blaze",
        id: 2,
        weapon: 6,
        rarity: 2
    }, {
        name: "SG Digital",
        id: 3,
        weapon: 6,
        rarity: 0
    }, {
        name: "Flecken",
        id: 4,
        weapon: 6,
        rarity: 1
    }, {
        name: "Woodland",
        id: 5,
        weapon: 6,
        rarity: 0
    }, {
        name: "Hazard Slug",
        id: 6,
        weapon: 6,
        rarity: 1
    }, {
        name: "Kodac Slug",
        id: 7,
        weapon: 6,
        rarity: 1
    }, {
        name: "Buccaneer",
        id: 8,
        weapon: 6,
        rarity: 0
    }, {
        name: "SG Trail",
        id: 9,
        weapon: 6,
        rarity: 0
    }, {
        name: "Arctic LMG",
        id: 0,
        weapon: 7,
        rarity: 1
    }, {
        name: "Autumn LMG",
        id: 1,
        weapon: 7,
        rarity: 1
    }, {
        name: "Blaze LMG",
        id: 2,
        weapon: 7,
        rarity: 2
    }, {
        name: "Digital LMG",
        id: 3,
        weapon: 7,
        rarity: 0
    }, {
        name: "Flecken LMG",
        id: 4,
        weapon: 7,
        rarity: 1
    }, {
        name: "Woodland LMG",
        id: 5,
        weapon: 7,
        rarity: 0
    }, {
        name: "Hazard LMG",
        id: 6,
        weapon: 7,
        rarity: 1
    }, {
        name: "Kodac LMG",
         id: 7,
        weapon: 7,
        rarity: 1
    }, {
        name: "Seafarer LMG",
        id: 8,
        weapon: 7,
        rarity: 0
    }, {
        name: "Trail LMG",
        id: 9,
        weapon: 7,
        rarity: 0
    }, {
        name: "Arctic Auto",
        id: 0,
        weapon: 8,
        rarity: 1
    }, {
        name: "Autumn Auto",
        id: 1,
        weapon: 8,
        rarity: 1
    }, {
        name: "Blaze Auto",
        id: 2,
        weapon: 8,
        rarity: 2
    }, {
        name: "Digital Auto",
        id: 3,
        weapon: 8,
        rarity: 0
    }, {
        name: "Flecken Auto",
        id: 4,
        weapon: 8,
        rarity: 1
    }, {
        name: "Woodland Auto",
        id: 5,
        weapon: 8,
        rarity: 0
    }, {
        name: "Hazard Auto",
        id: 6,
        weapon: 8,
        rarity: 1
    }, {
        name: "Kodac Auto",
        id: 7,
        weapon: 8,
        rarity: 1
    }, {
        name: "Seafarer Auto",
        id: 8,
        weapon: 8,
        rarity: 0
    }, {
        name: "Trail Auto",
        id: 9,
        weapon: 8,
        rarity: 0
    }, {
        name: "Mach Auto",
        id: 10,
        creator: "AtarSt",
        weapon: 8,
        rarity: 1
    }, {
        name: "Arctic RL",
        id: 0,
        weapon: 9,
        rarity: 1
    }, {
        name: "Autumn RL",
        id: 1,
        weapon: 9,
        rarity: 1
    }, {
        name: "Blaze RL",
        id: 2,
        weapon: 9,
        rarity: 2
    }, {
        name: "Digital RL",
        id: 3,
        weapon: 9,
        rarity: 0
    }, {
        name: "Flecken RL",
        id: 4,
        weapon: 9,
        rarity: 1
    }, {
        name: "Woodland RL",
        id: 5,
        weapon: 9,
        rarity: 0
    }, {
        name: "Hazard RL",
        id: 6,
        weapon: 9,
        rarity: 1
    }, {
        name: "Kodac RL",
        id: 7,
        weapon: 9,
        rarity: 1
    }, {
        name: "Seafarer RL",
        id: 8,
        weapon: 9,
        rarity: 0
    }, {
        name: "Trail RL",
        id: 9,
        weapon: 9,
        rarity: 0
    }, {
        name: "101 Skullbreaker",
        id: 12,
        weapon: 1,
        rarity: 3
    }, {
        name: "Reticle Faded",
        id: 13,
        weapon: 1,
        rarity: 0
    }, {
        name: "Puma Sniper",
        id: 14,
        weapon: 1,
        rarity: 0
    }, {
        name: "Scoped Elite",
        id: 15,
        weapon: 1,
        rarity: 2
    }, {
        name: "Faded AK",
        id: 11,
        weapon: 2,
        rarity: 0
    }, {
        name: "Puma AR",
        id: 12,
        weapon: 2,
        rarity: 1
    }, {
        name: "SMG Fade",
        id: 10,
        weapon: 4,
        rarity: 0
    }, {
        name: "SMG Puma",
        id: 11,
        weapon: 4,
        rarity: 1
    }, {
        name: "Faded Python",
        id: 10,
        weapon: 5,
        rarity: 0
    }, {
        name: "Puma Python",
        id: 11,
        weapon: 5,
        rarity: 1
    }, {
        name: "SG Fade",
        id: 10,
        weapon: 6,
        rarity: 0
    }, {
        name: "Slug Puma",
        id: 11,
        weapon: 6,
        rarity: 1
    }, {
        name: "Faded LMG",
        id: 10,
        weapon: 7,
        rarity: 0
    }, {
        name: "Puma LMG",
        id: 11,
        weapon: 7,
        rarity: 1
    }, {
        name: "Faded MMR",
        id: 11,
        weapon: 8,
        rarity: 0
    }, {
        name: "Puma MMR",
        id: 12,
        weapon: 8,
        rarity: 1
    }, {
        name: "Faded RTL",
        id: 10,
        weapon: 9,
        rarity: 0
    }, {
        name: "Puma RTL",
        id: 11,
        weapon: 9,
        rarity: 1
    }, {
        name: "Scoped Carbon",
        id: 16,
        weapon: 1,
        rarity: 0
    }, {
        name: "Carbon AK",
        id: 13,
        weapon: 2,
        rarity: 0
    }, {
        name: "SMG Carbon",
        id: 12,
        weapon: 4,
        rarity: 0
    }, {
        name: "Carbon Python",
        id: 12,
        weapon: 5,
        rarity: 0
    }, {
        name: "SG Carbon",
        id: 12,
        weapon: 6,
        rarity: 0
    }, {
        name: "Carbon LMG",
        id: 12,
        weapon: 7,
        rarity: 0
    }, {
        name: "Carbon MMR",
        id: 13,
        weapon: 8,
        rarity: 0
    }, {
        name: "Carbon RTL",
        id: 12,
        weapon: 9,
        rarity: 0
    }, {
        name: "Neon Ripper",
        id: 14,
        glow: true,
        weapon: 2,
        rarity: 4
    }, {
        name: "Top Hat",
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sitOff: 0.4,
        yOff: -4,
        id: 1,
        rarity: 2
    }, {
        name: "SMG Spitfire",
        id: 13,
        weapon: 4,
        rarity: 3
    }, {
        name: "Cowboy Hat",
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sitOff: 0.4,
        yOff: -3,
        id: 0,
        rarity: 0
    }, {
        name: "Flame Tamer",
        id: 13,
        pulsT: 0.0015,
        weapon: 5,
        glow: true,
        rarity: 5
    }, {
        name: "Cool Cap",
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sitOff: 0.4,
        yOff: -3,
        xOff: 2,
        id: 2,
        rarity: 1
    }, {
        name: "Jack O' Lantern",
        type: 1,
        keyW: "Head",
        scl: 2.8,
        glow: true,
        sclMlt: 1.4,
        sitOff: 2.05,
        yOff: -4,
        id: 3,
        rarity: 3
    }, {
        name: "Medic Helmet",
        type: 1,
        keyW: "Head",
        scl: 2.8,
        sclMlt: 1.0,
        sitOff: 0.65,
        yOff: -2.5,
        id: 4,
        rarity: 2
    }, {
        name: "Neon Reaver",
        creator: "Electrode_",
        id: 17,
        glow: true,
        weapon: 1,
        rarity: 4
    }, {
        name: "Sun Glasses",
        type: 1,
        keyW: "Head",
        scl: 2.8,
        sclMlt: 1.0,
        sitOff: 2.3,
        yOff: -5,
        xOff: 2,
        id: 5,
        rarity: 0
    }, {
        name: "Afro",
        type: 1,
        keyW: "Head",
        scl: 2.0,
        sclMlt: 0.9,
        sitOff: 1.4,
        yOff: -4,
        id: 6,
        rarity: 0
    }, {
        name: "Hard Hat",
        type: 1,
        keyW: "Head",
        scl: 3,
        sitOff: 0.4,
        yOff: -3,
        id: 7,
        rarity: 0
    }, {
        name: "Zombie Head",
        type: 1,
        keyW: "Head",
        scl: 2.8,
        glow: true,
        sclMlt: 1.2,
        sitOff: 2.05,
        yOff: -4,
        id: 8,
        rarity: 3
    }, {
        name: "Barbed Rifle",
        id: 18,
        weapon: 1,
        rarity: 2
    }, {
        name: "Blushed Sniper",
        id: 19,
        weapon: 1,
        rarity: 0
    }, {
        name: "AWP Mech",
        id: 20,
        weapon: 1,
        rarity: 1
    }, {
        name: "Olympus Rifle",
        id: 21,
        weapon: 1,
        rarity: 2
    }, {
        name: "Scoped Tuscan",
        id: 22,
        weapon: 1,
        rarity: 1
    }, {
        name: "AWP Pacemaker",
        id: 23,
        weapon: 1,
        rarity: 4,
        glow: true
    }, {
        name: "AR Wired",
        id: 15,
        weapon: 2,
        rarity: 2
    }, {
        name: "Blushed AK",
        id: 16,
        weapon: 2,
        rarity: 0
    }, {
        name: "Mach Rifle",
        id: 17,
        weapon: 2,
        rarity: 1
    }, {
        name: "Olympus Rifle",
        id: 18,
        weapon: 2,
        rarity: 2
    }, {
        name: "AR Tuscan",
        id: 19,
        weapon: 2,
        rarity: 1
    }, {
        name: "SMG Barbed",
        id: 14,
        weapon: 4,
        rarity: 2
    }, {
        name: "SMG Blossom",
        id: 15,
        weapon: 4,
        rarity: 0
    }, {
        name: "SMG Machinist",
        id: 16,
        weapon: 4,
        rarity: 1
    }, {
        name: "SMG Lazarus",
        id: 17,
        weapon: 4,
        rarity: 2
    }, {
        name: "SMG Tuscan",
        id: 18,
        weapon: 4,
        rarity: 1
    }, {
        name: "Barbed Python",
        id: 14,
        weapon: 5,
        rarity: 2
    }, {
        name: "Blushed Revolver",
        id: 15,
        weapon: 5,
        rarity: 0
    }, {
        name: "Machinist Python",
        id: 16,
        weapon: 5,
        rarity: 1
    }, {
        name: "REV Olympus",
        id: 17,
        weapon: 5,
        rarity: 2
    }, {
        name: "Tuscan Revolver",
        id: 18,
        weapon: 5,
        rarity: 1
    }, {
        name: "Coach Barb",
        id: 13,
        weapon: 6,
        rarity: 2
    }, {
        name: "Blossom",
        id: 14,
        weapon: 6,
        rarity: 0
    }, {
        name: "MD Frag",
        id: 15,
        weapon: 6,
         rarity: 1
    }, {
        name: "SG Olympus",
        id: 16,
        weapon: 6,
        rarity: 2
    }, {
        name: "SG Tuscan",
        id: 17,
        weapon: 6,
        rarity: 1
    }, {
        name: "Blushed LMG",
        id: 13,
        weapon: 7,
        rarity: 0
    }, {
        name: "Machinist LMG",
        id: 14,
        weapon: 7,
        rarity: 1
    }, {
        name: "Olympus LMG",
        id: 15,
        weapon: 7,
        rarity: 2
    }, {
        name: "Tuscan LMG",
        id: 16,
        weapon: 7,
        rarity: 1
    }, {
        name: "Barbed Auto",
        id: 14,
        weapon: 8,
        rarity: 2
    }, {
        name: "Blushed MMA",
        id: 15,
        weapon: 8,
        rarity: 0
    }, {
        name: "Auto Machinist",
        id: 16,
        weapon: 8,
        rarity: 1
    }, {
        name: "Olympus MMA",
        id: 17,
        weapon: 8,
        rarity: 2
    }, {
        name: "Tuscan MMA",
        id: 18,
        weapon: 8,
        rarity: 1
    }, {
        name: "Barbed Launcher",
        id: 13,
        weapon: 9,
        rarity: 2
    }, {
        name: "Blushed Launcher",
        id: 14,
        weapon: 9,
        rarity: 0
    }, {
        name: "Machinist Launcher",
        id: 15,
        weapon: 9,
        rarity: 1
    }, {
        name: "Olympus Launcher",
        id: 16,
        weapon: 9,
        rarity: 2
    }, {
        name: "Tuscan Launcher",
        id: 17,
        weapon: 9,
        rarity: 1
    }, {
        name: "Omen",
        glow: true,
        id: 24,
        creator: "Zino",
        weapon: 1,
        rarity: 3
    }, {
        name: "Scoped Moss",
        id: 25,
        weapon: 1,
        rarity: 0
    }, {
         name: "Swamped Scope",
        id: 26,
        weapon: 1,
        rarity: 0
    }, {
        name: "Tiger Bolt",
        id: 27,
        weapon: 1,
        rarity: 2
    }, {
        name: "Zebra Bolt",
        id: 28,
        weapon: 1,
        rarity: 2
    }, {
        name: "Necron Bolt",
        id: 29,
        weapon: 1,
        rarity: 4,
        glow: true
    }, {
        name: "Lava Bolt",
        id: 30,
        weapon: 1,
        rarity: 3
    }, {
        name: "Sky Bolt",
        id: 31,
        weapon: 1,
         rarity: 2
    }, {
        name: "AWP Iris",
        id: 32,
        weapon: 1,
        rarity: 1
    }, {
        name: "Bolt Wanderer",
        id: 33,
        weapon: 1,
        rarity: 1
    }, {
        name: "Mossy Rifle",
        id: 20,
        weapon: 2,
        rarity: 1
    }, {
        name: "Swamped AK",
        id: 21,
        weapon: 2,
        rarity: 0
    }, {
        name: "Tiger Rifle",
        id: 22,
        weapon: 2,
        rarity: 2
    }, {
        name: "Zebra Rifle",
        id: 23,
        weapon: 2,
        rarity: 2
    }, {
        name: "Plasma Rifle",
        id: 24,
        weapon: 2,
        rarity: 4,
        glow: true
    }, {
        name: "Lava Rifle",
        id: 25,
        weapon: 2,
        glow: true,
        rarity: 3
    }, {
        name: "Sky Rifle",
        id: 26,
        weapon: 2,
        rarity: 2
    }, {
        name: "Bark AK",
        id: 27,
        weapon: 2,
        rarity: 0
    }, {
        name: "Rifle Wanderer",
        id: 28,
        weapon: 2,
        rarity: 0
    }, {
        name: "SMG Growth",
        id: 19,
        weapon: 4,
        rarity: 1
    }, {
        name: "SMG Marsh",
        id: 20,
        weapon: 4,
        rarity: 0
    }, {
        name: "SMG Tigris",
        id: 21,
        weapon: 4,
        rarity: 2
    }, {
        name: "SMG Safari",
        id: 22,
        weapon: 4,
        rarity: 2
    }, {
        name: "Rapid Plasma",
        id: 23,
        weapon: 4,
        rarity: 4,
        glow: true
    }, {
        name: "Lava SMG",
        id: 24,
        weapon: 4,
        rarity: 3,
        glow: true
    }, {
        name: "UMP Atmos",
        id: 25,
        weapon: 4,
        rarity: 2
    }, {
        name: "Birch SMG",
        id: 26,
        weapon: 4,
        rarity: 0
    }, {
        name: "SMG Wanderer",
        id: 27,
        weapon: 4,
        rarity: 0
    }, {
        name: "Mossy Python",
        id: 19,
        weapon: 5,
        rarity: 1
    }, {
        name: "Swamped Revolver",
        id: 20,
        weapon: 5,
        rarity: 0
    }, {
        name: "Tiger Python",
        id: 21,
        weapon: 5,
        rarity: 2
    }, {
        name: "Zebra Python",
        id: 22,
        weapon: 5,
        rarity: 2
    }, {
        name: "Venomous",
        creator: "Rengar",
        glow: true,
        id: 23,
        weapon: 5,
        rarity: 3
    }, {
        name: "Lava Revolver",
        id: 24,
        weapon: 5,
        rarity: 3
    }, {
        name: "Sky Python",
        id: 25,
        weapon: 5,
        rarity: 2,
        glow: true
    }, {
        name: "Bark Python",
        id: 26,
        weapon: 5,
        rarity: 0
    }, {
        name: "Wanderer Python",
        id: 27,
        weapon: 5,
        rarity: 0
    }, {
        name: "Gabrand",
        id: 19,
        weapon: 6,
        rarity: 1
    }, {
        name: "Tennessee",
        id: 20,
        weapon: 6,
        rarity: 0
    }, {
        name: "SG Tigris",
        id: 21,
        weapon: 6,
        rarity: 2
    }, {
        name: "Safaris",
        id: 22,
        weapon: 6,
        rarity: 2
    }, {
        name: "Neuromance",
        id: 23,
        weapon: 6,
        rarity: 4,
        glow: true
    }, {
        name: "Anatomis",
        id: 24,
        weapon: 6,
        rarity: 3,
        glow: true
    }, {
        name: "Sky Pump",
        id: 25,
        weapon: 6,
        rarity: 2
    }, {
        name: "Bark Slug",
        id: 26,
        weapon: 6,
        rarity: 0
    }, {
        name: "Slug Wanderer",
        id: 27,
        weapon: 6,
         rarity: 0
    }, {
        name: "Mossy LMG",
        id: 17,
        weapon: 7,
        rarity: 1
    }, {
        name: "Swamped LMG",
        id: 18,
        weapon: 7,
         rarity: 0
    }, {
        name: "Tiger LMG",
        id: 19,
        weapon: 7,
        rarity: 2
    }, {
        name: "Zebra LMG",
        id: 20,
        weapon: 7,
        rarity: 2
    }, {
        name: "Heavy Plasma",
        id: 21,
        weapon: 7,
        rarity: 4,
        glow: true
    }, {
        name: "Lava LMG",
        id: 22,
        weapon: 7,
        rarity: 3
    }, {
         name: "Sky LMG",
        id: 23,
        weapon: 7,
        rarity: 2,
        glow: true
    }, {
        name: "Bark LMG",
        id: 24,
        weapon: 7,
        rarity: 0
    }, {
        name: "LMG Wanderer",
        id: 25,
        weapon: 7,
        rarity: 0
    }, {
        name: "Overgrowth",
        id: 19,
        weapon: 8,
        rarity: 1
    }, {
        name: "Marshland",
        id: 20,
        weapon: 8,
        rarity: 0
    }, {
        name: "Tiger MMA",
        id: 21,
        weapon: 8,
        rarity: 2
    }, {
        name: "Zebra MMA",
        id: 22,
        weapon: 8,
        rarity: 2
    }, {
        name: "MMA Plasma",
        id: 23,
        weapon: 8,
        rarity: 4,
        glow: true
    }, {
        name: "Magnis",
        id: 24,
        weapon: 8,
        rarity: 3,
        glow: true
    }, {
        name: "Sky AUTO",
        id: 25,
        weapon: 8,
        rarity: 2
    }, {
        name: "Bark AUTO",
        id: 26,
        weapon: 8,
        rarity: 0
    }, {
        name: "MMA Wanderer",
        id: 27,
        weapon: 8,
        rarity: 0
    }, {
        name: "Mossy Rocket",
        id: 18,
        weapon: 9,
        rarity: 1
    }, {
        name: "Swamped Launcher",
        id: 19,
        weapon: 9,
        rarity: 0
    }, {
        name: "Tiger Rocket",
        id: 20,
        weapon: 9,
        rarity: 2
    }, {
        name: "Zebra Launcher",
        id: 21,
        weapon: 9,
        rarity: 2
    }, {
        name: "Plasma Nuke",
        id: 22,
        weapon: 9,
        rarity: 4,
        glow: true
    }, {
        name: "Lava Rocket",
        id: 23,
        weapon: 9,
        rarity: 3
    }, {
        name: "Sky Launcher",
        id: 24,
        weapon: 9,
        rarity: 2
    }, {
        name: "Bark Launcher",
        id: 25,
        weapon: 9,
        rarity: 0
    }, {
        name: "Wanderer Rocket",
        id: 26,
        weapon: 9,
        rarity: 0
    }, {
        name: "Purple Cap",
        id: 2,
        tex: 1,
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sitOff: 0.4,
        yOff: -3,
        xOff: 2,
        rarity: 0
    }, {
        name: "Bear Mask",
        id: 9,
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sclMlt: 1.3,
        sitOff: 2.05,
        yOff: -4,
        xOff: 1,
        rarity: 2
    }, {
        name: "Panda Mask",
        id: 9,
        tex: 1,
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sclMlt: 1.3,
        sitOff: 2.05,
        yOff: -4,
        xOff: 1,
        rarity: 2
    }, {
        name: "Brown Beard",
        id: 11,
        type: 1,
        keyW: "Head",
        scl: 2.8,
        sclMlt: 0.9,
        sitOff: 2.0,
        yOff: -3,
        rarity: 2
    }, {
        name: "Blonde Beard",
        id: 11,
        tex: 1,
        type: 1,
        keyW: "Head",
        scl: 2.8,
        sclMlt: 0.9,
        sitOff: 2.0,
        yOff: -3,
        rarity: 2
    }, {
        name: "Skull Mask",
        id: 12,
        type: 1,
        keyW: "Head",
        scl: 3.0,
        glow: true,
        sclMlt: 1.05,
        sitOff: 2.5,
        sitOffZ: 1.1,
        yOff: -4.5,
        xOff: -3,
        tex: 0,
        rarity: 3
    }, {
        name: "Red Beanie",
        id: 13,
        type: 1,
        keyW: "Head",
        scl: 3.0,
        sclMlt: 1.1,
        sitOff: 0.4,
        yOff: -3,
        tex: 0,
        rarity: 0
    }, {
        name: "Blue Beanie",
        id: 13,
        type: 1,
        keyW: "Head",
        scl: 3.0,
        sclMlt: 1.1,
        sitOff: 0.4,
        yOff: -3,
        tex: 1,
        rarity: 0
    }, {
        name: "Krunk Headset",
        id: 14,
        type: 1,
        keyW: "Head",
        scl: 2.0,
        sclMlt: 1.1,
        sitOff: 1.4,
        yOff: -4,
        rarity: 2
    }, {
        name: "Cherry Headset",
        id: 14,
        type: 1,
        keyW: "Head",
        tex: 1,
        scl: 2.0,
        sclMlt: 1.1,
        sitOff: 1.4,
        yOff: -4,
        rarity: 2
    }, {
        name: "Demonic Wings",
        id: 0,
        type: 2,
        keyW: "Back",
        glow: true,
        scl: 3.5,
        sclMlt: 3.0,
        xOff: -1.5,
        sitOff: -1.3,
        sitOffZ: -1.4,
        yOff: -2,
        rarity: 4
    }, {
        name: "Bass Guitar",
        id: 1,
        type: 2,
        keyW: "Back",
        scl: 4.0,
        sclMlt: 3.8,
        sitOff: -1.3,
        sitOffZ: -1.0,
        yOff: -2,
        rarity: 2
    }, {
        name: "Samurai Blades",
        id: 2,
        type: 2,
        keyW: "Back",
        glow: true,
        scl: 4.5 * 0.00010691567839196,
        sclMlt: 3.8 * 0.00010691567839196,
        sitOff: -1.3,
        sitOffZ: -0.95,
        yOff: -1,
        xOff: -0.5,
        rarity: 3
    }, {
        name: "Blood Harvest",
        id: 3,
        type: 2,
        keyW: "Back",
        glow: true,
        scl: 5.1,
        sclMlt: 5.0,
        sitOff: -1.3,
        sitOffZ: -0.95,
        yOff: -1,
        rarity: 3
    }, {
        name: "Panda Body",
        id: 4,
        type: 2,
        keyW: "Back",
        scl: 2.1,
        sclMlt: 1.3,
        sitOff: 2.2,
        sitOffZ: 0.0,
        yOff: -5,
        rarity: 3
    }, {
        name: "Bear Body",
        id: 4,
        tex: 1,
        type: 2,
        keyW: "Back",
        scl: 2.1,
        sclMlt: 1.3,
        sitOff: 2.2,
        sitOffZ: 0.0,
        yOff: -5,
        rarity: 3
    }, {
        name: "Angelic Wings",
        id: 5,
        type: 2,
        keyW: "Back",
        glow: true,
        scl: 3.5,
        sclMlt: 3.6,
        xOff: -1.5,
        sitOff: -1.3,
        sitOffZ: -1.4,
        yOff: -2,
        rarity: 4
    }, {
        name: "Ninja Mask",
        id: 15,
        glow: true,
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sclMlt: 1.1,
        sitOff: 2.05,
        yOff: -4,
        xOff: 0,
        rarity: 3
    }, {
        name: "Halo",
        id: 16,
        glow: true,
        type: 1,
        keyW: "Head",
        scl: 3.5,
        sclMlt: 1.1,
        sitOff: -0.65,
        yOff: -1,
        rarity: 3
    }, {
        name: "Welder Mask",
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sitOff: 2.1,
        yOff: -3,
        xOff: 1,
        id: 17,
        rarity: 1
    }, {
        name: "Diver Goggles",
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sclMlt: 0.9,
        sitOff: 1.0,
        yOff: -1,
        id: 18,
        rarity: 1
    }, {
        name: "Mad Cap",
        type: 1,
        keyW: "Head",
        tex: 2,
        scl: 2.5,
        sitOff: 0.4,
        yOff: -3,
        xOff: 2,
        id: 2,
        rarity: 1
    }, {
        name: "Ace Cap",
        type: 1,
        keyW: "Head",
        tex: 3,
        scl: 2.5,
        sitOff: 0.4,
        yOff: -3,
        xOff: 2,
        id: 2,
        rarity: 1
    }, {
        name: "Ice Cap",
        type: 1,
        keyW: "Head",
        tex: 4,
        scl: 2.5,
        sitOff: 0.4,
        yOff: -3,
        xOff: 2,
        id: 2,
        rarity: 1
    }, {
        name: "Soldier Pack",
        id: 6,
        type: 2,
        keyW: "Back",
        glow: true,
        scl: 2.6,
        sclMlt: 1.8,
        xOff: 1,
        sitOff: 1.3,
        sitOffZ: -1.75,
        yOff: -5,
        rarity: 1
    }, {
        name: "Robo Wings",
        id: 7,
        type: 2,
        keyW: "Back",
        glow: true,
        scl: 5.0,
        sclMlt: 3.9,
        xOff: -3.5,
        sitOff: -1.3,
        sitOffZ: -0.75,
        yOff: -4,
        rarity: 4
    }, {
        name: "Basket",
        id: 8,
        type: 2,
        keyW: "Back",
        scl: 3.5,
        sclMlt: 2.0,
        xOff: -1.5,
        sitOff: 0.75,
        sitOffZ: -0.8,
        yOff: -4,
        rarity: 1
    }, {
        name: "Baby Panda",
        id: 9,
        type: 2,
        keyW: "Back",
        scl: 3.5,
        sclMlt: 2.0,
        xOff: 1,
        sitOff: 0.75,
        sitOffZ: -0.8,
        yOff: -5,
        xRot: Math.PI,
        rarity: 3
    }, {
        name: "Sturm Helmet",
        type: 1,
        keyW: "Head",
        tex: 1,
        scl: 2.8,
        sclMlt: 1.0,
        sitOff: 0.65,
        yOff: -2.5,
        id: 4,
        rarity: 1
    }, {
        name: "Brown Afro",
        type: 1,
        keyW: "Head",
        tex: 1,
        scl: 2.0,
        sclMlt: 0.9,
        sitOff: 1.4,
        yOff: -4,
        id: 6,
        rarity: 0
    }, {
        name: "Acid Skull",
        id: 12,
        type: 1,
        keyW: "Head",
        tex: 1,
        scl: 3.0,
        glow: true,
        sclMlt: 1.05,
        sitOff: 2.5,
        sitOffZ: 1.1,
        yOff: -4.5,
        xOff: -3,
        rarity: 3
    }, {
        name: "Uranium",
        type: 1,
        keyW: "Head",
        tex: 1,
        scl: 2.5,
        sitOff: 2.1,
        yOff: -3,
        xOff: 1,
        id: 17,
        rarity: 2
    }, {
        name: "Panda King",
        id: 19,
        glow: true,
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sclMlt: 1.3,
        sitOff: 2.05,
        yOff: -4,
        xOff: 1,
        rarity: 3
    }, {
        name: "Kolt Rifle",
        creator: "iSpy",
        id: 35,
        weapon: 1,
        rarity: 3
    }, {
        name: "Pace Dore",
        id: 34,
        glow: true,
        weapon: 1,
        rarity: 4
    }, {
        name: "Shot Element",
        creator: "Electrode_",
        glow: true,
        id: 28,
        weapon: 6,
        rarity: 3
    }, {
        name: "Warp Sequence",
        creator: "Electrode_",
        id: 28,
        glow: true,
        weapon: 4,
        rarity: 4
    }, {
        name: "Radioactive",
        creator: "Electrode_",
        glow: true,
        id: 29,
        weapon: 5,
        rarity: 4
    }, {
        name: "Targeted",
        creator: "Subza",
        glow: true,
        id: 28,
        weapon: 5,
        rarity: 3
    }, {
        name: "Robot Helmet",
        type: 1,
        keyW: "Head",
        glow: true,
        scl: 2.4,
        sclMlt: 1.0,
        sitOff: 2,
        yOff: -3.4,
        id: 20,
        rarity: 3
    }, {
        name: "Knight Helmet",
        type: 1,
        keyW: "Head",
        scl: 2.3,
        sclMlt: 1.0,
        sitOff: 2,
        yOff: -3.2,
        id: 21,
        rarity: 3
    }, {
        name: "Cat Ears",
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sclMlt: 1.2,
        sitOff: 1.65,
        yOff: -3.2,
        id: 22,
        rarity: 2
    }, {
        name: "Snowman",
        type: 1,
        keyW: "Head",
        scl: 2.2,
        sclMlt: 1.0,
        sitOff: 2.05,
        yOff: -3.2,
        id: 23,
        rarity: 2
    }, {
        name: "Trendy Biker",
        type: 1,
        keyW: "Head",
        scl: 2.2,
        sclMlt: 1.0,
        sitOff: 1.8,
        yOff: -3.2,
        id: 24,
        rarity: 3
    }, {
        name: "Golden Crown",
        type: 1,
        keyW: "Head",
        glow: true,
        scl: 2.4,
        sclMlt: 1.0,
        sitOff: 0.65,
        yOff: -3.2,
        id: 25,
        rarity: 3
    }, {
        name: "Master Drinker",
        type: 1,
        keyW: "Head",
        scl: 2.4,
        sclMlt: 1.0,
        sitOff: 0.65,
        yOff: -2.7,
        id: 26,
        rarity: 3
    }, {
        name: "Pig Head",
        type: 1,
        keyW: "Head",
        scl: 2.5,
        sclMlt: 1.0,
        sitOff: 2.05,
        yOff: -3.2,
        id: 27,
        rarity: 3
    }, {
        name: "Red Bandana",
        type: 1,
        keyW: "Head",
        scl: 2.2,
        sclMlt: 1.0,
        sitOff: 1.6,
        yOff: -3.2,
        id: 28,
        rarity: 1
    }, {
        name: "Sheriff",
        type: 1,
        keyW: "Head",
        scl: 2.2,
        sclMlt: 1.0,
        sitOff: 2.05,
        yOff: -3.2,
        id: 29,
        rarity: 4
    }, {
        name: "Bandit",
        type: 1,
        keyW: "Head",
        glow: true,
        scl: 2.2,
        sclMlt: 1.0,
        sitOff: 2.05,
        yOff: -3.2,
        id: 30,
        rarity: 4
    }, {
        name: "Vlaine",
        creator: "Hoodgail",
        id: 36,
        weapon: 1,
        rarity: 1
    }, {
        name: "AWP Supersport",
        creator: "Kitter",
        id: 37,
        weapon: 1,
        rarity: 2
    }, {
        name: "Reine",
        id: 38,
        weapon: 1,
        rarity: 3
    }, {
        name: "Melted",
        glow: true,
        id: 39,
        weapon: 1,
        rarity: 4
    }, {
        name: "Viper",
        glow: true,
        id: 40,
        weapon: 1,
        rarity: 3
    }, {
        name: "Razor",
        glow: true,
        id: 41,
        weapon: 1,
        rarity: 4
    }, {
        name: "Lazor",
        id: 29,
        glow: true,
        weapon: 2,
        rarity: 4
    }, {
        name: "Uzera",
        creator: "Hoodgail",
        id: 2,
        glow: true,
        weapon: 10,
        rarity: 4
    }, {
        name: "Tazor",
        creator: "Hoodgail",
        glow: true,
        id: 7,
        weapon: 10,
        rarity: 3
    }, {
        name: "Dual Woodland",
        id: 0,
        weapon: 10,
        rarity: 1
    }, {
        name: "Flecken Uzi",
        id: 1,
        weapon: 10,
        rarity: 1
    }, {
        name: "Dual Seafarer",
        id: 3,
        weapon: 10,
        rarity: 2
    }, {
        name: "Rapid Digital",
        id: 4,
        weapon: 10,
        rarity: 1
    }, {
        name: "Sap Uzi",
        id: 5,
        weapon: 10,
        rarity: 0
    }, {
        name: "Torn Dual",
        id: 6,
        weapon: 10,
        rarity: 1
    }, {
        name: "Haste",
        glow: true,
        id: 42,
        weapon: 1,
        rarity: 3
    }, {
        name: "Leine",
        creator: "Hoodgail",
        id: 43,
        weapon: 1,
        rarity: 3
    }, {
        name: "Lore",
        glow: true,
        id: 44,
        weapon: 1,
        rarity: 4
    }, {
        name: "Reaver",
        glow: true,
        id: 45,
        weapon: 1,
        rarity: 4
    }, {
        name: "Splixen",
        glow: true,
        id: 46,
        weapon: 1,
        rarity: 4
    }, {
        name: "AWP Stream",
        creator: "Electrode_",
        glow: true,
        id: 47,
        weapon: 1,
        rarity: 4
    }, {
        name: "Circuit",
        creator: "Electrode_",
        glow: true,
        id: 30,
        weapon: 2,
        rarity: 4
    }, {
        name: "SMG Iris",
        id: 29,
        weapon: 4,
        rarity: 2
    }, {
        name: "SMG Venom",
        id: 30,
        weapon: 4,
        rarity: 2,
        glow: true
    }, {
        name: "SMG Wingman",
        id: 31,
        weapon: 4,
        rarity: 2
    }, {
        name: "x0n-voX",
        creator: "???",
        pat: 0,
        tex: "weapons/pat/0",
        sameGlow: true,
        movT: 0.0001,
        weapon: 4,
        rarity: 5
    }, {
        name: "1Ad-dA0",
        creator: "???",
        pat: 0,
        tex: "weapons/pat/0",
        sameGlow: true,
        movT: 0.0001,
        weapon: 2,
        rarity: 5
    }, {
        name: "Raynb0w",
        creator: "???",
        pat: 1,
        tex: "weapons/pat/1",
        sameGlow: true,
        movT: 0.0015,
        weapon: 2,
        rarity: 5
    }, {
        name: "Raynb0w",
        creator: "???",
        pat: 1,
        tex: "weapons/pat/1",
        sameGlow: true,
        movT: 0.0015,
        weapon: 4,
        rarity: 5
    }, {
        name: "UMP Saphire",
        id: 32,
        weapon: 4,
        rarity: 1
    }, {
        name: "UMP Jade",
        id: 33,
        weapon: 4,
        rarity: 1
    }, {
        name: "UMP Plexus",
        id: 34,
        weapon: 4,
        rarity: 1
    }, {
        name: "UMP Lapis",
        id: 35,
        weapon: 4,
        rarity: 0
    }, {
        name: "Perplex",
        id: 36,
        weapon: 4,
        rarity: 0
    }, {
        name: "UMP Torpe",
        id: 37,
        weapon: 4,
        rarity: 0
    }, {
        name: "SMG Como",
        id: 38,
        weapon: 4,
        rarity: 0
    }, {
        name: "SMG Liquid",
        id: 39,
        weapon: 4,
        rarity: 0
    }, {
        name: "Clementine",
        id: 40,
        weapon: 4,
        rarity: 1
    }, {
        name: "Dropper",
        id: 41,
        weapon: 4,
        rarity: 0
    }, {
        name: "SMG Auburn",
        id: 42,
        weapon: 4,
        rarity: 1
    }, {
        name: "UMP Laurel",
        id: 43,
        weapon: 4,
        rarity: 1
    }, {
        name: "UMP Crimson",
        id: 44,
        weapon: 4,
        rarity: 1
    }, {
        name: "UMP Azure",
        id: 45,
        weapon: 4,
        rarity: 1
    }, {
        name: "Laguna",
        id: 46,
        weapon: 4,
        rarity: 1
    }, {
        name: "UMP Cygenta",
        id: 47,
        weapon: 4,
        rarity: 1
    }, {
        name: "UMP Cygentro",
        id: 48,
        weapon: 4,
        rarity: 2
    }, {
        name: "Chartreuse",
        id: 49,
        weapon: 4,
        rarity: 2
    }, {
        name: "UMP Tortobe",
        id: 50,
        weapon: 4,
        rarity: 2
    }, {
        name: "UMP Octo",
        id: 51,
        weapon: 4,
        rarity: 2
    }, {
        name: "UMP Versate",
        id: 52,
        weapon: 4,
        rarity: 2
    }, {
        name: "SMG Purpur",
        id: 53,
        weapon: 4,
        rarity: 2
    }, {
        name: "Leaf",
        id: 54,
        weapon: 4,
        rarity: 0
    }, {
        name: "Flame",
        id: 55,
        weapon: 4,
        rarity: 0
    }, {
        name: "Aqua",
        id: 56,
        weapon: 4,
        rarity: 0
    }, {
        name: "Gravel",
        id: 57,
        weapon: 4,
        rarity: 0
    }, {
        name: "AR Saphire",
        id: 31,
        weapon: 2,
        rarity: 1
    }, {
        name: "AR Jade",
        id: 32,
        weapon: 2,
        rarity: 1
    }, {
        name: "AR Plexus",
        id: 33,
        weapon: 2,
        rarity: 1
    }, {
        name: "AR Lapis",
        id: 34,
        weapon: 2,
        rarity: 1
    }, {
        name: "Perplex",
        id: 35,
        weapon: 2,
        rarity: 0
    }, {
        name: "Trople",
        id: 36,
        weapon: 2,
        rarity: 0
    }, {
        name: "AR Altis",
        id: 37,
        weapon: 2,
        rarity: 1
    }, {
        name: "Liquid",
        id: 38,
        weapon: 2,
        rarity: 1
    }, {
        name: "Clementine",
        id: 39,
        weapon: 2,
        rarity: 1
    }, {
        name: "Dropper",
        id: 40,
        weapon: 2,
        rarity: 0
    }, {
        name: "Laurel",
        id: 41,
        weapon: 2,
        rarity: 1
    }, {
        name: "Crimson",
        id: 42,
        weapon: 2,
        rarity: 1
    }, {
        name: "Azure",
        id: 43,
        weapon: 2,
        rarity: 1
    }, {
        name: "Laguna",
        id: 44,
        weapon: 2,
        rarity: 1
    }, {
        name: "Cygenta",
        id: 45,
        weapon: 2,
        rarity: 1
    }, {
        name: "Cygento",
        id: 46,
        weapon: 2,
        rarity: 2
    }, {
        name: "Chartreuse",
        id: 47,
        weapon: 2,
        rarity: 2
    }, {
        name: "Tortobe",
        id: 48,
        weapon: 2,
        rarity: 2
    }, {
        name: "AK Octo",
        id: 49,
        weapon: 2,
        rarity: 2
    }, {
        name: "Versate",
        id: 50,
        weapon: 2,
        rarity: 2
    }, {
        name: "Purpur",
        id: 51,
        weapon: 2,
        rarity: 2
    }, {
        name: "Leaf",
        id: 52,
        weapon: 2,
        rarity: 0
    }, {
        name: "Flame",
        id: 53,
        weapon: 2,
        rarity: 0
    }, {
        name: "Aqua",
        id: 54,
        weapon: 2,
        rarity: 0
    }, {
        name: "Gravel",
        id: 55,
        weapon: 2,
        rarity: 0
    }, {
        name: "Saphire",
        id: 28,
        weapon: 8,
        rarity: 1
    }, {
        name: "Jade",
        id: 29,
        weapon: 8,
        rarity: 1
    }, {
        name: "Plexus",
        id: 30,
        weapon: 8,
        rarity: 1
    }, {
        name: "Lapis",
        id: 31,
        weapon: 8,
        rarity: 1
    }, {
        name: "Perplexum",
        id: 32,
        weapon: 8,
        rarity: 0
    }, {
        name: "Torped",
        id: 33,
        weapon: 8,
        rarity: 0
    }, {
        name: "Commo",
        id: 34,
        weapon: 8,
        rarity: 0
    }, {
        name: "MMA Liquid",
        id: 35,
        weapon: 8,
        rarity: 1
    }, {
        name: "Dropper",
        id: 36,
        weapon: 8,
        rarity: 0
    }, {
        name: "MMA Auburn",
        id: 37,
        weapon: 8,
        rarity: 1
    }, {
        name: "MMA Laurel",
        id: 38,
        weapon: 8,
        rarity: 1
    }, {
        name: "MMA Crimson",
        id: 39,
        weapon: 8,
        rarity: 1
    }, {
        name: "MMA Azure",
        id: 40,
        weapon: 8,
        rarity: 1
    }, {
        name: "MMA Laguna",
        id: 41,
        weapon: 8,
        rarity: 1
    }, {
        name: "MMA Cygneta",
        id: 42,
        weapon: 8,
        rarity: 1
    }, {
        name: "MMA Cygneto",
        id: 43,
        weapon: 8,
        rarity: 2
    }, {
        name: "M14 Chartreuse",
        id: 44,
        weapon: 8,
        rarity: 2
    }, {
        name: "MMA Tortobe",
        id: 45,
        weapon: 8,
        rarity: 2
    }, {
        name: "MMA Octo",
        id: 46,
        weapon: 8,
        rarity: 2
    }, {
        name: "MMA Versate",
        id: 47,
        weapon: 8,
        rarity: 2
    }, {
        name: "MMA Purpur",
        id: 48,
        weapon: 8,
        rarity: 2
    }, {
        name: "Nature",
        id: 49,
        weapon: 8,
        rarity: 0
    }, {
        name: "Flame",
        id: 50,
        weapon: 8,
        rarity: 0
    }, {
        name: "Aqua",
        id: 51,
        weapon: 8,
        rarity: 0
    }, {
        name: "Earth",
        id: 52,
        weapon: 8,
        rarity: 0
    }, {
        name: "Black Ice",
        creator: "Electrode_",
        id: 53,
        weapon: 8,
        rarity: 2
    }, {
        name: "Mach 3",
        creator: "Jytesh",
        id: 54,
        weapon: 8,
        rarity: 1
    }, {
        name: "Bloodripper",
        creator: "Jytesh",
        id: 55,
        weapon: 8,
        rarity: 1
    }, {
        name: "Theta",
        creator: "Floatingpoint",
        seas: 2,
        id: 48,
        weapon: 1,
        rarity: 3
    }, {
        name: "Raynb0w",
        creator: "???",
        pat: 1,
        tex: "weapons/pat/1",
        sameGlow: true,
        movT: 0.0015,
        weapon: 1,
        rarity: 5
    }, {
        name: "Diablo Wings",
        id: 10,
        type: 2,
        keyW: "Back",
        scl: 3.5 * 0.00015981366834171,
        sclMlt: 4.1 * 0.00015981366834171,
        xOff: -3,
        sitOff: -1.3,
        sitOffZ: -1.4,
        yOff: -2,
        rarity: 4
    }, {
        name: "AK Gold Rush",
        creator: "_irizu",
        id: 56,
        weapon: 2,
        rarity: 3,
        seas: 2
    }, {
        name: "AK Mortal",
        creator: "_irizu",
        glow: true,
        id: 57,
        weapon: 2,
        rarity: 4
    }, {
        name: "nV Dragon",
        creator: "nightly-build7",
        id: 51,
        weapon: 1,
        rarity: 3
    }, {
        name: "Cherry Blossom",
        creator: "jonschmiddy",
        id: 50,
        weapon: 1,
        rarity: 2
    }, {
        name: "Vapormoon",
        creator: "jonschmiddy",
        id: 58,
        weapon: 2,
        rarity: 2
    }, {
        name: "Tesselate",
        creator: "jonschmiddy",
        id: 59,
        weapon: 2,
        rarity: 2
    }, {
        name: "Polydrive",
        creator: "Ziggy",
        id: 49,
        weapon: 1,
        rarity: 2
    }, {
        name: "Safran",
        id: 29,
        weapon: 6,
        rarity: 2
    }, {
        name: "Purple Rain",
        id: 30,
        weapon: 6,
        rarity: 2
    }, {
        name: "Cobra",
        id: 31,
        weapon: 6,
        rarity: 2
    }, {
        name: "Spectrum",
        id: 32,
        weapon: 6,
        rarity: 2
    }, {
        name: "Anodized",
        creator: "Blitz-.",
        id: 33,
        weapon: 6,
        rarity: 3
    }, {
        name: "Blunderbuss",
        creator: "Blitz-.",
        id: 34,
        weapon: 6,
        rarity: 2
    }, {
        name: "Tv Tron A",
        type: 1,
        keyW: "Head",
        glow: true,
        scl: 1,
        sclMlt: 0.6,
        sitOff: 2.05,
        yOff: -3.2,
        id: 32,
        rarity: 4
    }, {
        name: "Tv Tron B",
        tex: 1,
        type: 1,
        keyW: "Head",
        glow: true,
        scl: 1,
        sclMlt: 0.6,
        sitOff: 2.05,
        yOff: -3.2,
        id: 32,
        rarity: 4
    }, {
        name: "Hollow Fade",
        keyW: "Knife",
        animInd: 1,
        glow: true,
        tex: 2,
        id: 0,
        type: 3,
        scl: 2,
        sclMlt: 0.9,
        yOff: -2.0,
        rarity: 5
    }, {
        name: "Tv Tron C",
        tex: 2,
        type: 1,
        keyW: "Head",
        glow: true,
        scl: 1,
        sclMlt: 0.6,
        sitOff: 2.05,
        yOff: -3.2,
        id: 32,
        rarity: 4
    }, {
        name: "Tv Tron D",
        tex: 3,
        type: 1,
        keyW: "Head",
        glow: true,
        scl: 1,
        sclMlt: 0.6,
        sitOff: 2.05,
        yOff: -3.2,
        id: 32,
        rarity: 4
    }, {
        name: "AWP Dazzle",
        glow: true,
        id: 53,
        weapon: 1,
        rarity: 4
    }, {
        name: "Octodance",
        glow: true,
        id: 54,
        weapon: 1,
        rarity: 4
    }, {
        name: "Ice Fade",
        glow: true,
        id: 55,
        weapon: 1,
        rarity: 4
    }, {
        name: "Frostlance",
        keyW: "Knife",
        animInd: 1,
        glow: true,
        tex: 3,
        id: 0,
        type: 3,
        scl: 2,
        sclMlt: 0.9,
        yOff: -2.0,
        rarity: 5
    }, {
        name: "Frostbite",
        keyW: "Axe",
        animInd: 1,
        glow: true,
        id: 1,
        type: 3,
        scl: 2,
        sclMlt: 0.9,
        yOff: -0.5,
        rarity: 6
    }, {
        name: "Arctic",
        id: 0,
        weapon: 15,
        rarity: 1
    }, {
        name: "Autumn Burst",
        id: 1,
        weapon: 15,
        rarity: 1
    }, {
        name: "Reticle Burst",
        id: 2,
        weapon: 15,
        rarity: 2
    }, {
        name: "Digital Burst",
        id: 3,
        weapon: 15,
        rarity: 0
    }, {
        name: "Bushwalker",
        id: 4,
        weapon: 15,
        rarity: 1
    }, {
        name: "Woodland",
        id: 5,
        weapon: 15,
        rarity: 0
    }, {
        name: "Burst Hazard",
        id: 6,
        weapon: 15,
        rarity: 1
    }, {
        name: "Kodac Famas",
        id: 7,
        weapon: 15,
        rarity: 1
    }, {
        name: "Seafarer G2",
        id: 8,
        weapon: 15,
        rarity: 0
    }, {
        name: "G2 Trail",
        id: 9,
        weapon: 15,
        rarity: 0
    }, {
        name: "Burst Fade",
        id: 10,
        weapon: 15,
        rarity: 0
    }, {
        name: "G2 Puma",
        id: 11,
        weapon: 15,
        rarity: 0
    }, {
        name: "Burst Carbo",
        id: 12,
        weapon: 15,
        rarity: 0
    }, {
        name: "G2 Barb",
        id: 13,
        weapon: 15,
        rarity: 2
    }, {
        name: "F1 Blush",
        id: 14,
        weapon: 15,
        rarity: 0
    }, {
        name: "Machinist",
        id: 15,
        weapon: 15,
        rarity: 1
    }, {
        name: "Triple Olympus",
        id: 16,
        weapon: 15,
        rarity: 2
    }, {
        name: "Honey Badger",
        id: 17,
        weapon: 15,
        rarity: 1
    }, {
        name: "G2 Moss",
        id: 18,
        weapon: 15,
        rarity: 1
    }, {
        name: "F1 Marshland",
        id: 19,
        weapon: 15,
        rarity: 1
    }, {
        name: "G2 Tigris",
        id: 20,
        weapon: 15,
        rarity: 2
    }, {
        name: "Zebra Burst",
        id: 21,
        weapon: 15,
        rarity: 2
    }, {
        name: "Skyfarer",
        id: 22,
        weapon: 15,
        rarity: 2
    }, {
        name: "Commando Fade",
        id: 23,
        weapon: 15,
        rarity: 2
    }, {
        name: "Mindseeker",
        id: 24,
        glow: true,
        weapon: 15,
        rarity: 4
    }, {
        name: "Intervention VI",
        mid: 0,
        glow: true,
        pulsT: 0.0015,
        scl: 0.9 * 0.0010536710552764,
        mScl: 0.0010536710552764,
        zOff: -0.25,
        seas: 2,
        yOff: 0.05,
        weapon: 1,
        rarity: 5
    }, {
        name: "Intervention XI",
        mid: 0,
        midT: "weapons/weapon_1_1",
        glow: true,
        seas: 2,
        pulsT: 0.0015,
        scl: 0.9 * 0.0010536710552764,
        mScl: 0.0010536710552764,
        zOff: -0.25,
        yOff: 0.05,
        weapon: 1,
        rarity: 5
    }, {
        name: "Soul Fang",
        keyW: "Knife",
        animInd: 1,
        glow: true,
        pulsT: 0.1,
        id: 2,
        type: 3,
        scl: 3,
        seas: 2,
        sclMlt: 0.98,
        yOff: -2.0,
        rarity: 5
    }, {
        name: "Dusk Fang",
        keyW: "Knife",
        animInd: 1,
        glow: true,
        tex: 4,
        id: 0,
        type: 3,
        scl: 2,
        sclMlt: 0.9,
        yOff: -2.0,
        rarity: 4
    },
    
    // SEASON 2 START HERE:
    {
        name: "Boneclaw",
        id: 56,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Blue Digital",
        id: 57,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Green Digital",
        id: 58,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Digital",
        id: 59,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Red Digital",
        id: 60,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Cascade",
        id: 61,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Pink Poly",
        id: 62,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Poly",
        id: 63,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 64,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 65,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "War Torn",
        id: 66,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Spook",
        id: 67,
        weapon: 1,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Pink Drip",
        id: 68,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Drip",
        id: 69,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Sepia",
        id: 70,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Olive",
        id: 71,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Spruce",
        id: 72,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Dijon",
        id: 73,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Red Splat",
        id: 74,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Splat",
        id: 75,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Splat",
        id: 76,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Green Splat",
        id: 77,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Yellow Poly",
        id: 78,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Red Poly",
        id: 79,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 80,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 81,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Sandstorm",
        id: 82,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Fabrica",
        id: 83,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Azazel",
        creator: "Lxckless",
        id: 84,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Picnic",
        id: 85,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Picasso",
        id: 86,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Cracked",
        id: 87,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Fire Stream",
        id: 88,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Ripped Sun",
        id: 89,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Bliss Flow",
        id: 90,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Kenzo",
        id: 91,
        weapon: 1,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Snowy",
        id: 92,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Galaxy",
        id: 93,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Ducky",
        id: 94,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Graphite",
        id: 95,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Porcelain",
        id: 96,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Neon Spill",
        id: 97,
        weapon: 1,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Danger",
        id: 98,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Paint Spill",
        id: 99,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Goop",
        id: 100,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Cerise",
        id: 101,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Orange Drip",
        id: 102,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Red Drip",
        id: 103,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Green Drip",
        id: 104,
        weapon: 1,
        rarity: 0,
        seas: 2
    },{
        name: "Flame Viper",
        id: 105,
        weapon: 1,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Red Phantom",
        id: 106,
        weapon: 1,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Arctic",
        creator: "Blitz",
        id: 107,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Magma Core",
        id: 108,
        weapon: 1,
        rarity: 4,
        animInd: 1,
        pulsT: 0.1,
        glow: true,
        seas: 2
    },{
        name: "Wired",
        creator: "Floatingpoint",
        id: 109,
        weapon: 1,
        rarity: 3,
        seas: 2
    },{
        name: "Kings",
        creator: "Floatingpoint",
        id: 110,
        weapon: 1,
        rarity: 3,
        seas: 2
    },{
        name: "Tessalate",
        id: 111,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Sunset",
        creator: "Graham",
        id: 112,
        weapon: 1,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Poly Blush",
        id: 113,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Cuircuitor",
        creator: "Gnnr",
        id: 114,
        weapon: 1,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Marbled .50",
        creator: "Blitz",
        id: 115,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Exoscarlet",
        creator: "CyAnIdE",
        id: 116,
        weapon: 1,
        rarity: 1,
        seas: 2
    },{
        name: "Sorable V",
        creator: "Zino",
        id: 117,
        weapon: 1,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Boneclaw",
        id: 60,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Blue Digital",
        id: 61,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Green Digital",
        id: 62,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Digital",
        id: 63,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Red Digital",
        id: 64,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Cascade",
        id: 65,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Pink Poly",
        id: 66,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Poly",
        id: 67,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 68,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 69,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "War Torn",
        id: 70,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Phantasma",
        id: 72,
        weapon: 2,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Pink Drip",
        id: 73,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Drip",
        id: 74,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Sepia",
        id: 75,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Olive",
        id: 76,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Spruce",
        id: 77,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Dijon",
        id: 78,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Red Splat",
        id: 79,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Splat",
        id: 80,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Splat",
        id: 81,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Green Splat",
        id: 82,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Yellow Poly",
        id: 83,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Red Poly",
        id: 84,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 85,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 86,
        weapon: 2,
        rarity: 1,
        seas: 2
    },{
        name: "Sandstorm",
        id: 87,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Fabrica",
        id: 88,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Zebrik",
        id: 89,
        weapon: 2,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Picnic",
        id: 90,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Picasso",
        id: 91,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Cracked",
        id: 92,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Fire Stream",
        id: 93,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Ripped Sun",
        id: 94,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Bliss Flow",
        id: 95,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Snowy",
        id: 96,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Ducky",
        id: 97,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Graphite",
        id: 98,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Porcelain",
        id: 99,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Danger",
        id: 100,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Paint Spill",
        id: 101,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Goop",
        id: 102,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Cerise",
        id: 103,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Orange Drip",
        id: 104,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Red Drip",
        id: 105,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Green Drip",
        id: 106,
        weapon: 2,
        rarity: 0,
        seas: 2
    },{
        name: "Void",
        id: 107,
        weapon: 2,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Lightning Storm",
        id: 108,
        weapon: 2,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Scribbler",
        id: 109,
        weapon: 2,
        rarity: 3,
        seas: 2
    },{
        name: "Scorched",
        creator: "0mar",
        id: 110,
        weapon: 2,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Heat-Tint",
        creator: "Leaaf",
        id: 111,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Welded",
        id: 112,
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Acid Howler",
        id: 113,
        weapon: 2,
        rarity: 5,
        glow: true,
        seas: 2
    },{
        name: "Boneclaw",
        id: 58,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Blue Digital",
        id: 59,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Green Digital",
        id: 60,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Digital",
        id: 61,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Red Digital",
        id: 62,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Cascade",
        id: 63,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Pink Poly",
        id: 64,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Poly",
        id: 65,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 66,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 67,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "War Torn",
        id: 68,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Pink Drip",
        id: 69,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Drip",
        id: 70,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Sepia",
        id: 71,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Olive",
        id: 72,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Spruce",
        id: 73,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Dijon",
        id: 74,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Red Splat",
        id: 75,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Splat",
        id: 76,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Splat",
        id: 77,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Green Splat",
        id: 78,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Yellow Poly",
        id: 79,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Red Poly",
        id: 80,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 81,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 82,
        weapon: 4,
        rarity: 1,
        seas: 2
    },{
        name: "Sandstorm",
        id: 83,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Fabrica",
        id: 84,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Picnic",
        id: 85,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Picasso",
        id: 86,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Cracked",
        id: 87,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Fire Stream",
        id: 88,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Ripped Sun",
        id: 89,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Bliss Flow",
        id: 90,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Snowy",
        id: 91,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Ducky",
        id: 92,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Graphite",
        id: 93,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Porcelain",
        id: 94,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Danger",
        id: 95,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Paint Spill",
        id: 96,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Goop",
        id: 97,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Cerise",
        id: 98,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Orange Drip",
        id: 99,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Red Drip",
        id: 100,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Green Drip",
        id: 101,
        weapon: 4,
        rarity: 0,
        seas: 2
    },{
        name: "Polymer",
        id: 102,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Andromeda",
        id: 103,
        weapon: 4,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Liberty",
        id: 104,
        weapon: 4,
        rarity: 3,
        seas: 2
    },{
        name: "Dragon Breath",
        id: 105,
        weapon: 4,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Parabellum",
        creator: "Floatingpoint",
        id: 106,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Poly Fade",
        id: 107,
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Picnic",
        id: 31,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Picasso",
        id: 32,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Cracked",
        id: 33,
        weapon: 5,
        rarity: 2,
        seas: 2
    },{
        name: "Fire Stream",
        id: 34,
        weapon: 5,
        rarity: 2,
        seas: 2
    },{
        name: "Ripped Sun",
        id: 35,
        weapon: 5,
        rarity: 2,
        seas: 2
    },{
        name: "Bliss Flow",
        id: 36,
        weapon: 5,
        rarity: 2,
        seas: 2
    },{
        name: "Snowy",
        id: 37,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Ducky",
        id: 38,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Graphite",
        id: 39,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Porcelain",
        id: 40,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Danger",
        id: 41,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Paint Spill",
        id: 42,
        weapon: 5,
        rarity: 2,
        seas: 2
    },{
        name: "Slime Spill",
        id: 43,
        weapon: 5,
        rarity: 2,
        seas: 2
    },{
        name: "Cerise",
        id: 44,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Orange Drip",
        id: 45,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Red Drip",
        id: 46,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Green Drip",
        id: 47,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Overheated",
        id: 48,
        weapon: 5,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Royal",
        id: 49,
        weapon: 5,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Nordic",
        id: 50,
        weapon: 5,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Boneclaw",
        id: 51,
        weapon: 5,
        rarity: 2,
        seas: 2
    },{
        name: "Blue Digital",
        id: 52,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Green Digital",
        id: 53,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Digital",
        id: 54,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Red Digital",
        id: 55,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Cascade",
        id: 56,
        weapon: 5,
        rarity: 2,
        seas: 2
    },{
        name: "Pink Poly",
        id: 57,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Poly",
        id: 58,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 59,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 60,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "War Torn",
        id: 61,
        weapon: 5,
        rarity: 2,
        seas: 2
    },{
        name: "Pink Drip",
        id: 62,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Drip",
        id: 63,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Sepia",
        id: 64,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Olive",
        id: 65,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Spruce",
        id: 66,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Dijon",
        id: 67,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Red Splat",
        id: 68,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Splat",
        id: 69,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Splat",
        id: 70,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Green Splat",
        id: 71,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Yellow Poly",
        id: 72,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Red Poly",
        id: 73,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 74,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 75,
        weapon: 5,
        rarity: 1,
        seas: 2
    },{
        name: "Sandstorm",
        id: 76,
        weapon: 5,
        rarity: 0,
        seas: 2
    },{
        name: "Fabrica",
        id: 77,
        weapon: 5,
        rarity: 2,
        seas: 2
    },{
        name: "Outlaw",
        id: 78,
        weapon: 5,
        rarity: 3,
        seas: 2
    },{
        name: "Green Poly",
        id: 26,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 27,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Sandstorm",
        id: 28,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Fabrica",
        id: 29,
        weapon: 7,
        rarity: 2,
        seas: 2
    },{
        name: "Zebrik",
        id: 30,
        weapon: 7,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Picnic",
        id: 31,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Picasso",
        id: 32,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Cracked",
        id: 33,
        weapon: 7,
        rarity: 2,
        seas: 2
    },{
        name: "Fire Stream",
        id: 34,
        weapon: 7,
        rarity: 2,
        seas: 2
    },{
        name: "Ripped Sun",
        id: 35,
        weapon: 7,
        rarity: 2,
        seas: 2
    },{
        name: "Bliss Flow",
        id: 36,
        weapon: 7,
        rarity: 2,
        seas: 2
    },{
        name: "Snowy",
        id: 37,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Ducky",
        id: 38,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Graphite",
        id: 39,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Porcelain",
        id: 40,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Danger",
        id: 41,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Paint Spill",
        id: 42,
        weapon: 7,
        rarity: 2,
        seas: 2
    },{
        name: "Slime Spill",
        id: 43,
        weapon: 7,
        rarity: 2,
        seas: 2
    },{
        name: "Cerise",
        id: 44,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Orange Drip",
        id: 45,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Red Drip",
        id: 46,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Green Drip",
        id: 47,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Neoran",
        id: 48,
        weapon: 7,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Fire Breath",
        id: 49,
        weapon: 7,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Boneclaw",
        id: 50,
        weapon: 7,
        rarity: 2,
        seas: 2
    },{
        name: "Blue Digital",
        id: 51,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Green Digital",
        id: 52,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Digital",
        id: 53,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Red Digital",
        id: 54,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Cascade",
        id: 55,
        weapon: 7,
        rarity: 2,
        seas: 2
    },{
        name: "Pink Poly",
        id: 56,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Poly",
        id: 57,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 58,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 59,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "War Torn",
        id: 60,
        weapon: 7,
        rarity: 2,
        seas: 2
    },{
        name: "Pink Drip",
        id: 61,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Drip",
        id: 62,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Sepia",
        id: 63,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Olive",
        id: 64,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Spruce",
        id: 65,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Dijon",
        id: 66,
        weapon: 7,
        rarity: 0,
        seas: 2
    },{
        name: "Red Splat",
        id: 67,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Splat",
        id: 68,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Splat",
        id: 69,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Green Splat",
        id: 70,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Yellow Poly",
        id: 71,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Bloodbath",
        id: 72,
        weapon: 7,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Red Poly",
        id: 73,
        weapon: 7,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 27,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Sandstorm",
        id: 28,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Fabrica",
        id: 29,
        weapon: 9,
        rarity: 2,
        seas: 2
    },{
        name: "Picnic",
        id: 30,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Picasso",
        id: 31,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Cracked",
        id: 32,
        weapon: 9,
        rarity: 2,
        seas: 2
    },{
        name: "Fire Stream",
        id: 33,
        weapon: 9,
        rarity: 2,
        seas: 2
    },{
        name: "Ripped Sun",
        id: 34,
        weapon: 9,
        rarity: 2,
        seas: 2
    },{
        name: "Bliss Flow",
        id: 35,
        weapon: 9,
        rarity: 2,
        seas: 2
    },{
        name: "Kenzo",
        id: 36,
        weapon: 9,
        rarity: 2,
        seas: 2
    },{
        name: "Snowy",
        id: 37,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Ducky",
        id: 38,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Graphite",
        id: 39,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Porcelain",
        id: 40,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Danger",
        id: 41,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Paint Spill",
        id: 42,
        weapon: 9,
        rarity: 2,
        seas: 2
    },{
        name: "Goop",
        id: 43,
        weapon: 9,
        rarity: 2,
        seas: 2
    },{
        name: "Cerise",
        id: 44,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Orange Drip",
        id: 45,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Red Drip",
        id: 46,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Green Drip",
        id: 47,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Boneclaw",
        id: 48,
        weapon: 9,
        rarity: 2,
        seas: 2
    },{
        name: "Blue Digital",
        id: 49,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Green Digital",
        id: 50,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Digital",
        id: 51,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Red Digital",
        id: 52,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Cascade",
        id: 53,
        weapon: 9,
        rarity: 2,
        seas: 2
    },{
        name: "Pink Poly",
        id: 54,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Poly",
        id: 55,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 56,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 57,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "War Torn",
        id: 58,
        weapon: 9,
        rarity: 2,
        seas: 2
    },{
        name: "Pink Drip",
        id: 59,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Drip",
        id: 60,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Sepia",
        id: 61,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Olive",
        id: 62,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Spruce",
        id: 63,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Dijon",
        id: 64,
        weapon: 9,
        rarity: 0,
        seas: 2
    },{
        name: "Red Splat",
        id: 65,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Splat",
        id: 66,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Splat",
        id: 67,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Green Splat",
        id: 68,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Yellow Poly",
        id: 69,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Red Poly",
        id: 70,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 71,
        weapon: 9,
        rarity: 1,
        seas: 2
    },{
        name: "Coffin",
        id: 72,
        weapon: 9,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Lightning Strike",
        id: 73,
        weapon: 9,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Boneclaw",
        id: 25,
        weapon: 15,
        rarity: 3,
        seas: 2
    },{
        name: "Blue Digital",
        id: 26,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Green Digital",
        id: 27,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Digital",
        id: 28,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Red Digital",
        id: 29,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Cascade",
        id: 30,
        weapon: 15,
        rarity: 2,
        seas: 2
    },{
        name: "Pink Poly",
        id: 31,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Poly",
        id: 32,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 33,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 34,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "War Torn",
        id: 35,
        weapon: 15,
        rarity: 2,
        seas: 2
    },{
        name: "Spook",
        id: 36,
        weapon: 15,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Pink Drip",
        id: 37,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Drip",
        id: 38,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Sepia",
        id: 39,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Olive",
        id: 40,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Spruce",
        id: 41,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Dijon",
        id: 42,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Red Splat",
        id: 43,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Purple Splat",
        id: 44,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Orange Splat",
        id: 45,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Green Splat",
        id: 46,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Yellow Poly",
        id: 47,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Red Poly",
        id: 48,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Green Poly",
        id: 49,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Blue Poly",
        id: 50,
        weapon: 15,
        rarity: 1,
        seas: 2
    },{
        name: "Sandstorm",
        id: 51,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Fabrica",
        id: 52,
        weapon: 15,
        rarity: 2,
        seas: 2
    },{
        name: "Zebrik",
        id: 53,
        weapon: 15,
        rarity: 2,
        seas: 2
    },{
        name: "Picnic",
        id: 54,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Picasso",
        id: 55,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Cracked",
        id: 56,
        weapon: 15,
        rarity: 2,
        seas: 2
    },{
        name: "Fire Stream",
        id: 57,
        weapon: 15,
        rarity: 2,
        seas: 2
    },{
        name: "Ripped Sun",
        id: 58,
        weapon: 15,
        rarity: 2,
        seas: 2
    },{
        name: "Bliss Flow",
        id: 59,
        weapon: 15,
        rarity: 2,
        seas: 2
    },{
        name: "Kenzo",
        id: 60,
        weapon: 15,
        rarity: 3,
        seas: 2
    },{
        name: "Snowy",
        id: 61,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Ducky",
        id: 62,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Graphite",
        id: 63,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Porcelain",
        id: 64,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Danger",
        id: 65,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Paint Spill",
        id: 66,
        weapon: 15,
        rarity: 2,
        seas: 2
    },{
        name: "Slime Spill",
        id: 67,
        weapon: 15,
        rarity: 2,
        seas: 2
    },{
        name: "Cerise",
        id: 68,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Orange Drip",
        id: 69,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Red Drip",
        id: 70,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Green Drip",
        id: 71,
        weapon: 15,
        rarity: 0,
        seas: 2
    },{
        name: "Galaxy Morse",
        id: 72,
        weapon: 15,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Fire Storm",
        id: 73,
        weapon: 15,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Marked",
        id: 74,
        weapon: 15,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Frosted",
        id: 75,
        weapon: 15,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Gold Tipped",
        creator: "jonschmiddy",
        id: 76,
        weapon: 15,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Damascus",
        keyW: "Knife",
        tex: 6,
        id: 0,
        type: 3,
        scl: 2.3,
        seas: 2,
        sclMlt: 0.9,
        yOff: -2.0,
        rarity: 3
    },{
        name: "Prism",
        creator: "jonschmiddy",
        keyW: "Knife",
        tex: 7,
        id: 0,
        type: 3,
        scl: 2.3,
        seas: 2,
        sclMlt: 0.9,
        yOff: -2.0,
        rarity: 3
    },{
        name: "Bloodless",
        keyW: "Knife",
        id: 2,
        tex: 1,
        glow: true,
        type: 3,
        scl: 3,
        seas: 2,
        sclMlt: 0.9,
        yOff: -2.0,
        rarity: 4
    },{
        name: "Steelfang",
        keyW: "Knife",
        id: 3,
        type: 3,
        scl: 2.6,
        seas: 2,
        sclMlt: 1.0,
        yOff: -1.0,
        xOff: -1.5,
        rarity: 4,
        sxRot: 0.3,
        sxOff: 0.1
    },{
        name: "Flamefang",
        keyW: "Knife",
        tex: 1,
        glow: true,
        id: 3,
        type: 3,
        scl: 2.6,
        seas: 2,
        sclMlt: 0.9,
        yOff: -1.0,
        xOff: -1.5,
        rarity: 5,
        sxRot: 0.3,
        sxOff: 0.1
    },{
        name: "Plasma Dust",
        keyW: "Knife",
        tex: 2,
        glow: true,
        id: 3,
        type: 3,
        scl: 2.6,
        seas: 2,
        sclMlt: 0.9,
        yOff: -1.0,
        xOff: -1.5,
        rarity: 5,
        sxRot: 0.3,
        sxOff: 0.1
    },{
        name: "Volt Fang",
        keyW: "Knife",
        tex: 3,
        glow: true,
        id: 3,
        type: 3,
        scl: 2.6,
        seas: 2,
        sclMlt: 0.9,
        yOff: -1.0,
        xOff: -1.5,
        rarity: 5,
        sxRot: 0.3,
        sxOff: 0.1
    },{
        name: "Black Cowboy Hat",
        type: 1,
        keyW: "Head",
        id: 39,
        rarity: 0,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.6
    },{
        name: "Brown Cowboy Hat",
        type: 1,
        keyW: "Head",
        id: 39,
        tex: 1,
        rarity: 0,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.6,
        yOff: -1.2,
        scl: 1.2
    },{
        name: "Outback Hat",
        type: 1,
        keyW: "Head",
        id: 40,
        rarity: 1,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.6,
        yOff: -1.2,
        scl: 1.2
    },{
        name: "Dundee Hat",
        type: 1,
        keyW: "Head",
        id: 40,
        tex: 1,
        rarity: 1,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.6,
        yOff: -1.2,
        scl: 1.2
    },{
        name: "Red Hat",
        type: 1,
        keyW: "Head",
        id: 41,
        rarity: 1,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.6,
        yOff: -1.2,
        scl: 1.2
    },{
        name: "Blue Hat",
        type: 1,
        keyW: "Head",
        id: 41,
        tex: 1,
        rarity: 0,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.6,
        yOff: -1.2,
        scl: 1.2
    },{
        name: "Urban Soldier",
        type: 1,
        keyW: "Head",
        id: 42,
        tex: 0,
        rarity: 1,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.78,
        yOff: -1.2,
        scl: 1.2
    },{
        name: "Desert Soldier",
        type: 1,
        keyW: "Head",
        id: 42,
        tex: 1,
        rarity: 1,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.78,
        yOff: -1.2,
        scl: 1.2
    },{
        name: "Arctic Soldier",
        type: 1,
        keyW: "Head",
        id: 42,
        tex: 2,
        rarity: 1,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.78,
        yOff: -1.2,
        scl: 1.2
    },{
        name: "Ace",
        type: 1,
        keyW: "Head",
        id: 43,
        rarity: 3,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.7,
        yOff: -1.2,
        scl: 1.2
    },{
        name: "Pinata",
        type: 1,
        keyW: "Head",
        id: 44,
        rarity: 1,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.6,
        yOff: -1.2,
        scl: 1.2
    },{
        name: "Sombrerro",
        type: 1,
        keyW: "Head",
        id: 44,
        tex: 1,
        rarity: 1,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 0.6,
        yOff: -1.2,
        scl: 1.2
    },{
        name: "Swagger",
        type: 1,
        keyW: "Head",
        id: 45,
        rarity: 3,
        seas: 2,
        sclMlt: 0.56,
        sitOff: 1.8,
        yOff: -2.0,
        scl: 1.2
    },{
        name: "Acid Bane",
        id: 11,
        rarity: 3,
        glow: true,
        type: 2,
        keyW: "Back",
        seas: 2,
        scl: 5.0,
        sclMlt: 3.4,
        sitOff: -1.3,
        sitOffZ: -0.8,
        yOff: -2.0,
        xOff: -4.0
    },{
        name: "Plasma Bones",
        id: 11,
        tex: 1,
        rarity: 3,
        glow: true,
        type: 2,
        keyW: "Back",
        seas: 2,
        scl: 5.0,
        sclMlt: 3.4,
        sitOff: -1.3,
        sitOffZ: -0.8,
        yOff: -2.0,
        xOff: -4.0
    },{
        name: "Jet Pack",
        id: 13,
        rarity: 2,
        glow: true,
        type: 2,
        keyW: "Back",
        seas: 2,
        scl: 6.0,
        sclMlt: 3.0,
        sitOff: -0.5,
        sitOffZ: -0.93,
        yOff: -1.3,
        xRot: Math.PI
    },{
        name: "Red Backpack",
        id: 14,
        rarity: 1,
        type: 2,
        keyW: "Back",
        seas: 2,
        scl: 4.0,
        sclMlt: 2.3,
        sitOff: -0.8,
        sitOffZ: -0.8,
        yOff: -1.5,
        xRot: Math.PI
    },{
        name: "Blue Backpack",
        id: 14,
        tex: 1,
        rarity: 1,
        type: 2,
        keyW: "Back",
        seas: 2,
        scl: 3.5,
        sclMlt: 2.3,
        sitOff: -0.8,
        sitOffZ: -0.8,
        yOff: -1.5,
        xRot: Math.PI
    },{
        name: "Police Vest",
        id: 15,
        rarity: 1,
        type: 2,
        keyW: "Back",
        seas: 2,
        scl: 4.5,
        sclMlt: 2.5,
        sitOff: 0.4,
        sitOffZ: 0.0,
        yOff: -2.0,
        xRot: Math.PI
    },{
        name: "Angelic Wings",
        id: 16,
        rarity: 3,
        glow: true,
        type: 2,
        keyW: "Back",
        seas: 2,
        scl: 3.0,
        sclMlt: 3.0,
        sitOff: -0.5,
        sitOffZ: -2.0,
        xOff: -2.0,
        yOff: -3.0
    },{
        name: "Gradient Pennon",
        id: 16,
        tex: 1,
        rarity: 4,
        glow: true,
        type: 2,
        keyW: "Back",
        seas: 2,
        scl: 3.0,
        sclMlt: 3.0,
        sitOff: -0.5,
        sitOffZ: -2.0,
        xOff: -2.0,
        yOff: -3.0
    },{
        name: "Torn Aileron",
        id: 17,
        rarity: 4,
        glow: true,
        type: 2,
        keyW: "Back",
        seas: 2,
        scl: 3.0,
        sclMlt: 3.0,
        sitOff: 0.0,
        sitOffZ: -2.0,
        xOff: -2.0,
        yOff: -3.0
    },{
        name: "Cursed",
        id: 17,
        tex: 1,
        rarity: 3,
        glow: true,
        type: 2,
        keyW: "Back",
        seas: 2,
        scl: 3.0,
        sclMlt: 3.0,
        sitOff: 0.0,
        sitOffZ: -2.0,
        xOff: -2.0,
        yOff: -3.0
    },{
        name: "Butterfly",
        id: 19,
        rarity: 2,
        type: 2,
        keyW: "Back",
        seas: 2,
        scl: 3.5,
        sclMlt: 3.3,
        sitOff: -0.9,
        sitOffZ: -2.4,
        yOff: -2
    },{
        name: "Mr. Rabbiton",
        id: 46,
        rarity: 2,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.89,
        sitOff: 0.9,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "Madman",
        id: 47,
        rarity: 2,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.95,
        sitOff: 0.8,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "Grizz Lee",
        id: 48,
        rarity: 2,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.95,
        sitOff: 0.8,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "Claws",
        id: 48,
        tex: 1,
        rarity: 3,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.89,
        sitOff: 0.9,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "Simba",
        id: 49,
        rarity: 2,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.89,
        sitOff: 0.9,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "Captain Walrus",
        id: 50,
        rarity: 2,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.89,
        sitOff: 0.9,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "Monke",
        id: 51,
        rarity: 2,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.89,
        sitOff: 0.9,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "Lord Panda",
        id: 52,
        rarity: 3,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.89,
        sitOff: 0.9,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "Ray Bam",
        id: 53,
        rarity: 0,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.51,
        sitOff: 1.1,
        scl: 1.4,
        xOff: 1.5,
        yOff: -1.2
    },{
        name: "Gold Sunnies",
        id: 53,
        tex: 1,
        rarity: 1,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.51,
        sitOff: 1.1,
        scl: 1.4,
        xOff: 1.5,
        yOff: -1.2
    },{
        name: "Queens Guard",
        id: 54,
        rarity: 0,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.6,
        sitOff: 0.9,
        scl: 0.9,
        yOff: -2.1
    },{
        name: "Snowman",
        id: 55,
        rarity: 2,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.89,
        sitOff: 0.8,
        xOff: 1.5,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "Misty",
        id: 56,
        rarity: 2,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.89,
        sitOff: 0.9,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "Unicorn",
        id: 57,
        rarity: 3,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.89,
        sitOff: 0.9,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "TV Tron LCD",
        id: 32,
        tex: 4,
        rarity: 4,
        type: 1,
        keyW: "Head",
        seas: 2,
        scl: 1,
        sclMlt: 0.6,
        sitOff: 2.05,
        yOff: -3.2,
        frames: 2,
        frameT: 400
    },{
        name: "Acidic Bane",
        id: 36,
        rarity: 3,
        glow: true,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.56,
        sitOff: 1.3,
        xOff: 1.2,
        scl: 1.1,
        yOff: -1.2
    },{
        name: "Tentacus",
        id: 34,
        tex: 1,
        rarity: 3,
        glow: true,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.56,
        sitOff: 1.3,
        scl: 1.1,
        yOff: -1.2
    },{
        name: "Soldier 159",
        id: 35,
        tex: 1,
        rarity: 2,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.56,
        sitOff: 1.3,
        scl: 1.1,
        yOff: -1.2
    },{
        name: "Soldier 160",
        id: 35,
        tex: 2,
        rarity: 2,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.56,
        sitOff: 1.3,
        scl: 1.1,
        yOff: -1.2
    },{
        name: "Templar",
        id: 37,
        rarity: 3,
        type: 1,
        glow: true,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.56,
        sitOff: 1.3,
        scl: 1.1,
        yOff: -1.2
    }, {
        name: "Phase Blades",
        id: 2,
        tex: 1,
        type: 2,
        seas: 2,
        keyW: "Back",
        glow: true,
        scl: 4.5 * 0.00010691567839196,
        sclMlt: 3.8 * 0.00010691567839196,
        sitOff: -1.3,
        sitOffZ: -0.95,
        yOff: -1,
        xOff: -0.5,
        rarity: 3
    },{
        name: "Pot'O'Gold",
        id: 20,
        rarity: 2,
        type: 2,
        keyW: "Back",
        seas: 2,
        sclMlt: 2.5,
        sitOff: -0.8,
        sitOffZ: -2.0,
        yOff: -2,
        xOff: 0.5,
        scl: 4.0,
        xRot: Math.PI
    },{
        name: "Unicorn Backpack",
        id: 21,
        rarity: 3,
        type: 2,
        keyW: "Back",
        seas: 2,
        sclMlt: 2.3,
        sitOff: -0.8,
        sitOffZ: -0.8,
        yOff: -2,
        xOff: -1.5,
        scl: 3.5,
        xRot: Math.PI
    },{
        name: "Flame Talon",
        weapon: 5,
        glow: true,
        id: 79,
        seas: 2,
        rarity: 4
    },{
        name: "Raynb0w",
        creator: "???",
        pat: 1,
        seas: 2,
        tex: "weapons/pat/1",
        sameGlow: true,
        movT: 0.0015,
        weapon: 7,
        rarity: 5
    },{
        name: "Raynb0w",
        creator: "???",
        pat: 1,
        seas: 2,
        tex: "weapons/pat/1",
        sameGlow: true,
        movT: 0.0015,
        weapon: 5,
        rarity: 5
    },{
        name: "Terminal",
        id: 39,
        type: 4,
        rarity: 0,
        seas: 2,
        opacity: 0.6,
        frames: 2,
        frameT: 250,
        keyW: "Sprays"
    },{
        name: "Clickbait",
        id: 40,
        type: 4,
        rarity: 2,
        seas: 2,
        opacity: 0.75,
        frames: 2,
        frameT: 550,
        keyW: "Sprays"
    },{
        name: "Kunai",
        keyW: "Knife",
        glow: true,
        pulsT: 0.0015,
        id: 4,
        type: 3,
        seas: 2,
        rarity: 4,
        scl: 2,
        sclMlt: 0.75,
        yOff: -1.0,
        sxOff: -0.15,
        szOff: 0.3,
    },{
        name: "Wrench",
        keyW: "Knife",
        id: 5,
        type: 3,
        seas: 2,
        rarity: 4,
        scl: 2,
        sclMlt: 0.8,
        yOff: -2.5
    },{
        name: "Clown",
        id: 58,
        rarity: 3,
        type: 1,
        keyW: "Head",
        seas: 2,
        sclMlt: 0.89,
        sitOff: 0.9,
        scl: 1.6,
        yOff: -1.2
    },{
        name: "Wink",
        id: 41,
        type: 4,
        rarity: 1,
        seas: 2,
        opacity: 0.75,
        frames: 2,
        frameT: 550,
        keyW: "Sprays"
    },{
        name: "No U",
        id: 42,
        type: 4,
        rarity: 1,
        seas: 2,
        opacity: 0.75,
        frames: 2,
        frameT: 550,
        keyW: "Sprays"
    },{
        name: "Coolman",
        id: 43,
        type: 4,
        rarity: 1,
        seas: 2,
        opacity: 0.75,
        frames: 2,
        frameT: 550,
        keyW: "Sprays"
    },{
        name: "Paranoid",
        id: 44,
        type: 4,
        rarity: 0,
        seas: 2,
        opacity: 0.75,
        frames: 2,
        frameT: 1200,
        keyW: "Sprays"
    },{
        name: "Dab",
        id: 45,
        type: 4,
        rarity: 1,
        seas: 2,
        opacity: 0.75,
        frames: 2,
        frameT: 400,
        keyW: "Sprays"
    },{
        name: "Pepereel",
        id: 46,
        type: 4,
        rarity: 1,
        seas: 2,
        opacity: 0.8,
        movT: -0.0025,
        keyW: "Sprays"
    },{
        name: "Wanted",
        id: 47,
        type: 4,
        rarity: 0,
        seas: 2,
        opacity: 0.75,
        keyW: "Sprays"
    },{
        name: "Soon&trade;",
        id: 48,
        type: 4,
        rarity: 0,
        seas: 2,
        opacity: 0.7,
        frames: 2,
        frameT: 550,
        keyW: "Sprays"
    },{
        name: "Art",
        id: 49,
        type: 4,
        rarity: 2,
        seas: 2,
        opacity: 0.8,
        frames: 2,
        frameT: 350,
        keyW: "Sprays"
    },{
        name: "Nautilus",
        id: 50,
        type: 4,
        rarity: 3,
        seas: 2,
        opacity: 0.85,
        frames: 4,
        frameT: 200,
        keyW: "Sprays"
    },{
        name: "Baller",
        creator: "???",
        pat: 6,
        tex: "weapons/pat/6",
        sameGlow: true,
        movT: 0.0002,
        weapon: 1,
        rarity: 5,
        seas: 2
    },{
        name: "Baller",
        creator: "???",
        pat: 6,
        tex: "weapons/pat/6",
        sameGlow: true,
        movT: 0.0002,
        weapon: 2,
        rarity: 5,
        seas: 2
    },{
        name: "Baller",
        creator: "???",
        pat: 6,
        tex: "weapons/pat/6",
        sameGlow: true,
        movT: 0.0002,
        weapon: 4,
        rarity: 5,
        seas: 2
    },{
        name: "Baller",
        creator: "???",
        pat: 6,
        tex: "weapons/pat/6",
        sameGlow: true,
        movT: 0.0002,
        weapon: 5,
        rarity: 5,
        seas: 2
    },{
        name: "TV Tron HD",
        id: 32,
        tex: 5,
        rarity: 4,
        type: 1,
        keyW: "Head",
        seas: 2,
        scl: 1,
        sclMlt: 0.6,
        sitOff: 2.05,
        yOff: -3.2,
        frames: 2,
        frameT: 400
    },{
        name: "Nova Pump",
        mid: 0,
        blocked: true,
        noSale: true,
        midT: "weapons/weapon_6_38",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 0
    },{
        name: "Roadkill",
        mid: 0,
        midT: "weapons/weapon_6_1",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 3
    },{
        name: "Molten Core",
        mid: 0,
        midT: "weapons/weapon_6_2",
        pulsT: 0.0015,
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        glow: true,
        rarity: 4
    },{
        name: "Mosaik",
        mid: 0,
        midT: "weapons/weapon_6_3",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 2
    },{
        name: "Kiason",
        mid: 0,
        midT: "weapons/weapon_6_4",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 2
    },{
        name: "Monatomic",
        mid: 0,
        midT: "weapons/weapon_6_5",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        glow: true,
        rarity: 3
    },{
        name: "Crystalline",
        mid: 0,
        midT: "weapons/weapon_6_6",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        glow: true,
        rarity: 4
    },{
        name: "Blue Digital",
        mid: 0,
        midT: "weapons/weapon_6_7",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 0
    },{
        name: "Green Digital",
        mid: 0,
        midT: "weapons/weapon_6_8",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 0
    },{
        name: "Purple Digital",
        mid: 0,
        midT: "weapons/weapon_6_9",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 0
    },{
        name: "Red Digital",
        mid: 0,
        midT: "weapons/weapon_6_10",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 0
    },{
        name: "Pink Poly",
        mid: 0,
        midT: "weapons/weapon_6_11",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Orange Poly",
        mid: 0,
        midT: "weapons/weapon_6_12",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Green Poly",
        mid: 0,
        midT: "weapons/weapon_6_13",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Blue Poly",
        mid: 0,
        midT: "weapons/weapon_6_14",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Pink Drip",
        mid: 0,
        midT: "weapons/weapon_6_15",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 2
    },{
        name: "Blue Drip",
        mid: 0,
        midT: "weapons/weapon_6_16",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 2
    },{
        name: "Sepia",
        mid: 0,
        midT: "weapons/weapon_6_17",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Olive",
        mid: 0,
        midT: "weapons/weapon_6_18",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 2
    },{
        name: "Spruce",
        mid: 0,
        midT: "weapons/weapon_6_19",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 2
    },{
        name: "Dijon",
        mid: 0,
        midT: "weapons/weapon_6_20",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 2
    },{
        name: "Red Splat",
        mid: 0,
        midT: "weapons/weapon_6_21",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Purple Splat",
        mid: 0,
        midT: "weapons/weapon_6_22",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Orange Splat",
        mid: 0,
        midT: "weapons/weapon_6_23",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Green Splat",
        mid: 0,
        midT: "weapons/weapon_6_24",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Yellow Comb",
        mid: 0,
        midT: "weapons/weapon_6_25",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Red Comb",
        mid: 0,
        midT: "weapons/weapon_6_26",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Green Comb",
        mid: 0,
        midT: "weapons/weapon_6_27",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Blue Comb",
        mid: 0,
        midT: "weapons/weapon_6_28",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Sandstorm",
        mid: 0,
        midT: "weapons/weapon_6_29",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Picnic",
        mid: 0,
        midT: "weapons/weapon_6_30",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Picasso",
        mid: 0,
        midT: "weapons/weapon_6_31",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 2
    },{
        name: "Snowy",
        mid: 0,
        midT: "weapons/weapon_6_32",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 2
    },{
        name: "Hazard",
        mid: 0,
        midT: "weapons/weapon_6_33",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 2
    },{
        name: "Cerise",
        mid: 0,
        midT: "weapons/weapon_6_34",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 2
    },{
        name: "Orange Drip",
        mid: 0,
        midT: "weapons/weapon_6_35",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Red Drip",
        mid: 0,
        midT: "weapons/weapon_6_36",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    },{
        name: "Green Drip",
        mid: 0,
        midT: "weapons/weapon_6_37",
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        seas: 2,
        weapon: 6,
        rarity: 1
    }, {
        name: "Wasteland",
        id: 118,
        creator: "FlowerKid",
        weapon: 1,
        rarity: 3,
        seas: 2
    },{
        name: "Turbo",
        id: 119,
        creator: "Floatingpoint",
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Urban Splat",
        id: 114,
        creator: "FlowerKid",
        glow: true,
        weapon: 2,
        rarity: 4,
        seas: 2
    },{
        name: "Cimota",
        id: 108,
        creator: "Cimota",
        glow: true,
        weapon: 4,
        rarity: 3,
        seas: 2
    },{
        name: "Fractal",
        id: 109,
        creator: "Cimota",
        weapon: 4,
        rarity: 3,
        seas: 2
    },{
        name: "Chrome",
        id: 80,
        creator: "Flowerkid",
        glow: true,
        weapon: 5,
        rarity: 3,
        seas: 2
    },{
        name: "World of Light",
        id: 77,
        creator: "Electrode",
        glow: true,
        weapon: 15,
        rarity: 3,
        seas: 2
    }, {
        name: "Vantablack",
        id: 0,
        shirtCol: 0x030303,
        sleeveCol: 0x030303,
        pantsCol: 0x030303,
        shoeCol: 0x030303,
        seas: 2,
        type: 5,
        rarity: 5
    }, {
        name: "Lederhose",
        id: 120,
        weapon: 1,
        rarity: 3,
        seas: 2
    }, {
        name: "Emboss",
        id: 121,
        weapon: 1,
        rarity: 2,
        seas: 2
    }, {
        name: "Spineless",
        id: 122,
        weapon: 1,
        rarity: 2,
        seas: 2
    }, {
        name: "Gold Plated",
        id: 123,
        weapon: 1,
        rarity: 2,
        seas: 2
    }, {
        name: "Daimyo Spirit",
        creator: "FlowerKid",
        id: 124,
        weapon: 1,
        glow: true,
        rarity: 4,
        seas: 2
    }, {
        name: "Heat Stroke",
        id: 125,
        weapon: 1,
        glow: true,
        rarity: 3,
        seas: 2
    }, {
        name: "Samurai Spirit",
        creator: "FlowerKid",
        id: 78,
        weapon: 15,
        glow: true,
        rarity: 4,
        seas: 2
    },{
        name: "Suede Blade",
        keyW: "Knife",
        id: 3,
        tex: 4,
        type: 3,
        scl: 2.6,
        seas: 2,
        sclMlt: 1.0,
        yOff: -1.0,
        xOff: -1.5,
        rarity: 3,
        sxRot: 0.3,
        sxOff: 0.1
    }, {
        name: "Aziru",
        creator: "Halloluke0201",
        keyW: "Knife",
        glow: true,
        id: 3,
        tex: 5,
        type: 3,
        scl: 2.6,
        seas: 2,
        sclMlt: 1.0,
        yOff: -1.0,
        xOff: -1.5,
        rarity: 4,
        sxRot: 0.3,
        sxOff: 0.1
    }, {
        name: "Clockwork",
        id: 126,
        seas: 2,
        weapon: 1,
        rarity: 3
    }, {
        name: "Jagdfaust IV",
        mid: 2,
        glow: true,
        limited: true,
        scl: 0.9,
        mScl: 1.0,
        spnScl: 1.35,
        zOff: -0.25,
        seas: 2,
        yOff: 0.05,
        weapon: 1,
        rarity: 6
    },{
        name: "Coroller",
        keyW: "Toilet",
        id: 7,
        type: 3,
        seas: 2,
        rarity: 6,
        scl: 2,
        sclMlt: 0.76,
        yOff: -2.5
    },{
        name: "Facemask",
        keyW: "Mask",
        limited: true,
        id: 60,
        rarity: 2,
        type: 1,
        seas: 2,
        sclMlt: 0.54,
        sitOff: 0.9,
        scl: 1.6
    },{
        name: "Spectralon",
        id: 1,
        shirtCol: 0xffffff,
        sleeveCol: 0xffffff,
        pantsCol: 0xffffff,
        shoeCol: 0xffffff,
        seas: 2,
        type: 5,
        rarity: 5
    },{
        name: "24/7",
        id: 127,
        creator: "Drag",
        weapon: 1,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Shattered",
        id: 128,
        creator: "Edibleporg",
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Lunatic",
        id: 115,
        creator: "Nxbulah",
        weapon: 2,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Auzora",
        id: 116,
        creator: "Cyanide",
        weapon: 2,
        rarity: 2,
        seas: 2
    },{
        name: "Botanical",
        id: 79,
        creator: "Nxbulah",
        weapon: 15,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Krunkette 1",
        id: 51,
        type: 4,
        rarity: 5,
        seas: 2,
        opacity: 0.7,
        keyW: "Sprays"
    },{
        name: "Krunkette 2",
        id: 52,
        type: 4,
        rarity: 4,
        seas: 2,
        opacity: 0.7,
        keyW: "Sprays"
    },{
        name: "Krunkette 3",
        id: 53,
        type: 4,
        rarity: 3,
        seas: 2,
        opacity: 0.7,
        keyW: "Sprays"
    },{
        name: "Lunar",
        id: 117,
        creator: "Nxbulah",
        weapon: 2,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "S&Y",
        id: 81,
        creator: "Cimota",
        weapon: 5,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Quarantine",
        creator: "Floatingpoint",
        midT: "weapons/weapon_6_39",
        mid: 0,
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        weapon: 6,
        rarity: 2,
        seas: 2
    },{
        name: "Scarlet",
        id: 118,
        creator: "FlowerKid",
        weapon: 2,
        rarity: 5,
        glow: true,
        seas: 2
    },{
        name: "Lunar Nitro",
        id: 129,
        creator: "Kitter",
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Sunset Raven",
        creator: "FlowerKid",
        midT: "weapons/weapon_6_40",
        mid: 0,
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        weapon: 6,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Otzarreta",
        id: 110,
        creator: "FlowerKid",
        weapon: 4,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Wychwood",
        id: 111,
        creator: "FlowerKid",
        weapon: 4,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Trip",
        id: 112,
        creator: "Nxbulah",
        weapon: 4,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Retribution",
        id: 130,
        creator: "Jhonxay_Playz",
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Spiritful",
        id: 80,
        creator: "Zinoob",
        weapon: 15,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Toxix",
        creator: "Kltter",
        midT: "weapons/weapon_6_41",
        mid: 0,
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        weapon: 6,
        rarity: 3,
        glow: true,
        seas: 2
    },{
        name: "Spec Ops",
        id: 131,
        creator: "floatingpoint",
        weapon: 1,
        rarity: 3,
        seas: 2
    },{
        name: "Retro-cade",
        id: 113,
        creator: "Kltter",
        weapon: 4,
        rarity: 2,
        seas: 2
    },{
        name: "Incognito",
        midT: "weapons/weapon_6_42",
        creator: "cimota",
        mid: 0,
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        weapon: 6,
        rarity: 3,
        seas: 2
    },{
        name: "Crator",
        id: 132,
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Scalar",
        creator: "floatingpoint",
        midT: "weapons/weapon_6_43",
        mid: 0,
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        weapon: 6,
        rarity: 3,
        seas: 2
    },{
        name: "HotRod",
        creator: "Kltter",
        midT: "weapons/weapon_6_44",
        glow: true,
        mid: 0,
        scl: 0.9,
        mScl: 1.0,
        zOff: 0.28,
        yOff: -0.5,
        weapon: 6,
        rarity: 2,
        seas: 2,
        seas: 2
    },{
        name: "Insanity",
        id: 119,
        weapon: 2,
        rarity: 4,
        glow: true,
        seas: 2
    },{
        name: "Violet",
        id: 133,
        creator: "Jhonxay_Playz",
        weapon: 1,
        rarity: 2,
        seas: 2
    },{
        name: "Savaged",
        id: 134,
        creator: "Vx Bomb",
        weapon: 1,
        rarity: 2,
        seas: 2
    }];
    
    
    /***/ }),
    
    /***/ "./src/data/streaks.js":
    /*!*****************************!*\
      !*** ./src/data/streaks.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
        // KILL STREAKS:
        module.exports = [{
            name: "Nuke",
            kills: 25,
            activate: function(game, player) {
                if (!game.nukeTimer) {
                    game.incStat("n", player);
                    game.startNuke(player);
                    player.nukes++;
                    return true;
                } return false;
            }
        }];
    
    
    /***/ }),
    
    /***/ "./src/data/triggers.js":
    /*!******************************!*\
      !*** ./src/data/triggers.js ***!
      \******************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
    // TRIGGERS:
    module.exports.events = [
        "onShoot",
        "onMelee",
        "onDamage",
        "onEnter",
        "onDestroy",
        "onRespawn"
    ];
    
    // TYPES:
    var tmpObj, tmpObj2;
    module.exports.actions = [{
        name: "Give Player Score",
        execute: function(game, io, player, object, chain) {
            game.players.score(player, object.triggerConstant||1);
        }
    }, {
        name: "Kill Player",
        execute: function(game, io, player, object, chain) {
            if (!player.godMode) game.players.kill(player);
        }
    }, {
        name: "Respawn Player",
        execute: function(game, io, player, object, chain) {
            var tmpSpawn = game.getSpawnPoint(player.team, player);
            player.x = tmpSpawn.x;
            player.y = tmpSpawn.y;
            player.z = tmpSpawn.z;
        }
    }, {
        name: "Change Player Health",
        execute: function(game, io, player, object, chain) {
            if (game.players.changeHealth(player, null, -(object.triggerConstant||0), true)) {
                game.players.kill(player, null, {});
            }
        }
    }, {
        name: "Destroy Interface",
        execute: function(game, io, player, object, chain) {
            for (var i = 0; i < game.map.manager.interfaces.length; ++i) {
                if (game.triggerChains[chain] <= 0) break;
                tmpObj2 = game.map.manager.objects[game.map.manager.interfaces[i]];
                if (tmpObj2.sid != object.sid && tmpObj2.health
                && tmpObj2.interface != object.interface
                && tmpObj2.interface == object.interfaceT) {
                    tmpObj2.active = false;
                    tmpObj2.health = 0;
                    tmpObj2.destroyedBy = player;
                    game.destObjs.push(tmpObj2.uid);
                    io.broadcast("game" + game.sid, "do", tmpObj2.uid);
                    if (tmpObj2.onDestroy || tmpObj2.onDamage) game.onTrigger(
                        player, tmpObj2, chain);
                }
            }
        }
    }, {
        name: "Toggle Interface Gate",
        execute: function(game, io, player, object, chain) {
            for (var i = 0; i < game.map.manager.interfaces.length; ++i) {
                tmpObj2 = game.map.manager.objects[game.map.manager.interfaces[i]];
                if (tmpObj2.sid != object.sid && tmpObj2.gate && tmpObj2.interface != object.interface
                && tmpObj2.interface == object.interfaceT) {
                    tmpObj2.active = !tmpObj2.active;
                    io.broadcast("game" + game.sid, "gte", tmpObj2.uid, tmpObj2.active);
                }
            }
        }
    }, {
        name: "Change Interface Health",
        execute: function(game, io, player, object, chain) {
            for (var i = 0; i < game.map.manager.interfaces.length; ++i) {
                if (game.triggerChains[chain] <= 0) break;
                tmpObj2 = game.map.manager.objects[game.map.manager.interfaces[i]];
                if (tmpObj2.sid != object.sid && tmpObj2.health
                && tmpObj2.interface != object.interface
                && tmpObj2.interface == object.interfaceT) {
                    tmpObj2.health -= -(object.triggerConstant||0);
                    if (tmpObj2.health <= 0) {
                        tmpObj2.active = false;
                        tmpObj2.health = 0;
                        tmpObj2.destroyedBy = player;
                        game.destObjs.push(tmpObj2.uid);
                        io.broadcast("game" + game.sid, "do", tmpObj2.uid);
                        if (tmpObj2 && tmpObj2.onDestroy) game.onTrigger(player, tmpObj2, chain);
                    }
                    if (tmpObj2 && tmpObj2.onDamage && (object.triggerConstant||0) < 0)
                        game.onTrigger(player, tmpObj2, chain);
                }
            }
        }
    }, {
        name: "Teleport To Interface",
        execute: function(game, io, player, object, chain) {
            for (var i = 0; i < game.map.manager.interfaces.length; ++i) {
                if (game.triggerChains[chain] <= 0) break;
                tmpObj2 = game.map.manager.objects[game.map.manager.interfaces[i]];
                if (tmpObj2.sid != object.sid && tmpObj2.interface != object.interface
                && tmpObj2.interface == object.interfaceT) {
                    game.players.changePosition(player, tmpObj2.x,
                        (tmpObj2.y - tmpObj2.height), tmpObj2.z, true);
                }
            }
        }
    }, {
        name: "Change Interface Deposit Box Amount",
        execute: function(game, io, player, object, chain) {
            for (var i = 0; i < game.map.manager.interfaces.length; ++i) {
                if (game.triggerChains[chain] <= 0) break;
                tmpObj2 = game.map.manager.objects[game.map.manager.interfaces[i]];
                if (tmpObj2.sid != object.sid && tmpObj2.interface != object.interface
                && tmpObj2.interface == object.interfaceT && tmpObj2.bank) {
                    tmpObj2.deposited += object.triggerConstant||0;
                    io.broadcast("game" + game.sid, "bnk", tmpObj2.uid, tmpObj2.deposited);
                }
            }
        }
    }, {
        name: "Kill Opposing Team",
        execute: function(game, io, player, object, chain) {
            for (var i = 0; i < game.players.list.length; ++i) {
                tmpObj = game.players.list[i];
                if (tmpObj.active && tmpObj != player && !tmpObj.godMode
                    && !(tmpObj.team && player.team == tmpObj.team)) {
                    game.players.kill(tmpObj, null, null, true);
                }
            }
        }
    }, {
        name: "Respawn Opposing Team",
        execute: function(game, io, player, object, chain) {
            for (var i = 0; i < game.players.list.length; ++i) {
                tmpObj = game.players.list[i];
                if (tmpObj.active && tmpObj != player && !(tmpObj.team && player.team == tmpObj.team)) {
                    var tmpSpawn = game.getSpawnPoint(tmpObj.team, tmpObj);
                    tmpObj.x = tmpSpawn.x;
                    tmpObj.y = tmpSpawn.y;
                    tmpObj.z = tmpSpawn.z;
                }
            }
        }
    }, {
        name: "Respawn Destructible Interface",
        execute: function(game, io, player, object, chain) {
            for (var i = 0; i < game.map.manager.interfaces.length; ++i) {
                if (game.triggerChains[chain] <= 0) break;
                tmpObj = game.map.manager.objects[game.map.manager.interfaces[i]];
                tmpObj2 = game.destObjs.indexOf(tmpObj.uid);
                if (tmpObj.sid != object.sid && tmpObj.startHealth
                && tmpObj.health == 0 && tmpObj2 != -1
                && tmpObj.interface != object.interface
                && tmpObj.interface == object.interfaceT) {
                    game.destObjs.splice(tmpObj2, 1);
                    tmpObj.active = true;
                    tmpObj.respawnT = tmpObj.respawnR ? 0 : tmpObj.respawnTStart;
                    if (tmpObj.health!=undefined) tmpObj.health = tmpObj.startHealth;
                    io.broadcast("game" + game.sid, "ro", tmpObj.uid);
    
                    // RESPAWN TRIGGER
                    if (tmpObj && tmpObj.onRespawn && tmpObj.destroyedBy)
                        game.onTrigger(tmpObj.destroyedBy, tmpObj, chain);
    
                    tmpObj.destroyedBy = null;
                }
            }
        }
    }, {
        name: "Toggle Destructible Interface",
        execute: function(game, io, player, object, chain) {
            for (var i = 0; i < game.map.manager.interfaces.length; ++i) {
                if (game.triggerChains[chain] <= 0) break;
                tmpObj = game.map.manager.objects[game.map.manager.interfaces[i]];
                tmpObj2 = game.destObjs.indexOf(tmpObj.uid);
                if (tmpObj.sid != object.sid && tmpObj.startHealth
                && tmpObj.interface != object.interface
                && tmpObj.interface == object.interfaceT) {
                    if (tmpObj2 != -1) { // RESPAWN OBJECT
                        game.destObjs.splice(tmpObj2, 1);
                        tmpObj.active = true;
                        tmpObj.respawnT = tmpObj.respawnR ? 0 : tmpObj.respawnTStart;
                        if (tmpObj.health!=undefined) tmpObj.health = tmpObj.startHealth;
                        io.broadcast("game" + game.sid, "ro", tmpObj.uid);
    
                        // RESPAWN TRIGGER
                        if (tmpObj && tmpObj.onRespawn && tmpObj.destroyedBy)
                            game.onTrigger(tmpObj.destroyedBy, tmpObj, chain);
    
                        tmpObj.destroyedBy = null;
                    } else { // DESTROY OBJECT
                        tmpObj.active = false;
                        tmpObj.health = 0;
                        tmpObj.destroyedBy = player;
                        game.destObjs.push(tmpObj.uid);
                        io.broadcast("game" + game.sid, "do", tmpObj.uid);
                        // DESTROY TRIGGER
                        if (tmpObj.onDestroy || tmpObj.onDamage) game.onTrigger(player, tmpObj, chain);
                    }
                }
            }
        }
    }, {
        name: "Set Player Score",
        execute: function(game, io, player, object, chain) {
            game.players.score(player, object.triggerConstant||0, false, true);
        }
    }];
    
    
    /***/ }),
    
    /***/ "./src/data/weapons.js":
    /*!*****************************!*\
      !*** ./src/data/weapons.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
    // WEAPONS:
    module.exports = [{
        name: "Sniper Rifle",
        src: "weapon_1",
        icon: "icon_1",
        sound: "weapon_1",
        animWhileAim: true,
        trail: true,
        flap: {
            src: "flap_0",
            rot: 2.1,
            scl: 1.0,
            zOff: 0.43,
            xOff: 0.17,
            yOff: 0.53
        },
        noAo: true,
        nAuto: true,
        type: 0,
        scope: true,
        swapTime: 300,
        aimSpeed: 120,
        spdMlt: 0.95,
        ammo: 3,
        reload: 1500,
        dmg: 100,
        pierce: 0.2,
        range: 1000,
        dropStart: 230,
        dmgDrop: 30,
        scale: 1.1 * 0.0010509883417085,
        leftHoldY: -0.65,
        rightHoldY: -0.68,
        leftHoldZ: 2.1,
        rightHoldZ: 0.75,
        holdW: 1.0,
        xOff: 0.8,
        yOff: -0.65,
        zOff: -1.8,
        xOrg: 0,
        yOrg: -0.55,
        zOrg: -0.8,
        cLean: 0.2,
        cRot: 0.2,
        cDrop: 0.1,
        inspectR: 0.2,
        inspectM: 0.1,
        muzOff: 8.0,
        muzMlt: 1.6,
        rate: 900,
        spread: 260,
        zoom: 2.7,
        leanMlt: 1.5,
        recoil: 0.009,
        recoilR: 0.02,
        recover: 0.993,
        recoverY: 0.997,
        recoverF: 0.975,
        recoilYM: 0.35,
        recoilZ: 1.4,
        recoilAnim: {
            time: 280,
            aimTime: 500,
            recoilTweenY: 0.3
        },
        jumpYM: 0.15,
        rumble: 0.9,
        rumbleDur: 500,
        icnPad: 9
    }, {
        name: "Assault Rifle",
        src: "weapon_2",
        icon: "icon_2",
        sound: "weapon_2",
        noAo: true,
        swapWiggle: 0.3,
        attach: 0,
        attachYOff: -0.1,
        attachZOff: -0.8,
        zRot: 1.0,
        type: 0,
        swapTime: 300,
        aimSpeed: 130,
        spdMlt: 0.95,
        ammo: 30,
        rate: 110,
        reload: 1200,
        dmg: 23,
        pierce: 1.0,
        range: 700,
        dmgDrop: 5,
        scale: 1.0 * 0.00095745145728643,
        leftHoldY: -0.41,
        rightHoldY: -0.6,
        leftHoldZ: 0.5,
        rightHoldZ: -1.2,
        holdW: 0.8,
        xOff: 1.0,
        yOff: -0.9,
        rotOff: -0.07,
        yRot: 0.0018,
        zOff: -3.6,
        xOrg: 0,
        yOrg: -0.625,
        zOrg: -2.3,
        cLean: 0.2,
        cRot: 0.2,
        cDrop: 0.1,
        inspectR: 0.1,
        inspectM: 1.5,
        caseZOff: -1.7,
        caseYOff: -0.2,
        muzOff: 5.1,
        muzOffY: -0.05,
        muzMlt: 1.4,
        spread: 100,
        minSpread: 5,
        zoom: 1.6,
        leanMlt: 1.5,
        recoil: 0.003,
        recoilR: 0.021,
        recover: 0.978,
        recoverY: 0.995,
        recoverF: 0.975,
        jYMlt: 0.9,
        recoilYM: 0.35,
        recoilZ: 5.7,
        recoilZM: -0.05,
        aimRecMlt: 0.7,
        recoilAnim: {
            time: 300,
            recoilTweenY: 0.05
        },
        jumpYM: 0.6,
        rumble: 0.5,
        icnPad: 5
    }, {
        name: "Pistol",
        src: "weapon_3",
        icon: "icon_3",
        sound: "weapon_3",
        secondary: true,
        noAo: true,
        transp: true,
        nAuto: true,
        kill: ["", 75],
        swapWiggle: 0.3,
        type: 1,
        shine: 10,
        swapTime: 350,
        aimSpeed: 120,
        spdMlt: 1.05,
        ammo: 10,
        reload: 700,
        dmg: 20,
        range: 700,
        dmgDrop: 10,
        scale: 0.84 * 0.00037606512562814,
        leftHoldY: -1.1,
        rightHoldY: -0.62,
        leftHoldZ: -0.3,
        rightHoldZ: -0.32,
        rightHoldX: 0.13,
        holdW: 1.3,
        xOff: 1.2,
        yOff: -0.6,
        zOff: -3.7,
        xOrg: 0,
        yRot: -0.005,
        yOrg: -0.23,
        zOrg: -3.9,
        jYMlt: 0.1,
        cLean: 0.3,
        cRot: 0.3,
        caseZOff: 0.2,
        caseYOff: 0.0,
        inspectR: 0.3,
        inspectM: 0.8,
        muzOff: 1.5,
        muzOffY: 0.0,
        muzMlt: 0.95,
        rate: 150,
        spread: 90,
        zoom: 1.4,
        leanMlt: 1.0,
        recoil: 0.006,
        recoilR: 0.01,
        recover: 0.98,
        recoverY: 0.99,
        recoverF: 0.98,
        recoilYM: 0.2,
        aimRecMlt: 0.4,
        recoilZ: 3.8,
        recoilZM: -0.4,
        recoilAnim: {
            time: 200,
            recoilTweenY: 0.28
        },
        rumble: 0.4,
        icnPad: -15
    }, {
        name: "Submachine Gun",
        src: "weapon_4",
        icon: "icon_4",
        sound: "weapon_4",
        swapWiggle: 0.5,
        attach: 0,
        attachYOff: -0.09,
        attachZOff: -1.1,
        zRot: 0.75,
        noAo: true,
        type: 0,
        shine: 50,
        swapTime: 300,
        aimSpeed: 120,
        spdMlt: 1.04,
        ammo: 28,
        reload: 1000,
        dmg: 18,
        pierce: 1.0,
        range: 700,
        dmgDrop: 12,
        scale: 1.1 * 0.00052263417085427,
        leftHoldY: -0.4,
        leftHoldX: -0.1,
        rightHoldY: -0.5,
        leftHoldZ: 1.1,
        rightHoldZ: -0.95,
        holdW: 0.85,
        xOff: 0.85,
        yOff: -0.86,
        zOff: -3.0,
        xOrg: 0,
        yOrg: -0.59,
        zOrg: -2.5,
        cRot: 0.18,
        cLean: 0.16,
        inspectR: 0.2,
        inspectM: 1.2,
        caseYOff: -0.15,
        caseZOff: -0.4,
        muzOff: 2.15,
        muzOffY: 0.1,
        rate: 90,
        spread: 70,
        minSpread: 5,
        zoom: 1.65,
        jYMlt: 0.8,
        leanMlt: 1.0,
        recoil: 0.0034,
        recoilY: 0.77,
        recoilR: 0.02,
        recover: 0.975,
        recoverY: 0.996,
        recoverF: 0.975,
        recoilZ: 3.2,
        recoilZM: -0.1,
        aimRecMlt: 0.6,
        recoilAnim: {
            time: 200,
            recoilTweenYM: 0.05,
            recoilTweenY: 0.06
        },
        expScale: 0.8,
        rumble: 0.4,
        icnPad: 0
    }, {
        name: "Revolver",
        src: "weapon_5",
        icon: "icon_5",
        sound: "weapon_5",
        nAuto: true,
        noAo: true,
        nCase: true,
        transp: true,
        kill: ["", 50],
        type: 0,
        swapTime: 200,
        swapWiggle: 0.4,
        aimSpeed: 110,
        spdMlt: 1.04,
        ammo: 6,
        reload: 900,
        dmg: 66,
        pierce: 0.85,
        dmgDrop: 10,
        scale: 1.3 * 0.00039656251256281,
        hDstOff: 1.6,
        leftHoldY: -1.3,
        rightHoldY: -0.8,
        leftHoldZ: -0.6,
        rightHoldZ: -0.72,
        rightHoldX: 0.1,
        holdW: 1.1,
        rotOff: -0.05,
        xOff: 0.7,
        yOff: -0.5,
        zOff: -3.5,
        xOrg: 0,
        yOrg: -0.31,
        zOrg: -3.5,
        jYMlt: 0.8,
        cLean: 0.2,
        cRot: 0.1,
        cDrop: 0.1,
        inspectR: 0.1,
        inspectM: 0.3,
        muzOff: 2.75,
        muzOffY: 0.2,
        muzMlt: 0.95,
        range: 700,
        rate: 390,
        spread: 100,
        zoom: 1.45,
        leanMlt: 1.6,
        recoil: 0.013,
        recoilR: 0.06,
        recover: 0.982,
        recoverY: 0.992,
        recoverF: 0.98,
        recoilYM: 0.5,
        aimRecMlt: 0.1,
        recoilZM: 0.01,
        recoilZ: 3.4,
        recoilAnim: {
            time: 300,
            recoilTweenY: 0.36,
            recoilTweenYM: 0.25
        },
        expScale: 0.9,
        rumble: 0.7,
        icnPad: -10
    }, {
        name: "Shotgun",
        src: "weapon_6",
        icon: "icon_6",
        sound: "weapon_6",
        altSkin: 886,
        noAo: true,
        nAuto: true,
        nCase: true,
        nRing: true,
        swapWiggle: 0.4,
        shine: 35,
        type: 0,
        physRang: 35,
        physPow: 0.085,
        swapTime: 300,
        aimSpeed: 120,
        spdMlt: 1.0,
        ammo: 2,
        reload: 1100,
        dmg: 50,
        dmgDrop: 50,
        scale: 1.0 * 0.00082934281407035,
        rightHoldX: 0.1,
        leftHoldY: -0.6,
        rightHoldY: -0.6,
        leftHoldZ: 0.4,
        rightHoldZ: -1.3,
        holdW: 1.0,
        xOff: 0.95,
        yOff: -0.6,
        zOff: -3.8,
        xOrg: 0,
        yOrg: -0.3,
        zOrg: -2.8,
        cLean: 0.2,
        cRot: 0.2,
        cDrop: 0.1,
        jYMlt: 0.2,
        inspectR: 0.1,
        inspectM: 1.9,
        muzOff: 6.0,
        muzMlt: 1.8,
        range: 240,
        rate: 400,
        innac: 110,
        spread: 180,
        shots: 5,
        cSpread: [
            0.03, 0.02,
            -0.27, 0.02,
            0.03, -0.31,
            0.30, -0.01,
            0.01, 0.28,
    
            0.01, 0.02,
            -0.17, -0.22,
            -0.3, 0.31,
            0.32, 0.28,
            0.3, -0.2
        ],
        minSpread: 20,
        zoom: 1.25,
        leanMlt: 1.6,
        recoil: 0.02,
        recoilR: 0.015,
        recover: 0.99,
        recoverF: 0.97,
        recoilZ: 2.1,
        recoilZM: 0.2,
        aimRecMlt: 0.67,
        recoilYM: 0.65,
        recoilAnim: {
            time: 340,
            recoilTweenY: 0.22
        },
        jumpYM: 0.5,
        rumble: 0.8,
        icnPad: 10,
        expScale: 0.85
    }, {
        name: "Machine Gun",
        src: "weapon_7",
        icon: "icon_7",
        sound: "weapon_7",
        type: 0,
        attach: 0,
        swapWiggle: 0.3,
        attachYOff: -0.085,
        attachZOff: -0.7,
        zRot: 0.75,
        noAo: true,
        swapTime: 700,
        aimSpeed: 200,
        spdMlt: 0.79,
        ammo: 60,
        reload: 3500,
        dmg: 20,
        pierce: 1.0,
        range: 700,
        dmgDrop: 10,
        jYMlt: 0.8,
        scale: 1.16 * 0.00076344904522613,
        leftHoldY: -0.85,
        leftHoldX: 0.4,
        rightHoldY: -0.75,
        leftHoldZ: 1.1,
        rightHoldZ: -0.2,
        holdW: 1.1,
        yRot: -0.01,
        xOff: 0.95,
        yOff: -0.75,
        zOff: -2.8,
        xOrg: 0,
        yOrg: -0.6,
        zOrg: -1.8,
        cLean: 0.1,
        cRot: 0.1,
        cDrop: 0.1,
        inspectR: 0.2,
        inspectM: 0.6,
        caseInd: 2,
        caseZOff: -0.5,
        caseYOff: -0.1,
        muzOff: 5.5,
        muzOffY: -0.14,
        muzMlt: 1.7,
        rate: 130,
        spread: 300,
        minSpread: 10,
        zoom: 1.3,
        leanMlt: 1.6,
        recoil: 0.0032,
        recoilR: 0.014,
        recover: 0.98,
        recoverY: 0.9975,
        recoverF: 0.975,
        recoilZ: 3.8,
        recoilYM: 0.25,
        recoilZ: 3.0,
        recoilZM: -0.1,
        aimRecMlt: 0.5,
        recoilAnim: {
            time: 200,
            recoilTweenY: 0.055
        },
        jumpYM: 0.5,
        expScale: 0.85,
        rumble: 0.65,
        icnPad: 10
    }, {
        name: "Semi Auto",
        src: "weapon_8",
        icon: "icon_8",
        sound: "weapon_8",
        attach: 0,
        attachYOff: -0.08,
        attachZOff: -1.55,
        nAuto: true,
        zRot: 0.7,
        type: 0,
        noAo: true,
        swapWiggle: 0.4,
        swapTime: 300,
        aimSpeed: 120,
        spdMlt: 1.0,
        ammo: 8,
        reload: 1500,
        dmg: 34,
        pierce: 0.2,
        range: 1000,
        dmgDrop: 0,
        scale: 1.0 * 0.00093686221105528,
        leftHoldY: -0.5,
        rightHoldY: -0.45,
        leftHoldZ: 0.4,
        rightHoldZ: -1.85,
        jYMlt: 0.9,
        xOff: 0.8,
        yOff: -0.55,
        zOff: -3.5,
        xOrg: 0,
        yOrg: -0.395,
        yRot: -0.005,
        zOrg: -3.4,
        cLean: 0.2,
        cRot: 0.2,
        cDrop: 0.1,
        inspectR: 0.2,
        inspectM: 1.4,
        muzOff: 4.0,
        muzOffY: -0.05,
        muzMlt: 1.1,
        rate: 120,
        spread: 250,
        caseZOff: -1.3,
        zoom: 2.1,
        recoil: 0.01,
        recoilR: 0.012,
        recover: 0.98,
        recoilY: 0.36,
        recoverY: 0.994,
        recoverF: 0.975,
        recoilYM: 0.6,
        recoilZ: 2.0,
        recoilZM: 0.2,
        aimRecMlt: 0.8,
        recoilAnim: {
            time: 250,
            recoilTweenY: 0.11
        }, jumpYM: 0.5,
        rumble: 0.75,
        icnPad: 10
    }, {
        name: "Rocket Launcher",
        src: "weapon_9",
        icon: "icon_9",
        sound: "weapon_9",
        nInsp: true,
        nSkill: true,
        nAuto: true,
        nCase: true,
        nRing: true,
        noAo: true,
        projectile: 0,
        type: 0,
        swapTime: 400,
        swapWiggle: 0.4,
        aimSpeed: 200,
        spdMlt: 0.9,
        physRang: 40,
        physPow: 0.095,
        ammo: 2,
        shots: 0,
        reload: 1800,
        scale: 1.0 * 0.00076263407035176,
        leftHoldX: -0.1,
        leftHoldY: -0.36,
        rightHoldY: -0.3,
        leftHoldZ: 1.2,
        rightHoldX: -0.15,
        rightHoldZ: -0.45,
        holdW: 0.9,
        jYMlt: 0.4,
        xOff: 0.95,
        yOff: -0.56,
        zOff: -2.6,
        xOrg: 0,
        yOrg: -0.945,
        zOrg: -3.0,
        zRot: 0.9,
        cLean: 0.2,
        cRot: 0.2,
        cDrop: 0.1,
        muzOff: 5.0,
        muzOffY: 0.0,
        muzMlt: 1.5,
        rate: 350,
        spread: 120,
        minSpread: 15,
        zoom: 1.5,
        leanMlt: 1.4,
        landBob: 0.8,
        recoil: 0.008,
        recoilR: 0.012,
        recover: 0.99,
        recoverY: 0.998,
        recoverF: 0.975,
        recoilZ: 4,
        recoilZM: -0.5,
        aimRecMlt: 0.9,
        recoilAnim: {
            time: 400,
            recoilTweenY: 0.25
        },
        jumpYM: 0.3,
        expScale: 0.7,
        rumble: 1,
        rumbleDur: 750,
        icnPad: 10
    }, {
        name: "Akimbo Uzi",
        src: "weapon_10",
        icon: "icon_10",
        sound: "weapon_10",
        nInsp: true,
        noAim: true,
        akimbo: true,
        type: 0,
        swapTime: 300,
        aimSpeed: 120,
        spdMlt: 1.04,
        ammo: 18,
        reload: 1200,
        dmg: 18,
        pierce: 1.0,
        range: 700,
        dmgDrop: 12,
        scale: 0.9,
        rightHoldY: -0.55,
        leftHoldZ: 0.3,
        leftHoldX: -0.25,
        leftHoldY: -0.55,
        rightHoldZ: 0.3,
        rightHoldX: -0.25,
        holdW: 1.3,
        xOff: 1.5,
        yOff: -0.95,
        zOff: -3.3,
        xOrg: 0,
        yOrg: -0.62,
        zOrg: -2.5,
        zLnM: 0.4,
        cLean: 0.1,
        cRot: 0.1,
        cDrop: 0.2,
        caseYOff: -0.15,
        caseZOff: -0.4,
        muzOff: 3.6,
        rate: 60,
        spread: 40,
        spreadInc: 1.5,
        minSpread: 10,
        zoom: 1.5,
        leanMlt: 0.6,
        recoil: 0.0034,
        recoilR: 0.015,
        recover: 0.978,
        recoverY: 0.996,
        recoverF: 0.975,
        recoilZ: 5.0,
        recoilYM: 0.6,
        recoilAnim: {
            recoilTweenY: 0.01
        },
        expScale: 0.7,
        rumble: 0.4,
        icnPad: -4
    }, {
        name: "Desert Eagle",
        src: "weapon_11",
        icon: "icon_11",
        sound: "weapon_11",
        secondary: true,
        minRec: 15,
        nAuto: true,
        noAo: true,
        transp: true,
        kill: ["", 50],
        type: 1,
        swapTime: 200,
        aimSpeed: 120,
        spdMlt: 1,
        ammo: 6,
        reload: 1000,
        dmg: 50,
        pierce: 0.85,
        dmgDrop: 10,
        scale: 0.94,
        leftHoldY: -0.9,
        rightHoldY: -0.7,
        leftHoldZ: -0.5,
        rightHoldZ: -0.5,
        holdW: 1.1,
        xOff: 1.0,
        yOff: -0.55,
        zOff: -4.1,
        xOrg: 0,
        yOrg: -0.195,
        zOrg: -3.8,
        cLean: 0.3,
        cRot: 0.3,
        inspectR: 0.35,
        inspectM: 0.9,
        muzOff: 2.0,
        muzMlt: 1.1,
        range: 700,
        rate: 400,
        spread: 150,
        jYMlt: 0.5,
        zoom: 1.4,
        leanMlt: 1.6,
        recoil: 0.01,
        recoilR: 0.01,
        recover: 0.985,
        recoverY: 0.996,
        recoverF: 0.98,
        recoilYM: 0.4,
        aimRecMlt: 0.43,
        recoilZ: 2.5,
        recoilZM: 0.2,
        recoilAnim: {
            time: 270,
            recoilTweenY: 0.42
        },
        rumble: 0.8,
        icnPad: -10
    }, {
        name: "Alien Blaster",
        src: "weapon_13",
        icon: "icon_13",
        sound: "weapon_13",
        secondary: true,
        nRing: true,
        nAuto: true,
        transp: true,
        nCase: true,
        minRec: 50,
        kill: ["", 50],
        type: 1,
        swapTime: 200,
        aimSpeed: 120,
        spdMlt: 1,
        ammo: 4,
        reload: 1500,
        dmg: 50,
        pierce: 0.85,
        dmgDrop: 10,
        scale: 1.1,
        leftHoldY: -1.0,
        rightHoldY: -0.65,
        leftHoldZ: -0.2,
        rightHoldZ: -0.2,
        holdW: 1.0,
        xOff: 1.3,
        yOff: -0.83,
        zOff: -4.1,
        xOrg: 0,
        yRot: -0.01,
        yOrg: -0.53,
        zOrg: -3.8,
        cLean: 0.2,
        cRot: 0.2,
        cDrop: 0.0,
        inspectR: 0.1,
        inspectM: 0.8,
        muzOff: 2.2,
        muzOffY: 0.1,
        muzID: 3,
        muzMlt: 1.1,
        jYMlt: 0.8,
        range: 700,
        rate: 170,
        spread: 150,
        zoom: 1.4,
        leanMlt: 1.6,
        recoil: 0.006,
        recoilR: 0.01,
        recover: 0.98,
        recoverY: 0.99,
        recoverF: 0.98,
        recoilYM: 0.2,
        recoilZ: 2.2,
        aimRecMlt: 0.3,
        recoilAnim: {
            time: 200,
            recoilTweenY: 0.32
        },
        rumble: 0.4,
        icnPad: -8
    }, {
        name: "Combat Knife",
        icon: "icon_0",
        melee: true,
        nInsp: true,
        noSkins: true,
        holdW: 0.9,
        swapWiggle: 0.3,
        sounds: ["swish_0", "swish_1"],
        noAim: true,
        anim: function(player, TWEEN, index) {
            if (index == 1) {
                player.handAnimInd = (player.handAnimInd||1)*-1;
                var flip = false;
                if (player.meleeAnim.anim) {
                    player.meleeAnim.anim.stop();
                    flip = (player.meleeAnim.armM >= 2);
                }
                player.resetMeleeAnim();
                var weapMp = -1.2;
                var weapMf = 0.7;
                var armR = -0.4;
                if (flip) {
                    weapMp += 0.1;
                    player.meleeAnim.weaR = weapMp;
                    armR += 0.8;
                    player.meleeAnim.armR = armR;
                    weapMf += 0.2;
                    player.meleeAnim.weaM = weapMf;
                    player.meleeAnim.flipW = Math.PI;
                } else {
                    weapMp -= 0.4;
                }
                player.meleeAnim.anim = new TWEEN.Tween(player.meleeAnim).to({
                    armR: armR,
                    lArm: 1.0,
                    armT: (flip?-0.2:-0.8),
                    armY: (flip?-3.0:-3.0),
                    armM: (flip?-10:13),
                    armE: -2.0,
                    weaR: weapMp,
                    weaM: weapMf
                }, 220 * (flip?1.3:1)).easing(TWEEN.Easing.Cubic.Out).onComplete(function() {
                    player.meleeAnim.anim = new TWEEN.Tween(player.meleeAnim).to({
                        armR: 0,
                        armT: 0,
                        armY: 0,
                        lArm: 0,
                        armM: 0,
                        armE: 0,
                        weaR: 0,
                        weaM: 0,
                        flipW: 0
                    }, 350).easing(TWEEN.Easing.Cubic.Out).start();
                }).start();
            } else {
                player.handAnimInd = (player.handAnimInd||1)*-1;
                var tmpTwn = ((player.handAnimInd==1?"l":"r") + "HndTween");
                if (player[tmpTwn]) player[tmpTwn].stop();
                player[tmpTwn + "A"] = (player[tmpTwn + "A"]||0);
                player[tmpTwn] = new TWEEN.Tween(player).to({
                    [tmpTwn + "A"]: 2.4
                }, 30).easing(TWEEN.Easing.Linear.None).onComplete(function() {
                    player[tmpTwn] = new TWEEN.Tween(player).to({
                        [tmpTwn + "A"]: 0.0
                    }, 200).easing(TWEEN.Easing.Linear.None).delay(100).start();
                }).start();
            }
        },
        type: 1,
        swapTime: 280,
        aimSpeed: 120,
        rate: 250,
        dmg: 50,
        dmgDrop: 0,
        range: 15,
        spdMlt: 1.1,
        spread: 100,
        leftHoldY: -0.82,
        leftHoldX: 1.5,
        rightHoldX: -1.5,
        rightHoldY: -0.82,
        leftHoldZ: -0.5,
        rightHoldZ: -0.5,
        xOff: 0.0,
        yOff: -0.6,
        zOff: -3.6,
        xOrg: 0.5,
        yOrg: 0,
        zOrg: -3.6,
        zRM: 0.35,
        zoom: 1.0,
        leanMlt: 0.8,
        recoil: 0.006,
        recoilR: 0.01,
        recover: 0.98,
        recoverF: 0.98,
        rumble: 0.4,
        rumbleDur: 150,
        icnPad: -10
    }, {
        name: "Crossbow",
        src: "weapon_17",
        icon: "icon_17",
        sound: "weapon_17",
        noSkins: true,
        nInsp: true,
        nRing: true,
        nAuto: true,
        noAo: true,
        nCase: true,
        nMuz: true,
        attach: 0,
        attachYOff: -0.1,
        attachZOff: 0.65,
        kill: ["", 100],
        type: 0,
        projectile: 1,
        swapTime: 200,
        aimSpeed: 120,
        spdMlt: 1,
        ammo: 1,
        reload: 900,
        dmg: 100,
        pierce: 0,
        dmgDrop: 0,
        scale: 0.9 * 0.00081148311557789,
        leftHoldY: -0.33,
        rightHoldY: -0.28,
        leftHoldZ: 2.2,
        leftHoldX: 0.0,
        rightHoldZ: 0.9,
        xOff: 1.3,
        yOff: -0.95,
        zOff: -1.9,
        xOrg: 0,
        yOrg: -0.72,
        zOrg: -1.0,
        cLean: 0.1,
        cRot: 0.1,
        zRot: 0.9,
        cDrop: 0.2,
        holdW: 0.5,
        muzOff: 2.2,
        muzOffY: 0.1,
        muzID: 3,
        muzMlt: 1.1,
        jYMlt: 0.95,
        range: 700,
        rate: 150,
        spread: 300,
        zoom: 1.4,
        leanMlt: 0.3,
        recoil: 0.007,
        recoilR: 0.01,
        recover: 0.985,
        recoverY: 0.996,
        recoverF: 0.98,
        recoilZ: 4,
        recoilAnim: {
            time: 300,
            recoilTweenY: 0.1
        },
        rumble: 0.5,
        icnPad: 9
    }, {
        name: "Famas",
        src: "weapon_15",
        icon: "icon_15",
        sound: "weapon_15",
        noAo: true,
        nAuto: true,
        burst: {
            c: 3,
            r: 90
        },
        swapWiggle: 0.6,
        attach: 0,
        attachYOff: -0.1,
        attachZOff: -0.5,
        zRot: 1.0,
        type: 0,
        swapTime: 300,
        aimSpeed: 130,
        spdMlt: 0.95,
        ammo: 30,
        rate: 280,
        reload: 1200,
        dmg: 28,
        pierce: 1.0,
        range: 900,
        dmgDrop: 5,
        scale: 0.9 * 0.00098426884422111,
        leftHoldY: -0.45,
        rightHoldY: -0.5,
        leftHoldZ: 0.72,
        rightHoldZ: -0.75,
        holdW: 1.0,
        xOff: 1.0,
        yOff: -0.86,
        yRot: 0.0018,
        zOff: -3.0,
        xOrg: 0,
        yOrg: -1.14,
        zOrg: -2.0,
        cLean: 0.2,
        cRot: 0.2,
        cDrop: 0.1,
        inspectR: 0.1,
        inspectM: 1.5,
        caseZOff: -1.7,
        caseYOff: -0.2,
        muzOff: 4.9,
        muzOffY: -0.05,
        muzMlt: 1.4,
        spread: 90,
        minSpread: 5,
        zoom: 1.5,
        leanMlt: 1.5,
        recoil: 0.0032,
        recoilR: 0.02,
        recover: 0.978,
        recoverY: 0.995,
        recoverF: 0.975,
        jYMlt: 0.9,
        recoilYM: 0.32,
        recoilZ: 5.5,
        recoilZM: 0.05,
        aimRecMlt: 0.65,
        recoilAnim: {
            time: 300,
            recoilTweenY: 0.06
        },
        jumpYM: 0.6,
        rumble: 0.5,
        expScale: 0.9,
        icnPad: 9
    }, {
        name: "Sawed Off",
        src: "weapon_18",
        icon: "icon_18",
        sound: "weapon_6",
        noAo: true,
        nAuto: true,
        nCase: true,
        nRing: true,
        secondary: true,
        minRec: 20,
        swapWiggle: 0.4,
        shine: 35,
        type: 1,
        physRang: 36,
        physPow: 0.1,
        swapTime: 200,
        aimSpeed: 100,
        spdMlt: 1.0,
        ammo: 1,
        reload: 1100,
        dmg: 12,
        dmgDrop: 12,
        scale: 1.0,
        rightHoldX: 0.1,
        leftHoldY: -0.5,
        rightHoldY: -0.6,
        leftHoldZ: 0.4,
        rightHoldZ: -1.5,
        holdW: 1.0,
        xOff: 0.95,
        yOff: -0.65,
        zOff: -3.8,
        xOrg: 0,
        yOrg: -0.3,
        zOrg: -2.8,
        cLean: 0.2,
        cRot: 0.2,
        cDrop: 0.1,
        jYMlt: 0.2,
        inspectR: 0.1,
        inspectM: 1.9,
        muzOff: 6.0,
        muzMlt: 1.8,
        range: 210,
        rate: 400,
        innac: 110,
        spread: 120,
        shots: 5,
        cSpread: [
            0.01, 0.05,
            -0.17, -0.22,
            -0.3, 0.31,
            0.32, 0.28,
            0.3, -0.2
        ],
        minSpread: 20,
        zoom: 1.25,
        leanMlt: 1.6,
        recoil: 0.02,
        recoilR: 0.015,
        recover: 0.99,
        recoverF: 0.97,
        recoilZ: 2.1,
        recoilZM: 0.32,
        aimRecMlt: 0.3,
        recoilYM: 1.0,
        recoilAnim: {
            time: 340,
            recoilTweenY: 0.35
        },
        jumpYM: 0.5,
        rumble: 0.8,
        icnPad: 10
    }];
    module.exports.findWeaponBySrc = function(id) {
        for (var i = 0; i < module.exports.length; ++i) {
            if (module.exports[i].src == "weapon_" + id)
                return module.exports[i];
        } return null;
    };
    module.exports.findIndexBySrc = function(src) {
        for (var i = 0; i < module.exports.length; ++i) {
            if (module.exports[i].src == src)
                return i;
        } return null;
    };
    
    
    /***/ }),
    
    /***/ "./src/libs/OBJLoader.js":
    /*!*******************************!*\
      !*** ./src/libs/OBJLoader.js ***!
      \*******************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
    module.exports = function(THREE) {
        return ( function () {
    
            // o object_name | g group_name
            var object_pattern = /^[og]\s*(.+)?/;
            // mtllib file_reference
            var material_library_pattern = /^mtllib /;
            // usemtl material_name
            var material_use_pattern = /^usemtl /;
    
            function ParserState() {
    
                var state = {
                    objects: [],
                    object: {},
    
                    vertices: [],
                    normals: [],
                    colors: [],
                    uvs: [],
    
                    materialLibraries: [],
    
                    startObject: function ( name, fromDeclaration ) {
    
                        // If the current object (initial from reset) is not from a g/o declaration in the parsed
                        // file. We need to use it for the first parsed g/o to keep things in sync.
                        if ( this.object && this.object.fromDeclaration === false ) {
    
                            this.object.name = name;
                            this.object.fromDeclaration = ( fromDeclaration !== false );
                            return;
    
                        }
    
                        var previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );
    
                        if ( this.object && typeof this.object._finalize === 'function' ) {
    
                            this.object._finalize( true );
    
                        }
    
                        this.object = {
                            name: name || '',
                            fromDeclaration: ( fromDeclaration !== false ),
    
                            geometry: {
                                vertices: [],
                                normals: [],
                                colors: [],
                                uvs: []
                            },
                            materials: [],
                            smooth: true,
    
                            startMaterial: function ( name, libraries ) {
    
                                var previous = this._finalize( false );
    
                                // New usemtl declaration overwrites an inherited material, except if faces were declared
                                // after the material, then it must be preserved for proper MultiMaterial continuation.
                                if ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {
    
                                    this.materials.splice( previous.index, 1 );
    
                                }
    
                                var material = {
                                    index: this.materials.length,
                                    name: name || '',
                                    mtllib: ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),
                                    smooth: ( previous !== undefined ? previous.smooth : this.smooth ),
                                    groupStart: ( previous !== undefined ? previous.groupEnd : 0 ),
                                    groupEnd: - 1,
                                    groupCount: - 1,
                                    inherited: false,
    
                                    clone: function ( index ) {
    
                                        var cloned = {
                                            index: ( typeof index === 'number' ? index : this.index ),
                                            name: this.name,
                                            mtllib: this.mtllib,
                                            smooth: this.smooth,
                                            groupStart: 0,
                                            groupEnd: - 1,
                                            groupCount: - 1,
                                            inherited: false
                                        };
                                        cloned.clone = this.clone.bind( cloned );
                                        return cloned;
    
                                    }
                                };
    
                                this.materials.push( material );
    
                                return material;
    
                            },
    
                            currentMaterial: function () {
    
                                if ( this.materials.length > 0 ) {
    
                                    return this.materials[ this.materials.length - 1 ];
    
                                }
    
                                return undefined;
    
                            },
    
                            _finalize: function ( end ) {
    
                                var lastMultiMaterial = this.currentMaterial();
                                if ( lastMultiMaterial && lastMultiMaterial.groupEnd === - 1 ) {
    
                                    lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
                                    lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
                                    lastMultiMaterial.inherited = false;
    
                                }
    
                                // Ignore objects tail materials if no face declarations followed them before a new o/g started.
                                if ( end && this.materials.length > 1 ) {
    
                                    for ( var mi = this.materials.length - 1; mi >= 0; mi -- ) {
    
                                        if ( this.materials[ mi ].groupCount <= 0 ) {
    
                                            this.materials.splice( mi, 1 );
    
                                        }
    
                                    }
    
                                }
    
                                // Guarantee at least one empty material, this makes the creation later more straight forward.
                                if ( end && this.materials.length === 0 ) {
    
                                    this.materials.push( {
                                        name: '',
                                        smooth: this.smooth
                                    } );
    
                                }
    
                                return lastMultiMaterial;
    
                            }
                        };
    
                        // Inherit previous objects material.
                        // Spec tells us that a declared material must be set to all objects until a new material is declared.
                        // If a usemtl declaration is encountered while this new object is being parsed, it will
                        // overwrite the inherited material. Exception being that there was already face declarations
                        // to the inherited material, then it will be preserved for proper MultiMaterial continuation.
    
                        if ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function' ) {
    
                            var declared = previousMaterial.clone( 0 );
                            declared.inherited = true;
                            this.object.materials.push( declared );
    
                        }
    
                        this.objects.push( this.object );
    
                    },
    
                    finalize: function () {
    
                        if ( this.object && typeof this.object._finalize === 'function' ) {
    
                            this.object._finalize( true );
    
                        }
    
                    },
    
                    parseVertexIndex: function ( value, len ) {
    
                        var index = parseInt( value, 10 );
                        return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;
    
                    },
    
                    parseNormalIndex: function ( value, len ) {
    
                        var index = parseInt( value, 10 );
                        return ( index >= 0 ? index - 1 : index + len / 3 ) * 3;
    
                    },
    
                    parseUVIndex: function ( value, len ) {
    
                        var index = parseInt( value, 10 );
                        return ( index >= 0 ? index - 1 : index + len / 2 ) * 2;
    
                    },
    
                    addVertex: function ( a, b, c ) {
    
                        var src = this.vertices;
                        var dst = this.object.geometry.vertices;
    
                        dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
                        dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
                        dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );
    
                    },
    
                    addVertexPoint: function ( a ) {
    
                        var src = this.vertices;
                        var dst = this.object.geometry.vertices;
    
                        dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
    
                    },
    
                    addVertexLine: function ( a ) {
    
                        var src = this.vertices;
                        var dst = this.object.geometry.vertices;
    
                        dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
    
                    },
    
                    addNormal: function ( a, b, c ) {
    
                        var src = this.normals;
                        var dst = this.object.geometry.normals;
    
                        dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
                        dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
                        dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );
    
                    },
    
                    addColor: function ( a, b, c ) {
    
                        var src = this.colors;
                        var dst = this.object.geometry.colors;
    
                        dst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );
                        dst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );
                        dst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );
    
                    },
    
                    addUV: function ( a, b, c ) {
    
                        var src = this.uvs;
                        var dst = this.object.geometry.uvs;
    
                        dst.push( src[ a + 0 ], src[ a + 1 ] );
                        dst.push( src[ b + 0 ], src[ b + 1 ] );
                        dst.push( src[ c + 0 ], src[ c + 1 ] );
    
                    },
    
                    addUVLine: function ( a ) {
    
                        var src = this.uvs;
                        var dst = this.object.geometry.uvs;
    
                        dst.push( src[ a + 0 ], src[ a + 1 ] );
    
                    },
    
                    addFace: function ( a, b, c, ua, ub, uc, na, nb, nc ) {
    
                        var vLen = this.vertices.length;
    
                        var ia = this.parseVertexIndex( a, vLen );
                        var ib = this.parseVertexIndex( b, vLen );
                        var ic = this.parseVertexIndex( c, vLen );
    
                        this.addVertex( ia, ib, ic );
    
                        if ( ua !== undefined && ua !== '' ) {
    
                            var uvLen = this.uvs.length;
                            ia = this.parseUVIndex( ua, uvLen );
                            ib = this.parseUVIndex( ub, uvLen );
                            ic = this.parseUVIndex( uc, uvLen );
                            this.addUV( ia, ib, ic );
    
                        }
    
                        if ( na !== undefined && na !== '' ) {
    
                            // Normals are many times the same. If so, skip function call and parseInt.
                            var nLen = this.normals.length;
                            ia = this.parseNormalIndex( na, nLen );
    
                            ib = na === nb ? ia : this.parseNormalIndex( nb, nLen );
                            ic = na === nc ? ia : this.parseNormalIndex( nc, nLen );
    
                            this.addNormal( ia, ib, ic );
    
                        }
    
                        if ( this.colors.length > 0 ) {
    
                            this.addColor( ia, ib, ic );
    
                        }
    
                    },
    
                    addPointGeometry: function ( vertices ) {
    
                        this.object.geometry.type = 'Points';
    
                        var vLen = this.vertices.length;
    
                        for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {
    
                            this.addVertexPoint( this.parseVertexIndex( vertices[ vi ], vLen ) );
    
                        }
    
                    },
    
                    addLineGeometry: function ( vertices, uvs ) {
    
                        this.object.geometry.type = 'Line';
    
                        var vLen = this.vertices.length;
                        var uvLen = this.uvs.length;
    
                        for ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {
    
                            this.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );
    
                        }
    
                        for ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {
    
                            this.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );
    
                        }
    
                    }
    
                };
    
                state.startObject( '', false );
    
                return state;
    
            }
    
            //
    
            function OBJLoader( manager ) {
    
                this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
    
                this.materials = null;
    
            }
    
            OBJLoader.prototype = {
    
                constructor: OBJLoader,
    
                load: function ( url, onLoad, onProgress, onError ) {
    
                    var scope = this;
    
                    var loader = new THREE.FileLoader( scope.manager );
                    loader.setPath( this.path );
                    loader.load( url, function ( text ) {
    
                        onLoad( scope.parse( text ) );
    
                    }, onProgress, onError );
    
                },
    
                setPath: function ( value ) {
    
                    this.path = value;
    
                    return this;
    
                },
    
                setMaterials: function ( materials ) {
    
                    this.materials = materials;
    
                    return this;
    
                },
    
                parse: function ( text ) {
    
                    console.time( 'OBJLoader' );
    
                    var state = new ParserState();
    
                    if ( text.indexOf( '\r\n' ) !== - 1 ) {
    
                        // This is faster than String.split with regex that splits on both
                        text = text.replace( /\r\n/g, '\n' );
    
                    }
    
                    if ( text.indexOf( '\\\n' ) !== - 1 ) {
    
                        // join lines separated by a line continuation character (\)
                        text = text.replace( /\\\n/g, '' );
    
                    }
    
                    var lines = text.split( '\n' );
                    var line = '', lineFirstChar = '';
                    var lineLength = 0;
                    var result = [];
    
                    // Faster to just trim left side of the line. Use if available.
                    var trimLeft = ( typeof ''.trimLeft === 'function' );
    
                    for ( var i = 0, l = lines.length; i < l; i ++ ) {
    
                        line = lines[ i ];
    
                        line = trimLeft ? line.trimLeft() : line.trim();
    
                        lineLength = line.length;
    
                        if ( lineLength === 0 ) continue;
    
                        lineFirstChar = line.charAt( 0 );
    
                        // @todo invoke passed in handler if any
                        if ( lineFirstChar === '#' ) continue;
    
                        if ( lineFirstChar === 'v' ) {
    
                            var data = line.split( /\s+/ );
    
                            switch ( data[ 0 ] ) {
    
                                case 'v':
                                    state.vertices.push(
                                        parseFloat( data[ 1 ] ),
                                        parseFloat( data[ 2 ] ),
                                        parseFloat( data[ 3 ] )
                                    );
                                    if ( data.length >= 7 ) {
    
                                        state.colors.push(
                                            parseFloat( data[ 4 ] ),
                                            parseFloat( data[ 5 ] ),
                                            parseFloat( data[ 6 ] )
    
                                        );
    
                                    }
                                    break;
                                case 'vn':
                                    state.normals.push(
                                        parseFloat( data[ 1 ] ),
                                        parseFloat( data[ 2 ] ),
                                        parseFloat( data[ 3 ] )
                                    );
                                    break;
                                case 'vt':
                                    state.uvs.push(
                                        parseFloat( data[ 1 ] ),
                                        parseFloat( data[ 2 ] )
                                    );
                                    break;
    
                            }
    
                        } else if ( lineFirstChar === 'f' ) {
    
                            var lineData = line.substr( 1 ).trim();
                            var vertexData = lineData.split( /\s+/ );
                            var faceVertices = [];
    
                            // Parse the face vertex data into an easy to work with format
    
                            for ( var j = 0, jl = vertexData.length; j < jl; j ++ ) {
    
                                var vertex = vertexData[ j ];
    
                                if ( vertex.length > 0 ) {
    
                                    var vertexParts = vertex.split( '/' );
                                    faceVertices.push( vertexParts );
    
                                }
    
                            }
    
                            // Draw an edge between the first vertex and all subsequent vertices to form an n-gon
    
                            var v1 = faceVertices[ 0 ];
    
                            for ( var j = 1, jl = faceVertices.length - 1; j < jl; j ++ ) {
    
                                var v2 = faceVertices[ j ];
                                var v3 = faceVertices[ j + 1 ];
    
                                state.addFace(
                                    v1[ 0 ], v2[ 0 ], v3[ 0 ],
                                    v1[ 1 ], v2[ 1 ], v3[ 1 ],
                                    v1[ 2 ], v2[ 2 ], v3[ 2 ]
                                );
    
                            }
    
                        } else if ( lineFirstChar === 'l' ) {
    
                            var lineParts = line.substring( 1 ).trim().split( " " );
                            var lineVertices = [], lineUVs = [];
    
                            if ( line.indexOf( "/" ) === - 1 ) {
    
                                lineVertices = lineParts;
    
                            } else {
    
                                for ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {
    
                                    var parts = lineParts[ li ].split( "/" );
    
                                    if ( parts[ 0 ] !== "" ) lineVertices.push( parts[ 0 ] );
                                    if ( parts[ 1 ] !== "" ) lineUVs.push( parts[ 1 ] );
    
                                }
    
                            }
                            state.addLineGeometry( lineVertices, lineUVs );
    
                        } else if ( lineFirstChar === 'p' ) {
    
                            var lineData = line.substr( 1 ).trim();
                            var pointData = lineData.split( " " );
    
                            state.addPointGeometry( pointData );
    
                        } else if ( ( result = object_pattern.exec( line ) ) !== null ) {
    
                            // o object_name
                            // or
                            // g group_name
    
                            // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
                            // var name = result[ 0 ].substr( 1 ).trim();
                            var name = ( " " + result[ 0 ].substr( 1 ).trim() ).substr( 1 );
    
                            state.startObject( name );
    
                        } else if ( material_use_pattern.test( line ) ) {
    
                            // material
    
                            state.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );
    
                        } else if ( material_library_pattern.test( line ) ) {
    
                            // mtl file
    
                            state.materialLibraries.push( line.substring( 7 ).trim() );
    
                        } else if ( lineFirstChar === 's' ) {
    
                            result = line.split( ' ' );
    
                            // smooth shading
    
                            // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
                            // but does not define a usemtl for each face set.
                            // This should be detected and a dummy material created (later MultiMaterial and geometry groups).
                            // This requires some care to not create extra material on each smooth value for "normal" obj files.
                            // where explicit usemtl defines geometry groups.
                            // Example asset: examples/models/obj/cerberus/Cerberus.obj
    
                            /*
                             * http://paulbourke.net/dataformats/obj/
                             * or
                             * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf
                             *
                             * From chapter "Grouping" Syntax explanation "s group_number":
                             * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
                             * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
                             * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
                             * than 0."
                             */
                            if ( result.length > 1 ) {
    
                                var value = result[ 1 ].trim().toLowerCase();
                                state.object.smooth = ( value !== '0' && value !== 'off' );
    
                            } else {
    
                                // ZBrush can produce "s" lines #11707
                                state.object.smooth = true;
    
                            }
                            var material = state.object.currentMaterial();
                            if ( material ) material.smooth = state.object.smooth;
    
                        } else {
    
                            // Handle null terminated files without exception
                            if ( line === '\0' ) continue;
    
                            throw new Error( 'THREE.OBJLoader: Unexpected line: "' + line + '"' );
    
                        }
    
                    }
    
                    state.finalize();
    
                    var container = new THREE.Group();
                    container.materialLibraries = [].concat( state.materialLibraries );
    
                    for ( var i = 0, l = state.objects.length; i < l; i ++ ) {
    
                        var object = state.objects[ i ];
                        var geometry = object.geometry;
                        var materials = object.materials;
                        var isLine = ( geometry.type === 'Line' );
                        var isPoints = ( geometry.type === 'Points' );
                        var hasVertexColors = false;
    
                        // Skip o/g line declarations that did not follow with any faces
                        if ( geometry.vertices.length === 0 ) continue;
    
                        var buffergeometry = new THREE.BufferGeometry();
    
                        buffergeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( geometry.vertices, 3 ) );
    
                        if ( geometry.normals.length > 0 ) {
    
                            buffergeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( geometry.normals, 3 ) );
    
                        } else {
    
                            buffergeometry.computeVertexNormals();
    
                        }
    
                        if ( geometry.colors.length > 0 ) {
    
                            hasVertexColors = true;
                            buffergeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( geometry.colors, 3 ) );
    
                        }
    
                        if ( geometry.uvs.length > 0 ) {
    
                            buffergeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( geometry.uvs, 2 ) );
    
                        }
    
                        // Create materials
    
                        var createdMaterials = [];
    
                        for ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {
    
                            var sourceMaterial = materials[ mi ];
                            var material = undefined;
    
                            if ( this.materials !== null ) {
    
                                material = this.materials.create( sourceMaterial.name );
    
                                // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.
                                if ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {
    
                                    var materialLine = new THREE.LineBasicMaterial();
                                    materialLine.copy( material );
                                    materialLine.lights = false; // TOFIX
                                    material = materialLine;
    
                                } else if ( isPoints && material && ! ( material instanceof THREE.PointsMaterial ) ) {
    
                                    var materialPoints = new THREE.PointsMaterial( { size: 10, sizeAttenuation: false } );
                                    materialLine.copy( material );
                                    material = materialPoints;
    
                                }
    
                            }
    
                            if ( ! material ) {
    
                                if ( isLine ) {
    
                                    material = new THREE.LineBasicMaterial();
    
                                } else if ( isPoints ) {
    
                                    material = new THREE.PointsMaterial( { size: 1, sizeAttenuation: false } );
    
                                } else {
    
                                    material = new THREE.MeshPhongMaterial();
    
                                }
    
                                material.name = sourceMaterial.name;
    
                            }
    
                            material.flatShading = sourceMaterial.smooth ? false : true;
                            material.vertexColors = hasVertexColors ? THREE.VertexColors : THREE.NoColors;
    
                            createdMaterials.push( material );
    
                        }
    
                        // Create mesh
    
                        var mesh;
    
                        if ( createdMaterials.length > 1 ) {
    
                            for ( var mi = 0, miLen = materials.length; mi < miLen; mi ++ ) {
    
                                var sourceMaterial = materials[ mi ];
                                buffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );
    
                            }
    
                            if ( isLine ) {
    
                                mesh = new THREE.LineSegments( buffergeometry, createdMaterials );
    
                            } else if ( isPoints ) {
    
                                mesh = new THREE.Points( buffergeometry, createdMaterials );
    
                            } else {
    
                                mesh = new THREE.Mesh( buffergeometry, createdMaterials );
    
                            }
    
                        } else {
    
                            if ( isLine ) {
    
                                mesh = new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] );
    
                            } else if ( isPoints ) {
    
                                mesh = new THREE.Points( buffergeometry, createdMaterials[ 0 ] );
    
                            } else {
    
                                mesh = new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] );
    
                            }
    
                        }
    
                        mesh.name = object.name;
    
                        container.add( mesh );
    
                    }
    
                    console.timeEnd( 'OBJLoader' );
    
                    return container;
    
                }
    
            };
    
            return OBJLoader;
    
        } )();
    }
    
    
    /***/ }),
    
    /***/ "./src/libs/PointerLockControls.js":
    /*!*****************************************!*\
      !*** ./src/libs/PointerLockControls.js ***!
      \*****************************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    /**
     * @author mrdoob / http://mrdoob.com/
     */
    
    module.exports = function(THREE) {
        return function ( camera ) {
    
            var scope = this;
    
            camera.rotation.set( 0, 0, 0 );
    
            var pchObjc = new THREE.Object3D();
            pchObjc.add( camera );
    
            var yawObject = new THREE.Object3D();
            yawObject.position.y = 10;
            yawObject.add( pchObjc );
    
            var PI_2 = Math.PI / 2;
    
            var onMouseMove = function ( event ) {
    
                if ( scope.enabled === false ) return;
    
                var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
    
                yawObject.rotation.y -= movementX * 0.002;
                pchObjc.rotation.x -= movementY * 0.002;
    
                pchObjc.rotation.x = Math.max( - PI_2, Math.min( PI_2, pchObjc.rotation.x ) );
    
            };
    
            var onMouseUp = function ( event ) {
                scope.enabled = false;
            };
    
            this.dispose = function () {
    
                document.removeEventListener( 'mousemove', onMouseMove, false );
                document.removeEventListener( 'mouseup', onMouseUp, false );
    
            };
    
            document.addEventListener( 'mousemove', onMouseMove, false );
            document.addEventListener( 'mouseup', onMouseUp, false );
    
            this.enabled = false;
    
            this.getObject = function () {
    
                return yawObject;
    
            };
    
            this.getRotation = function() {
                return [yawObject.rotation.y, pchObjc.rotation.x, 0];
            };
    
            this.setRotation = function (x, y, z) {
                yawObject.rotation.y = x;
                pchObjc.rotation.x = y;
    
                pchObjc.rotation.x = Math.max( - PI_2, Math.min( PI_2, pchObjc.rotation.x ) );
            };
    
            this.getDir = function () {
    
                // assumes the camera itself is not rotated
    
                var direction = new THREE.Vector3( 0, 0, - 1 );
                var rotation = new THREE.Euler( 0, 0, 0, 'YXZ' );
    
                return function ( v ) {
    
                    rotation.set( pchObjc.rotation.x, yawObject.rotation.y, 0 );
    
                    v.copy( direction ).applyEuler( rotation );
    
                    return v;
    
                };
    
            }();
    
        };
    };
    
    
    /***/ }),
    
    /***/ "./src/libs/SkyDome.js":
    /*!*****************************!*\
      !*** ./src/libs/SkyDome.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    const COLORS = __webpack_require__(/*! ../data/colors.js */ "./src/data/colors.js");
    const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
    const DOME_MATERIAL = new THREE.MeshBasicMaterial({
        color: 0xFFFFFF,
        flatShading: false,
        vertexColors: THREE.VertexColors,
        side: THREE.BackSide
    });
    const SEGMENTS = 32;
    const GRADIENT_REVERSE = true;
    const GRADIENT_AXIS = 'y';
    const GRADIENT_COLORS = [{
        stp: 0,
        col: null
    }, {
        stp: .5,
        col: null
    }, {
        stp: 1,
        col: null
    }];
    
    class SkyDome extends THREE.Object3D {
        static fromConfig(config) {
            return new SkyDome(config.skyDomeCol0,
                config.skyDomeCol1, config.skyDomeCol2);
        }
    
        constructor(col0, col1, col2) {
            super();
    
            // SETUP:
            GRADIENT_COLORS[0].col = new THREE.Color(col0 || COLORS.skyDome[0]);
            GRADIENT_COLORS[1].col = new THREE.Color(col1 || COLORS.skyDome[1]);
            GRADIENT_COLORS[2].col = new THREE.Color(col2 || COLORS.skyDome[2]);
    
            // CREATE GEO:
            let baseGeo = new THREE.SphereGeometry(50, SEGMENTS, SEGMENTS);
    
            baseGeo.computeBoundingBox();
    
            let bbox = baseGeo.boundingBox;
            let size = new THREE.Vector3().subVectors(bbox.max, bbox.min);
            let vertexIndices = ['a', 'b', 'c'];
            let face, normalized = new THREE.Vector3(), normalizedAxis = 0;
    
            for (let c = 0; c < GRADIENT_COLORS.length - 1; c++) {
                let colorDiff = GRADIENT_COLORS[c + 1].stp - GRADIENT_COLORS[c].stp;
                for (let i = 0; i < baseGeo.faces.length; i++) {
                    let face = baseGeo.faces[i];
                    for (var v = 0; v < 3; v++) {
                        normalizedAxis = normalized.subVectors(baseGeo.vertices[face[vertexIndices[v]]],
                            bbox.min).divide(size)[GRADIENT_AXIS];
                        if (GRADIENT_REVERSE) normalizedAxis = 1 - normalizedAxis;
                        if (normalizedAxis >= GRADIENT_COLORS[c].stp && normalizedAxis <= GRADIENT_COLORS[c + 1].stp) {
                            face.vertexColors[v] = GRADIENT_COLORS[c].col.clone().lerp(GRADIENT_COLORS[c + 1].col,
                                (normalizedAxis - GRADIENT_COLORS[c].stp) / colorDiff);
                        }
                    }
                }
            }
    
            // COMPUTE NORMALS:
            baseGeo.computeVertexNormals(true);
            baseGeo.computeFaceNormals();
    
            // ADD MESH:
            this.baseMesh = new THREE.Mesh(baseGeo, DOME_MATERIAL);
            this.baseMesh.doubleSided = false;
            this.add(this.baseMesh);
        }
    }
    
    module.exports = SkyDome;
    
    
    /***/ }),
    
    /***/ "./src/libs/Terrain.js":
    /*!*****************************!*\
      !*** ./src/libs/Terrain.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
    const UTILS = __webpack_require__(/*! ./utils.js */ "./src/libs/utils.js");
    const config = __webpack_require__(/*! ../config.js */ "./src/config.js");
    const SimplexNoise = __webpack_require__(/*! simplex-noise */ "./node_modules/simplex-noise/simplex-noise.js");
    const easing = __webpack_require__(/*! ./easing.js */ "./src/libs/easing.js").easing;
    
    let isClient = typeof location != "undefined";
    let TERRAIN_MATERIAL;
    if (isClient) {
        TERRAIN_MATERIAL = new THREE.StrippedLambertMaterial({
            color: 0x8c8c8c,
            flatShading: false,
            vertexColors: THREE.VertexColors
        });
    
        // DEBUG:
        // TERRAIN_MATERIAL = new THREE.MeshBasicMaterial({
        //     color: 0xffffff,
        //     vertexColors: THREE.VertexColors
        // });
    }
    
    
    const BIOMES = {
        GRASS: 0,
        MOUNTAIN: 1
    };
    const BIOME_COUNT = Object.keys(BIOMES).length;
    const BIOME_COLORS = {
        [BIOMES.GRASS]: [56, 226, 102],
        [BIOMES.MOUNTAIN]: [160, 160, 160]
    };
    const COLORS = {
        DIRT: [140, 104, 53], // #8c6835
        GRASS: [155, 186, 46], // #4a6904
        MOUNTAIN: [160, 160, 160] // #a0a0a0
    };
    const hexToRGB = hex => hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,
        (m, r, g, b) => '#' + r + r + g + g + b + b)
        .substring(1).match(/.{2}/g)
        .map(x => parseInt(x, 16));
    
    const TARGET_SEGMENT_SIZE = 60;
    const SIZE_MLT = 3;
    class Terrain extends THREE.Object3D {
        static fromConfig(data) {
            // SEE Terrain.CONFIG_PROPS
            return new Terrain(data.terrainSeed, data.terrainWidth,
                data.terrainHeight, data.sizeMlt, data.terrainMntMlt,
                data.terrainDrtCol, data.terrainGrsCol, data.terrainMntCol);
        }
    
        constructor(seed, sizeX, sizeY, sizeMlt, mntMlt, drtCol, grsCol, mntCol) {
            super();
    
            // SETUP:
            sizeMlt = SIZE_MLT;
            this.sizeMlt = sizeMlt;
            // sizeX /= sizeMlt;
            // sizeY /= sizeMlt;
            this.sizeX = UTILS.limitMM(sizeX, config.minTerrainSize, config.maxTerrainSize);
            this.sizeY = UTILS.limitMM(sizeY, config.minTerrainSize, config.maxTerrainSize);
            this.edgeSize = 500;
            this.mntMlt = UTILS.limitMM(mntMlt, config.minMountainMlt, config.maxMountainMlt);
            COLORS.DIRT = hexToRGB(drtCol||"#8c6835");
            COLORS.MOUNTAIN = hexToRGB(mntCol||"#a0a0a0");
            COLORS.GRASS = hexToRGB(grsCol||"#4a6904");
            this.simplex = new SimplexNoise(seed);
    
            // CREATE GEO:
            let xSegmentCount = Math.floor(sizeX / TARGET_SEGMENT_SIZE);
            let ySegmentCount = Math.floor(sizeY / TARGET_SEGMENT_SIZE);
            this.xSegmentCount = xSegmentCount;
            this.ySegmentCount = ySegmentCount;
            let xSegmentSize = (sizeX / xSegmentCount);
            let ySegmentSize = (sizeY / ySegmentCount);
            this.xSegmentSize = xSegmentSize;
            this.ySegmentSize = ySegmentSize;
            let baseGeo = new THREE.BufferGeometry();
    
            // ADD ATTRIBUTES:
            let totalSegmentCount = xSegmentCount * ySegmentCount;
            let vertCount = totalSegmentCount * 6;  // 6 verts per segment (since we need to color each tri differently)
            let positions = new THREE.BufferAttribute(new Float32Array(vertCount * 3), 3);
            baseGeo.setAttribute("position", positions);
            let colors = new THREE.BufferAttribute(new Uint8Array(vertCount * 3), 3, true);
            baseGeo.setAttribute("color", colors);
    
            // STORE ATTRIBUTES FOR QUICK ACCESS:
            this.vertPositions = positions;
    
            // TERRAIN HEIGHTS: (we cache this for performance)
            this.terrainPoints = (xSegmentCount + 1) * (ySegmentCount + 1);
            this.terrainHeights = new Float32Array(this.terrainPoints);
            this.terrainBiomes = new Float32Array(this.terrainPoints * BIOME_COUNT);
            for (let xSeg = 0; xSeg < xSegmentCount + 1; xSeg++) {
                for (let ySeg = 0; ySeg < ySegmentCount + 1; ySeg++) {
                    let i = xSeg + ySeg * (xSegmentCount + 1);  // Index inside mesh
                    let x = this._vertPos(xSeg, xSegmentSize, sizeX);
                    let y = this._vertPos(ySeg, ySegmentSize, sizeY);
                    let [height, biomes] = this.evaluate(x, y);
    
                    // Set height
                    this.terrainHeights[i] = height;
    
                    // Save the biomes
                    this.terrainBiomes.set(biomes, i * BIOME_COUNT);
                }
            }
    
            // UPDATE ATTRIBUTES:
            for (let xSeg = 0; xSeg < xSegmentCount; xSeg++) {
                for (let ySeg = 0; ySeg < ySegmentCount; ySeg++) {
                    // GET PROPERTIES:
                    let i = xSeg + ySeg * xSegmentCount;  // Index inside mesh
                    let i6 = i * 6;
                    let x = this._vertPos(xSeg, xSegmentSize, sizeX);
                    let y = this._vertPos(ySeg, ySegmentSize, sizeY);
    
                    // GET POSITIONS:
                    let p0 = [x, y, this.terrainHeight(xSeg, ySeg)];
                    let p1 = [x + xSegmentSize, y, this.terrainHeight(xSeg + 1, ySeg)];
                    let p2 = [x + xSegmentSize, y + ySegmentSize, this.terrainHeight(xSeg + 1, ySeg + 1)];
                    let p3 = [x, y + ySegmentSize, this.terrainHeight(xSeg, ySeg + 1)];
    
                    // GET AO:
                    let ao0 = this.calcAOWeight(xSeg, ySeg);
                    let ao1 = this.calcAOWeight(xSeg + 1, ySeg);
                    let ao2 = this.calcAOWeight(xSeg + 1, ySeg + 1);
                    let ao3 = this.calcAOWeight(xSeg, ySeg + 1);
                    // ao0 = ao1 = ao2 = ao3 = 0;  // TEMP: Test shading
    
                    // SET POSITIONS
                    positions.setXYZ(i6, ...p0);
                    positions.setXYZ(i6 + 1, ...p1);
                    positions.setXYZ(i6 + 2, ...p2);
    
                    positions.setXYZ(i6 + 3, ...p2);
                    positions.setXYZ(i6 + 4, ...p3);
                    positions.setXYZ(i6 + 5, ...p0);
    
                    // GET CENTROIDS:
                    let centroidA = this._centroid3D(p0, p1, p2);
                    let centroidB = this._centroid3D(p2, p3, p0);
                    let normalA = this._normal3D(p0, p1, p2);
                    let normalB = this._normal3D(p2, p3, p0);
                    let biomeA = this.terrainBiomeAt(centroidA);
                    let biomeB = this.terrainBiomeAt(centroidB);
                    let colorA = this.evaluateColor(centroidA, normalA, biomeA);
                    let colorB = this.evaluateColor(centroidB, normalB, biomeB);
    
                    // SET PER TRIANGLE COLOR:
                    colors.setXYZ(i6, ...this._weightColor(colorA, ao0));
                    colors.setXYZ(i6 + 1, ...this._weightColor(colorA, ao1));
                    colors.setXYZ(i6 + 2, ...this._weightColor(colorA, ao2));
    
                    colors.setXYZ(i6 + 3, ...this._weightColor(colorB, ao2));
                    colors.setXYZ(i6 + 4, ...this._weightColor(colorB, ao3));
                    colors.setXYZ(i6 + 5, ...this._weightColor(colorB, ao0));
                }
            }
    
            if (isClient) {
                // COMPUTE NORMALS:
                baseGeo.computeVertexNormals(true);
                baseGeo.computeFaceNormals();
    
                // ADD MESH:
                this.baseMesh = new THREE.Mesh(baseGeo, TERRAIN_MATERIAL);
                this.baseMesh.receiveShadow = true;
                this.baseMesh.scale.set(sizeMlt, sizeMlt, 1);
                this.add(this.baseMesh);
            }
    
            // RAYCAST UTILS:
            this._raycastRay = new THREE.Ray();
            this._raycastTriA = new THREE.Vector3();
            this._raycastTriB = new THREE.Vector3();
            this._raycastTriC = new THREE.Vector3();
            this._raycastTriangle = new THREE.Triangle();
            this._raycastNormal = new THREE.Vector3();
            this._raycastTarget = new THREE.Vector3();
            this._raycastClosestTarget = new THREE.Vector3();
        }
    
        terrainIndex(xSeg, ySeg) {
            let index = xSeg + ySeg * (this.xSegmentCount + 1);
            if (index < 0 || index >= this.terrainHeights.length) return 0;
            return index;
        }
    
        terrainHeight(xSeg, ySeg) {
            // TERRAIN HEIGHT FOR SEGMENT:
            return this.terrainHeights[this.terrainIndex(xSeg, ySeg)];
        }
    
        terrainBiome(xSeg, ySeg) {
            // TERRAIN BIOME FOR SEGMENT:
            let startIndex = this.terrainIndex(xSeg, ySeg) * BIOME_COUNT;
            return this.terrainBiomes.slice(startIndex, startIndex + BIOME_COUNT);
        }
    
        terrainBiomeAt(x, y) {
            let xSeg0 = Math.floor(x / this.xSegmentSize);
            let xSeg1 = Math.ceil(x / this.xSegmentSize);
            let ySeg0 = Math.floor(y / this.ySegmentSize);
            let ySeg1 = Math.ceil(y / this.ySegmentSize);
    
            let b0 = this.terrainBiome(xSeg0, ySeg0);
            let b1 = this.terrainBiome(xSeg1, ySeg0);
            let b2 = this.terrainBiome(xSeg0, ySeg1);
            let b3 = this.terrainBiome(xSeg1, ySeg1);
    
            return (b0 + b1 + b2 + b3) / 4;
        }
    
        calcAOWeight(xSeg, ySeg) {
    
            // GET VERT POSITION:
            let x = this._vertPos(xSeg, this.xSegmentSize, this.sizeX);
            let y = this._vertPos(ySeg, this.ySegmentSize, this.sizeY);
    
            // GET ANGLE ON TOP SIDE OF TERRAIN:
            let xAngle = this._topAngleOnTerrain(
                x - this.xSegmentSize, this.terrainHeight(xSeg - 1, ySeg),
                x, this.terrainHeight(xSeg, ySeg),
                x + this.xSegmentSize, this.terrainHeight(xSeg + 1, ySeg),
            );
            let yAngle = this._topAngleOnTerrain(
                y - this.xSegmentSize, this.terrainHeight(xSeg, ySeg - 1),
                y, this.terrainHeight(xSeg, ySeg),
                y + this.ySegmentSize, this.terrainHeight(xSeg, ySeg + 1),
            );
    
            // CALCULATE WEIGHTS:
            let compAngle = Math.PI;
            let xWeight = Math.max(compAngle - xAngle, 0) / compAngle;
            let yWeight = Math.max(compAngle - yAngle, 0) / compAngle;
    
            // COMBINE WEIGHTS:
            let tmpW = (1 - (1 - xWeight) * (1 - yWeight));
            if (tmpW >= 0.5) tmpW = 0.65;
            else if (tmpW >= 0.2) tmpW = 0.3;
            else if (tmpW >= 0.1) tmpW = 0.25;
            return tmpW;
        }
    
        // heightAt(x, y) {
        //     // INTERPOLATED HEIGHT FOR POSITION:
        //
        //     x /= this.sizeMlt;
        //     y /= this.sizeMlt;
        //
        //     let xSeg = Math.floor(this._worldToLocal(x, this.sizeX, this.xSegmentSize));
        //     let ySeg = Math.floor(this._worldToLocal(y, this.sizeY, this.ySegmentSize));
        //
        //     let progressX = modFix(this._worldToLocal(x), this.xSegmentSize) / this.xSegmentSize;
        //     let progressY = modFix(this._worldToLocal(y), this.ySegmentSize) / this.ySegmentSize;
        //
        //     // SAMPLE LEFT AND RIGHT SIDE OF QUAD:
        //     let leftLerp = lerp(this.terrainHeight(xSeg, ySeg), this.terrainHeight(xSeg, ySeg + 1), progressY);
        //     let rightLerp = lerp(this.terrainHeight(xSeg + 1, ySeg), this.terrainHeight(xSeg + 1, ySeg + 1), progressY);
        //
        //     return lerp(leftLerp, rightLerp, progressX);
        // }
        //
        // normalAt(x, y) {
        //     // TODO: SIZE MULT
        //
        //     let xSeg0 = Math.floor(x / this.xSegmentSize);
        //     let ySeg0 = Math.floor(y / this.ySegmentSize);
        //     let xSeg1 = xSeg0 + 1;
        //     let ySeg1 = ySeg0 + 1;
        //
        //     let progressX = modFix(x, this.xSegmentSize) / this.xSegmentSize;
        //     let progressY = modFix(y, this.ySegmentSize) / this.ySegmentSize;
        //
        //     // let x0 = this.heigh
        // }
    
        _worldToLocal(v, sizeV, vSegmentSize) {
            // ASSUMES ALREADY DIVIDED `v` by `this.sizeMlt`
            return (v + sizeV / 2) / vSegmentSize;
        }
    
        raycast(oX, oY, oZ, dX, dY, dZ, calcNormal = false) {
            // CONVERT COORDINATE SPACE FOR X AND Y:
            oX /= this.sizeMlt;
            oY /= this.sizeMlt;
            dX /= this.sizeMlt;
            dY /= this.sizeMlt;
    
            // SETUP DATA:
            let maxDist = Math.sqrt(dX * dX + dY * dY + dZ * dZ);
            this._raycastRay.origin.set(oX, oY, oZ);
            this._raycastRay.direction.set(dX, dY, dZ);
    
            // CONVERT PROPERTIES TO WORK WITH CODE:
            let x0 = this._worldToLocal(oX, this.sizeX, this.xSegmentSize), y0 = this._worldToLocal(oY, this.sizeY, this.ySegmentSize);
            let x1 = x0 + dX / this.xSegmentSize, y1 = y0 + dY / this.ySegmentSize;
    
            // FROM: http://playtechs.blogspot.com/2007/03/raytracing-on-grid.html
            let sdx = Math.abs(x1 - x0);
            let sdy = Math.abs(y1 - y0);
    
            let x = Math.floor(x0);
            let y = Math.floor(y0);
    
            let n = 1;
            let xInc, yInc;
            let error;
    
            if (sdx == 0) {
                xInc = 0;
                error = Number.POSITIVE_INFINITY;
            } else if (x1 > x0) {
                xInc = 1;
                n += Math.floor(x1) - x;
                error = (Math.floor(x0) + 1 - x0) * sdy;
            } else {
                xInc = -1;
                n += x - Math.floor(x1);
                error = (x0 - Math.floor(x0)) * sdy;
            }
    
            if (sdy == 0) {
                yInc = 0;
                error -= Number.POSITIVE_INFINITY;
            } else if (y1 > y0) {
                yInc = 1;
                n += Math.floor(y1) - y;
                error -= (Math.floor(y0) + 1 - y0) * sdx;
            } else {
                yInc = -1;
                n += y - Math.floor(y1);
                error -= (y0 - Math.floor(y0)) * sdx;
            }
    
            for (; n > 0; n--) {
    
                // VISIT CELL:
                let foundTri = this._raycastVisit(x, y, oX, oY, oZ, dX, dY, dZ, maxDist, calcNormal);
                if (foundTri) {
                    // CONVERT COORDINATE SPACE:
                    let result = this._raycastClosestTarget;
                    result.x *= this.sizeMlt;
                    result.y *= this.sizeMlt;
    
                    return result;
                }
    
                // STEP BLOCK:
                if (error > 0) {
                    y += yInc;
                    error -= sdx;
                } else {
                    x += xInc;
                    error += sdy;
                }
            }
        }
    
        _raycastVisit(xSeg, ySeg, x0, y0, z0, x1, y1, z1, maxDist, calcNormal) {
            // CALCULATE INDEXES:
            let baseI = xSeg + ySeg * this.xSegmentCount;  // Index inside mesh
    
            // FIND CLOSEST POINT:
            let closestDist = Number.POSITIVE_INFINITY;
            let foundClosest = false;
            for (let j = 0; j < 2; j++) {
                // GET INDEX FOR INDIVIDUAL TRIANGLE:
                let i = baseI * 6 + j * 3;
    
                // SETUP DATA:
                this._raycastTriA.set(this.vertPositions.getX(i), this.vertPositions.getY(i), this.vertPositions.getZ(i));
                this._raycastTriB.set(this.vertPositions.getX(i + 1), this.vertPositions.getY(i + 1), this.vertPositions.getZ(i + 1));
                this._raycastTriC.set(this.vertPositions.getX(i + 2), this.vertPositions.getY(i + 2), this.vertPositions.getZ(i + 2));
    
                // PERFORM INTERSECTION:
                let result = this._raycastRay.intersectTriangle(this._raycastTriA, this._raycastTriB, this._raycastTriC, true, this._raycastTarget);
                if (result) {
                    let dist = result.distanceTo(this._raycastRay.origin);
                    if (dist < closestDist && dist < maxDist) {
                        closestDist = dist;
                        foundClosest = true;
                        this._raycastClosestTarget.copy(result);
                        this._raycastTriangle.set(this._raycastTriA, this._raycastTriB, this._raycastTriC);
                    }
                }
            }
    
            // CALC NORMAL IF NEEDED:
            if (calcNormal && foundClosest) {
                this._raycastTriangle.getNormal(this._raycastNormal);
            }
    
            return foundClosest;
        }
    
        evaluate(x, y) {
            let v = 0;
            this.sampleIndex = 0;
    
            // Get samples and convert to percentages
            let biomeSamples = [];
            for (let i = 0; i < BIOME_COUNT; i++) {
                biomeSamples.push(this._sample(x, y, 1300));
            }
            // biomeSamples[BIOMES.GRASS] = 0;
            // biomeSamples[BIOMES.MOUNTAIN] = 1;
            // biomeSamples[BIOMES.DESERT] = 0;
            let biomeSum = biomeSamples.reduce((prev, curr) => prev + curr, 0);
            biomeSamples = biomeSamples.map((v, i) => [i, v / biomeSum]);  // Map to % total tagged with biome index
            biomeSamples = biomeSamples.sort((a, b) => b[1] - a[1]);
    
            // Ease biomes
            let biomes = {};
            let [firstI, firstV] = biomeSamples[0];
            biomes[firstI] = this._easeTerrain(firstV / (firstV + biomeSamples[1][1]));  // Get percent between first and second
            for (let i = 1; i < biomeSamples.length; i++) {
                let [currI, currV] = biomeSamples[i];
                biomes[currI] = this._easeTerrain(currV / (firstV + currV));
            }
    
            // Grass
            let grassSample = this._sample(x, y, 300);
            let grassSteps = 3;
            grassSample = Math.floor(grassSample * grassSteps) / grassSteps;
            v += (grassSample * 25 * biomes[BIOMES.GRASS]) * this.sizeMlt;
    
            // Mountain
            let mRidgeCenter = 0.4 + this._sample(x, y, 200) * 0.3;  // Find the center of the ridge; this gives it a bit more wavy and hilly effect
            let mRidgeDistance = 1 - Math.abs(mRidgeCenter - this._sample(x, y, 500)) * 2;  // Create sharp tops (combined with log later)
            let mEmphasis = (0.4 + this._sample(x, y, 400) * 1.4);
            v += (mRidgeDistance * mEmphasis * (220 * this.mntMlt) * biomes[BIOMES.MOUNTAIN]) * this.sizeMlt;
    
            // Edge fade
            let fade = this._calcEdgeFade(x, this.sizeX) * this._calcEdgeFade(y, this.sizeY);
            v *= fade;  // Remove terrain features
            v += (fade - 1) * 2000;  // Sink below the ocean
            if (Math.abs(x) >= this.sizeX / 2 || Math.abs(y) >= this.sizeY / 2) v = -1000;
    
            return [v, biomes];
        }
    
        evaluateColor(centroid, normal, biome) {
    
            // CALC ANGLE:
            let height = centroid[2];
            let xAngle = Math.atan2(Math.abs(normal[0]), Math.abs(normal[2]));
            let yAngle = Math.atan2(Math.abs(normal[1]), Math.abs(normal[2]));
    
            // CALC COLOR:
            let xShade = (1 - xAngle / (Math.PI * 2));
            let yShade = (1 - yAngle / (Math.PI * 2));
            let slopeShade = (xShade * yShade);
            let color;
            if (slopeShade <= 0.85) color = COLORS.MOUNTAIN;
            else if (height > 100) color = COLORS.MOUNTAIN;
            else if (height > 5) color = COLORS.GRASS;
            else color = COLORS.DIRT;
    
            // color = [0, slopeShade * 255, 0];
    
            return color;
        }
    
        _sample(x, y, divisor) {
            this.sampleIndex++;
            return this.simplex.noise3D(x / divisor, y / divisor, this.sampleIndex * 10000) / 2 + 0.5;
        }
    
        _easeTerrain(v) {
            return easing.easeInOutQuint(easing.easeInOutQuint(v));
        }
    
        _calcEdgeFade(x, size) {
            if (Math.abs(x) >= size / 2) return 0;  // Don't do anything beyond the edge
            let fade = (Math.abs(x) - (size / 2) + this.edgeSize) / this.edgeSize;
            fade = 1 - Math.max(fade, 0);
            return easing.easeOutQuint(fade);
        }
    
        _blendColors(biomes) {
    
            // Get the total biome weight
            let biomeTotal = Object.values(biomes).reduce((prev, curr) => prev + curr, 0);
    
            // Blend the colors
            let color = [0, 0, 0];
            for (let biomeId in biomes) {
                let biomeColor = BIOME_COLORS[biomeId];
                let biomeWeight = biomes[biomeId] / biomeTotal;
                for (let i = 0; i < 3; i++) {
                    color[i] += biomeColor[i] * biomeWeight;
                }
            }
            return color;
        }
    
        _vertPos(vIndex, vSegmentSize, sizeV) {
            return vIndex * vSegmentSize - sizeV / 2;
        }
    
        _avgPos(pointA, pointB) {
            return [
                (pointA[0] + pointB[0]) / 2,
                (pointA[1] + pointB[1]) / 2,
                (pointA[2] + pointB[2]) / 2,
            ]
        }
    
        _centroid3D(a, b, c) {
            let centerX = ((a[0] + b[0] + c[0]) / 3);
            let centerY = ((a[1] + b[1] + c[1]) / 3);
            let centerZ = ((a[2] + b[2] + c[2]) / 3);
    
            return [centerX, centerY, centerZ];
        }
    
        _normal3D(a, b, c) {
            // C - B:
            let cbX = c[0] - b[0];
            let cbY = c[1] - b[1];
            let cbZ = c[2] - b[2];
    
            // A - B:
            let abX = a[0] - b[0];
            let abY = a[1] - b[1];
            let abZ = a[2] - b[2];
    
            // CB X AB
            let nX = cbY * abZ - cbZ * abY;
            let nY = cbZ * abX - cbX * abZ;
            let nZ = cbX * abY - cbY * abX;
    
            // NORMALIZE:
            let L = Math.sqrt(nX * nX + nY * nY + nZ + nZ);
            return [nX / L, nY / L, nZ / L];
        }
    
        _topAngleOnTerrain(x0, y0, x1, y1, x2, y2) {
            let atanA = Math.atan2(y0 - y1, x0 - x1);
            let atanB = Math.atan2(y2 - y1, x2 - x1);
            if (atanA < 0) atanA += Math.PI * 2;
            return atanA - atanB;
        }
    
        _weightColor(color, weight) {
            let m = 1 - weight;
            return color.map(v => v * m);
    
            // DEBUG MATCAP:
            // m *= 255;
            // return [m, m, m];
        }
    }
    
    Terrain.CONFIG_PROPS = [
        "terrainSeed",
        "terrainWidth",
        "terrainHeight",
        "sizeMlt",
        "terrainMntMlt",
        "terrainDrtCol",
        "terrainGrsCol",
        "terrainMntCol",
    ];
    
    function modFix(a, b) {
        return ((a % b) + b) % b;
    }
    
    function lerp(v0, v1, t) {
        return v0*(1-t)+v1*t
    }
    
    module.exports = Terrain;
    
    
    /***/ }),
    
    /***/ "./src/libs/Zone.js":
    /*!**************************!*\
      !*** ./src/libs/Zone.js ***!
      \**************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    
    // INIT:
    const COLORS = __webpack_require__(/*! ../data/colors.js */ "./src/data/colors.js");
    const THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
    const UTILS = __webpack_require__(/*! ../libs/utils.js */ "./src/libs/utils.js");
    const config = __webpack_require__(/*! ../config.js */ "./src/config.js");
    const SEGMENTS = 32;
    var DOME_TEXTURE;
    var DOME_MATERIAL;
    const GRADIENT_REVERSE = true;
    const GRADIENT_AXIS = 'y';
    const GRADIENT_COLORS = [{
        stp: 0,
        col: null
    }, {
        stp: .5,
        col: null
    }, {
        stp: 1,
        col: null
    }];
    const SHRINK_AMOUNT = 2.5;
    const DOME_HEIGHT = 1000;
    class Zone extends THREE.Object3D {
        static fromConfig(data, RENDER) {
            // SEE Zone.CONFIG_PROPS
            return new Zone(data.zoneSize, data.zoneSpeed,
                data.zoneCol0, data.zoneCol1, data.zoneCol2, RENDER);
        }
    
        // INIT:
        constructor(_size, speed, col0, col1, col2, RENDER) {
            super();
    
            // SETUP:
            this._size = UTILS.limitMM((_size||50), config.minZoneSize, config.maxZoneSize);
            this._shrink = SHRINK_AMOUNT * UTILS.limitMM((speed||1),
                config.minShrinkSpeed, config.maxShrinkSpeed);
    
            // SETUP MESH AND TEXTURE:
            if (RENDER) {
                if (!DOME_TEXTURE) DOME_TEXTURE = new THREE.TextureLoader()
                    .load(UTILS.assetsUrl("/textures/zone_0.png"), texture => {
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.minFilter = THREE.NearestFilter;
                    texture.magFilter = THREE.NearestFilter;
                    texture.repeat.set(20, 20);
                    texture.needsUpdate = true;
                });
                if (!DOME_MATERIAL) DOME_MATERIAL = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    depthWrite: false,
                    flatShading: false,
                    map: DOME_TEXTURE,
                    vertexColors: THREE.VertexColors,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.5
                });
    
                // COLORS:
                GRADIENT_COLORS[0].col = new THREE.Color(col0 || COLORS.zones.BR[0]);
                GRADIENT_COLORS[1].col = new THREE.Color(col1 || COLORS.zone.BR[1]);
                GRADIENT_COLORS[2].col = new THREE.Color(col2 || COLORS.zone.BR[2]);
    
                // CREATE GEO:
                let baseGeo = new THREE.SphereGeometry(1, SEGMENTS, SEGMENTS);
                baseGeo.computeBoundingBox();
                let bbox = baseGeo.boundingBox;
                let size = new THREE.Vector3().subVectors(bbox.max, bbox.min);
                let vertexIndices = ['a', 'b', 'c'];
                let face, normalized = new THREE.Vector3(), normalizedAxis = 0;
                for (let c = 0; c < GRADIENT_COLORS.length - 1; c++) {
                    let colorDiff = GRADIENT_COLORS[c + 1].stp - GRADIENT_COLORS[c].stp;
                    for (let i = 0; i < baseGeo.faces.length; i++) {
                        let face = baseGeo.faces[i];
                        for (var v = 0; v < 3; v++) {
                            normalizedAxis = normalized.subVectors(baseGeo.vertices[face[vertexIndices[v]]],
                                bbox.min).divide(size)[GRADIENT_AXIS];
                            if (GRADIENT_REVERSE) normalizedAxis = 1 - normalizedAxis;
                            if (normalizedAxis >= GRADIENT_COLORS[c].stp && normalizedAxis <= GRADIENT_COLORS[c + 1].stp) {
                                face.vertexColors[v] = GRADIENT_COLORS[c].col.clone().lerp(GRADIENT_COLORS[c + 1].col,
                                    (normalizedAxis - GRADIENT_COLORS[c].stp) / colorDiff);
                            }
                        }
                    }
                }
    
                // COMPUTE NORMALS:
                baseGeo.computeVertexNormals(true);
                baseGeo.computeFaceNormals();
    
                // ADD MESH:
                this.baseMesh = new THREE.Mesh(baseGeo, DOME_MATERIAL);
    
            }
    
            // FINALIZE AND ADD:
            this.destination = null;
            this.reset();
            if (RENDER) this.add(this.baseMesh);
        }
    
        // UPDATE SIZE:
        shrink() {
            if (this.scale.x <= 0) this.visible = false;
            else {
                this.scale.x -= this._shrink;
                this.scale.z -= this._shrink;
                if (this.destination) {
                    var currX = this.position.x;
                    var currZ = this.position.z;
    
                    var diffX = Math.abs(currX - this.destination[0]);
                    var diffZ = Math.abs(currZ - this.destination[2]);
                    if ((currX + (this.scale.x / 2)) > this.destination[0]) {
                        currX -= (this._shrink / (diffX>diffZ ? diffZ / diffX:1));
                        if ((currX + (this.scale.x / 2)) < this.destination[0])
                            currX = this.destination[0] + (this.scale.x / 2);
                    } else if ((currX + (this.scale.x / 2)) < this.destination[0]) {
                        currX += (this._shrink / (diffX>diffZ ? diffZ / diffX:1));
                        if ((currX + (this.scale.x / 2)) > this.destination[0])
                            currX = this.destination[0] - (this.scale.x / 2);
                    }
    
                    if ((currZ + (this.scale.z / 2)) > this.destination[2]) {
                        currZ -= (this._shrink / (diffZ>diffX ? diffX / diffZ:1));
                        if ((currZ + (this.scale.z / 2)) < this.destination[2])
                            currZ = this.destination[2] + (this.scale.z / 2);
                    } else if ((currZ + (this.scale.z / 2)) < this.destination[2]) {
                        currZ += (this._shrink / (diffZ>diffX ? diffX / diffZ:1));
                        if ((currZ + (this.scale.z / 2)) > this.destination[2])
                            currZ = this.destination[2] - (this.scale.z / 2);
                    }
    
                    this.position.set(currX, this.position.y, currZ);
                }
            }
        }
    
        // CLIENT ANIMATION:
        animate(delta) {
            if (this.baseMesh && this.baseMesh.material.map) {
                this.baseMesh.material.map.offset.y += 0.00003 * delta;
            }
        }
    
        // UPDATE DOME:
        update(size, pos, des) {
            this.scale.set(size.x, DOME_HEIGHT, size.z);
            if (pos) this.position.set(pos.x, 0, pos.z);
            if (des) this.destination = des;
            if (this.scale.x <= 0) this.visible = false;
        }
    
        // RESET EVERYTHING:
        reset(des) {
            this.scale.set(this._size, DOME_HEIGHT, this._size);
            this.position.set(0, 0, 0);
            if (des) this.destination = des;
            this.visible = true;
        }
    
        // CHECK PLAYER COLLISION:
        isOutside(player) {
            return UTILS.getDistance(player.x, player.z,
                this.position.x, this.position.z) > this.scale.x;
        }
    }
    
    Zone.CONFIG_PROPS = [
        "zoneSize",
        "zoneSpeed",
        "zoneCol0",
        "zoneCol1",
        "zoneCol2",
    ];
    
    module.exports = Zone;
    
    
    /***/ }),
    
    /***/ "./src/libs/easing.js":
    /*!****************************!*\
      !*** ./src/libs/easing.js ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    /*
     * Easing Functions - inspired from http://gizma.com/easing/
     * only considering the t value for the range [0, 1] => [0, 1]
     */
    module.exports.easing = {
        // no easing, no acceleration
        linear: function (t) { return t },
        // accelerating from zero velocity
        easeInQuad: function (t) { return t * t },
        // decelerating to zero velocity
        easeOutQuad: function (t) { return t * (2 - t) },
        // acceleration until halfway, then deceleration
        easeInOutQuad: function (t) { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t },
        // accelerating from zero velocity 
        easeInCubic: function (t) { return t * t * t },
        // decelerating to zero velocity 
        easeOutCubic: function (t) { return (--t) * t * t + 1 },
        // acceleration until halfway, then deceleration 
        easeInOutCubic: function (t) { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1 },
        // accelerating from zero velocity 
        easeInQuart: function (t) { return t * t * t * t },
        // decelerating to zero velocity 
        easeOutQuart: function (t) { return 1 - (--t) * t * t * t },
        // acceleration until halfway, then deceleration
        easeInOutQuart: function (t) { return t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t },
        // accelerating from zero velocity
        easeInQuint: function (t) { return t * t * t * t * t },
        // decelerating to zero velocity
        easeOutQuint: function (t) { return 1 + (--t) * t * t * t * t },
        // acceleration until halfway, then deceleration 
        easeInOutQuint: function (t) { return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t },
    };
    
    
    /***/ }),
    
    /***/ "./src/libs/errors.js":
    /*!****************************!*\
      !*** ./src/libs/errors.js ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    /* WEBPACK VAR INJECTION */(function(process) {const config = __webpack_require__(/*! ../config.js */ "./src/config.js");
    
    let Sentry;
    if (config.isNode && process.env.IS_PROD) {
        // INITIATE SENTRY:
        Sentry = ( true ? require : undefined)("@sentry/node");
        Sentry.init({
            environment: (process.env.VULTR_SCHEME || "local").replace("_", " ").replace("-", " "),
            dsn: process.env.SENTRY_DSN,
            ignoreErrors: ["Request failed with status code 400"]
        });
    
        // LINK TO SERVER MANAGER:
        // const ServerManager = require("../../sid-utils/server-manager").default;
        // ServerManager.linkSentry(Sentry);
    }
    
    module.exports = {
        capture(e) {
            // SEND TO SENTRY OR LOG ON DEV:
            if (Sentry) Sentry.captureException(e);
            console.warn("UNCAUGHT EXCEPTION:", e)
        },
    
        warn(msg, meta = null) {
            // SEND TO SENTRY OR LOG ON DEV:
            if (Sentry) {
                Sentry.withScope(scope => {
                    if (meta) scope.setExtra("meta", JSON.stringify(meta));
                    Sentry.captureMessage(msg);
                });
            } else {
                console.warn("WARNING:", msg, meta);
            }
        }
    };
    
    /* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/process/browser.js */ "./node_modules/process/browser.js")))
    
    /***/ }),
    
    /***/ "./src/libs/geos.js":
    /*!**************************!*\
      !*** ./src/libs/geos.js ***!
      \**************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    var THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
    
    // IMPORTS:
    const config = __webpack_require__(/*! ../config.js */ "./src/config.js");
    const UTILS = __webpack_require__(/*! ./utils.js */ "./src/libs/utils.js");
    
    // COLORS:
    var colors = {};
    module.exports.getColor = function(color, mlt) {
        var tmpIndx = color + "-" + (mlt||"");
        var tmpCol = colors[tmpIndx];
        if (!tmpCol) {
            tmpCol = new THREE.Color(color);
            if (mlt) tmpCol.multiplyScalar(mlt);
            colors[tmpIndx] = tmpCol;
        } return tmpCol;
    };
    
    // COLORIZE:
    module.exports.colorize = function(geo, color, colorO) {
        color = colorO||module.exports.getColor(color);
        for (var i = 0; i < geo.faces.length; ++i) {
            geo.faces[i].vertexColors[0] = color;
            geo.faces[i].vertexColors[1] = color;
            geo.faces[i].vertexColors[2] = color;
        }
    };
    
    // UVS:
    var tmpGeo;
    var scaleUV = function(geo, x, y, s) {
        var scaleVector = new THREE.Vector2(x, y).multiplyScalar(s||1);
        for (var i = 0; i < geo.faceVertexUvs.length; i++) {
            var uv = geo.faceVertexUvs[i];
            for (var j = 0; j < uv.length; j++) {
                for (var k = 0; k < 3; k++) {
                    var v = uv[j][k].multiply(scaleVector);
                    v.x = 0.5 + v.x - scaleVector.x / 2;
                }
            }
        }
    };
    
    // POINT IN RECT:
    var pointInRect = function(x, y, x2, y2, w, l) {
        return (x >= x2 - w && x <= x2 + w && y >= y2 - l && y <= y2 + l);
    };
    
    // PLANE GENERATOR:
    var cachedPlanes = [];
    var faceIndices = ['a', 'b', 'c', 'd'];
    module.exports.generatePlane = function(w, l, data, xP, yP, zP) {
        w *= data.ratio||1;
        var tmpIndx = (data.scale?(w + "_" + l + "_"):"") + (data.scale||"") + (data.tilesX||"")
            + (data.tilesZ||"") + (data.noise?(xP+"_"+yP+"_"+zP):"")
            + (data.colr!=undefined?data.colr:"") + (data.dark||"");
        tmpGeo = cachedPlanes[tmpIndx];
        if (!tmpGeo) {
            tmpGeo = new THREE.PlaneGeometry(1, 1, data.tilesX||1, data.tilesZ||1);
            if (data.noise) {
                var tmpColors = {};
                var tmpM = data.margin||0;
                for (var i = 0; i < tmpGeo.vertices.length; ++i) {
                    var tX = tmpGeo.vertices[i].x;
                    var tY = tmpGeo.vertices[i].y;
                    if (!data.pinEdges || (tX != -0.5 && tX != 0.5 && tY != -0.5 && tY != 0.5)) {
                        if (data.objects) {
                            for (var x = 0; x < data.objects.length; ++x) {
                                if (data.objects[x].y - data.objects[x].height <= yP + 0.1 &&
                                    data.objects[x].y + data.objects[x].height > yP + data.noise
                                    && pointInRect(zP + (-tY * w * 2), xP + (tX * l * 2), data.objects[x].z, data.objects[x].x,
                                    data.objects[x].length + tmpM, data.objects[x].width + tmpM)) {
                                    tmpGeo.vertices[i].z = (Math.random() * data.noise) + 1;
                                    tmpColors[i] = module.exports.getColor(data.colr, 0.6);
                                    break;
                                }
                            }
                        } else tmpGeo.vertices[i].z = Math.random() * data.noise;
                    }
                    if (!tmpColors[i]) tmpColors[i] = module.exports.getColor(data.colr);
                }
    
                // APPLY COLORS AND CLEAN GEO:
                for (var i = 0; i < tmpGeo.faces.length; i++) {
                    var tmpFace = tmpGeo.faces[i];
                    var removeC = 0;
                    for (var j = 0; j < 3; j++) {
                        tmpFace.vertexColors[j] = tmpColors[tmpFace[faceIndices[j]]];
                        if (tmpGeo.vertices[tmpFace[faceIndices[j]]].z <= 0) removeC++;
                    }
                    if (removeC >= 3) delete tmpGeo.faces[i];
                }
                tmpGeo.faces = tmpGeo.faces.filter(function(v){return v});
                tmpGeo.elementsNeedUpdate = true;
            } else {
                module.exports.colorize(tmpGeo, null,
                    module.exports.getColor(data.colr
                    ||0xffffff, data.dark||1));
            }
            if (data.scale) scaleUV(tmpGeo, l / config.worldUV, w / config.worldUV, data.scale);
            tmpGeo.computeVertexNormals();
            cachedPlanes[tmpIndx] = tmpGeo;
        }
        return tmpGeo;
    };
    
    // CUBE GENERATOR:
    var cachedCubes = [];
    module.exports.generateCube = function(sides, w, h, l, data) {
        sides = sides||[1,1,1,1,1,1];
        data.flipp = ((w>h||l>h) && data.src == "floor_0");
        data.flippW = (w > l && data.src == "floor_0");
        var tmpIndx = (data.scale?w + "_" + h + "_" + l + "_":"") + (data.colr!=undefined?data.colr:"")
            + (data.scale||"") + (data.flippW?"flw":"fnw") + (data.flipp?"fl":"fn")
            + (data.amb||"") + (data.fAmb||"")
            + (data.useScale||"");
        for (var i = 0; i < sides.length; ++i) tmpIndx += "_" + sides[i];
        tmpGeo = cachedCubes[tmpIndx];
        if (!tmpGeo) {
    
            // COLORS:
            data.colr = (data.colr!=undefined?data.colr:0xffffff);
            var light = module.exports.getColor(data.colr);
            var shadow = (data.amb?module.exports.getColor(
                data.colr, data.amb):light);
            if (data.fAmb) {
                var tmpLi = light;
                light = shadow;
                shadow = tmpLi;
            }
    
            // CREATE OBJECTS:
            tmpGeo = new THREE.Geometry();
            var geos = [];
            var tmpPlane;
            if (sides[0]) { // Right
                tmpPlane = new THREE.PlaneGeometry(1, 1);
                tmpPlane.rotateY(Math.PI / 2);
                if (data.flipp) tmpPlane.rotateX(Math.PI / 2);
                tmpPlane.translate(.5, .5, 0);
                tmpPlane.faces[0].vertexColors = [light, shadow, light];
                tmpPlane.faces[1].vertexColors = [shadow, shadow, light];
                if (data.scale) scaleUV(tmpPlane, (data.flipp?h:l) / config.worldUV,
                    (data.flipp?l:h) / config.worldUV, data.scale);
                geos.push(tmpPlane);
            } if (sides[1]) { // Left
                tmpPlane = new THREE.PlaneGeometry(1, 1);
                tmpPlane.rotateY(-Math.PI / 2);
                if (data.flipp) tmpPlane.rotateX(Math.PI / 2);
                tmpPlane.translate(-.5, .5, 0);
                tmpPlane.faces[0].vertexColors = [light, shadow, light];
                tmpPlane.faces[1].vertexColors = [shadow, shadow, light];
                if (data.scale) scaleUV(tmpPlane, (data.flipp?h:l) / config.worldUV,
                    (data.flipp?l:h) / config.worldUV, data.scale);
                geos.push(tmpPlane);
            } if (sides[2]) { // Top
                tmpPlane = new THREE.PlaneGeometry(1, 1);
                tmpPlane.rotateX(-Math.PI / 2);
                if (data.flippW) tmpPlane.rotateY(Math.PI / 2);
                tmpPlane.translate(0, 1, 0);
                tmpPlane.faces[0].vertexColors = [light, light, light];
                tmpPlane.faces[1].vertexColors = [light, light, light];
                if (data.scale) scaleUV(tmpPlane, (data.flippW?l:w) / config.worldUV,
                    (data.flippW?w:l) / config.worldUV, data.scale);
                geos.push(tmpPlane);
            } if (sides[3]) { // Bottom
                tmpPlane = new THREE.PlaneGeometry(1, 1);
                tmpPlane.rotateX(Math.PI / 2);
                if (data.flippW) tmpPlane.rotateY(Math.PI / 2);
                tmpPlane.translate(0, 0, 0);
                tmpPlane.faces[0].vertexColors = [shadow, shadow, shadow];
                tmpPlane.faces[1].vertexColors = [shadow, shadow, shadow];
                if (data.scale) scaleUV(tmpPlane, (data.flippW?l:w) / config.worldUV,
                     (data.flippW?w:l) / config.worldUV, data.scale);
                geos.push(tmpPlane);
            } if (sides[4]) { // Back
                tmpPlane = new THREE.PlaneGeometry(1, 1);
                if (data.flipp) tmpPlane.rotateZ(Math.PI / 2);
                tmpPlane.translate(0, .5, .5);
                tmpPlane.faces[0].vertexColors = [light, shadow, light];
                tmpPlane.faces[1].vertexColors = [shadow, shadow, light];
                if (data.scale) scaleUV(tmpPlane, (data.flipp?h:w) / config.worldUV,
                    (data.flipp?w:h) / config.worldUV, data.scale);
                geos.push(tmpPlane);
            } if (sides[5]) { // Front
                tmpPlane = new THREE.PlaneGeometry(1, 1);
                tmpPlane.rotateY(Math.PI);
                if (data.flipp) tmpPlane.rotateZ(Math.PI / 2);
                tmpPlane.translate(0, .5, -.5);
                tmpPlane.faces[0].vertexColors = [light, shadow, light];
                tmpPlane.faces[1].vertexColors = [shadow, shadow, light];
                if (data.scale) scaleUV(tmpPlane, (data.flipp?h:w) / config.worldUV,
                    (data.flipp?w:h) / config.worldUV, data.scale);
                geos.push(tmpPlane);
            } for (var i = 0; i < geos.length; i++) tmpGeo.merge(geos[i], new THREE.Matrix4());
            if (data && data.useScale) {
                tmpGeo.scale(w, h, l);
                tmpGeo.translate(0, -h / 2, 0);
            } cachedCubes[tmpIndx] = tmpGeo;
        }
        return tmpGeo;
    }
    
    // CONE GENERATOR:
    var cachedCones = [];
    module.exports.generateCone = function(w, h, l, data) {
        var tmpIndx = (data.scale?w + "_" + h + "_" + l + "_":"")
            + (data.scale||"") + (data.useScale||"")
            + (data.colr!=undefined?data.colr:"") + (data.dark||"");
        tmpGeo = cachedCones[tmpIndx];
        if (!tmpGeo) {
            // CREATE OBJECTS:
            tmpGeo = new THREE.ConeGeometry(Math.min(w, l) / 2, h,
                12, 12, true);
            if (data && !data.useScale) {
                tmpGeo.translate(0, h/2, 0);
            }
            module.exports.colorize(tmpGeo, null,
                module.exports.getColor(data.colr
                ||0xffffff, data.dark||1));
            cachedCones[tmpIndx] = tmpGeo;
        }
        return tmpGeo;
    }
    
    // CUBE GENERATOR:
    var cachedSpheres = [];
    module.exports.generateSphere = function(w, h, l, data) {
        var tmpIndx = (data.scale?w + "_" + h + "_" + l + "_":"") + (data.colr!=undefined?data.colr:"")
            + (data.scale||"") + (data.amb||"") + (data.fAmb||"")
            + (data.useScale||"");
        tmpGeo = cachedSpheres[tmpIndx];
        if (!tmpGeo) {
    
            // COLORS:
            data.colr = (data.colr!=undefined?data.colr:0xffffff);
    
            // CREATE OBJECTS:
            tmpGeo = new THREE.SphereGeometry(1, 12, 8);
            if (data && data.useScale) {
                tmpGeo.scale(w/2, h/2, l/2);
            }
            module.exports.colorize(tmpGeo, null,
                module.exports.getColor(data.colr
                ||0xffffff, data.dark||1));
            cachedSpheres[tmpIndx] = tmpGeo;
        }
        return tmpGeo;
    }
    
    
    /***/ }),
    
    /***/ "./src/libs/particles.js":
    /*!*******************************!*\
      !*** ./src/libs/particles.js ***!
      \*******************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    
    // IMPORT:
    var THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
    var UTILS = __webpack_require__(/*! ./utils.js */ "./src/libs/utils.js");
    var GEOS = __webpack_require__(/*! ./geos.js */ "./src/libs/geos.js");
    var tmpVector = new THREE.Vector3();
    
    // TRAILS:
    var trailGeo = GEOS.generateCube(null, 1, 1, 1, {});
    var Trail = function(RENDER) {
        this.mesh = new THREE.Mesh(trailGeo);
    
        // INIT:
        this.init = function(parent) {
            this.dst = parent.dst;
            this.spd = parent.spd;
            this.xS = parent.xS;
            this.zS = parent.zS;
            this.yS = parent.yS;
            this.scale = 0.45;
            this.len = 0;
            this.mesh.material = RENDER.getMat("default", {
                mat: THREE.MeshBasicMaterial,
                color: 0xededed,
                transparent: true,
                opacity: 0.21
            });
            var x = parent.mesh.position.x;
            var y = parent.mesh.position.y;
            var z = parent.mesh.position.z;
            RENDER.moveMesh(this.mesh, x, y, z);
            this.mesh.lookAt(x + this.xS, y + this.yS, z + this.zS);
            this.mesh.rotateX(Math.PI / 2);
            RENDER.scaleMesh(this.mesh, this.scale, this.len, this.scale);
            this.mesh.visible = true;
        };
    
        // UPDATE:
        this.update = function(delta) {
            if (this.mesh.visible) {
                if (this.len < this.dst) {
                    this.len += this.spd * delta;
                    if (this.len >= this.dst) this.len = this.dst;
                } this.scale -= 0.00036 * delta;
                RENDER.scaleMesh(this.mesh, this.scale,
                    this.len, this.scale);
                if (this.scale <= 0) {
                    this.scale = 0;
                    this.mesh.visible = false;
                }
            }
        };
    
    }
    
    // EXPLOSION OBJECT:
    function ExplosionManager() {
        THREE.Object3D.call(this);
        this.largeSpawnCount = 8;
        this.smallSpawnCount = 15;
        this.emissiveness = 0.55;
        this.velocityDamping = 3;
        this.lifeSpeedMin = 2.2;
        this.lifeSpeedRange = 3;
        var geometry = new THREE.Geometry({
            dynamic: true
        });
        var tmpColor = new THREE.Color(0xBBBBBB);
        this.mesh = new THREE.Mesh(geometry, new THREE.StrippedLambertMaterial({
            color: tmpColor,
            emissive: tmpColor.multiplyScalar(this.emissiveness),
            smoothShading: true
        }));
        this.mesh.castShadow = true;
        this.mesh.receiveShadow = true;
        this.add(this.mesh);
        this.cubeTemplate = new THREE.BoxGeometry(1, 1, 1);
        for (var i = 0; i < this.cubeTemplate.faces.length; i++) {
            this.cubeTemplate.faces[i].materialIndex = 0;
        }
        this.cubeTemplate.faceVertexUvs = [[]];
        this.entities = [];
    }
    ExplosionManager.staticMatrix = new THREE.Matrix4();
    ExplosionManager.prototype = Object.create(THREE.Object3D.prototype);
    Object.defineProperty(ExplosionManager, "finished", function() {
        return this.entities.length === 0;
    });
    ExplosionManager.prototype.explodeAt = function(x, y, z, scaleMult) {
        this.sizeMin = 0.35 * scaleMult;
        this.sizeRange = 1.8 * scaleMult;
        this.velocityMin = 30 * scaleMult;
        this.velocityRange = 17 * scaleMult;
        tmpVector.set(x, y, z);
        for (var i = 0; i < this.largeSpawnCount; i++) {
            this.spawnEntity(Math.random() * 0.1 + 0.9, tmpVector, false);
        }
        for (var i = 0; i < this.smallSpawnCount; i++) {
            this.spawnEntity(Math.random() * 0.9, tmpVector, false);
        }
    }
    ExplosionManager.prototype.spawnEntity = function(rankSeed, position) {
        var rank = Math.pow(rankSeed, 2.5);
        var size = rank * this.sizeRange + this.sizeMin;
        var velocityScale = (1 - rank) * this.velocityRange + this.velocityMin;
        var velocity = this._randomVector().normalize().multiplyScalar(velocityScale);
        var lifeSpeed = rank * this.lifeSpeedRange + this.lifeSpeedMin;
        var index = 0;
        while (true) {
            var uniqueIndex = true;
            for (var i = 0; i < this.entities.length; i++) {
                var e = this.entities[i];
                if (e.index === index) {
                    uniqueIndex = false;
                    break;
                }
            }
            if (uniqueIndex) break;
            else index++;
        }
        if (index * 8 > this.mesh.geometry.vertices.length - 1) {
            this.mesh.geometry.merge(this.cubeTemplate, ExplosionManager.emptyMatrix);
        }
        this.entities.push({
            index: index,
            rank: rank,
            rankSeed: rankSeed,
            life: 0,
            lifeSpeed: lifeSpeed,
            size: size,
            position: position.clone(),
            velocity: velocity
        });
    }
    ExplosionManager.prototype.destroyEntity = function(entity) {
        this.entities.splice(this.entities.indexOf(entity), 1);
        for (var i = entity.index * 8; i < (entity.index + 1) * 8; i++) {
            this.mesh.geometry.vertices[i].set(0, 0, 0);
        }
        this.mesh.geometry.verticesNeedUpdate = true;
        this.mesh.geometry.elementsNeedUpdate = true;
        this._cleanGeometry();
    }
    ExplosionManager.prototype.update = function(dt) {
        dt /= 1000;
        for (var j = 0; j < this.entities.length; j++) {
            var entity = this.entities[j];
            entity.life += dt * entity.lifeSpeed;
            entity.velocity.multiplyScalar(1 - this.velocityDamping * dt);
            entity.position.add(entity.velocity.clone().multiplyScalar(dt));
            var scale = -Math.pow(entity.life / Math.sqrt(2), 2) + 2;
            scale *= entity.size;
            var vertCount = 8;
            for (var i = entity.index * vertCount; i < (entity.index + 1) * vertCount; i++) {
                var vert = this.mesh.geometry.vertices[i];
                var vertOffset = this.cubeTemplate.vertices[i % vertCount];
                vert.set(entity.position.x, entity.position.y, entity.position.z).addScaledVector(vertOffset, scale);
            }
            if (scale <= 0) {
                this.destroyEntity(entity);
            }
        }
        this.mesh.geometry.verticesNeedUpdate = true;
        this.mesh.geometry.elementsNeedUpdate = true;
        this.mesh.geometry.computeBoundingSphere();
    }
    ExplosionManager.prototype._cleanGeometry = function() {
        var verts = this.mesh.geometry.vertices;
        var faces = this.mesh.geometry.faces;
        var highestIndex = -1;
        for (var i = 0; i < this.entities.length; i++) {
            var e = this.entities[i];
            if (e.index > highestIndex) {
                highestIndex = e.index;
            }
        }
        var deleteIndex = highestIndex + 1;
        verts.splice(deleteIndex * 8, verts.length - deleteIndex * 8);
        faces.splice(deleteIndex * 12, faces.length - deleteIndex * 12);
    }
    ExplosionManager.prototype._randomVector = function() {
        return new THREE.Vector3(
            Math.random() - 0.5,
            Math.random() - 0.5,
            Math.random() - 0.5
        )
    }
    
    // PHYS TYPES:
    var physTypes = [{
        mat: THREE.MeshBasicMaterial,
        snd: {
            rng: 26,
            src: ["whizz_0", "whizz_1"],
            vol: 0.12
        },
        spd: 1.7,
        scale: 1.0,
        length: 13,
        color: 0xffffdb
    }, {
        spd: [0.03, 0.031],
        rand: true,
        carryV: true,
        grav: 0.0003,
        spn: [0.04, 0.05],
        scale: 0.15,
        length: 0.5,
        color: 0x9a7b3e
    }, {
        spd: [0.03, 0.031],
        rand: true,
        carryV: true,
        grav: 0.0003,
        spn: [0.03, 0.05],
        scale: 0.1,
        length: 0.4,
        color: 0x9a7b3e
    }];
    
    // PHYS OBJ:
    var PhysObj = function(RENDER) {
        this.mesh = new THREE.Mesh(RENDER.cubeGeo);
    
        // INIT:
        this.init = function(x, y, z, xD, yD, dst, data, holder) {
            this.dst = dst;
            this.scale = data.scale;
            this.spd = (data.spd[1]?UTILS.randFloat(data.spd[0],
                data.spd[1]):data.spd);
            var carryVel = (data&&data.carryV&&holder);
            xD -= Math.PI;
            this.xS = (this.spd * Math.sin(xD) * Math.cos(yD)) + (carryVel?holder.xVel:0);
            this.zS = (this.spd * Math.cos(xD) * Math.cos(yD)) + (carryVel?holder.zVel:0);
            this.yS = (this.spd * Math.sin(yD)) + (carryVel?holder.yVel:0);
            this.grav = data.grav;
            this.spin = data.spn?(data.spn[1]?UTILS.randFloat(data.spn[0], data.spn[1]):data.spn):0;
            this.mesh.receiveShadow = (data.mat!=THREE.MeshBasicMaterial);
            this.mesh.material = RENDER.getMat("default", {
                fog: (data.mat!=THREE.MeshBasicMaterial),
                color: data.color,
                emissive: data.emis,
                mat: data.mat
            });
            this.layer = (holder&&holder.renderYou?1:0);
            this.sound = (holder&&holder.isYou?null:data.snd);
            this.soundPlayed = false;
            this.mesh.layers.set(this.layer);
            RENDER.moveMesh(this.mesh, x, y, z);
            this.mesh.lookAt(x + this.xS, y + this.yS, z + this.zS);
            if (data && data.rand) this.mesh.rotateX(UTILS.randFloat(-Math.PI, Math.PI));
            RENDER.scaleMesh(this.mesh, data.scale, data.scale, data.length);
        };
    
        // CHECK SOUND:
        this.checkSound = function() {
            if (this.sound && !this.soundPlayed) {
                var tmpPos = Howler.pos();
                var tmpDst = UTILS.getD3D(tmpPos[0], tmpPos[1], tmpPos[2],
                    this.mesh.position.x, this.mesh.position.y, this.mesh.position.z);
                if (tmpDst <= this.sound.rng) {
                    SOUND.play(this.sound.src[UTILS.randInt(0, this.sound.src.length - 1)],
                        this.sound.vol, false, UTILS.randFloat(0.8, 1.2));
                    this.soundPlayed = true;
                }
            }
        };
    
        // UPDATE:
        this.update = function(delta) {
            if (this.mesh.visible) {
                this.mesh.position.x += this.xS * delta;
                this.mesh.position.z += this.zS * delta;
                this.mesh.position.y += this.yS * delta;
                if (this.spin) this.mesh.rotateX(this.spin * delta);
                this.yS -= (this.grav||0) * delta;
                this.dst -= this.spd * delta;
                this.checkSound();
                if (this.dst <= 0) this.mesh.visible = false;
            }
        };
    
    };
    
    // SPRITE OBJECT:
    THREE.Sprite.prototype.init = function(x, y, z, data, area) {
        this.position.x = x;
        this.position.y = y;
        this.position.z = z;
        this.xVel = data.xV||0;
        this.yVel = data.yV||0;
        this.oYVel = this.yVel;
        this.zVel = data.zV||0;
        this.startSiz = data.siz||0;
        this.scale.x = this.scale.y = this.startSiz;
        this.sclSpd = data.scl||0;
        this.life = data.life||0;
        this.decl = data.decl||0;
        this.grav = data.grav||0;
        this.static = data.static;
        this.area = area;
        this.updC = 0;
    };
    THREE.Sprite.prototype.update = function(delta, act, playr) {
        if (this.area) this.visible = (act && UTILS.getD3D((playr?playr.x:0),
                (playr?playr.y:0), (playr?playr.z:0), this.position.x,
                this.position.y, this.position.z) <= 160);
        if (this.visible || this.area) {
            this.position.x += this.xVel * delta;
            this.position.z += this.zVel * delta;
            this.position.y += this.yVel * delta;
            this.yVel -= (this.grav * delta);
            if (this.sclSpd) {
                // this.scale.x += this.sclSpd * delta;
                // this.scale.y = this.scale.x;
            }
            if (this.area) {
                var tmpScl = this.scale.x / 2;
                if (this.position.x - tmpScl >= this.area.x + this.area.w)
                    this.position.x = this.area.x - this.area.w - tmpScl;
                else if (this.position.x + tmpScl <= this.area.x - this.area.w)
                    this.position.x = this.area.x + this.area.w + tmpScl;
                if (this.position.z - tmpScl >= this.area.z + this.area.l)
                    this.position.z = this.area.z - this.area.l - tmpScl;
                else if (this.position.z + tmpScl <= this.area.z - this.area.l)
                    this.position.z = this.area.z + this.area.l + tmpScl;
                if (this.position.y - tmpScl > this.area.y + this.area.h) {
                    this.position.y = this.area.y - tmpScl;
                    this.yVel = this.oYVel;
                    this.visible = false;
                } else if (this.position.y + tmpScl < this.area.y) {
                    this.position.y = this.area.y + this.area.h + tmpScl;
                    this.yVel = this.oYVel;
                    this.visible = false;
                }
            }
            if (this.life > 0) {
                this.life -= delta;
                if (this.life <= 0 && this.updC) this.visible = false;
                this.updC++;
            } else if (this.life <= 0 && this.updC) this.visible = false;
        }
    };
    
    // EFFECTS:
    var rotations = [Math.PI / 3, -Math.PI / 3];
    var effects = [{
        src: "0",
        hole: true,
        count: 2,
        grav: -0.00002,
        scale: [5, 9],
        speed: [0, 0.025],
        spread: [-0.4, 0.4],
        life: [300, 500]
    }, {}, {
        count: 1,
        blending: 2,
        scale: [5, 7],
        speed: [0, 0],
        spread: [0, 0],
        life: [30, 35]
    }, {
        count: 1,
        blending: 2,
        scale: [2000, 2000],
        speed: [0, 0],
        spread: [0, 0]
    }, {
        count: 4,
        src: "0",
        scale: [5, 6],
        speed: [0, 0.01],
        spread: [-1, 1],
        life: [600, 800]
    }];
    
    // PARTICLE MANAGER:
    module.exports = function(RENDER, config) {
    
        // INIT:
        var context = this;
        var tmpObj, tmpParticle, tmpTrail;
        this.particles = [];
        this.trails = [];
        this.physObjs = [];
        this.areas = [];
        this.active = true;
        this.ExplosionManager = new ExplosionManager();
    
        // ADD TRAIL:
        this.addTrail = function(parent) {
            tmpTrail = null;
            for (var i = 0; i < this.trails.length; ++i) {
                if (!this.trails[i].mesh.visible) {
                    tmpTrail = this.trails[i];
                    break;
                }
            }
            if (!tmpTrail) {
                tmpTrail = new Trail(RENDER);
                this.trails.push(tmpTrail);
                RENDER.scene.add(tmpTrail.mesh);
            } tmpTrail.init(parent);
        };
    
        // PARTICLE AREA:
        this.area = function(x, y, z, w, h, l, data, f) {
            w /= 2;
            l /= 2;
            context.areas.push({
                f: f,
                x: x,
                y: y,
                z: z,
                w: w,
                h: h,
                l: l
            });
            var tmpSpd = data.spd * 0.005;
            var tmpDr = (((data.dir||0) + 1) * Math.PI / 2) - (Math.PI / 2);
            var tmpSrc = (config.particleIDS[data.txt||0]||"default");
            if (tmpSrc != "default") tmpSrc += "_0";
            for (var i = 0; i < data.cnt; ++i) {
                context.add(x + UTILS.randInt(-w, w), y + UTILS.randInt(0, h),
                    z + UTILS.randInt(-l, l), {
                    src: tmpSrc,
                    cnt: data.cnt,
                    static: true,
                    xV: (tmpSpd * Math.cos(tmpDr)),
                    zV: (tmpSpd * Math.sin(tmpDr)),
                    grav: (data.grav||0) * (0.00001 * UTILS.randFloat(0.7, 1.3)),
                    decl: data.decl,
                    scl: data.scl,
                    siz: data.siz,
                    colr: data.colr
                } , this.areas[this.areas.length - 1]);
            }
        };
    
        // PARTICLE EFFECT:
        this.effect = function(x, y, z, xDir, yDir, effect) {
            if (!this.active || (RENDER.useDepthMap != 0 && RENDER.useDepthMap != "0")) return;
            tmpObj = effects[effect];
            for (var i = 0; i < tmpObj.count; ++i) {
                var tmpSpd = UTILS.randFloat(tmpObj.speed[0], tmpObj.speed[1]);
                var tmpX = xDir + UTILS.randFloat(tmpObj.spread[0], tmpObj.spread[1]);
                var tmpY = yDir + UTILS.randFloat(tmpObj.spread[0], tmpObj.spread[1]);
                this.add(x, y, z, {
                    src: tmpObj.src||0,
                    xV: tmpSpd * Math.sin(tmpX) * Math.cos(tmpY),
                    yV: tmpSpd * Math.sin(tmpY),
                    zV: tmpSpd * Math.cos(tmpX) * Math.cos(tmpY),
                    blend: tmpObj.blending,
                    grav: tmpObj.grav,
                    siz: UTILS.randFloat(tmpObj.scale[0], tmpObj.scale[1]),
                    life: (tmpObj.life?UTILS.randInt(tmpObj.life[0],
                        tmpObj.life[1]):0),
                });
            }
            if (tmpObj.hole) this.add(x, y, z, {
                src: "1",
                blend: THREE.SubtractiveBlending,
                siz: UTILS.randFloat(0.4, 1),
                life: 4000
            });
        };
    
        // SHOW PARTICLES:
        this.add = function(x, y, z, data, area) {
            tmpParticle = null;
            for (var i = 0; i < this.particles.length; ++i) {
                if (!this.particles[i].visible && !this.particles[i].static) {
                    tmpParticle = this.particles[i];
                    break;
                }
            }
            if (!tmpParticle) {
                tmpParticle = new THREE.Sprite();
                this.particles.push(tmpParticle);
                RENDER.scene.add(tmpParticle);
            }
            this.setMaterial(tmpParticle, data.src, // TEMP
                data.blend||0, (data.src!="grass_0"), data.colr);
            tmpParticle.visible = true;
            tmpParticle.init(x, y, z, data, area);
        };
    
        // SET MATERIAL:
        this.setMaterial = function(particle, src, blending, rot, colr) {
            particle.material = RENDER.getMat("particles/" + src, {
                mat:  THREE.SpriteMaterial,
                color: (colr!=undefined?colr:0xffffff),
                depthWrite: false,
                blending: blending||THREE.NormalBlending,
                rotation: (rot?rotations[UTILS.randInt(0, 2)]:0)
            });
        };
    
        // ADD PHYS OBJ:
        this.physObj = function(x, y, z, xD, yD, dst, trail, indx, holder, dat, sid) {
            if (RENDER.useDepthMap != 0 && RENDER.useDepthMap != "0") return;
            tmpParticle = null;
            for (var i = 0; i < this.physObjs.length; ++i) {
                if (!this.physObjs[i].mesh.visible) {
                    tmpParticle = this.physObjs[i];
                    break;
                }
            } if (!tmpParticle) {
                tmpParticle = new PhysObj(RENDER);
                this.physObjs.push(tmpParticle);
                RENDER.scene.add(tmpParticle.mesh);
            }
            tmpParticle.sid = (sid!=undefined?sid:null);
            tmpParticle.mesh.visible = true;
            tmpParticle.init(x, y, z, xD, yD, dst, dat||physTypes[indx], holder);
            if (trail && this.showTrails) this.addTrail(tmpParticle);
        };
    
        // DISABLE BY SID:
        this.disablePhys = function(sid) {
            for (var i = 0; i < this.physObjs.length; ++i) {
                if (this.physObjs[i].sid == sid) this.physObjs[i].mesh.visible = false;
            }
        };
    
        // UPDATE:
        this.update = function(delta, player) {
            if (player && player.active) for (var i = 0; i < this.areas.length; ++i) {
                if (this.areas[i].f) {
                    this.areas[i].x = player.x
                    this.areas[i].y = player.y;
                    this.areas[i].z = player.z;
                }
            }
            for (var i = 0; i < this.trails.length; ++i)
                this.trails[i].update(delta);
            for (var i = 0; i < this.particles.length; ++i)
                this.particles[i].update(delta, this.active, player);
            for (var i = 0; i < this.physObjs.length; ++i)
                this.physObjs[i].update(delta);
            this.ExplosionManager.update(delta);
        };
    
        // RESET:
        this.reset = function() {
            this.particles.length = 0;
            this.trails.length = 0;
            this.physObjs.length = 0;
            this.areas.length = 0;
        };
    
        // TRACER COLOR:
        this.setTracerColor = function(val) {
            physTypes[0].color = val;
        };
    
    };
    
    
    /***/ }),
    
    /***/ "./src/libs/render.js":
    /*!****************************!*\
      !*** ./src/libs/render.js ***!
      \****************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    var config = __webpack_require__(/*! ../config.js */ "./src/config.js");
    var THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
    var SkyDome = __webpack_require__(/*! ./SkyDome */ "./src/libs/SkyDome.js");
    
    // RENDER MANAGER:
    var mapData;
    var modeData;
    module.exports = function(THREE, UTILS, COLORS, config, OVERLAY) {
    
        // VALS:
        THREE.ImageUtils.crossOrigin = '';
        var GEOS = __webpack_require__(/*! ./geos.js */ "./src/libs/geos.js");
        var loadManager = new THREE.LoadingManager();
        var objLoader = new THREE.OBJLoader(loadManager);
        this.cubeGeo = new THREE.BoxGeometry(1, 1, 1);
        this.getCubeMesh = function() {
            return new THREE.Mesh(this.cubeGeo);
        };
        var planeGeo = new THREE.PlaneGeometry(1, 1);
        var cylinderGeo = new THREE.CylinderGeometry(0.1, 1, 1, 4, 1, false, Math.PI / 4);
        cylinderGeo.computeFlatVertexNormals();
        var textureLoader = new THREE.TextureLoader();
        var depthMaterial = new THREE.MeshBasicMaterial({color: 0xffffff});
        var greenMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00});
        this.invisMat = new THREE.MeshBasicMaterial();
        this.invisMat.visible = false;
        var cubes = {};
        var materials = {};
        var textures = {};
        this.movTextures = [];
        this.pulsMats = [];
        this.frameMats = [];
        this.liquids = [];
        this.pulsVal = 0;
        this.liquidVal = 0;
        var tmpObj;
    
        // INIT:
        var context = this;
        var groupMeshes = {};
        this.frustum = new THREE.Frustum();
        var tmpMatrix = new THREE.Matrix4();
        this.camera = new THREE.PerspectiveCamera(0,
            window.innerWidth / window.innerHeight, 0.1, 6000);
        Object.freeze(this.camera.scale);
    
        // FPS CAM:
        this.fpsCamera = new THREE.PerspectiveCamera(config.fov,
            window.innerWidth / window.innerHeight, 0.1, 300);
        Object.freeze(this.fpsCamera.scale);
        Object.freeze(this.fpsCamera.quaternion);
        Object.freeze(this.fpsCamera.position);
        Object.freeze(this.fpsCamera.rotation);
        this.fpsCamera.layers.set(1);
        this.camera.add(this.fpsCamera);
    
        // OTHER VALS:
        this.weaponLean = 1;
        this.weaponOffX = 1;
        this.weaponOffY = 1;
        this.weaponOffZ = 1;
        this.weaponBob = 1;
        this.hideADS = 0;
        this.showHands = true;
        this.aimAnim = true;
        this.renderDst = 0;
        this.customADS = '';
        this.reticleIndex = 0;
        this.lowSpec = false;
        this.customRatio = null;
        this.aspectRatio = '';
        this.aimFov = true;
        this.textureAnim = true;
    
        // SCENE SPECIFIC:
        this.init = function(map, mode) {
    
            // CLEAR PENDING MESHES:
            this.clearPendingMeshes();
    
            // CREATE SCENE:
            this.scene = new THREE.Scene();
    
            // CREATE BACKGROUND SCENE:
            this.backgroundScene = new THREE.Scene();
            if (map.skyDome && (mode&&mode.skyCol == undefined)) {
                this.skyDome = SkyDome.fromConfig(map);
                this.backgroundScene.add(this.skyDome);
            }
    
            // INITIATE SCENE:
            module.exports.initScene.apply(this, [map, mode]);
    
        };
    
        // GET ASPECT RATIO:
        this.getRes = function() {
            var arr = this.aspectRatio.split('x');
            return ((parseInt(arr[0])||window.innerWidth)
                / (parseInt(arr[1])||window.innerHeight));
        };
    
        // FLASH:
        var flashTimer = 0;
        this.flash = function(x, y) {
            OVERLAY.showFlash = true;
            OVERLAY.flashX = x;
            OVERLAY.flashY = 1 - y;
            flashTimer = 1;
        }
    
        // UPDATE LIGHTMAP:
        this.updateLightMap = function(map) {
            if (this.skyLight) {
                this.skyLight.shadow.camera.right = map.shadWidth;
                this.skyLight.shadow.camera.left = -map.shadWidth;
                this.skyLight.shadow.camera.top = map.shadLength;
                this.skyLight.shadow.camera.bottom = -map.shadLength;
            }
        };
    
        // TOGGLE DEPTH MAP:
        this.useDepthMap = 0;
        this.toggleDepthMap = function(val) {
            this.useDepthMap = val;
            if (this.scene) {
                var useDep = (val && val != "0");
                this.scene.overrideMaterial = useDep?depthMaterial:null;
                if (useDep) {
                    this.scene.fog = new THREE.Fog(0x000000, 0, val);
                    this.renderer.setClearColor(0x000000);
                } else module.exports.initScene.apply(this, [mapData, modeData]);
            }
        };
    
        // GREENSCREEN:
        this.greenScreen = false;
        this.updateGreenScreen = function(mesh) {
            if (context.greenScreen && !mesh.noGreen) {
                mesh.realMat = mesh.material;
                mesh.material = greenMaterial;
            } else mesh.material = mesh.realMat||mesh.material;
        };
        this.toggleGreenscreen = function(val) {
            this.greenScreen = val;
            if (this.scene) {
                if (val) {
                    this.renderer.setClearColor(0x00ff00);
                    this.scene.fog.near = 0.1;
                    this.scene.fog.far = 0;
                } else {
                    this.scene.fog.near = 1;
                    this.scene.fog.far = (modeData&&modeData.fogD!=undefined?modeData.fogD:mapData.fogD);
                    this.renderer.setClearColor((modeData&&modeData.skyCol!=undefined?modeData.skyCol:mapData.sky));
                }
                this.scene.traverse(function(mesh) {
                    context.updateGreenScreen(mesh);
                });
            }
        };
    
        // INIT RENDERER:
        this.renderer = new THREE.WebGLRenderer({
            precision: "mediump",
            powerPreference: "high-performance",
            antialias: false
        });
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.autoUpdate = false;
        this.renderer.shadowMap.type = THREE.BasicShadowMap;
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.autoClear = false;
        document.body.appendChild(this.renderer.domElement);
    
        // SHADOWS:
        this.shadows = true;
        this.updateShadowMap = function() {
            if (!this.shadows) return;
            this.renderer.shadowMap.needsUpdate = true;
        };
        this.toggleShadowMap = function(val) {
            if (!val) {
                this.shadows = false;
                if (this.skyLight) {
                    this.renderer.setRenderTarget(this.skyLight.shadow.map);
                    this.renderer.clear();
                    this.renderer.setRenderTarget(null);
                }
            } else {
                this.shadows = true;
                this.updateShadowMap();
            }
        };
    
        // ZOOM:
        this.zoomVal = 1;
        this.zoom = function(val) {
            if (!this.aimFov) val = 1;
            this.zoomVal = val;
            this.updateCamFOV();
            this.fpsCamera.fov = this.fpsFov / val;
            this.fpsCamera.updateProjectionMatrix();
        };
    
        // SET WEAPON FOV:
        this.setFPSFov = function(fov) {
            this.fpsFov = fov;
            this.fpsCamera.fov = fov;
            this.fpsCamera.updateProjectionMatrix();
        }; this.setFPSFov(config.fov);
    
        // FOV MULTIPLIER:
        this.fovMult = function(val) {
            if (this.fovMlt != val) {
                this.fovMlt = val;
                this.updateCamFOV();
            }
        };
    
        // UPDATE FOV:
        this.fovMlt = 1;
        this.updateCamFOV = function() {
            this.camera.fov = ((this.fov / this.zoomVal) * this.fovMlt);
             this.camera.updateProjectionMatrix();
        };
    
        // SET FOV:
        this.setFov = function(fov) {
            this.fov = fov;
            this.updateCamFOV();
        }; this.setFov(config.fov);
    
        // RESIZE:
        this.resize = function() {
            this.camera.aspect = this.getRes();
            this.camera.updateProjectionMatrix();
            this.fpsCamera.aspect = this.getRes();
            this.fpsCamera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        };
    
        // SET RESOLUTION:
        this.resMltV = 1;
        this.setResMlt = function(mlt) {
            this.resMltV = mlt;
            this.renderer.setPixelRatio(window.devicePixelRatio * this.resMltV);
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        };
    
        // UPDATE FRUSTUM:
        this.updateFrustum = function() {
            this.frustum.setFromProjectionMatrix(tmpMatrix.multiplyMatrices(
                this.camera.projectionMatrix,
                this.camera.matrixWorldInverse));
        };
    
        // SCREENSHAKE:
        var shakeRadius = 0;
        var shakeAngle = 0;
        this.shakeX = 0;
        this.shakeY = 0;
        this.updateShake = function(delta) {
            if (shakeRadius) {
                shakeRadius *= Math.pow(0.99, delta);
                shakeAngle += UTILS.randFloat(-Math.PI, Math.PI);
                this.shakeX = Math.cos(shakeAngle) * shakeRadius;
                this.shakeY = Math.sin(shakeAngle) * shakeRadius;
                if (shakeRadius <= 0.01) {
                    shakeRadius = 0;
                    this.shakeX = this.shakeY = 0;
                }
            }
        };
        this.shake = function(val) {
            shakeRadius = val;
        };
    
        // RENDER:
        this.render = function(delta, viewer) {
            if (!this.scene && !viewer) return;
    
            if (this.textureAnim) {
    
                // ANIMATE MOVING TEXTURES:
                for (var i = 0; i < this.movTextures.length; ++i) {
                    tmpObj = this.movTextures[i];
                    if (tmpObj.tex.offset) tmpObj.tex.offset[tmpObj.movD == 0?'x':'y'] += tmpObj.mov * delta;
                }
    
                // ANIMATE PULSATING MATERIALS:
                this.pulsVal += delta * 0.003; // UPDATE THIS TO BE DIFF PER SKIN
                for (var i = 0; i < this.pulsMats.length; ++i) {
                    var tmpEm = (Math.sin(this.pulsVal) / 2 + 0.5) * 1.2;
                    this.pulsMats[i].mat.emissiveIntensity = tmpEm;
                }
    
                // ANIMATE FRAME MATERIALS:
                for (var i = 0; i < this.frameMats.length; ++i) {
                    tmpObj = this.frameMats[i];
                    tmpObj.dur -= delta;
                    if (tmpObj.dur <= 0) {
                        tmpObj.dur = tmpObj.orgDur;
                        tmpObj.cur++;
                        if (tmpObj.cur >= tmpObj.num) tmpObj.cur = 0;
                        if (tmpObj.mat.map) tmpObj.mat.map.offset.x =
                            (tmpObj.cur % tmpObj.num) / tmpObj.num;
                    }
                }
    
                // LIQUID ANIMATION:
                // this.liquidVal += delta * 0.003;
                // for (var i = 0; i < this.liquids.length; ++i) {
                // 	tmpObj = this.liquids[i];
                // 	for (var x = 0; x < tmpObj.mesh.geometry.vertices.length; x++) {
                //         tmpObj.mesh.geometry.vertices[x].z = tmpObj.hght * Math.sin(x / 5 + (this.liquidVal * tmpObj.spd) / 4);
                //     }
                // 	tmpObj.mesh.geometry.normalsNeedUpdate = true;
                // 	tmpObj.mesh.geometry.verticesNeedUpdate =true;
                // }
            }
    
            // ALLOWS FOR VIEWER TO ANIMATE SKINS WITHOUT RENDER DOING OTHER STUFF
            if (viewer) return;
            this.renderer.clear();
            this.camera.layers.set(0);
            if (this.skyDome) {
    
                // MOVE SKYDOME TO CAMERA:
                this.camera.getWorldPosition(this.skyDome.position);
    
                // RENDER BACKGROUND:
                this.renderer.render(this.backgroundScene, this.camera);
                this.renderer.clearDepth();
    
            }
    
            // RENDER SCENE:
            this.renderer.render(this.scene, this.camera);
    
            // RENDER ALWAYS VIS OBJECTS:
            this.camera.layers.set(2);
            this.renderer.clearDepth();
            this.renderer.render(this.scene, this.camera);
    
            // RENDER FPS GUN:
            this.renderer.clearDepth();
            this.renderer.render(this.scene, this.fpsCamera);
            if (OVERLAY.showFlash) {
                if (flashTimer <= 0) {
                    flashTimer = 0;
                    OVERLAY.showFlash = false;
                } flashTimer -= delta;
            }
            this.updateShake(delta);
        };
    
        // UPDATE TEXTURE:
        this.updateTexture = function(src, img, data) {
            data=data||{};
            var cnt = 0;
            for (var index in textures) {
                if (index.substring(0, src.length + 2) == (src + "mt")
                    && index.endsWith('nad')) {
                    cnt++;
                    textures[index].image = img;
                    textures[index].needsUpdate = true;
                }
            }
            if (!cnt) {
                var tmpIndx = src + (data.movT!=undefined?"mt"+data.movT:"mt")
                    + (data.movD!=undefined?data.movD:"md")+(data.fontSize||"fs")
                    + (data.fcolr||"fc")+(data.bcolr||"bc")+(data.noBVis||"bv")
                    + (data.text||"txt")+(data.tAlign||"ta");
                var tmpTex = textures[tmpIndx];
                    tmpTex = new THREE.Texture(img);
                    textures[tmpIndx] = tmpTex;
                textures[tmpIndx].needsUpdate = true;
            }
        };
    
        // LOAD TEXTURE:
        this.loadTexture = function(tmpMat, src, data, type) {
            data = data||{};
            var tmpIndx = src + (data.movT!=undefined?"mt"+data.movT:"mt")
                + (data.movD!=undefined?data.movD:"md")+(data.fontSize||"fs")
                + (data.fcolr||"fc")+(data.bcolr||"bc")+(data.noBVis||"bv")
                + (data.text||"txt")+(data.tAlign||"ta")+(data.showAd?"ad":"nad");
            if (!textures[tmpIndx]) {
                textures[tmpIndx] = {
                    mats: [{
                        t: type,
                        m: tmpMat
                    }]
                };
                if (data.canvas) {
                    var texture = new THREE.Texture(data.canvas);
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(data.repeatX||1, data.repeatY||1);
                    texture.minFilter = (data.tFilter||THREE.NearestFilter);
                    texture.magFilter = (data.tFilter||THREE.NearestFilter);
                    texture.needsUpdate = true;
                    for (var i = 0; i < textures[tmpIndx].mats.length; ++i) {
                        textures[tmpIndx].mats[i].m[textures[tmpIndx].mats[i].t
                            ||"map"] = texture;
                        textures[tmpIndx].mats[i].m.needsUpdate = true;
                    } textures[tmpIndx] = texture;
                    if (data.movT) this.movTextures.push({
                        tex: texture,
                        mov: data.movT,
                        movD: data.movD||0
                    });
                } else if (typeof src == "string" && !src.includes('default')) {
                    textureLoader.load(UTILS.assetsUrl("/textures/" + src + ".png"), (texture) => {
                          texture.wrapS = THREE.RepeatWrapping;
                          texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(data.frames ? (1 / data.frames) : (data.repeatX||1), data.repeatY||1);
                          texture.minFilter = (data.tFilter||THREE.NearestFilter);
                          texture.magFilter = (data.tFilter||THREE.NearestFilter);
                          texture.needsUpdate = true;
                          for (var i = 0; i < textures[tmpIndx].mats.length; ++i) {
                              textures[tmpIndx].mats[i].m[textures[tmpIndx].mats[i].t
                                  ||"map"] = texture;
                              textures[tmpIndx].mats[i].m.needsUpdate = true;
                          } textures[tmpIndx] = texture;
                          if (data.movT) this.movTextures.push({
                              tex: texture,
                            mov: data.movT,
                              movD: data.movD||0
                          });
                      });
                  }
            } else if (textures[tmpIndx].mats) {
                textures[tmpIndx].mats.push({
                    t: type,
                    m: tmpMat
                });
            } else {
                tmpMat[type||"map"] = textures[tmpIndx];
                if (data.frames && tmpMat.map.repeat.x == 1)
                    tmpMat.map.repeat.x = (1 / data.frames);
                tmpMat.needsUpdate = true;
            } return tmpMat;
        };
    
        // GET MATERIAL:
        this.getMat = function(src, data) {
            var tmpIndx = (data?(data.texSrc||src):src) + (data?(data.rotation||"x")+(data.noFog||"y")
                + (data.opacity||"z")+(data.color||"b")+(data.mat?"ma":"nm")+(data.ao||"a")+(data.emissive||"e")+(data.glowText||"g")
                + (data.movT!=undefined?data.movT:"mt")	+ (data.movD!=undefined?data.movD:"md")	+ (data.canvas!=undefined?"canvas":"")
                + (data.pulsT!=undefined?"pt"+data.pulsT:"npt")
                + (data.frames!=undefined?"fr"+data.frames:"nfr") + (data.frameT!=undefined?"frt"+data.frameT:"nfrt")
                + (data.depthWrite!=undefined?data.depthWrite:"d")+(data.fontSize||"fs")+(data.fcolr||"fc")+(data.bcolr||"bc")
                + (data.noBVis||"bv")+(data.text||"txt")+(data.tAlign||"ta")+(data.showAd?"ad":"nad"):"");
            var tmpMat = materials[tmpIndx];
            if (!tmpMat) {
                data = data||{};
                tmpMat = new (data.mat?data.mat:THREE.StrippedLambertMaterial)(data);
                if (data.canvas) this.loadTexture(tmpMat, tmpIndx, data);
                if (src && src != "default") this.loadTexture(tmpMat, (data.texSrc||src), data);
                if (data && data.emissive) this.loadTexture(tmpMat, (data.glowText
                    ?data.texSrc||src:src) + (data.sameGlow?"":"_e"), data, "emissiveMap");
                if (data && data.ao) {
                    this.loadTexture(tmpMat, src + "_ao", data, "aoMap");
                    tmpMat.aoMapIntensity = 1.3;
                } if (data && data.normal) this.loadTexture(tmpMat, src + "_n", data, "normalMap");
                if (src == "default") tmpMat.vertexColors = THREE.VertexColors;
                if (data && data.noFog) tmpMat.fog = false;
                tmpMat.shading = THREE.SmoothShading;
                materials[tmpIndx] = tmpMat;
                if (data.pulsT) this.pulsMats.push({
                    mat: tmpMat,
                    pul: data.pulsT
                });
                if (data.frames) this.frameMats.push({
                    mat: tmpMat,
                    num: data.frames,
                    cur: 0,
                    dur: data.frameT,
                    orgDur: data.frameT
                });
            } return tmpMat;
        };
    
        // GEN COLOR CUBE:
        this.genColorCube = function(w, h, l, segments, offset, data) {
            data = data||{};
            var tmpIndex = (data.us?"us":"ns");
            for (var i = 0; i < segments.length; ++i) {
                for (var x = 0; x < segments[i].length; ++x) {
                    tmpIndex += segments[i][x] + "_";
                } tmpIndex += "|";
            }
            var tmpGeo = cubes[tmpIndex];
            if (!tmpGeo) {
                tmpGeo = new THREE.Geometry();
                var yOff = 0.5 + (offset||0);
                for (var i = 0; i < segments.length; ++i) {
                    var tmpH = segments[i][1];
                    var tmpS = (segments[i][2]||1);
                    var tmpMesh;
                    if (!data.us) {
                        var colGeo = new THREE.BoxGeometry(tmpS, tmpH, tmpS);
                        GEOS.colorize(colGeo, segments[i][0]);
                        tmpMesh = new THREE.Mesh(colGeo);
                        this.moveMesh(tmpMesh, 0, yOff - (tmpH / 2), 0);
                    } else {
                        var colGeo = GEOS.generateCube([1,1,1,1,1,1], 1, 1, 1, {
                            colr: segments[i][0],
                            fAmb: segments[i][4],
                            amb: segments[i][3]
                        });
                        tmpMesh = new THREE.Mesh(colGeo);
                        tmpMesh.scale.set(tmpS, tmpH, tmpS);
                        this.moveMesh(tmpMesh, 0, yOff - tmpH, 0);
                    } this.merge(tmpGeo, tmpMesh);
                    yOff -= tmpH;
                } cubes[tmpIndex] = tmpGeo;
            } var tmpMesh = new THREE.Mesh(tmpGeo, this.getMat("default"));
            this.scaleMesh(tmpMesh, w, h, l);
            return tmpMesh;
        };
    
        // GENERATE BODY:
        var bodyGeos = {};
        this.genBody = function(color, color2, color3, color4, det) {
            var tmpIndx = (color + "-" + color2 + "-" + color3 + "-" + color4);
            var tmpGeo = bodyGeos[tmpIndx];
            if (!tmpGeo) {
                tmpGeo = new THREE.Geometry();
                var bH = config.playerHeight - config.headScale - config.legHeight;
                var body = this.genColorCube(config.chestWidth, bH, config.chestScale,
                    [[color, 0.8, 1, 0.8], [color2, 0.2, 1.05]], 0, {
                    us: det
                });
                this.moveMesh(body, 0, (bH / 2), 0);
                this.merge(tmpGeo, body);
                var head = this.genColorCube(config.headScale, config.headScale,
                    config.headScale, [[color3, 0.2, 1, 0.6], [color4, 0.8]], 0, {
                    us: det
                });
                this.moveMesh(head, 0, config.playerHeight - (config.headScale / 2)
                    - config.legHeight, 0);
                this.merge(tmpGeo, head);
                tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
                bodyGeos[tmpIndx] = tmpGeo;
            }
            var tmpMesh = new THREE.Mesh(tmpGeo, this.getMat("default"));
            tmpMesh.receiveShadow = true;
            tmpMesh.noGreen = true;
            return tmpMesh;
        };
    
        // GENERATE LEG:
        var legGeos = {};
        this.genLeg = function(left, color, color2, crouch, det) {
            var ls = config.legScale;
            var tmpGeo = null;
            if (crouch) {
                var tmpIndx = color + "-" + (crouch||"");
                tmpGeo = legGeos[tmpIndx];
                if (!tmpGeo) {
                    var ll = config.legHeight / 2;
                    var hs = ls / 2;
                    var angles = [0.5, 2.0];
                    var upper = this.genColorCube(ls, ll, ls, [[color, 1]], 0, {
                        us: det
                    });
                    this.moveMesh(upper, 0, -((ll / 2) * Math.cos(angles[1])),
                        -((ll / 2) * Math.sin(angles[1])));
                    this.rotateMesh(upper, 0, angles[1], 0);
                    var tmpD = Math.sqrt((hs * hs) + (hs * hs) - (2 * hs * hs) * Math.cos(angles[0] - angles[1]));
                    var tmpL = Math.sqrt((hs * hs) - ((tmpD / 2) * (tmpD / 2))) * 2;
                    var connector = this.genColorCube(ls, tmpD, tmpL, [[color, 1]], 0, {
                        us: det
                    });
                    this.moveMesh(connector, 0, -(ll * Math.cos(angles[1])), -(ll * Math.sin(angles[1])));
                    this.rotateMesh(connector, 0, (angles[1] + angles[0]) / 2, 0);
                    var lower = this.genColorCube(ls, ll, ls, [[color, 0.5, 1, 0.8], [color2, 0.5]], 0, {
                        us: det
                    });
                    this.moveMesh(lower, 0, (-ll * Math.cos(angles[1])) - ((ll / 2) * Math.cos(angles[0])),
                        (-ll * Math.sin(angles[1])) - ((ll / 2) * Math.sin(angles[0])));
                    this.rotateMesh(lower, 0, angles[0], 0);
                    var tmpGeo = new THREE.Geometry();
                    this.merge(tmpGeo, upper);
                    this.merge(tmpGeo, connector);
                    this.merge(tmpGeo, lower);
                    legGeos[tmpIndx] = tmpGeo;
                }
                tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
                tmpGeo = new THREE.Mesh(tmpGeo, this.getMat("default"));
                this.moveMesh(tmpGeo, (config.legScale / 2) * (left?-1:1), (config.legHeight
                    - config.crouchDst + 0.5), 0);
            } else {
                tmpGeo = this.genColorCube(ls, config.legHeight, ls, [[color, 0.75, 1], [color2, 0.25]], -0.5, {
                    us: det
                });
                this.moveMesh(tmpGeo, (config.legScale / 2) * (left?-1:1), config.legHeight, 0);
            }
            tmpGeo.receiveShadow = true;
            tmpGeo.noGreen = true;
            return tmpGeo;
        };
    
        // GENERATE ARMS:
        var armGeos = {};
        this.genArms = function(weapon, color, color2, color3, sepIndex, isYou) {
            var tmpIndx = weapon.name + "-" + color2 + "-" + color3 + "-" + isYou + "-" + (sepIndex||0);
            var tmpGeo = armGeos[tmpIndx];
            if (!tmpGeo) {
                tmpGeo = new THREE.Geometry();
                var armX = (-config.chestWidth + (config.armScale / 2)
                    - config.armInset) * (isYou?(weapon.holdW||0.4):1);
                if (!sepIndex || sepIndex == 1) this.merge(tmpGeo, this.genArm(armX,
                    config.armOff, weapon, true, color, color2, color3, isYou));
                if (!sepIndex || sepIndex == 2) this.merge(tmpGeo, this.genArm(-armX,
                    config.armOff, weapon, false, color, color2, color3, isYou));
                tmpGeo = new THREE.BufferGeometry().fromGeometry(tmpGeo);
                armGeos[tmpIndx] = tmpGeo;
            }
            tmpGeo = new THREE.Mesh(tmpGeo, this.getMat("default"));
            tmpGeo.position.z += (isYou?weapon.hDstOff||0:0);
            tmpGeo.noGreen = true;
            tmpGeo.receiveShadow = true;
            return tmpGeo;
        };
    
        // GENERATE ARM:
        this.genArm = function(x, y, weapon, left, color, color2, color3, isYou) {
            var yOff = (left?weapon.leftHoldY:weapon.rightHoldY);
            var zOff = (left?weapon.leftHoldZ:weapon.rightHoldZ);
            zOff += (isYou?weapon.hDstOff||0:0);
            var xOff = (left?weapon.leftHoldX||0:weapon.rightHoldX||0);
            var armS = config.armScale * (isYou?0.7:1);
            var holdDist = Math.min(config.uArmLength + config.lArmLength - 0.01,
                UTILS.getD3D(x, y, 0, (weapon.xOff - xOff) *
                (left&&weapon.akimbo?-1:1),
                weapon.yOff + yOff, weapon.zOff - zOff));
            var angles = UTILS.getAnglesSSS(holdDist, config.uArmLength, config.lArmLength);
            var tmpAngle = Math.PI / 2;
            if (!isYou) {
                var upper = this.genColorCube(armS, config.uArmLength, armS, [[color, 1]], 0, {
                    us: isYou
                });
                this.moveMesh(upper, 0, -((config.uArmLength / 2) * Math.cos(tmpAngle)),
                    -((config.uArmLength / 2) * Math.sin(tmpAngle)));
                this.rotateMesh(upper, 0, tmpAngle, 0);
                var tmpS = armS / 2;
                var tmpD = Math.sqrt((tmpS * tmpS) + (tmpS * tmpS)
                    - (2 * tmpS * tmpS) * Math.cos(Math.PI + angles[0] + (Math.PI / 2)));
                var tmpL = Math.sqrt((tmpS * tmpS) - ((tmpD / 2) * (tmpD / 2))) * 2;
                var connector = this.genColorCube(armS, tmpD, tmpL, [[color, 1]], 0, {
                    us: isYou
                });
                this.moveMesh(connector, 0, -(config.uArmLength * Math.cos(tmpAngle)),
                     -(config.uArmLength * Math.sin(tmpAngle)));
                this.rotateMesh(connector, 0, (tmpAngle + angles[0]) / 2, 0);
            }
            var lower = this.genColorCube(armS, config.lArmLength, armS,
                [[color, 0.65, 1, 0.6], [color2, 0.15, 1.1], [color3,
                0.2, 1, 0.5, true]], 0, {
                    us: isYou
                });
            var tOff = (config.lArmLength / 2);
            this.moveMesh(lower, 0,
                (-config.uArmLength * Math.cos(tmpAngle)) -
                (tOff * Math.cos(angles[0])),
                (-config.uArmLength * Math.sin(tmpAngle)) -
                (tOff * Math.sin(angles[0])));
            this.rotateMesh(lower, 0, angles[0], 0);
            var tmpObj = new THREE.Geometry();
            if (!isYou) {
                this.merge(tmpObj, upper);
                this.merge(tmpObj, connector);
            } else {
                var extender = this.genColorCube(armS, 20, armS, [[color, 1]], 0, {
                    us: isYou
                });
                this.moveMesh(extender, 0,
                    (-config.uArmLength * Math.cos(tmpAngle)) -
                    (-10 * Math.cos(angles[0])),
                    (-config.uArmLength * Math.sin(tmpAngle)) -
                    (-10 * Math.sin(angles[0])));
                this.rotateMesh(extender, 0, angles[0], 0);
                this.merge(tmpObj, extender);
            } this.merge(tmpObj, lower);
            tmpObj = new THREE.Mesh(tmpObj);
            this.moveMesh(tmpObj, x - weapon.xOff, y - weapon.yOff, -weapon.zOff);
            tmpObj.rotation.order = "YXZ";
            tmpObj.rotation.x = (-angles[1] -UTILS.getDir(0, y, weapon.zOff - zOff,
                weapon.yOff + yOff));
            tmpObj.rotation.y = (UTILS.getDir(-x, 0, (left&&weapon.akimbo?1:-1) *
                 (weapon.xOff - xOff), weapon.zOff - zOff) - (Math.PI / 2));
            return tmpObj;
        };
    
        // ADD CUBE:
        this.addCube = function(x, y, z, w, h, l, sides, data) {
            data = data||{};
            var mesh = new THREE.Mesh(GEOS.generateCube(sides, w, h, l, data));
            this.moveMesh(mesh, x, y, z);
            mesh.rotation.set(data.yR||0, data.xR||0, data.zR||0);
            mesh.scale.set(w, h, l);
            if (data.src && !data.noGroup) this.meshGroup(mesh, data);
            else this.add(mesh, data);
            return mesh;
        };
    
        // ADD SPHERE:
        this.addSphere = function(x, y, z, w, h, l, data) {
            data = data||{};
            var mesh = new THREE.Mesh(GEOS.generateSphere(w, h, l, data));
            this.moveMesh(mesh, x, y + (h / 2), z);
            mesh.rotation.set(data.yR||0, data.xR||0, data.zR||0);
            mesh.scale.set(w/2, h/2, l/2);
            if (data.src && !data.noGroup) this.meshGroup(mesh, data);
            else this.add(mesh, data);
            return mesh;
        };
    
        // ADD CONE:
        this.addCone = function(x, y, z, w, h, l, data) {
            data = data||{};
            var mesh = new THREE.Mesh(GEOS.generateCone(w, h, l, data));
            this.moveMesh(mesh, x, y, z);
            mesh.rotation.set(data.yR||0, data.xR||0, data.zR||0);
            if (data.src && !data.noGroup) this.meshGroup(mesh, data);
            else this.add(mesh, data);
            return mesh;
        };
    
        // ADD SPRAY:
        var sprays = [];
        this.addSpray = function(sid, index, x, y, z, xD, yD, data) {
            data = data||{};
            tmpObj = null;
            for (var i = 0; i < sprays.length; ++i) {
                if (sprays[i].sid == sid) {
                    tmpObj = sprays[i];
                    break;
                }
            }
            if (!tmpObj) {
                tmpObj = new THREE.Mesh(planeGeo);
                tmpObj.sid = sid;
                tmpObj.scale.set(config.sprayScale, config.sprayScale, 1);
                tmpObj.receiveShadow = true;
                sprays.push(tmpObj);
                this.add(tmpObj);
            }
            this.moveMesh(tmpObj, x, y, z);
            tmpObj.rotation.y = UTILS.toRad(xD);
            tmpObj.rotation.x = UTILS.toRad(yD);
            tmpObj.material = this.getMat("sprays/" + (data.id ||0), {
                depthWrite: false,
                opacity: data.opacity,
                transparent: true,
                frames: data.frames,
                frameT: data.frameT,
                movT: data.movT,
                movD: data.movD,
            });
        }
        this.clearSprays = function() {
            for (var i = 0; i < sprays.length; ++i) {
                if (sprays[i] && sprays[i].material.map) sprays[i].material.map.dispose();
                this.scene.remove(sprays[i]);
            }
            sprays.length = 0;
        };
    
        // ADD PLANE:
        this.addPlane = function(x, y, z, w, l, data, xR, yR, zR) {
            data = data||{};
            data.premultipliedAlpha = true;
            var mesh = new THREE.Mesh(GEOS.generatePlane(l, w, data, x, y, z));
            if (data.euler) mesh.rotation.order = data.euler;
            this.moveMesh(mesh, x, y, z);
            mesh.rotateY(xR||0);
            mesh.rotateX((yR||0) - Math.PI / 2);
            mesh.rotateZ(zR||0);
            mesh.scale.set(w * 2, l * 2, 1);
            if (!data.dontAdd) {
                if (data.src && !data.noGroup) this.meshGroup(mesh, data, 1);
                else this.add(mesh, data);
            } else if (data.src) mesh.material = this.getMat(data.src, data);
            return mesh;
        };
    
        // ADD RAMP:
        this.addRamp = function(x, y, z, w, h, l, dir, data, zD) {
            data = data||{};
            var mesh = new THREE.Mesh(GEOS.generatePlane(l * 2, w, data));
            this.moveMesh(mesh, x, y + (h / 2), z);
            l *= 2;
            var rl = Math.sqrt((h * h) + (l * l));
            mesh.scale.set(w, rl, 2);
            mesh.rotateY(-(Math.PI / 2) - dir);
            mesh.rotateX(Math.asin(h / rl) - (Math.PI / 2));
            mesh.rotateZ(zD||0);
            if (data.src) this.meshGroup(mesh, data, 1);
            else this.add(mesh, data);
            return mesh;
        };
    
        // ADD GRASS:
        this.addGrass = function(x, y, z, w, h, l, data)  {
            data = data||{};
            let tmpGeo = new THREE.Geometry();
            let angle = (Math.PI * 2) * Math.random();
            let tmpMesh = new THREE.Mesh(GEOS.generatePlane(w, h, data));
            tmpMesh.rotateY(angle * (Math.PI / 2));
            this.merge(tmpGeo, tmpMesh);
            let tmpMesh2 = new THREE.Mesh(GEOS.generatePlane(w, h, data));
            tmpMesh2.rotateY((angle + 1) * (Math.PI / 2));
            this.merge(tmpGeo, tmpMesh2);
            let mesh = new THREE.Mesh(tmpGeo);
            this.moveMesh(mesh, x, y + (h / 2), z);
            mesh.rotation.set(data.yR||0, data.xR||0, data.zR||0);
            mesh.scale.set(w, h, l);
            if (data.src && !data.noGroup) this.meshGroup(mesh, data);
            else this.add(mesh, data);
            return mesh;
        };
    
        // LOAD MESH:
        var loadedGeos = [];
        var pendingMeshes = [];
        var failedLoads = [];
        this.loadMesh = function(data, x, y, z, r, scale, obj, merge) {
            var tmpMat = this.getMat(data.src, data);
            var tmpGeo = loadedGeos[data.src];
            if (!tmpGeo) {
                tmpGeo = merge?new THREE.Geometry():new THREE.BufferGeometry();
                loadedGeos[data.src] = tmpGeo;
                objLoader.load(UTILS.assetsUrl("/models/" + data.src + ".obj"), function (mesh) {
                    tmpGeo.copy(merge?(new THREE.Geometry().fromBufferGeometry(
                        mesh.children[0].geometry)):mesh.children[0].geometry);
                    if (data.uv2) tmpGeo.setAttribute('uv2', new THREE.BufferAttribute(
                        tmpGeo.attributes.uv.array, 2));
                    if (merge) {
                        var addGeo = new THREE.Geometry();
                        for (var i = 0; i < pendingMeshes[data.src].length; ++i) {
                            context.merge(addGeo, pendingMeshes[data.src][i]);
                        } context.add(new THREE.Mesh(new THREE.BufferGeometry()
                            .fromGeometry(addGeo), tmpMat), data);
                        pendingMeshes[data.src].length = 0;
                        pendingMeshes[data.src].loaded = true;
                    } if (data.centerZ) {
                        tmpGeo.computeBoundingBox();
                        var center = tmpGeo.boundingBox.getCenter();
                        obj.translateZ(center.x * scale);
                    }
                });
            } else if (data.centerZ) {
                tmpGeo.computeBoundingBox();
                var center = tmpGeo.boundingBox.getCenter();
                obj.translateZ(center.x * scale);
            }
            var tmpMesh = new THREE.Mesh(tmpGeo, tmpMat);
            tmpMesh.receiveShadow = (data.noShadow?false:true);
            tmpMesh.noGreen = data.noGreen;
            tmpMesh.castShadow = data.shadows;
            if (typeof r == 'object') {
                tmpMesh.rotation.x = tmpMesh.xR = (r[0]||0);
                tmpMesh.rotation.y = tmpMesh.yR = (r[1]||0);
                tmpMesh.rotation.z = tmpMesh.zR = (r[2]||0);
            } else tmpMesh.rotation.y = (r||0);
            tmpMesh.xP = x;
            tmpMesh.yP = y;
            tmpMesh.zP = z;
            context.moveMesh(tmpMesh, x, y, z);
            context.scaleMesh(tmpMesh, scale||1, scale||1, scale||1);
            if (merge) {
                if (!pendingMeshes[data.src]) pendingMeshes[data.src] = [tmpMesh];
                else if (pendingMeshes[data.src].loaded) this.meshGroup(tmpMesh, data);
                else pendingMeshes[data.src].push(tmpMesh);
            } else obj.add(tmpMesh);
            return tmpMesh;
        };
    
        // LOAD SPRITE:
        this.loadSprite = function(data, obj) {
            var tmpMat = this.getMat(data.src, data);
            var tmpSprite = new THREE.Sprite(tmpMat);
            tmpSprite.xP = 0;
            tmpSprite.yP = 0;
            tmpSprite.zP = 0;
            tmpSprite.position.set(0, config.playerHeight/2, 0);
            tmpSprite.scale.set(config.playerHeight, config.playerHeight, 1);
            obj.add(tmpSprite);
            return tmpSprite;
        };
    
        // CLEAR PENDING MESHES:
        this.clearPendingMeshes = function() {
            for (var msh in pendingMeshes) {
                if (pendingMeshes.hasOwnProperty(msh) && pendingMeshes[msh]) {
                    pendingMeshes[msh].length = 0;
                }
            }
        };
    
        // UPDATE MESH:
        this.updateMesh = function(src, text) {
            var mesh = objLoader.parse(text);
            var tmpGeo = new THREE.BufferGeometry();
            loadedGeos[src] = tmpGeo;
            // mesh.children[0].geometry.computeVertexNormals();
            tmpGeo.copy(mesh.children[0].geometry);
            tmpGeo.needsUpdate = true;
        };
    
        // GENERATE GROUP:
        this.genObj3D = function(x, y, z) {
            if (typeof Module !== "undefined") { 
                return Module.vrt_func_199592592952592(THREE, this, x||0, y||0, z||0);
            } else {
                var obj3D = new THREE.Object3D();
                this.moveMesh(obj3D, x||0, y||0, z||0);
                return obj3D;
            }	
        };
    
        // MERGE:
        this.merge = function(parent, child, index) {
            child.updateMatrix();
            parent.merge(child.geometry, child.matrix, index);
        };
    
        // ADD MESH TO GROUP:
        this.meshGroup = function(mesh, data) {
            var tmpIndx = (data.src + "-" + (data.shadowsR||"a") +
                (data.emissive||"e") + (data.opacity||"o") +
                (data.movT!=undefined?data.movT:"mt") +
                  (data.movD!=undefined?data.movD:"md") +
                (data.showAd?"ad":"nad"));
            if (!groupMeshes[tmpIndx]) {
                groupMeshes[tmpIndx] = new THREE.Geometry();
                groupMeshes[tmpIndx].data = data;
            } mesh.updateMatrix();
            groupMeshes[tmpIndx].merge(mesh.geometry, mesh.matrix);
        };
    
        // ADD MESH GROUPS:
        this.addMeshGroups = function() {
            for (var mesh in groupMeshes) {
                if (groupMeshes.hasOwnProperty(mesh)) {
                    var tmpMesh = new THREE.Mesh(new
                        THREE.BufferGeometry().fromGeometry(
                        groupMeshes[mesh]));
                    tmpMesh.groupSrc = groupMeshes[mesh].data.src;
                    tmpMesh.visible = (meshVisibilities[tmpMesh.groupSrc]?false:true);
                    tmpMesh.matrixAutoUpdate = false;
                    this.add(tmpMesh, groupMeshes[mesh].data);
                }
            } groupMeshes = {};
        };
    
        // TOGGLE MESH GROUP:
        var meshVisibilities = {};
        this.toggleMeshGroup = function(src, vis) {
            meshVisibilities[src] = !vis;
            if (this.scene) this.scene.traverse(function(node) {
                if (node instanceof THREE.Mesh && node.groupSrc == src) {
                    node.visible = vis;
                }
            });
        };
    
        // ADD MESHES TO SCENE:
        this.add = function(mesh, data) {
            if (data) {
                mesh.castShadow = data.shadows;
                mesh.receiveShadow = data.shadows||data.shadowsR;
                mesh.material = this.getMat(data.src, data);
            } this.updateGreenScreen(mesh);
            this.scene.add(mesh);
            this.updateShadowMap();
        };
    
        // REMOVE MESHES FROM SCENE:
        this.remove = function(meshes) {
            this.scene.remove(meshes);
            // TODO: DISPOSE MATERIAL OF ALL CHILDREN
            // DISPOSE GEOMETRY OF ALL CHILDREN
        };
    
        // MOVE MESH:
        this.moveMesh = function(mesh, x, y, z) {
            if (!mesh) return;
            if (x != undefined) mesh.position.x = x;
            if (y != undefined) mesh.position.y = y;
            if (z != undefined) mesh.position.z = z;
        };
    
        // SCALE MESH:
        this.scaleMesh = function(mesh, x, y, z) {
            mesh.scale.set(x, y, z);
        };
    
        // ROTATE MESH:
        this.rotateMesh = function(mesh, x, y, z) {
            if (!mesh) return;
            if (x || x == 0) mesh.rotation.y = x;
            if (y || y == 0) mesh.rotation.x = y;
            if (z || z == 0) mesh.rotation.z = z;
        };
    
        // CLEAR RENDER:
        this.reset = function() {
            loadedGeos = [];
            pendingMeshes = [];
            groupMeshes = {};
            materials = {};
            textures = {};
            this.movTextures.length = 0;
            this.pulsMats.length = 0;
            this.frameMats.length = 0;
            this.pulsVal = 0;
            this.liquidVal = 0;
            this.liquids.length = 0;
        };
    
    };
    
    // EFFECT INITIATOR:
    module.exports.initScene = function(map, mode) {
        mapData = map;
        modeData = mode;
        if ((mode && mode.ambCol != undefined) || map.ambient) {
            this.ambientLight = new THREE.AmbientLight((mode&&mode.ambCol!=undefined?mode.ambCol:map.ambient),
                (map.ambientI != undefined ? map.ambientI : config.ambIntensity));
            this.ambientLight.layers.enable(1);
            this.ambientLight.layers.enable(2);
            this.ambientLight.name = "ambLight";
            if (!this.scene.getObjectByName('ambLight')) this.scene.add(this.ambientLight);
        } if ((mode && mode.lightCol != undefined) || map.light) {
            this.skyLight = new THREE.DirectionalLight((mode&&mode.lightCol!=undefined?mode.lightCol:map.light),
                (map.lightI != undefined ? map.lightI : config.lightIntensity));
            this.skyLight.name = "skyLight";
            this.skyLight.layers.enable(1);
            this.skyLight.layers.enable(2);
            if (!this.scene.getObjectByName('skyLight'))
                this.scene.add(this.skyLight);
            var theta = Math.PI * ((map.sunAngY != undefined ? map.sunAngY : config.sunAngleY)/-180);
            var phi = Math.PI * ((map.sunAngX != undefined ? map.sunAngX : config.sunAngleX)/-180);
            var dis = (map.lightD != undefined ? map.lightD : config.lightDistance);
            this.skyLight.position.x = dis * Math.cos(phi);
            this.skyLight.position.y = dis * Math.sin(phi) * Math.sin(theta);
            this.skyLight.position.z = dis * Math.sin(phi) * Math.cos(theta);
            this.skyLight.castShadow = true;
            this.skyLight.shadow.mapSize.width = (map.shadowR||config.shadowRes);
            this.skyLight.shadow.mapSize.height = (map.shadowR||config.shadowRes);
            this.skyLight.shadow.camera.far = (map.shadowD||config.shadowDst);
        }
        this.scene.fog = new THREE.Fog((mode&&mode.fogC!=undefined?mode.fogC:map.fog),
            1, (mode&&mode.fogD!=undefined?mode.fogD:map.fogD));
        this.renderer.setClearColor((mode&&mode.skyCol!=undefined?mode.skyCol:map.sky));
        if (this.useDepthMap && this.useDepthMap != "0") this.toggleDepthMap(this.useDepthMap);
        if (this.greenScreen) this.toggleGreenscreen(this.greenScreen);
    };
    
    
    /***/ }),
    
    /***/ "./src/libs/shaders.js":
    /*!*****************************!*\
      !*** ./src/libs/shaders.js ***!
      \*****************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
    // SHADERS:
    module.exports = function(THREE) {
    
        // STRIPPED LAMBERT:
        // See definition: https://github.com/mrdoob/three.js/blob/dev/src/materials/MeshLambertMaterial.js
        // See chunks: https://github.com/mrdoob/three.js/tree/dev/src/renderers/shaders/ShaderChunk
        // See frag: https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/meshlambert_frag.glsl.js
        // See vert: https://github.com/mrdoob/three.js/blob/dev/src/renderers/shaders/ShaderLib/meshlambert_vert.glsl.js
        THREE.StrippedLambertMaterial = function(parameters) {
            let material = new THREE.ShaderMaterial({
                name: "lambert-stripped",
                uniforms: THREE.UniformsUtils.merge([
                    THREE.ShaderLib.lambert.uniforms,
                ]),
    
                lights: true,
                fog: true,
    
                vertexShader: `
    #define LAMBERT
    varying vec3 vLightFront;
    varying vec3 vIndirectFront;
    #ifdef DOUBLE_SIDED
        varying vec3 vLightBack;
        varying vec3 vIndirectBack;
    #endif
    #include <common>
    #include <uv_pars_vertex>
    #include <uv2_pars_vertex>
    // #include <envmap_pars_vertex>
    #include <bsdfs>
    #include <lights_pars_begin>
    #include <color_pars_vertex>
    #include <fog_pars_vertex>
    // #include <morphtarget_pars_vertex>
    // #include <skinning_pars_vertex>
    #include <shadowmap_pars_vertex>
    // #include <logdepthbuf_pars_vertex>
    // #include <clipping_planes_pars_vertex>
    void main() {
        #include <uv_vertex>
        #include <uv2_vertex>
        #include <color_vertex>
        #include <beginnormal_vertex>
        // #include <morphnormal_vertex>
        // #include <skinbase_vertex>
        // #include <skinnormal_vertex>
        #include <defaultnormal_vertex>
        #include <begin_vertex>
        // #include <morphtarget_vertex>
        // #include <skinning_vertex>
        #include <project_vertex>
        // #include <logdepthbuf_vertex>
        // #include <clipping_planes_vertex>
        #include <worldpos_vertex>
        // #include <envmap_vertex>
        #include <lights_lambert_vertex>
        #include <shadowmap_vertex>
        #include <fog_vertex>
    }
    `,
                fragmentShader: `
    uniform vec3 diffuse;
    uniform vec3 emissive;
    uniform float opacity;
    
    varying vec3 vLightFront;
    varying vec3 vIndirectFront;
    
    #ifdef DOUBLE_SIDED
        varying vec3 vLightBack;
        varying vec3 vIndirectBack;
    #endif
    
    
    #include <common>
    #include <packing>
    // #include <dithering_pars_fragment>
    #include <color_pars_fragment>
    #include <uv_pars_fragment>
    #include <uv2_pars_fragment>
    #include <map_pars_fragment>
    // #include <alphamap_pars_fragment>
    #include <aomap_pars_fragment>
    #include <lightmap_pars_fragment>
    #include <emissivemap_pars_fragment>
    // #include <envmap_pars_fragment>
    #include <bsdfs>  // Shading functions
    #include <lights_pars_begin>
    #include <fog_pars_fragment>
    #include <shadowmap_pars_fragment>
    #include <shadowmask_pars_fragment>
    // #include <specularmap_pars_fragment>
    // #include <logdepthbuf_pars_fragment>
    // #include <clipping_planes_pars_fragment>
    
    void main() {
    
        // #include <clipping_planes_fragment>
    
        vec4 diffuseColor = vec4( diffuse, opacity );
        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
        vec3 totalEmissiveRadiance = emissive;
    
        // #include <logdepthbuf_fragment>
        #include <map_fragment>
        #include <color_fragment>
        // #include <alphamap_fragment>
        #include <alphatest_fragment>
        // #include <specularmap_fragment>
        #include <emissivemap_fragment>
    
        // accumulation
        reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );
    
        #ifdef DOUBLE_SIDED
    
            reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
    
        #else
    
            reflectedLight.indirectDiffuse += vIndirectFront;
    
        #endif
    
        #include <lightmap_fragment>
    
        reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
    
        #ifdef DOUBLE_SIDED
    
            reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
    
        #else
    
            reflectedLight.directDiffuse = vLightFront;
    
        #endif
    
        reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
    
        // modulation
        #include <aomap_fragment>
    
        vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
    
        // #include <envmap_fragment>
    
        gl_FragColor = vec4( outgoingLight, diffuseColor.a );
    
        // #include <tonemapping_fragment>
        // #include <encodings_fragment>
        #include <fog_fragment>
        #include <premultiplied_alpha_fragment>
        // #include <dithering_fragment>
    }
        `
            });
    
            // // Define properties that forward their value to the uniforms
            // let swizzledProperties = {
            //     "color": "diffuse",
            //     // "emissive": "emissive",
            // };
            // for (let prop in swizzledProperties) {
            //     let uniformKey = swizzledProperties[prop];
            //     Object.defineProperty(material, prop, {
            //         get() {
            //             return material.uniforms[uniformKey].value;
            //         },
    
            //         set(v) {
            //             material.uniforms[uniformKey].value = v;
            //         }
            //     });
            // }
            // console.log("unifroms", material.uniforms);
    
            // Apply properties from lambert material
            Object.assign(material, new THREE.MeshLambertMaterial(parameters));
    
            // Flag as lambert material so other uniforms are applied appropriately
            // material.isShaderMaterial = false;
            material.isMeshLambertMaterial = true;
    
            // Set initial parameters
            material.setValues(parameters);
    
            return material;
        }
    };
    
    
    /***/ }),
    
    /***/ "./src/libs/sound.js":
    /*!***************************!*\
      !*** ./src/libs/sound.js ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports) {
    
    
    // SOUND MANAGER:
    module.exports = function(UTILS, config) {
    
        // INIT:
        var tmpSound;
        this.sounds = [];
        this.listener = {};
        this.rate = 1;
        this.volumes = [
            1, // MASTER 0
            1, // VOICE 1
            1, // AMBIENT 2
            1, // GUNS 3
            1, // PLAYER SOUNDS 4
            1  // UI 5
        ];
        this.soundCats = {
            // NOT USED
            // 'appear': 0, 'rico_1': 0, 'rico_2': 0,
    
            // UNKNOWN or MASTER 0
            'nuke_0': 0, 'siren_0': 0,
    
            // AMBIENT 1
            'ambient_1': 2, 'ambient_2': 2, 'ambient_3': 2, 'ambient_4': 2, 'ambient_5': 2,
    
            // GUNS 3
            'aim_0': 3, 'aim_1': 3, 'explosion': 3, 'gclick_0': 3, 'pick_0': 3, 'pick_1': 3,
            'reload_1': 3, 'reload_2': 3, 'swish_0': 3, 'swish_1': 3, 'weapon_1': 3,
            'weapon_1_0': 3, 'weapon_2': 3, 'weapon_3': 3, 'weapon_4': 3, 'weapon_5': 3,
            'weapon_6': 3, 'weapon_7': 3, 'weapon_8': 3, 'weapon_9': 3, 'weapon_10': 3,
            'weapon_11': 3, 'weapon_12': 3, 'weapon_13': 3, 'weapon_14': 3, 'weapon_15': 3,
            'weapon_16': 3, 'weapon_17': 3, 'weapon_18': 3, 'whizz_0': 3, 'whizz_1': 3,
            'weapon_6_0': 3, 'weapon_1_2': 3,
    
            // PLAYER SOUNDS 4
            'fart_0': 4, 'headshot_0': 4, 'hit_0': 4, 'impact_0': 4, 'jump_0': 4,
            'jump_1': 4, 'land_0': 4, 'punch_0': 4, 'punch_1': 4, 'scare_0': 4, 'slide_0': 4,
            'spray': 4, 'step_0': 4, 'step_1': 4, 'step_2': 4, 'taunt_0': 4, 'taunt_1': 4,
            'taunt_2': 4, 'taunt_3': 4, 'taunt_3': 4,
    
            // UI 5
            'buy_0': 5, 'buy_1': 5, 'case_0': 5, 'case_1': 5, 'cheer_0': 5, 'reward': 5,
            'store': 5, 'tick_0': 5,
        };
    
        // TOGGLE:
        this.setVolume = function(volume, cat = 0) {
            if (this.volumes[cat] != undefined) {
                this.volumes[cat] = volume;
                if (cat == 0) Howler.volume(volume);
            }
        };
    
        // GET SOUND:
        this.getSound = function(id, group) {
            var tmpIndx = (id + (group||"")
                + (window.activeHacker?"hckd":""));
            tmpSound = this.sounds[tmpIndx];
            if (!tmpSound) {
                tmpSound = new Howl({
                    src: ".././sound/" + (window.activeHacker?
                        "fart_0":id) + ".mp3"
                });
                this.sounds[tmpIndx] = tmpSound;
            }
        };
    
        // PLAY SOUND:
        this.play = function(id, vol, loop, rate) {
            this.getSound(id);
            if (this.rate && (!loop || !tmpSound.isPlaying)) {
                tmpSound.isPlaying = true;
                var tmpID = tmpSound.play();
                tmpSound.volume((vol||1) * (this.soundCats[id] != undefined
                    ? this.volumes[this.soundCats[id]] : 1), tmpID);
                tmpSound.loop(loop, tmpID);
                tmpSound.rate((rate||1)*this.rate, tmpID);
            }
        };
    
        // STOP SOUND:
        this.stop = function(id) {
            this.getSound(id);
            if (tmpSound) {
                tmpSound.isPlaying = false;
                tmpSound.stop();
            }
        };
    
        // PLAY 3D NOT SPACIAL:
        this.play3Dv = function(id, x, y, z, rng, vol, rate, list) {
            var tmpDst = UTILS.getD3D(x, y, z, list.x, list.y, list.z);
            var tmpMlt = (1 - (tmpDst / rng));
            if (tmpMlt > 0.1) {
                this.getSound(id, "3dv");
                var tmpID = tmpSound.play();
                vol = ((vol||1) * tmpMlt * config.otherSoundMlt);
                tmpSound.volume(vol * (this.soundCats[id] != undefined
                    ? this.volumes[this.soundCats[id]] : 1), tmpID);
                tmpSound.rate(rate||1, tmpID);
            }
        };
    
        // PLAY 3D:
        this.play3D = function(id, x, y, z, vol, rate, dist, roll) {
            this.getSound(id, "3d");
            var tmpID = tmpSound.play();
            vol = (vol||1) * config.otherSoundMlt;
            if (vol > 0.05) {
                tmpSound.volume(vol * (this.soundCats[id] != undefined
                    ? this.volumes[this.soundCats[id]] : 1), tmpID);
                tmpSound.rate(rate||1, tmpID);
                tmpSound.pos(x, y, z, tmpID);
                tmpSound.pannerAttr({
                    refDistance: dist||25,
                    rolloffFactor: roll||1
                }, tmpID);
            }
        };
    
    };
    
    
    /***/ }),
    
    /***/ "./src/libs/utils.js":
    /*!***************************!*\
      !*** ./src/libs/utils.js ***!
      \***************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
        const config = __webpack_require__(/*! ../config */ "./src/config.js");
        const gameVersion = __webpack_require__(/*! ../../version.json */ "./version.json");
    
        // KEY VALUES:
        module.exports.keyboardMap = "   CANCEL   HELP  BACK_SPACE TAB   CLEAR ENTER ENTER_SPECIAL  SHIFT CONTROL ALT PAUSE CAPS_LOCK KANA EISU JUNJA FINAL HANJA  ESCAPE CONVERT NONCONVERT ACCEPT MODECHANGE SPACE PAGE_UP PAGE_DOWN END HOME LEFT UP RIGHT DOWN SELECT PRINT EXECUTE PRINTSCREEN INSERT DELETE  0 1 2 3 4 5 6 7 8 9 COLON SEMICOLON LESS_THAN EQUALS GREATER_THAN QUESTION_MARK AT A B C D E F G H I J K L M N O P Q R S T U V W X Y Z OS_KEY  CONTEXT_MENU  SLEEP NUMPAD0 NUMPAD1 NUMPAD2 NUMPAD3 NUMPAD4 NUMPAD5 NUMPAD6 NUMPAD7 NUMPAD8 NUMPAD9 MULTIPLY ADD SEPARATOR SUBTRACT DECIMAL DIVIDE F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24         NUM_LOCK SCROLL_LOCK WIN_OEM_FJ_JISHO WIN_OEM_FJ_MASSHOU WIN_OEM_FJ_TOUROKU WIN_OEM_FJ_LOYA WIN_OEM_FJ_ROYA          CIRCUMFLEX EXCLAMATION DOUBLE_QUOTE HASH DOLLAR PERCENT AMPERSAND UNDERSCORE OPEN_PAREN CLOSE_PAREN ASTERISK PLUS PIPE HYPHEN_MINUS OPEN_CURLY_BRACKET CLOSE_CURLY_BRACKET TILDE     VOLUME_MUTE VOLUME_DOWN VOLUME_UP   SEMICOLON EQUALS COMMA MINUS PERIOD SLASH BACK_QUOTE                           OPEN_BRACKET BACK_SLASH CLOSE_BRACKET QUOTE  META ALTGR  WIN_ICO_HELP WIN_ICO_00  WIN_ICO_CLEAR   WIN_OEM_RESET WIN_OEM_JUMP WIN_OEM_PA1 WIN_OEM_PA2 WIN_OEM_PA3 WIN_OEM_WSCTRL WIN_OEM_CUSEL WIN_OEM_ATTN WIN_OEM_FINISH WIN_OEM_COPY WIN_OEM_AUTO WIN_OEM_ENLW WIN_OEM_BACKTAB ATTN CRSEL EXSEL EREOF PLAY ZOOM  PA1 WIN_OEM_CLEAR ".split(" ");
    
        // BASE64:
        module.exports.getB64Size = function(base64) {
    
        };
    
        // COMPRESS NUMBER ARRAY:
        module.exports.compressNumArray = function(arr) {
            var lastVal = null;
            var noVariant = true;
            for (var i = arr.length - 1; i >= 0; --i) {
                if (typeof arr[i] == "number") {
                    if (lastVal !== null) {
                        lastVal++;
                        arr[i] = lastVal;
                        arr.splice(i + 1);
                    } else lastVal = 0;
                } else {
                    lastVal = null;
                    noVariant = false;
                }
            } return (noVariant?arr[0]:arr);
        };
    
        // UTILS:
        Number.prototype.round = function(places) {
            return +this.toFixed(places);
        };
        String.prototype.escape = function() {
            return (this + '').replace(/[\\"']/g, '\\$&').replace(/\u0000/g, '\\0');
        };
        Number.prototype.roundToNearest = function(near) {
            if (this > 0) return Math.ceil(this / near) * near;
            else if (this < 0) return Math.floor(this / near) * near;
            else return this;
        };
        module.exports.capFirst = function(str) {
            return (str.charAt(0).toUpperCase() + str.slice(1));
        };
        module.exports.isURL = function(str) {
            try {
                var pattern = new RegExp('^(https?:\\/\\/)?'+
                  '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|'+
                  '((\\d{1,3}\\.){3}\\d{1,3}))'+
                  '(\\:\\d+)?'+
                  '(\\/[-a-z\\d%@_.~+&:]*)*'+
                  '(\\?[;&a-z\\d%@_.,~+&:=-]*)?'+
                  '(\\#[-a-z\\d_]*)?$','i');
                return pattern.test(str);
            } catch (e) {}
            return false;
        };
        module.exports.arrayAverage = function(a) {
            var val = 0;
            for (var i = 0; i < a.length; i++) {
                val += a[i];
            } return (val / a.length);
        };
        module.exports.countInArray = function(array, val) {
            var count = 0;
            for (var i = 0; i < array.length; i++) {
                if (array[i] === val) count++;
            } return count;
        };
        module.exports.formatNum = function(n, fixed = 1) {
            var base = Math.floor(Math.log(Math.abs(n)) / Math.log(1000));
            var suffix = 'kmb'[base - 1];
            return suffix?((n / Math.pow(1000, base)).toFixed(fixed) + suffix):('' + n);
        };
        module.exports.randInt = function (min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        };
        module.exports.randFloat = function (min, max) {
            return Math.random() * (max - min) + min;
        };
        module.exports.getPercentDiff = function (first, last) {
            return Math.round(((last-first)/first) * 100, 1);
        };
        module.exports.getRandom = function(array) {
            return array[module.exports.randInt(0, array.length - 1)];
        };
        module.exports.getDistance = function (x1, y1, x2, y2) {
            return Math.sqrt((x2 -= x1) * x2 + (y2 -= y1) * y2);
        };
        module.exports.getD3D = function(x1, y1, z1, x2, y2, z2) {
            var dx = x1 - x2;
            var dy = y1 - y2;
            var dz = z1 - z2;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        };
        module.exports.getAnglesSSS = function(a, b, c) {
            var angleA = Math.acos(((b * b) + (c * c) - (a * a)) / (2 * b * c));
            var angleB = Math.acos(((c * c) + (a * a) - (b * b)) / (2 * c * a));
            var angleC = Math.PI - angleA - angleB;
            return [-angleA - (Math.PI / 2), angleB, angleC];
        };
        module.exports.getXDire = function(x1, y1, z1, x2, y2, z2) {
            var h = Math.abs(y1 - y2);
            var dst = module.exports.getD3D(x1, y1, z1, x2, y2, z2);
            return (Math.asin(h / dst) * ((y1 > y2)?-1:1));
        };
        module.exports.getAngleDst = function (a, b) {
            return Math.atan2(Math.sin(b - a), Math.cos(a - b));
        };
        module.exports.getAngleDist2 = function(alpha, beta) {
            var phi = Math.abs(beta - alpha) % (Math.PI * 2);
            return (phi>Math.PI?(Math.PI * 2)-phi:phi);
        };
        module.exports.toRad = function(angle) {
            return (angle * (Math.PI / 180));
        }
        module.exports.getDir = function (x1, y1, x2, y2) {
            return Math.atan2(y1 - y2, x1 - x2);
        };
        module.exports.lerp = function (value1, value2, amount) {
            return value1 + (value2 - value1) * amount;
        };
        module.exports.orderByScore = function(a, b) {
            return (b.score - a.score);
        };
        module.exports.orderByKills = function(a, b) {
            return (b.kills - a.kills);
        };
        module.exports.orderByDst = function(a, b) {
            return (a.dst - b.dst);
        };
        module.exports.orderByNum = function(a, b) {
            return (a - b);
        };
        module.exports.capFirst = function(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        };
        module.exports.truncateText = function(string, length) {
           if (string.length > length) return string.substring(0, length) + "...";
           else return string;
        };
        module.exports.cleanseString = function(txt) {
            return (txt?txt.replace(/['"]+/g,''):txt);
        };
        module.exports.randomString = function(length) {
            var text = "";
            var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            for (var i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            } return text;
        };
        module.exports.formatNumCash = function(val) {
            return parseFloat(Math.round(val * 100) / 100).toFixed(2);
        };
        module.exports.formatConstName = function(original) {
            return original.toLowerCase().split("_").map(s => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase()).join(" ")
        };
        module.exports.getKeyName = function(key) {
            return (key < 0 ? 'UNBOUND' : (key == 20000 ? 'SCROLL' :
            (key > 10000 ? ('M' + (key - 10000)) :
            module.exports.keyboardMap[key])));
        };
        var monthNames = [
            "Jan", "Feb", "Mar",
            "Apr", "May", "Jun", "Jul",
            "Aug", "Sep", "Oct",
            "Nov", "Dec"
        ];
        module.exports.getDate = function(tm) {
            if (!tm) return "None";
            tm = tm.split(/[-A-Z :\.]/i);
            var d = new Date(tm[0],--tm[1],tm[2],tm[3],tm[4],tm[5]);
            var date = new Date(d.getTime());
            return (date.getDate() + ' ' + monthNames[date.getMonth()]
                + ' ' + date.getFullYear());
        };
        module.exports.getTime = function(val, ms) {
            if (val == "inf") return "Infinite";
            var milliseconds = parseInt((val % 1000) / 100);
            var seconds = parseInt((val / 1000) % 60);
            var minutes = parseInt((val / (1000 * 60)) % 60);
            minutes = (minutes < 10)?"0" + minutes:minutes;
            seconds = (seconds < 10)?"0" + seconds:seconds;
            return (minutes + ":" + seconds + (ms?("." + milliseconds):""));
        };
        module.exports.commaFormatNum = function(val) {
            return val.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        };
        module.exports.getReadableTime = function(ms, ss) {
            var sec = Math.floor(ms / 1000);
            var minutes = Math.floor(sec / 60);
            sec = sec % 60;
            var hours = Math.floor(minutes / 60);
            minutes = minutes % 60;
            var days = Math.floor(hours / 24);
            hours = hours % 24;
            return ((days?days+'d ':'')+(hours?hours+'h ':'')
                +(minutes?minutes:0)+'m '+(ss?(sec+"s"):""));
        };
        module.exports.getReadableTime2 = function(ms) {
            if (ms < 0) return "just now";
            var sec = Math.floor(ms / 1000);
            var minutes = Math.floor(sec / 60);
            var hours = Math.floor(minutes / 60);
            minutes = minutes % 60;
            var days = Math.floor(hours / 24);
            hours = hours % 24;
    
            if (days) return days + "d ago";
            else if (hours) return hours + "h ago";
            else if (minutes) return minutes + "m ago";
            else return "just now";
        };
        module.exports.getTimeH = function(ms) {
            var milliseconds = parseInt((ms % 1000) / 100),
            seconds = Math.floor((ms / 1000) % 60),
            minutes = Math.floor((ms / (1000 * 60)) % 60),
            hours = Math.floor((ms / (1000 * 60 * 60)) % 24);
            hours = (hours < 10) ? "0" + hours:hours;
            minutes = (minutes < 10) ? "0" + minutes:minutes;
            seconds = (seconds < 10) ? "0" + seconds:seconds;
            return (hours + ":" + minutes + ":" + seconds);
        };
        module.exports.scrambleS = function(txt) {
            return (txt&&txt.replace?(txt.replace(/.(.)?/g, '$1')
                + ("d"+txt).replace(/.(.)?/g, '$1')):txt);
        };
        module.exports.sanitizeStr = function(txt) {
            return (txt&&txt.replace?(txt.replace(/<|>|&/g, "")
                .replace(/[^\x00-\x7F]/g, "")):txt);
        };
        module.exports.fixTo = function (n, v) {
            return parseFloat(n.toFixed(v));
        };
        module.exports.limit = function(val, limit) {
            if (val < -limit) return -limit;
            if (val > limit) return limit;
            return val;
        };
        module.exports.limitMM = function(val, min, max) {
            if (val < min) return min;
            if (val > max) return max;
            return val;
        };
        module.exports.cropVal = function(val, range) {
            if (val <= range && val >= -range) return 0;
            return val;
        };
        module.exports.isNumber = function (n) {
            return (n !== null && n !== undefined && typeof n == "number" && !isNaN(n) && isFinite(n));
        };
        module.exports.arrayInts = function(array) {
            for (var i = 0; i < array.length; ++i) {
                if (!module.exports.isNumber(array[i])) return false;
            }
            return true;
        };
        module.exports.isArray = function(a) {
            return (!!a && a.constructor === Array);
        };
        module.exports.isString = function (s) {
            return (s && typeof s == "string");
        };
        module.exports.emptyString = function(str) {
            return (!str || str.length === 0 ||
                /^\s*$/.test(str) || !str.trim());
        };
        module.exports.compareString = function(str1, str2) {
            if (!(typeof str1 === "string" && typeof str2 === "string")) return false;
            return (str1.toLowerCase().indexOf(str2.toLowerCase()) >= 0 ||
                str2.toLowerCase().indexOf(str1.toLowerCase()) >= 0);
        };
        var tmpList = [];
        module.exports.lineInRect = function(lx1, lz1, ly1, dx, dz, dy, x1, z1, y1, x2, z2, y2) {
            var t1 = (x1 - lx1) * dx;
            var t2 = (x2 - lx1) * dx;
            var t3 = (y1 - ly1) * dy;
            var t4 = (y2 - ly1) * dy;
            var t5 = (z1 - lz1) * dz;
            var t6 = (z2 - lz1) * dz;
            var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
            var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));
            if (tmax < 0) return false;
            if (tmin > tmax) return false;
            return tmin;
        };
        module.exports.pointInBox3D = function(x, y, z, box, pad) {
            pad = pad||0;
            return (x >= box.x - box.width - pad && x <= box.x + box.width + pad
                && y >= box.y - box.height - pad && y <= box.y + box.height + pad
                && z >= box.z - box.length - pad && z <= box.z + box.length + pad);
        };
        module.exports.similar = function(val1, val2, tresh) {
            tresh = tresh||0;
            return (Math.abs(val1 - val2) <= tresh);
        };
        module.exports.pointInBox = function(px, py, miX, miY, maX, maY, eq) {
            if (eq) return (px >= miX && px <= maX
                 && py >= miY && py <= maY);
            return (px > miX && px < maX
                 && py > miY && py < maY);
        };
        module.exports.sharePos = function(obj1, obj2, thr) {
            thr = thr||0;
            return (Math.abs(obj1.x - obj2.x) <= thr && Math.abs(obj1.y - obj2.y)
                <= thr && Math.abs(obj1.z - obj2.z) <= thr && Math.abs(obj1.d - obj2.d) <= thr);
        };
        module.exports.cdv = {"x":"width","y":"height","z":"length"};
        module.exports.boxIntersection = function(box1, box2, v1, v2, drs) {
            var v3 = module.exports.cdv[v1];
            var v4 = module.exports.cdv[v2];
            var xMin1 = box1[v1] - box1[v3] - 0.1;
            var xMin2 = box2[v1] - box2[v3] - 0.1;
            var xMax1 = box1[v1] + box1[v3] + 0.1;
            var xMax2 = box2[v1] + box2[v3] + 0.1;
            var zMin1 = box1[v2] - box1[v4] - 0.1;
            var zMin2 = box2[v2] - box2[v4] - 0.1;
            var zMax1 = box1[v2] + box1[v4] + 0.1;
            var zMax2 = box2[v2] + box2[v4] + 0.1;
            var xMin = Math.max(xMin1, xMin2);
            var xMax = Math.min(xMax1, xMax2);
            if (xMax >= xMin) {
                var zMin = Math.max(zMin1, zMin2);
                var zMax = Math.min(zMax1, zMax2);
                if (zMax >= zMin) {
                    var p = [
                        {[v1]:xMin,[v2]:zMin,d:drs[0]},
                        {[v1]:xMax,[v2]:zMax,d:drs[1]},
                        {[v1]:xMin,[v2]:zMax,d:drs[2]},
                        {[v1]:xMax,[v2]:zMin,d:drs[3]}
                    ];
                    for (var i = p.length - 1; i >= 0; --i) {
                        if ((p[i][v1] == xMax1 && p[i][v1] == xMax2) || (p[i][v1] == xMin1 && p[i][v1] == xMin2) ||
                            (p[i][v2] == zMax1 && p[i][v2] == zMax2) || (p[i][v2] == zMin1 && p[i][v2] == zMin2) ||
                            module.exports.pointInBox(p[i][v1], p[i][v2], xMin1, zMin1, xMax1, zMax1) ||
                            module.exports.pointInBox(p[i][v1], p[i][v2], xMin2, zMin2, xMax2, zMax2)) p[i].dontUse = true;
                    } return p;
                }
            } return null;
        };
        module.exports.boxCornerIntersection = function(box1, box2, v1, v2) {
            var v3 = module.exports.cdv[v1];
            var v4 = module.exports.cdv[v2];
            var xMin1 = box1[v1] - box1[v3];
            var xMin2 = box2[v1] - box2[v3];
            var xMax1 = box1[v1] + box1[v3];
            var xMax2 = box2[v1] + box2[v3];
            var zMin1 = box1[v2] - box1[v4];
            var zMin2 = box2[v2] - box2[v4];
            var zMax1 = box1[v2] + box1[v4];
            var zMax2 = box2[v2] + box2[v4];
            var p = [{[v1]:xMin1, [v2]:zMin1,d:Math.PI/2}, {[v1]:xMin1,[v2]:zMax1,d:Math.PI},
                {[v1]:xMax1,[v2]:zMin1,d:0}, {[v1]:xMax1,[v2]:zMax1,d:-Math.PI/2}];
            for (var i = p.length - 1; i >= 0; --i) {
                p[i].i = i;
                if (!module.exports.pointInBox(p[i][v1], p[i][v2], xMin2, zMin2, xMax2, zMax2, true)) p.splice(i, 1);
            }
            return (p.length?p:null);
        };
        module.exports.getIntersection = function(box1, box2, v1) {
            var v2 = module.exports.cdv[v1];
            var min1 = box1[v1] - box1[v2];
            var min2 = box2[v1] - box2[v2];
            var max1 = box1[v1] + box1[v2];
            var max2 = box2[v1] + box2[v2];
            var xMin = Math.max(min1, min2);
            var xMax = Math.min(max1, max2);
            if (xMax >= xMin) {
                var tmpV = (xMax - xMin) / 2;
                return {
                    [v1]: xMin + tmpV,
                    [v2]: tmpV
                };
            }
            return null;
        };
        module.exports.limitRectVal = function(obj1, obj2, v1) {
            var v2 = module.exports.cdv[v1];
            if (obj1[v1] - obj1[v2] < obj2[v1] - obj2[v2]) {
                var tmpD = ((obj2[v1] - obj2[v2]) - (obj1[v1] - obj1[v2])) / 2;
                obj1[v2] -= tmpD;
                obj1[v1] += tmpD;
            } if (obj1[v1] + obj1[v2] > obj2[v1] + obj2[v2]) {
                var tmpD = ((obj1[v1] + obj1[v2]) - (obj2[v1] + obj2[v2])) / 2;
                obj1[v2] -= tmpD;
                obj1[v1] -= tmpD;
            }
        };
        module.exports.getMaxRect = function(objs, v1, v2) {
            var v3 = module.exports.cdv[v1];
            var v4 = module.exports.cdv[v2];
            var minV1, minV2, maxV1, maxV2;
            for (var i = 0; i < objs.length; ++i) {
                if (minV1 == undefined) minV1 = (objs[i][v1] - objs[i][v3]);
                else minV1 = Math.min(objs[i][v1] - objs[i][v3], minV1);
                if (maxV1 == undefined) maxV1 = (objs[i][v1] + objs[i][v3]);
                else maxV1 = Math.max(objs[i][v1] + objs[i][v3], maxV1);
                if (minV2 == undefined) minV2 = (objs[i][v2] - objs[i][v4]);
                else minV2 = Math.min(objs[i][v2] - objs[i][v4], minV2);
                if (maxV2 == undefined) maxV2 = (objs[i][v2] + objs[i][v4]);
                else maxV2 = Math.max(objs[i][v2] + objs[i][v4], maxV2);
            } return {
                [v1]: ((minV1 + maxV1) / 2),
                [v2]: ((minV2 + maxV2) / 2),
                [v3]: Math.abs(maxV1 - minV1) / 2,
                [v4]: Math.abs(maxV2 - minV2) / 2
            };
        };
        module.exports.limitRect = function(x, z, w, l, d, objs, v1, v2) {
            var obj2 = module.exports.getMaxRect(objs, v1, v2);
            var v3 = module.exports.cdv[v1];
            var v4 = module.exports.cdv[v2];
            var obj1 = {};
            obj1[v1] = x;
            obj1[v2] = z;
            obj1[v3] = w;
            obj1[v4] = l;
            module.exports.limitRectVal(obj1, obj2, v1);
            module.exports.limitRectVal(obj1, obj2, v2);
            if (d == 0 || d == Math.PI) {
                var tmpV = obj1[v3];
                obj1[v3] = obj1[v4];
                obj1[v4] = tmpV;
            } return obj1;
        };
        module.exports.progressOnLine = function(x1, y1, x2, y2, x3, y3) {
            var ux = x2 - x1, uy = y2 - y1;
            var u2 = Math.sqrt(ux*ux + uy*uy);
            ux /= u2;
            uy /= u2;
            return (ux * (x3 - x1) + uy * (y3 - y1)) / Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        };
        module.exports.generateSID = function(list) {
            var tmpID = 0;
            var isUsed = true;
            while (isUsed) {
                isUsed = false;
                tmpID++;
                for (var i = 0; i < list.length; ++i) {
                    if (list[i].sid == tmpID) {
                        isUsed = true;
                        break;
                    }
                }
            }
            return tmpID;
        };
        module.exports.levelIconId = function(level) {
            return Math.max(Math.min(config.maxLevel - 1, level.roundToNearest(2) - 1), 0);
        };
        module.exports.eloIconId = function(elo) {
            return Math.max(Math.min(config.maxELOLevel, Math.floor((elo||0)/config.eloPer)), 1) - 1;
        };
        module.exports.eloIconHTML = function(elo, style) {
            var levelId = module.exports.eloIconId(elo);
            if (levelId >= 0) return "<img class='accountEloIcon' style='"+(style||'margin-bottom:-2px;')+"' src='./img/ranks/icon_" + levelId + ".png'>";
            else return "";
        };
        module.exports.getElo = function(account, queueId) {
            if (queueId) {
                // GET ELO FOR QUEUE:
                var eloKey = config.queues.filter(q => q.id == queueId)[0].key;
                return account[eloKey];
            } return null;
        };
        module.exports.maxElo = function(account) {
            // FIND MAX ELO:
            var max = account.elo;
            if (account.elo2 > max) max = account.elo2;
            else if (account.elo4 > max) max = account.elo4;
            return max;
        };
        module.exports.copyToClipboard = function(str) {
            const el = document.createElement('textarea');
            el.value = str;
            el.setAttribute('readonly', '');
            el.style.position = 'absolute';
            el.style.left = '-9999px';
            document.body.appendChild(el);
            const selected =
                document.getSelection().rangeCount > 0
                    ? document.getSelection().getRangeAt(0)
                    : false;
            el.select();
            document.execCommand('copy');
            document.body.removeChild(el);
            if (selected) {
                document.getSelection().removeAllRanges();
                document.getSelection().addRange(selected);
            }
        };
    
        // FLATMAP:
        var concat = function(x, y) { return x.concat(y) };
        var flatMap = function(f, xs) { return xs.map(f).reduce(concat, []); };
        Array.prototype.flatMap = function(f) {
            return flatMap(f, this)
        };
    
        // NETWORK ENCODING:
        var msgpack = __webpack_require__(/*! msgpack-lite */ "./node_modules/msgpack-lite/lib/browser.js");
    
        // NOTE: Remind Ptato any time this changes for his bot
        // NOTE: FIX SOCIAL
        var padding = 2;
        module.exports.encodeNetworkMessage = function(data, num) {  // TODO: Rotate each bit by num with mod 256
            let encoded = msgpack.encode(data);
            let binary = new Uint8Array(encoded.length + padding);
            binary.set(module.exports.encodeShort(num), binary.length - 2);  // Insert number
            binary.set(encoded, 0);  // Insert the encoded data
            return binary;
        };
    
        module.exports.decodeNetworkMessage = function(data) {
            data = new Uint8Array(data);
            let decodedNum = module.exports.decodeShort(data[data.length - 2], data[data.length - 1]);
            let binary = data.slice(0, data.length - padding);
            return [msgpack.decode(binary), decodedNum];
        };
    
        module.exports.rotateNumber = function(num, prime) {
            return (num + prime) & 0xFF;
        };
    
        module.exports.encodeShort = function(num) {
            return [(num >> 4) & 0xF, num & 0xF];
        };
    
        module.exports.decodeShort = function(byte1, byte2) {
            return (byte1 << 4) + byte2;
        };
    
        module.exports.thumbnailSize = function(thumb) {
            return parseInt(thumb.replace(/=/g,"").length * 0.75) / 1000;
        };
    
        module.exports.hexToRGB = hex => hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i,
            (m, r, g, b) => '#' + r + r + g + g + b + b)
            .substring(1).match(/.{2}/g)
            .map(x => parseInt(x, 16));
    
        module.exports.rgbToHex = function(red, green, blue) {
            var h = ((red << 16) | (green << 8) | (blue)).toString(16);
            while (h.length < 6) h = '0' + h;
            return '#' + h;
        };
    
        module.exports.hexFromHue = function(hue) {
            var h = hue/60;
            var x = (1 - Math.abs(h%2 - 1))*255;
            var i = Math.floor(h);
            return module.exports.rgbToHex(
                (i < 1||i > 4 ? 255 : (i == 1||i == 4 ? x : 0)),
                (i == 0||i == 3 ? x : (i == 1||i == 2 ? 255 : 0)),
                (i == 0||i == 1 ? 0 : (i == 3||i == 4 ? 255 : x))
            );
        };
    
        module.exports.versionifyUrl = function(url) {
            // Adds the game version to the URL so the browser cache gets
            // invalidated every update
            return url + "?build=" + gameVersion;
        };
    
        module.exports.assetsUrl = function(url) {
            if (url.startsWith("/")) url = url.slice(1);
            return this.versionifyUrl("https://assets.krunker.io/" + url);
        };
    
        module.exports.getPreview = function(item, store) {
          return module.exports.assetsUrl("/textures/" + (item.type && item.type == 4 ?
              "sprays/" + item.id : "previews/" +
              (item.type && (item.type < 3 || item.type == 5) ?"cosmetics/" + item.type + "_"+item.id +
              (item.tex ? "_" + item.tex:""):
              store.types[item.type||0] +
              ((item.type && item.type == 3) ? item.id + (item.tex!=undefined? "_" + item.tex:""):
              (item.weapon||0)+"_"+
              (item.mid!=undefined?"m"+item.mid+(item.midT!=undefined?"_"+item.midT.split('_').slice(-1)[0]:""):
              (item.pat!=undefined?"c"+item.pat:(item.tex?item.tex:item.id))))))
              + ".png");
        };
    
        module.exports.getFrameAnim = function(item, name) {
            return (item.frames ? "animation: " + name + item.frames
                + " " + (1 + (item.frameT/1000)) + "s steps("
                + item.frames + ") infinite;" : "");
        };
    
        // SOCIAL LINK
        module.exports.toSocial = function(username) {
            return `./social.html?p=profile&q=${module.exports.cleanseString(username)}`;
        };
    
        // IS DROPBOX URL
        module.exports.isDropbox = function(url) {
            return (/^(http:\/\/www\.|https:\/\/www\.|http:\/\/|https:\/\/)?(dropbox|dropboxusercontent|dl\.dropboxusercontent)\.com\//g.test(url));
        };
    
        // MAKE TEXT FIT:
        module.exports.getFontSizeToFit = function(text, fontFace, maxWidth) {
            var ctx = document.createElement('canvas').getContext('2d');
            ctx.font = `1px ${fontFace}`;
            return maxWidth / ctx.measureText(text).width;
        };
    
        module.exports.ctxText = function(ctx, txt, color, x, y) {
            ctx.save();
            ctx.translate(~~x, ~~y);
            ctx.fillStyle = color;
            ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
            ctx.lineWidth = 1;
            ctx.strokeText(txt, 0, 0);
            ctx.fillText(txt, 0, 0);
            ctx.restore();
        };
        module.exports.getLines = function(ctx, text, maxWidth) {
            //THX https://stackoverflow.com/a/16599668
            var words = text.split(" ");
            var lines = [];
            var currentLine = words[0];
            for (var i = 1; i < words.length; i++) {
                var word = words[i];
                var width = ctx.measureText(currentLine + " " + word).width;
                if (width < maxWidth) currentLine += " " + word;
                else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        };
    
        // MAKE A TEXT CANVAS (SIGN):
        module.exports.createCanvasText = function(l, h, txt, fontSize, color, bg, noBVis, tAlign) {
            var hRatio = 0;
            var lRatio = 0;
            if (h > l) {
                hRatio = 1;
                lRatio = (l / h);
            } else if (h < l) {
                hRatio = (h / l);
                lRatio = 1;
            } else {
                hRatio = 1;
                lRatio = 1;
            }
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            var canvRes = 1024;
            canvas.width = (canvRes * lRatio);
            canvas.height = (canvRes * hRatio);
            if (!noBVis) {
                ctx.fillStyle = bg;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            var tFS = (fontSize);
            ctx.font = tFS + 'px GameFont';
            txt = txt.substring(0, config.signTextLimit - 1);
            //ctx.textBaseline = "middle";
            ctx.textAlign = tAlign==2?"right":(tAlign==1?"center":"left");
            var lY = tFS * 2;
            var lX = ctx.measureText("M").width / 2;
            lX = tAlign==2?(canvas.width-lX):(tAlign==1?(canvas.width/2):lX);
            var lH = ctx.measureText("M").width * 1.2;
            var lines = txt.split("\\n");
            var lines2 = null;
            for (var i = 0; i < lines.length; ++i) {
                lines2 = module.exports.getLines(ctx, lines[i], canvas.width - tFS);
                for (var x = 0; x < lines2.length; ++x) {
                    module.exports.ctxText(ctx, lines2[x], color, lX, lY);
                    lY += lH;
                    if (lY > canvas.height) break;
                }
            }
            return canvas;
        };
    
        module.exports.createCanvasAD = function(text) {
            var canvas = document.createElement('canvas');
            var canvRes = 1024;
            canvas.width = (canvRes * 2);
            canvas.height = (canvRes * 1);
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            module.exports.drawMultilineText(ctx, text, canvas.width, canvas.height);
            return canvas;
        };
    
        module.exports.drawMultilineText = function(ctx, text, maxWidth, maxHeight) {
            var minFontSize = 15;
            var maxFontSize = 2000;
    
            var words = text.split(" ");
            var lines = [];
            var finalSize = 0;
            for (var fontSize = minFontSize; fontSize <= maxFontSize; fontSize++) {
                // Line height
                var lineHeight = fontSize * 1.4;
                // Set font for testing with measureText()
                ctx.font = fontSize + "px GameFont";
    
                var x = ((maxWidth - 80) / 2);
                var y = lineHeight;
                var tmpL = [];
    
                var currentLine = words[0];
                if (ctx.measureText(currentLine).width > (maxWidth - 80))  {
                    finalSize = fontSize-1;
                    break;
                }
                for (var i = 1; i < words.length; i++) {
                    var word = words[i];
                    var width = ctx.measureText(currentLine + " " + word).width;
                    if (width < (maxWidth - 80)) currentLine += " " + word;
                    else {
                        tmpL.push(currentLine);
                        currentLine = word;
                        y += lineHeight;
                    }
                } tmpL.push(currentLine);
                if (y > maxHeight - 80) {
                    finalSize = fontSize-1;
                    break;
                } else {
                    lines = tmpL;
                    finalSize = fontSize;
                }
            }
    
            // Print lines
            var lineHeight = fontSize * 1.4;
            var x = (maxWidth / 2);
            var y = (maxHeight / 2);
            if (lines.length > 1) y -= ((lineHeight * (lines.length-1))/2);
            x += 40 / lines.length;
            y += 80 / lines.length;
            ctx.font = finalSize + "px GameFont";
            ctx.fillStyle = "#FFFFFF";
            ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
            ctx.lineWidth = 1;
            for (var i = 0; i < lines.length; i++) {
                ctx.strokeText(lines[i].trim(), x - (ctx.measureText(lines[i].trim()).width / 2), y + (fontSize/2));
                ctx.fillText(lines[i].trim(), x - (ctx.measureText(lines[i].trim()).width / 2), y + (fontSize/2));
                y += lineHeight;
            }
            // Returns font size
            return fontSize;
        }
    
    
        // CALCULATE VOTE2KICK WEIGHT
        module.exports.calcVoteNum = function(acc) {
            if (acc.featured) return 2;
            else if (acc.level >= 50) return 1.5;
            else if (acc.level >= 30) return 1.3;
            else if (acc.level <= 10) return 0.75;
            else return 1;
        };
    
        module.exports.extractProperties = function(input, props) {
            return props.reduce(function(out, prop) {
                out[prop] = input[prop];
                return out;
            }, {});
        };
    
        module.exports.getChalProg = function(account, game) {
            var prog = account.stats['chgP'];
            var savedLvl = prog.split(':')[0];
            var lvl = (parseInt(account.chal)||0);
    
            if (lvl >= config.maxChal) return '';
    
            if (!prog.includes(':') || parseInt(savedLvl) != lvl) {
                account.stats['chgP'] = lvl + ':' + Array(game.challenges[
                    lvl].list.length).fill(0).join();
            }
    
            return account.stats['chgP'].split(':')[1];
        };
    
        // GET KICK BAN MESSAGE TYPE:
        module.exports.getMsgType = function(p) {
            if (p.kicked) return 2;
            else if (p.banned) return 3;
            else if (p.kickedByVote) return 4;
            else return 1;
        };
    
        // FIX TEXT SENT TO CHAT
        module.exports.fixStr = function(str) {
            if (!str) return "";
            return config.invisChar + str + config.invisChar;
        };
    
        // ADAPTIVE TIMEOUT:
        var useNativeTimeouts = true;  // START NATIVE SINCE ALWAYS LAGS ON LOAD
        var switchTimeoutsCounter = 0;
        var pendingTimeoutCbs = {};
        var pendingTimeoutDelays = {};
        var timeoutId = 0;
    
        module.exports.isUsingNativeTimeouts = function() {
            return useNativeTimeouts;
        };
    
        module.exports.setTimeout = function(cb, delay) {
            if (useNativeTimeouts) {
                return setTimeout(cb, delay);
            } else {
                var id = ++timeoutId;
                pendingTimeoutCbs[id] = cb;
                pendingTimeoutDelays[id] = Date.now() + delay;
                return id;
            }
        };
    
        module.exports.setInterval = function(cb, delay) {
            // NOTE: WE CAN'T CLEAR INTERVALS SINCE THE ID WILL CHANCE
    
            // CALL REPEATING TIMEOUT:
            var timeoutId;
            function repeat() {
                cb();
                module.exports.setTimeout(repeat, delay, timeoutId);
            }
            timeoutId = module.exports.setTimeout(repeat, delay);
    
            return timeoutId;
        };
    
        module.exports.clearTimeout = function(id) {
            // CLEAR NATIVE TIMEOUT:
            clearTimeout(id);
    
            // CLEAR NON-NATIVE TIMEOUT:
            delete pendingTimeoutCbs[id];
            delete pendingTimeoutDelays[id];
        };
    
        module.exports.triggerTimeouts = function(fps) {
            var now = Date.now();
    
            // DETERMINE IF SHOULD SWITCH TIMEOUTS:
            var shouldUserNativeTimeouts = fps < 100;
            if (shouldUserNativeTimeouts != useNativeTimeouts) {
                switchTimeoutsCounter++;
                if (switchTimeoutsCounter > 100) {
                    switchTimeoutsCounter = 0;
                    useNativeTimeouts = shouldUserNativeTimeouts;
                }
            } else {
                switchTimeoutsCounter = 0;
            }
    
            // FIND TIMEOUTS TO TRIGGER:
            var triggerTimeouts = null;
            for (var id in pendingTimeoutDelays) {
                // CHECK IF SHOULD TRIGGER:
                if (pendingTimeoutDelays[id] <= now) {
                    // SAVE THE TIMEOUT
                    if (triggerTimeouts == null) triggerTimeouts = [];
                    triggerTimeouts.push(id);
                }
            }
    
            // TRIGGER TIMEOUTS:
            if (triggerTimeouts) {
                for (var timeoutId of triggerTimeouts) {
                    var cb = pendingTimeoutCbs[timeoutId];
    
                    // DELETE TIMEOUT:
                    delete pendingTimeoutCbs[timeoutId];
                    delete pendingTimeoutDelays[timeoutId];
    
                    // CALL CALLBACK:
                    try {
                        cb();
                    } catch (err) {
                        console.error("Timeout callback error", err);
                    }
                }
            }
        };
    
    
    /***/ }),
    
    /***/ "./src/theatre.js":
    /*!************************!*\
      !*** ./src/theatre.js ***!
      \************************/
    /*! no static exports found */
    /***/ (function(module, exports, __webpack_require__) {
    
    
    // DISABLE ERRORS:
    function resize() {
        RENDER.resize();
    };
    window.addEventListener("resize", resize);
    
    var canStore = (typeof(Storage) !== "undefined");
    window.saveVal = function(name, val) {
        if (canStore) localStorage.setItem(name, val);
    }
    function deleteVal(name) {
        if (canStore) localStorage.removeItem(name);
    }
    window.getSavedVal = function(name) {
        if (canStore) return localStorage.getItem(name);
        return null;
    }
    
    // IMPORTS:
    var THREE = __webpack_require__(/*! three */ "./node_modules/three/build/three.module.js");
    THREE.OBJLoader = __webpack_require__(/*! ./libs/OBJLoader.js */ "./src/libs/OBJLoader.js")(THREE);
    THREE.PointerLockControls = __webpack_require__(/*! ./libs/PointerLockControls.js */ "./src/libs/PointerLockControls.js")(THREE);
    THREE.Shaders = __webpack_require__(/*! ./libs/shaders.js */ "./src/libs/shaders.js")(THREE);
    const UTILS = __webpack_require__(/*! ./libs/utils.js */ "./src/libs/utils.js");
    const config = __webpack_require__(/*! ./config.js */ "./src/config.js");
    var RENDER = new (__webpack_require__(/*! ./libs/render.js */ "./src/libs/render.js"))(THREE, UTILS, config);
    RENDER.setResMlt(0.7);
    var SOUND = window["SOUND"] = new (__webpack_require__(/*! ./libs/sound.js */ "./src/libs/sound.js"))(UTILS, config);
    const initScene = __webpack_require__(/*! ./libs/render.js */ "./src/libs/render.js").initScene;
    const PARTICLES = new (__webpack_require__(/*! ./libs/particles.js */ "./src/libs/particles.js"))(RENDER, config);
    var GAME = {
        weapons: __webpack_require__(/*! ./data/weapons.js */ "./src/data/weapons.js"),
        classes: __webpack_require__(/*! ./data/classes.js */ "./src/data/classes.js"),
        map: new (__webpack_require__(/*! ./data/map.js */ "./src/data/map.js")).manager(RENDER, PARTICLES, UTILS, config),
        store: __webpack_require__(/*! ./data/store.js */ "./src/data/store.js"),
        attach: __webpack_require__(/*! ./data/attach.js */ "./src/data/attach.js"),
        streaks: __webpack_require__(/*! ./data/streaks.js */ "./src/data/streaks.js"),
        sprays: __webpack_require__(/*! ./data/sprays.js */ "./src/data/sprays.js"),
        config: {}
    };
    GAME.players = new (__webpack_require__(/*! ./data/players.js */ "./src/data/players.js")).manager(GAME,
        RENDER, null, PARTICLES, UTILS, config);
    var you = null;
    Math.PI2 = Math.PI * 2;
    var freeCam = false;
    
    // KEYS:
    var playKey = 32;
    var uiKey = 82;
    var keys = {};
    function toggleKey(key, state) {
        if (keys[key] !== state) {
            keys[key] = state;
            if (!state) return;
    
            // TOGGLE UI:
            if (key == uiKey) {
                uiHolder.style.display = (uiHolder.style.display!="none"?"none":"block");
            }
    
            // PLAYBACK:
            else if (key == playKey) {
                if (isPlaying) endPlayback();
                else playback();
            }
    
        }
    }
    function keyDown(e) {
        toggleKey(e.which||e.keyCode||0, 1);
    }
    window.addEventListener('keydown', keyDown, false);
    function keyUp(e) {
        toggleKey(e.which||e.keyCode||0, 0);
    }
    window.addEventListener('keyup', keyUp, false);
    
    uiHolder.addEventListener("drop", _ => {
        event.preventDefault();
        let files = event.dataTransfer.files;
        if (files.length != 1) return alert('Please select 1 file');
        let file = files[0];
        let reader = new FileReader();
        reader.onload = (event) => {
            let dataUri	= event.target.result;
            let base64 = dataUri.match(/[^,]*,(.*)/)[1];
            let json = window.atob(base64);
            loadClip(json);
        };
        reader.readAsDataURL(file);
    }, false);
    uiHolder.addEventListener("dragover", _ => {
        event.preventDefault();
    }, false);
    
    // UPDATE SLIDERS:
    window.updateTool = function(value, index) {
        var tmpEl = document.getElementById("slideVal" + index);
        if (tmpEl) tmpEl.innerHTML = value;
        if (tools[index].set) tools[index].set(value);
    };
    
    // TOOLS:
    var tools = [{
        name: "Toggle UI",
        pre: "Shortcuts",
        gen: function() {
            var tmpHTML = "<a href='javascript:;'>" + UTILS.getKeyName(uiKey) + "</a>";
            return tmpHTML;
        }
    }, {
        name: "Play",
        gen: function() {
            var tmpHTML = "<a href='javascript:;'>" + UTILS.getKeyName(playKey) + "</a>";
            return tmpHTML;
        }
    }, {
        name: "Depth Map",
        pre: "Render",
        gen: function() {
            var tmpHTML = "<div class='sliderVal' id='slideVal2'>0</div><div class='slidecontainer'>"
                + "<input type='range' oninput='updateTool(this.value, 2)' min='0' max='1000' "
                + "value='0' step='20' class='slider'></div>";
            return tmpHTML;
        }, set: function(val) {
            RENDER.toggleDepthMap(val);
            RENDER.render();
        }
    }, {
        name: "Green Screen",
        gen: function() {
            var tmpHTML = "<label class='switch' ><input  onclick='updateTool(this.checked, 3)'"
                + " type='checkbox'><span class='switchSlider'></span></label>";
            return tmpHTML;
        }, set: function(val) {
            RENDER.toggleGreenscreen(val);
            RENDER.render();
        }
    }, {
        name: "Time Scale",
        pre: "Replay",
        gen: function() {
            var tmpHTML = "<div class='sliderVal' id='slideVal4'>1.0</div><div class='slidecontainer'>"
                + "<input type='range' oninput='updateTool(this.value, 4)' "
                + "min='0.1' max='2' value='1' step='0.1' class='slider'></div>";
            return tmpHTML;
        }, set: function(val) {
            timeScale = val;
        }
    }, {
        name: "Freecam",
        gen: function() {
            var tmpHTML = "<label class='switch' ><input  onclick='updateTool(this.checked, 5)'"
                + " type='checkbox'><span class='switchSlider'></span></label>";
            return tmpHTML;
        }, set: function(val) {
            freeCam = val;
        }
    }, {
        name: "Resolution",
        gen: function() {
            var tmpHTML = "<div class='sliderVal' id='slideVal6'>0.7</div><div class='slidecontainer'>"
                + "<input type='range' oninput='updateTool(this.value, 6)' "
                + "min='0.1' max='2' value='0.7' step='0.1' class='slider'></div>";
            return tmpHTML;
        }, set: function(val) {
            RENDER.setResMlt(val);
        }
    }];
    var tmpHTML = "";
    var preCount = 0;
    for (var i = 0; i < tools.length; ++i) {
        if (tools[i].pre) {
            tmpHTML += "<div class='toolHead' style='" + (preCount?"margin-top:10px":"")
                + "'>" + tools[i].pre + "</div>";
            preCount++;
        } tmpHTML += "<div class='toolItem'>" + tools[i].name + "<div class='setHold'>"
            + tools[i].gen() + "</div></div>";
    }
    toolBox.innerHTML = tmpHTML;
    
    // SKIP CLIP:
    window.skipClip = function(value) {
        if (clip) {
            aimRecticle.style.opacity = 0;
            endPlayback();
            loadPlayers();
            var clipNum = Math.round(clip.states.length * value);
            for (var i = 0; i < clipNum; ++i) {
                playFrame(i, true);
            } clip.index = clipNum;
            updatePlayer(value);
            RENDER.render();
        }
    };
    
    // UPDATE PLAYER PROGRESS:
    window.updatePlayer = function(value, upd) {
        if (clip) {
            if (upd) playerSlider.value = value;
            playerVal.innerHTML = UTILS.getTime(value * clip.duration) +
            "/" + UTILS.getTime(clip.duration);
        }
    };
    updatePlayer(0, true);
    
    // SHOW CLIP LOADER:
    window.showClipLoader = function() {
        let mapRaw = prompt("Paste Clip Data");
        loadClip(mapRaw);
    };
    
    // LOAD PLAYERS:
    function loadPlayers() {
        GAME.players.clear();
        var initData = clip.states[0].input;
        you = GAME.players.add(-1, -1, initData.x, initData.y, initData.z,
            null, initData.classIndex, true);
        for (var key in initData) {
            if (initData.hasOwnProperty(key) && you.hasOwnProperty(key))
                you[key] = initData[key];
        }
        GAME.players.swapWeapon(you, null, true, you.weaponIndex);
        GAME.players.updateAim(you, (1 - you.aimVal));
        if (you.aimVal <= 0) GAME.players.toggleAim(you, 1);
        updateCamera();
    }
    
    // LOAD CLIP:
    var clip = null;
    function loadClip(data) {
        try {
    
            // CREATE CLIP:
            var tmpDat = JSON.parse(data);
            clip = {
                id: tmpDat.id,
                index: 0,
                states: [],
                duration: 0
            };
            for (var i = 0; i < tmpDat.states.length; ++i) {
                if (i) {
                    clip.states.push({
                        input: {
                            data: tmpDat.states[i][0]
                        }, players: (tmpDat.states[i][1]||[])
                    });
                } else clip.states.push(tmpDat.states[i]);
                clip.duration += clip.states[i].input.data[1];
            }
            updatePlayer(0, true);
            // FINISH:
            for (var x = 0; x < tmpDat.map.objects.length; ++x) {
                tmpDat.map.objects[x].id = config.prefabIDS[tmpDat.map.objects[x].id||0];
                tmpDat.map.objects[x].t = config.textureIDS[tmpDat.map.objects[x].t||0];
            }
            for (var i = 0; i < config.serverConfig.length; ++i) {
                var tmpO = config.serverConfig[i];
                if (tmpO.bool) {
                    GAME.config[tmpO.varN] = tmpO.def;
                } else {
                    GAME.config[tmpO.varN] = UTILS.limitMM(tmpO.def, tmpO.min,
                        (tmpDat&&tmpDat.featured?(tmpO.maxF||tmpO.max):tmpO.max));
                }
            }
            GAME.config.maps = [0];
            GAME.config.modes = [tmpDat.mode];
            GAME.config.classes = [];
            for (var i = 0; i < GAME.classes.length; i++) GAME.config.classes.push(i);
            GAME.map.maps = [tmpDat.map];
            GAME.map.generate(0, tmpDat.mode, true);
            GAME.mode = GAME.map.modes[tmpDat.mode];
            aimRecticle.style.opacity = 0;
            RENDER.scene.add(cam);
            loadPlayers();
        } catch (e) {
            console.log(e);
        }
    };
    // UPDATE CAMERA:
    var pchObjc = new THREE.Object3D();
    pchObjc.add(RENDER.camera);
    var cam = new THREE.Object3D();
    cam.add(pchObjc);
    function moveCamera(x, y, z, xD, yD) {
        cam.position.set(x, y, z);
        pchObjc.rotation.x = yD;
        cam.rotation.y = xD;
        RENDER.camera.updateProjectionMatrix();
        RENDER.updateFrustum();
    }
    function updateCamera() {
        if (you) moveCamera(you.x, you.y + you.height - config.cameraHeight, you.z, you.xDire,
            you.yDire + (you.recoilAnimY * config.recoilMlt) + (you.landBobY * 0.1));
    }
    
    // PLAYBACK:
    var timeScale = 1;
    var isPlaying = false;
    var playbackTimeout;
    function playback() {
        if (clip && clip.index < clip.states.length) {
            playFrame(clip.index);
            updatePlayer(clip.index / (clip.states.length - 1), true);
            clip.index++;
            isPlaying = true;
            if (clip.index < clip.states.length) playbackTimeout = setTimeout(playback,
                clip.states[clip.index].input.data[1] / timeScale);
        }
    }
    function endPlayback() {
        if (playbackTimeout) clearTimeout(playbackTimeout);
        isPlaying = false;
    }
    function playFrame(index, skipRender) {
        var tmpState = clip.states[index];
        var dt = tmpState.input.data[1];
        GAME.players.hideAll();
        //CONTROLS.update(dt * GAME.config.deltaMlt);
        if (you) {
            you.objInstances.visible = true;
            you.procInputs(tmpState.input.data, GAME);
            updateCamera();
            GAME.players.updateMsh(you);
        }
        for (var i = 0; i < tmpState.players.length; ++i) {
            var tmpDat = tmpState.players[i];
            var tmpPlayer = GAME.players.findBySid(tmpDat[0]);
            if (!tmpPlayer || tmpPlayer.classIndex != tmpDat[1]) tmpPlayer = GAME.players.add(i + 1,
                tmpDat[0], tmpDat[6], tmpDat[7], tmpDat[8], null, tmpDat[1]);
            tmpPlayer.objInstances.visible = true;
            tmpPlayer.x = tmpDat[6];
            tmpPlayer.y = tmpDat[7];
            tmpPlayer.z = tmpDat[8];
            tmpPlayer.xDire = tmpDat[3];
            tmpPlayer.yDire = tmpDat[4];
            tmpPlayer.crouchVal = tmpDat[5];
            GAME.players.swapWeapon(tmpPlayer, 0, false, tmpDat[2]);
            GAME.players.updateMsh(tmpPlayer);
        }
        //if (freeCam) CONTROLS.freeCam(dt);
        PARTICLES.update(dt, you);
        if (!skipRender) RENDER.render(dt);
    }
    
    
    /***/ }),
    
    /***/ "./version.json":
    /*!**********************!*\
      !*** ./version.json ***!
      \**********************/
    /*! exports provided: default */
    /***/ (function(module) {
    
    module.exports = "127OD";
    
    /***/ })
    
    /******/ });
    //# sourceMappingURL=../.tmp/theatre.js.map